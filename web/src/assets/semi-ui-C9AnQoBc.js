import { r as R, g as _e, c as Qi, R as f, a as di, b as lr, d as tP } from "./react-core-B_rT1BcQ.js"; function nP(r, e) { for (var t = 0; t < e.length; t++) { const n = e[t]; if (typeof n != "string" && !Array.isArray(n)) { for (const i in n) if (i !== "default" && !(i in r)) { const s = Object.getOwnPropertyDescriptor(n, i); s && Object.defineProperty(r, i, s.get ? s : { enumerable: !0, get: () => n[i] }) } } } return Object.freeze(Object.defineProperty(r, Symbol.toStringTag, { value: "Module" })) } var o1 = { exports: {} }, Id = {};/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var rP = R, iP = Symbol.for("react.element"), sP = Symbol.for("react.fragment"), aP = Object.prototype.hasOwnProperty, oP = rP.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, lP = { key: !0, ref: !0, __self: !0, __source: !0 }; function l1(r, e, t) { var n, i = {}, s = null, a = null; t !== void 0 && (s = "" + t), e.key !== void 0 && (s = "" + e.key), e.ref !== void 0 && (a = e.ref); for (n in e) aP.call(e, n) && !lP.hasOwnProperty(n) && (i[n] = e[n]); if (r && r.defaultProps) for (n in e = r.defaultProps, e) i[n] === void 0 && (i[n] = e[n]); return { $$typeof: iP, type: r, key: s, ref: a, props: i, _owner: oP.current } } Id.Fragment = sP; Id.jsx = l1; Id.jsxs = l1; o1.exports = Id; var c1 = o1.exports; const cP = _e(c1), uP = nP({ __proto__: null, default: cP }, [c1]); function dP() { } var u1 = dP; const z = _e(u1); var hP = Array.isArray, Dn = hP; const dm = _e(Dn); var pP = typeof Qi == "object" && Qi && Qi.Object === Object && Qi, d1 = pP, fP = d1, gP = typeof self == "object" && self && self.Object === Object && self, mP = fP || gP || Function("return this")(), Ci = mP, yP = Ci, bP = yP.Symbol, No = bP, iv = No, h1 = Object.prototype, vP = h1.hasOwnProperty, xP = h1.toString, ul = iv ? iv.toStringTag : void 0; function wP(r) { var e = vP.call(r, ul), t = r[ul]; try { r[ul] = void 0; var n = !0 } catch { } var i = xP.call(r); return n && (e ? r[ul] = t : delete r[ul]), i } var CP = wP, SP = Object.prototype, EP = SP.toString; function _P(r) { return EP.call(r) } var OP = _P, sv = No, TP = CP, IP = OP, PP = "[object Null]", kP = "[object Undefined]", av = sv ? sv.toStringTag : void 0; function RP(r) { return r == null ? r === void 0 ? kP : PP : av && av in Object(r) ? TP(r) : IP(r) } var Si = RP; function DP(r) { return r != null && typeof r == "object" } var Sr = DP, AP = Si, NP = Sr, FP = "[object Symbol]"; function $P(r) { return typeof r == "symbol" || NP(r) && AP(r) == FP } var Fo = $P, LP = Dn, MP = Fo, jP = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, VP = /^\w*$/; function BP(r, e) { if (LP(r)) return !1; var t = typeof r; return t == "number" || t == "symbol" || t == "boolean" || r == null || MP(r) ? !0 : VP.test(r) || !jP.test(r) || e != null && r in Object(e) } var hm = BP; function zP(r) { var e = typeof r; return r != null && (e == "object" || e == "function") } var Er = zP; const an = _e(Er); var HP = Si, KP = Er, UP = "[object AsyncFunction]", WP = "[object Function]", GP = "[object GeneratorFunction]", YP = "[object Proxy]"; function XP(r) { if (!KP(r)) return !1; var e = HP(r); return e == WP || e == GP || e == UP || e == YP } var Pd = XP; const we = _e(Pd); var qP = Ci, ZP = qP["__core-js_shared__"], JP = ZP, Kh = JP, ov = function () { var r = /[^.]+$/.exec(Kh && Kh.keys && Kh.keys.IE_PROTO || ""); return r ? "Symbol(src)_1." + r : "" }(); function QP(r) { return !!ov && ov in r } var ek = QP, tk = Function.prototype, nk = tk.toString; function rk(r) { if (r != null) { try { return nk.call(r) } catch { } try { return r + "" } catch { } } return "" } var p1 = rk, ik = Pd, sk = ek, ak = Er, ok = p1, lk = /[\\^$.*+?()[\]{}|]/g, ck = /^\[object .+?Constructor\]$/, uk = Function.prototype, dk = Object.prototype, hk = uk.toString, pk = dk.hasOwnProperty, fk = RegExp("^" + hk.call(pk).replace(lk, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"); function gk(r) { if (!ak(r) || sk(r)) return !1; var e = ik(r) ? fk : ck; return e.test(ok(r)) } var mk = gk; function yk(r, e) { return r == null ? void 0 : r[e] } var bk = yk, vk = mk, xk = bk; function wk(r, e) { var t = xk(r, e); return vk(t) ? t : void 0 } var wa = wk, Ck = wa, Sk = Ck(Object, "create"), kd = Sk, lv = kd; function Ek() { this.__data__ = lv ? lv(null) : {}, this.size = 0 } var _k = Ek; function Ok(r) { var e = this.has(r) && delete this.__data__[r]; return this.size -= e ? 1 : 0, e } var Tk = Ok, Ik = kd, Pk = "__lodash_hash_undefined__", kk = Object.prototype, Rk = kk.hasOwnProperty; function Dk(r) { var e = this.__data__; if (Ik) { var t = e[r]; return t === Pk ? void 0 : t } return Rk.call(e, r) ? e[r] : void 0 } var Ak = Dk, Nk = kd, Fk = Object.prototype, $k = Fk.hasOwnProperty; function Lk(r) { var e = this.__data__; return Nk ? e[r] !== void 0 : $k.call(e, r) } var Mk = Lk, jk = kd, Vk = "__lodash_hash_undefined__"; function Bk(r, e) { var t = this.__data__; return this.size += this.has(r) ? 0 : 1, t[r] = jk && e === void 0 ? Vk : e, this } var zk = Bk, Hk = _k, Kk = Tk, Uk = Ak, Wk = Mk, Gk = zk; function $o(r) { var e = -1, t = r == null ? 0 : r.length; for (this.clear(); ++e < t;) { var n = r[e]; this.set(n[0], n[1]) } } $o.prototype.clear = Hk; $o.prototype.delete = Kk; $o.prototype.get = Uk; $o.prototype.has = Wk; $o.prototype.set = Gk; var Yk = $o; function Xk() { this.__data__ = [], this.size = 0 } var qk = Xk; function Zk(r, e) { return r === e || r !== r && e !== e } var ac = Zk, Jk = ac; function Qk(r, e) { for (var t = r.length; t--;)if (Jk(r[t][0], e)) return t; return -1 } var Rd = Qk, eR = Rd, tR = Array.prototype, nR = tR.splice; function rR(r) { var e = this.__data__, t = eR(e, r); if (t < 0) return !1; var n = e.length - 1; return t == n ? e.pop() : nR.call(e, t, 1), --this.size, !0 } var iR = rR, sR = Rd; function aR(r) { var e = this.__data__, t = sR(e, r); return t < 0 ? void 0 : e[t][1] } var oR = aR, lR = Rd; function cR(r) { return lR(this.__data__, r) > -1 } var uR = cR, dR = Rd; function hR(r, e) { var t = this.__data__, n = dR(t, r); return n < 0 ? (++this.size, t.push([r, e])) : t[n][1] = e, this } var pR = hR, fR = qk, gR = iR, mR = oR, yR = uR, bR = pR; function Lo(r) { var e = -1, t = r == null ? 0 : r.length; for (this.clear(); ++e < t;) { var n = r[e]; this.set(n[0], n[1]) } } Lo.prototype.clear = fR; Lo.prototype.delete = gR; Lo.prototype.get = mR; Lo.prototype.has = yR; Lo.prototype.set = bR; var Dd = Lo, vR = wa, xR = Ci, wR = vR(xR, "Map"), pm = wR, cv = Yk, CR = Dd, SR = pm; function ER() { this.size = 0, this.__data__ = { hash: new cv, map: new (SR || CR), string: new cv } } var _R = ER; function OR(r) { var e = typeof r; return e == "string" || e == "number" || e == "symbol" || e == "boolean" ? r !== "__proto__" : r === null } var TR = OR, IR = TR; function PR(r, e) { var t = r.__data__; return IR(e) ? t[typeof e == "string" ? "string" : "hash"] : t.map } var Ad = PR, kR = Ad; function RR(r) { var e = kR(this, r).delete(r); return this.size -= e ? 1 : 0, e } var DR = RR, AR = Ad; function NR(r) { return AR(this, r).get(r) } var FR = NR, $R = Ad; function LR(r) { return $R(this, r).has(r) } var MR = LR, jR = Ad; function VR(r, e) { var t = jR(this, r), n = t.size; return t.set(r, e), this.size += t.size == n ? 0 : 1, this } var BR = VR, zR = _R, HR = DR, KR = FR, UR = MR, WR = BR; function Mo(r) { var e = -1, t = r == null ? 0 : r.length; for (this.clear(); ++e < t;) { var n = r[e]; this.set(n[0], n[1]) } } Mo.prototype.clear = zR; Mo.prototype.delete = HR; Mo.prototype.get = KR; Mo.prototype.has = UR; Mo.prototype.set = WR; var fm = Mo, f1 = fm, GR = "Expected a function"; function gm(r, e) { if (typeof r != "function" || e != null && typeof e != "function") throw new TypeError(GR); var t = function () { var n = arguments, i = e ? e.apply(this, n) : n[0], s = t.cache; if (s.has(i)) return s.get(i); var a = r.apply(this, n); return t.cache = s.set(i, a) || s, a }; return t.cache = new (gm.Cache || f1), t } gm.Cache = f1; var YR = gm, XR = YR, qR = 500; function ZR(r) { var e = XR(r, function (n) { return t.size === qR && t.clear(), n }), t = e.cache; return e } var JR = ZR, QR = JR, eD = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, tD = /\\(\\)?/g, nD = QR(function (r) { var e = []; return r.charCodeAt(0) === 46 && e.push(""), r.replace(eD, function (t, n, i, s) { e.push(i ? s.replace(tD, "$1") : n || t) }), e }), g1 = nD; function rD(r, e) { for (var t = -1, n = r == null ? 0 : r.length, i = Array(n); ++t < n;)i[t] = e(r[t], t, r); return i } var Ca = rD, uv = No, iD = Ca, sD = Dn, aD = Fo, dv = uv ? uv.prototype : void 0, hv = dv ? dv.toString : void 0; function m1(r) { if (typeof r == "string") return r; if (sD(r)) return iD(r, m1) + ""; if (aD(r)) return hv ? hv.call(r) : ""; var e = r + ""; return e == "0" && 1 / r == -1 / 0 ? "-0" : e } var y1 = m1, oD = y1; function lD(r) { return r == null ? "" : oD(r) } var Nd = lD; const Ss = _e(Nd); var cD = Dn, uD = hm, dD = g1, hD = Nd; function pD(r, e) { return cD(r) ? r : uD(r, e) ? [r] : dD(hD(r)) } var jo = pD, fD = Fo; function gD(r) { if (typeof r == "string" || fD(r)) return r; var e = r + ""; return e == "0" && 1 / r == -1 / 0 ? "-0" : e } var Sa = gD, mD = jo, yD = Sa; function bD(r, e) { e = mD(e, r); for (var t = 0, n = e.length; r != null && t < n;)r = r[yD(e[t++])]; return t && t == n ? r : void 0 } var Fd = bD, vD = Fd; function xD(r, e, t) { var n = r == null ? void 0 : vD(r, e); return n === void 0 ? t : n } var b1 = xD; const H = _e(b1), v1 = function (r) { if (H(process, "env.NODE_ENV") === "development") { for (var e = arguments.length, t = new Array(e > 1 ? e - 1 : 0), n = 1; n < e; n++)t[n - 1] = arguments[n]; console.log(r, ...t) } }; class ve { static get cssClasses() { return {} } static get strings() { return {} } static get numbers() { return {} } static get defaultAdapter() { return { getProp: z, getProps: z, getState: z, getStates: z, setState: z, getContext: z, getContexts: z, getCache: z, setCache: z, getCaches: z, stopPropagation: z, persistEvent: z } } constructor(e) { this._adapter = Object.assign(Object.assign({}, ve.defaultAdapter), e) } getProp(e) { return this._adapter.getProp(e) } getProps() { return this._adapter.getProps() } getState(e) { return this._adapter.getState(e) } getStates() { return this._adapter.getStates() } setState(e, t) { return this._adapter.setState(Object.assign({}, e), t) } getContext(e) { return this._adapter.getContext(e) } getContexts() { return this._adapter.getContexts() } getCaches() { return this._adapter.getCaches() } getCache(e) { return this._adapter.getCache(e) } setCache(e, t) { return e && this._adapter.setCache(e, t) } stopPropagation(e) { this._adapter.stopPropagation(e) } _isControlledComponent() { let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "value"; const t = this.getProps(); return e in t } _isInProps(e) { const t = this.getProps(); return e in t } init(e) { } destroy() { } log(e) { for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), i = 1; i < t; i++)n[i - 1] = arguments[i]; v1(e, ...n) } _persistEvent(e) { this._adapter.persistEvent(e) } } function Xr(r) { return Object.keys(r).reduce((e, t) => (t.substr(0, 5) === "data-" && (e[t] = r[t]), e), {}) } const { hasOwnProperty: wD } = Object.prototype; class de extends R.Component { constructor(e) { super(e), this.isControlled = t => !!(t && this.props && typeof this.props == "object" && wD.call(this.props, t)), this.setStateAsync = t => new Promise(n => { this.setState(t, n) }), this.cache = {}, this.foundation = null } componentDidMount() { this.foundation && typeof this.foundation.init == "function" && this.foundation.init() } componentWillUnmount() { this.foundation && typeof this.foundation.destroy == "function" && this.foundation.destroy(), this.cache = {} } get adapter() { return { getContext: e => { if (this.context && e) return this.context[e] }, getContexts: () => this.context, getProp: e => this.props[e], getProps: () => this.props, getState: e => this.state[e], getStates: () => this.state, setState: (e, t) => this.setState(Object.assign({}, e), t), getCache: e => e && this.cache[e], getCaches: () => this.cache, setCache: (e, t) => e && (this.cache[e] = t), stopPropagation: e => { try { e.stopPropagation(), e.nativeEvent && e.nativeEvent.stopImmediatePropagation() } catch { } }, persistEvent: e => { e && e.persist && typeof e.persist == "function" && e.persist() } } } log(e) { for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), i = 1; i < t; i++)n[i - 1] = arguments[i]; return v1(e, ...n) } getDataAttr() { let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.props; return Xr(e) } } de.propTypes = {}; de.defaultProps = {}; var CD = Ci, SD = function () { return CD.Date.now() }, ED = SD, _D = /\s/; function OD(r) { for (var e = r.length; e-- && _D.test(r.charAt(e));); return e } var TD = OD, ID = TD, PD = /^\s+/; function kD(r) { return r && r.slice(0, ID(r) + 1).replace(PD, "") } var RD = kD, DD = RD, pv = Er, AD = Fo, fv = NaN, ND = /^[-+]0x[0-9a-f]+$/i, FD = /^0b[01]+$/i, $D = /^0o[0-7]+$/i, LD = parseInt; function MD(r) { if (typeof r == "number") return r; if (AD(r)) return fv; if (pv(r)) { var e = typeof r.valueOf == "function" ? r.valueOf() : r; r = pv(e) ? e + "" : e } if (typeof r != "string") return r === 0 ? r : +r; r = DD(r); var t = FD.test(r); return t || $D.test(r) ? LD(r.slice(2), t ? 2 : 8) : ND.test(r) ? fv : +r } var mm = MD; const zr = _e(mm); var jD = Er, Uh = ED, gv = mm, VD = "Expected a function", BD = Math.max, zD = Math.min; function HD(r, e, t) { var n, i, s, a, o, l, u = 0, d = !1, h = !1, g = !0; if (typeof r != "function") throw new TypeError(VD); e = gv(e) || 0, jD(t) && (d = !!t.leading, h = "maxWait" in t, s = h ? BD(gv(t.maxWait) || 0, e) : s, g = "trailing" in t ? !!t.trailing : g); function m(v) { var T = n, I = i; return n = i = void 0, u = v, a = r.apply(I, T), a } function b(v) { return u = v, o = setTimeout(x, e), d ? m(v) : a } function y(v) { var T = v - l, I = v - u, k = e - T; return h ? zD(k, s - I) : k } function w(v) { var T = v - l, I = v - u; return l === void 0 || T >= e || T < 0 || h && I >= s } function x() { var v = Uh(); if (w(v)) return S(v); o = setTimeout(x, y(v)) } function S(v) { return o = void 0, g && n ? m(v) : (n = i = void 0, a) } function C() { o !== void 0 && clearTimeout(o), u = 0, n = l = i = o = void 0 } function O() { return o === void 0 ? a : S(Uh()) } function E() { var v = Uh(), T = w(v); if (n = arguments, i = this, l = v, T) { if (o === void 0) return b(l); if (h) return clearTimeout(o), o = setTimeout(x, e), m(l) } return o === void 0 && (o = setTimeout(x, e)), a } return E.cancel = C, E.flush = O, E } var x1 = HD; const $d = _e(x1); var KD = x1, UD = Er, WD = "Expected a function"; function GD(r, e, t) { var n = !0, i = !0; if (typeof r != "function") throw new TypeError(WD); return UD(t) && (n = "leading" in t ? !!t.leading : n, i = "trailing" in t ? !!t.trailing : i), KD(r, e, { leading: n, maxWait: e, trailing: i }) } var YD = GD; const xo = _e(YD); var w1 = { exports: {} };/*!
	Copyright (c) 2018 Jed Watson.
	Licensed under the MIT License (MIT), see
	http://jedwatson.github.io/classnames
*/(function (r) { (function () { var e = {}.hasOwnProperty; function t() { for (var s = "", a = 0; a < arguments.length; a++) { var o = arguments[a]; o && (s = i(s, n(o))) } return s } function n(s) { if (typeof s == "string" || typeof s == "number") return s; if (typeof s != "object") return ""; if (Array.isArray(s)) return t.apply(null, s); if (s.toString !== Object.prototype.toString && !s.toString.toString().includes("[native code]")) return s.toString(); var a = ""; for (var o in s) e.call(s, o) && s[o] && (a = i(a, o)); return a } function i(s, a) { return a ? s ? s + " " + a : s + a : s } r.exports ? (t.default = t, r.exports = t) : window.classNames = t })() })(w1); var XD = w1.exports; const F = _e(XD); var C1 = { exports: {} }, qD = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED", ZD = qD, JD = ZD; function S1() { } function E1() { } E1.resetWarningCache = S1; var QD = function () { function r(n, i, s, a, o, l) { if (l !== JD) { var u = new Error("Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"); throw u.name = "Invariant Violation", u } } r.isRequired = r; function e() { return r } var t = { array: r, bigint: r, bool: r, func: r, number: r, object: r, string: r, symbol: r, any: r, arrayOf: e, element: r, elementType: r, instanceOf: e, node: r, objectOf: e, oneOf: e, oneOfType: e, shape: e, exact: e, checkPropTypes: E1, resetWarningCache: S1 }; return t.PropTypes = t, t }; C1.exports = QD(); var oc = C1.exports; const c = _e(oc), G = "semi", Vo = ["default", "error", "warning", "success"]; function mv(r) { return typeof r == "object" && r != null && r.nodeType === 1 } function yv(r, e) { return (!e || r !== "hidden") && r !== "visible" && r !== "clip" } function Wh(r, e) { if (r.clientHeight < r.scrollHeight || r.clientWidth < r.scrollWidth) { var t = getComputedStyle(r, null); return yv(t.overflowY, e) || yv(t.overflowX, e) || function (n) { var i = function (s) { if (!s.ownerDocument || !s.ownerDocument.defaultView) return null; try { return s.ownerDocument.defaultView.frameElement } catch { return null } }(n); return !!i && (i.clientHeight < n.scrollHeight || i.clientWidth < n.scrollWidth) }(r) } return !1 } function Zc(r, e, t, n, i, s, a, o) { return s < r && a > e || s > r && a < e ? 0 : s <= r && o <= t || a >= e && o >= t ? s - r - n : a > e && o < t || s < r && o > t ? a - e + i : 0 } var bv = function (r, e) { var t = window, n = e.scrollMode, i = e.block, s = e.inline, a = e.boundary, o = e.skipOverflowHiddenElements, l = typeof a == "function" ? a : function (ht) { return ht !== a }; if (!mv(r)) throw new TypeError("Invalid target"); for (var u, d, h = document.scrollingElement || document.documentElement, g = [], m = r; mv(m) && l(m);) { if ((m = (d = (u = m).parentElement) == null ? u.getRootNode().host || null : d) === h) { g.push(m); break } m != null && m === document.body && Wh(m) && !Wh(document.documentElement) || m != null && Wh(m, o) && g.push(m) } for (var b = t.visualViewport ? t.visualViewport.width : innerWidth, y = t.visualViewport ? t.visualViewport.height : innerHeight, w = window.scrollX || pageXOffset, x = window.scrollY || pageYOffset, S = r.getBoundingClientRect(), C = S.height, O = S.width, E = S.top, v = S.right, T = S.bottom, I = S.left, k = i === "start" || i === "nearest" ? E : i === "end" ? T : E + C / 2, P = s === "center" ? I + O / 2 : s === "end" ? v : I, N = [], M = 0; M < g.length; M++) { var B = g[M], K = B.getBoundingClientRect(), U = K.height, W = K.width, Z = K.top, J = K.right, ee = K.bottom, $ = K.left; if (n === "if-needed" && E >= 0 && I >= 0 && T <= y && v <= b && E >= Z && T <= ee && I >= $ && v <= J) return N; var pe = getComputedStyle(B), re = parseInt(pe.borderLeftWidth, 10), j = parseInt(pe.borderTopWidth, 10), ae = parseInt(pe.borderRightWidth, 10), be = parseInt(pe.borderBottomWidth, 10), fe = 0, Ce = 0, ue = "offsetWidth" in B ? B.offsetWidth - B.clientWidth - re - ae : 0, te = "offsetHeight" in B ? B.offsetHeight - B.clientHeight - j - be : 0, le = "offsetWidth" in B ? B.offsetWidth === 0 ? 0 : W / B.offsetWidth : 0, Re = "offsetHeight" in B ? B.offsetHeight === 0 ? 0 : U / B.offsetHeight : 0; if (h === B) fe = i === "start" ? k : i === "end" ? k - y : i === "nearest" ? Zc(x, x + y, y, j, be, x + k, x + k + C, C) : k - y / 2, Ce = s === "start" ? P : s === "center" ? P - b / 2 : s === "end" ? P - b : Zc(w, w + b, b, re, ae, w + P, w + P + O, O), fe = Math.max(0, fe + x), Ce = Math.max(0, Ce + w); else { fe = i === "start" ? k - Z - j : i === "end" ? k - ee + be + te : i === "nearest" ? Zc(Z, ee, U, j, be + te, k, k + C, C) : k - (Z + U / 2) + te / 2, Ce = s === "start" ? P - $ - re : s === "center" ? P - ($ + W / 2) + ue / 2 : s === "end" ? P - J + ae + ue : Zc($, J, W, re, ae + ue, P, P + O, O); var at = B.scrollLeft, yt = B.scrollTop; k += yt - (fe = Math.max(0, Math.min(yt + fe / Re, B.scrollHeight - U / Re + te))), P += at - (Ce = Math.max(0, Math.min(at + Ce / le, B.scrollWidth - W / le + ue))) } N.push({ el: B, top: fe, left: Ce }) } return N }; function _1(r) { return r === Object(r) && Object.keys(r).length !== 0 } function eA(r, e) { e === void 0 && (e = "auto"); var t = "scrollBehavior" in document.body.style; r.forEach(function (n) { var i = n.el, s = n.top, a = n.left; i.scroll && t ? i.scroll({ top: s, left: a, behavior: e }) : (i.scrollTop = s, i.scrollLeft = a) }) } function tA(r) { return r === !1 ? { block: "end", inline: "nearest" } : _1(r) ? r : { block: "start", inline: "nearest" } } function Gh(r, e) { var t = r.isConnected || r.ownerDocument.documentElement.contains(r); if (_1(e) && typeof e.behavior == "function") return e.behavior(t ? bv(r, e) : []); if (t) { var n = tA(e); return eA(bv(r, n), n.behavior) } } const Ld = { PREFIX: `${G}-typography` }, qn = { WEIGHT: ["light", "regular", "medium", "semibold", "bold", "default"], TYPE: ["primary", "secondary", "danger", "warning", "success", "tertiary", "quaternary"], SIZE: ["normal", "small", "inherit"], SPACING: ["normal", "extended"], HEADING: [1, 2, 3, 4, 5, 6], RULE: ["text", "numbers", "bytes-decimal", "bytes-binary", "percentages", "exponential"], TRUNCATE: ["ceil", "floor", "round"] }; var nA = function (r, e) { var t = {}; for (var n in r) Object.prototype.hasOwnProperty.call(r, n) && e.indexOf(n) < 0 && (t[n] = r[n]); if (r != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, n = Object.getOwnPropertySymbols(r); i < n.length; i++)e.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(r, n[i]) && (t[n[i]] = r[n[i]]); return t }; const rA = Ld.PREFIX; let Md = class extends R.PureComponent { render() { const e = this.props, { component: t, className: n, children: i, forwardRef: s } = e, a = nA(e, ["component", "className", "children", "forwardRef"]), o = t, l = F(rA, n); return f.createElement(o, Object.assign({ className: l, ref: s }, a), i) } }; Md.defaultProps = { component: "article", style: {}, className: "" }; Md.propTypes = { component: c.string, style: c.object, className: c.string }; function iA(r) { return r === null } var sA = iA; const ss = _e(sA); var aA = Si, oA = Dn, lA = Sr, cA = "[object String]"; function uA(r) { return typeof r == "string" || !oA(r) && lA(r) && aA(r) == cA } var ym = uA; const Fe = _e(ym); var dA = Dd; function hA() { this.__data__ = new dA, this.size = 0 } var pA = hA; function fA(r) { var e = this.__data__, t = e.delete(r); return this.size = e.size, t } var gA = fA; function mA(r) { return this.__data__.get(r) } var yA = mA; function bA(r) { return this.__data__.has(r) } var vA = bA, xA = Dd, wA = pm, CA = fm, SA = 200; function EA(r, e) { var t = this.__data__; if (t instanceof xA) { var n = t.__data__; if (!wA || n.length < SA - 1) return n.push([r, e]), this.size = ++t.size, this; t = this.__data__ = new CA(n) } return t.set(r, e), this.size = t.size, this } var _A = EA, OA = Dd, TA = pA, IA = gA, PA = yA, kA = vA, RA = _A; function Bo(r) { var e = this.__data__ = new OA(r); this.size = e.size } Bo.prototype.clear = TA; Bo.prototype.delete = IA; Bo.prototype.get = PA; Bo.prototype.has = kA; Bo.prototype.set = RA; var jd = Bo, DA = wa, AA = function () { try { var r = DA(Object, "defineProperty"); return r({}, "", {}), r } catch { } }(), O1 = AA, vv = O1; function NA(r, e, t) { e == "__proto__" && vv ? vv(r, e, { configurable: !0, enumerable: !0, value: t, writable: !0 }) : r[e] = t } var bm = NA, FA = bm, $A = ac; function LA(r, e, t) { (t !== void 0 && !$A(r[e], t) || t === void 0 && !(e in r)) && FA(r, e, t) } var T1 = LA; function MA(r) { return function (e, t, n) { for (var i = -1, s = Object(e), a = n(e), o = a.length; o--;) { var l = a[r ? o : ++i]; if (t(s[l], l, s) === !1) break } return e } } var jA = MA, VA = jA, BA = VA(), I1 = BA, Ku = { exports: {} }; Ku.exports; (function (r, e) { var t = Ci, n = e && !e.nodeType && e, i = n && !0 && r && !r.nodeType && r, s = i && i.exports === n, a = s ? t.Buffer : void 0, o = a ? a.allocUnsafe : void 0; function l(u, d) { if (d) return u.slice(); var h = u.length, g = o ? o(h) : new u.constructor(h); return u.copy(g), g } r.exports = l })(Ku, Ku.exports); var P1 = Ku.exports, zA = Ci, HA = zA.Uint8Array, k1 = HA, xv = k1; function KA(r) { var e = new r.constructor(r.byteLength); return new xv(e).set(new xv(r)), e } var vm = KA, UA = vm; function WA(r, e) { var t = e ? UA(r.buffer) : r.buffer; return new r.constructor(t, r.byteOffset, r.length) } var R1 = WA; function GA(r, e) { var t = -1, n = r.length; for (e || (e = Array(n)); ++t < n;)e[t] = r[t]; return e } var Vd = GA, YA = Er, wv = Object.create, XA = function () { function r() { } return function (e) { if (!YA(e)) return {}; if (wv) return wv(e); r.prototype = e; var t = new r; return r.prototype = void 0, t } }(), qA = XA; function ZA(r, e) { return function (t) { return r(e(t)) } } var D1 = ZA, JA = D1, QA = JA(Object.getPrototypeOf, Object), xm = QA, eN = Object.prototype; function tN(r) { var e = r && r.constructor, t = typeof e == "function" && e.prototype || eN; return r === t } var lc = tN, nN = qA, rN = xm, iN = lc; function sN(r) { return typeof r.constructor == "function" && !iN(r) ? nN(rN(r)) : {} } var A1 = sN, aN = Si, oN = Sr, lN = "[object Arguments]"; function cN(r) { return oN(r) && aN(r) == lN } var uN = cN, Cv = uN, dN = Sr, N1 = Object.prototype, hN = N1.hasOwnProperty, pN = N1.propertyIsEnumerable, fN = Cv(function () { return arguments }()) ? Cv : function (r) { return dN(r) && hN.call(r, "callee") && !pN.call(r, "callee") }, cc = fN, gN = 9007199254740991; function mN(r) { return typeof r == "number" && r > -1 && r % 1 == 0 && r <= gN } var wm = mN, yN = Pd, bN = wm; function vN(r) { return r != null && bN(r.length) && !yN(r) } var Ei = vN, xN = Ei, wN = Sr; function CN(r) { return wN(r) && xN(r) } var Cm = CN, Uu = { exports: {} }; function SN() { return !1 } var F1 = SN; const jl = _e(F1); Uu.exports; (function (r, e) { var t = Ci, n = F1, i = e && !e.nodeType && e, s = i && !0 && r && !r.nodeType && r, a = s && s.exports === i, o = a ? t.Buffer : void 0, l = o ? o.isBuffer : void 0, u = l || n; r.exports = u })(Uu, Uu.exports); var uc = Uu.exports, EN = Si, _N = xm, ON = Sr, TN = "[object Object]", IN = Function.prototype, PN = Object.prototype, $1 = IN.toString, kN = PN.hasOwnProperty, RN = $1.call(Object); function DN(r) { if (!ON(r) || EN(r) != TN) return !1; var e = _N(r); if (e === null) return !0; var t = kN.call(e, "constructor") && e.constructor; return typeof t == "function" && t instanceof t && $1.call(t) == RN } var Sm = DN; const Wu = _e(Sm); var AN = Si, NN = wm, FN = Sr, $N = "[object Arguments]", LN = "[object Array]", MN = "[object Boolean]", jN = "[object Date]", VN = "[object Error]", BN = "[object Function]", zN = "[object Map]", HN = "[object Number]", KN = "[object Object]", UN = "[object RegExp]", WN = "[object Set]", GN = "[object String]", YN = "[object WeakMap]", XN = "[object ArrayBuffer]", qN = "[object DataView]", ZN = "[object Float32Array]", JN = "[object Float64Array]", QN = "[object Int8Array]", e2 = "[object Int16Array]", t2 = "[object Int32Array]", n2 = "[object Uint8Array]", r2 = "[object Uint8ClampedArray]", i2 = "[object Uint16Array]", s2 = "[object Uint32Array]", zt = {}; zt[ZN] = zt[JN] = zt[QN] = zt[e2] = zt[t2] = zt[n2] = zt[r2] = zt[i2] = zt[s2] = !0; zt[$N] = zt[LN] = zt[XN] = zt[MN] = zt[qN] = zt[jN] = zt[VN] = zt[BN] = zt[zN] = zt[HN] = zt[KN] = zt[UN] = zt[WN] = zt[GN] = zt[YN] = !1; function a2(r) { return FN(r) && NN(r.length) && !!zt[AN(r)] } var o2 = a2; function l2(r) { return function (e) { return r(e) } } var Ea = l2, Gu = { exports: {} }; Gu.exports; (function (r, e) { var t = d1, n = e && !e.nodeType && e, i = n && !0 && r && !r.nodeType && r, s = i && i.exports === n, a = s && t.process, o = function () { try { var l = i && i.require && i.require("util").types; return l || a && a.binding && a.binding("util") } catch { } }(); r.exports = o })(Gu, Gu.exports); var dc = Gu.exports, c2 = o2, u2 = Ea, Sv = dc, Ev = Sv && Sv.isTypedArray, d2 = Ev ? u2(Ev) : c2, Bd = d2; function h2(r, e) { if (!(e === "constructor" && typeof r[e] == "function") && e != "__proto__") return r[e] } var L1 = h2, p2 = bm, f2 = ac, g2 = Object.prototype, m2 = g2.hasOwnProperty; function y2(r, e, t) { var n = r[e]; (!(m2.call(r, e) && f2(n, t)) || t === void 0 && !(e in r)) && p2(r, e, t) } var zd = y2, b2 = zd, v2 = bm; function x2(r, e, t, n) { var i = !t; t || (t = {}); for (var s = -1, a = e.length; ++s < a;) { var o = e[s], l = n ? n(t[o], r[o], o, t, r) : void 0; l === void 0 && (l = r[o]), i ? v2(t, o, l) : b2(t, o, l) } return t } var _a = x2; function w2(r, e) { for (var t = -1, n = Array(r); ++t < r;)n[t] = e(t); return n } var M1 = w2, C2 = 9007199254740991, S2 = /^(?:0|[1-9]\d*)$/; function E2(r, e) { var t = typeof r; return e = e ?? C2, !!e && (t == "number" || t != "symbol" && S2.test(r)) && r > -1 && r % 1 == 0 && r < e } var hc = E2, _2 = M1, O2 = cc, T2 = Dn, I2 = uc, P2 = hc, k2 = Bd, R2 = Object.prototype, D2 = R2.hasOwnProperty; function A2(r, e) { var t = T2(r), n = !t && O2(r), i = !t && !n && I2(r), s = !t && !n && !i && k2(r), a = t || n || i || s, o = a ? _2(r.length, String) : [], l = o.length; for (var u in r) (e || D2.call(r, u)) && !(a && (u == "length" || i && (u == "offset" || u == "parent") || s && (u == "buffer" || u == "byteLength" || u == "byteOffset") || P2(u, l))) && o.push(u); return o } var j1 = A2; function N2(r) { var e = []; if (r != null) for (var t in Object(r)) e.push(t); return e } var F2 = N2, $2 = Er, L2 = lc, M2 = F2, j2 = Object.prototype, V2 = j2.hasOwnProperty; function B2(r) { if (!$2(r)) return M2(r); var e = L2(r), t = []; for (var n in r) n == "constructor" && (e || !V2.call(r, n)) || t.push(n); return t } var z2 = B2, H2 = j1, K2 = z2, U2 = Ei; function W2(r) { return U2(r) ? H2(r, !0) : K2(r) } var pc = W2, G2 = _a, Y2 = pc; function X2(r) { return G2(r, Y2(r)) } var q2 = X2, _v = T1, Z2 = P1, J2 = R1, Q2 = Vd, eF = A1, Ov = cc, Tv = Dn, tF = Cm, nF = uc, rF = Pd, iF = Er, sF = Sm, aF = Bd, Iv = L1, oF = q2; function lF(r, e, t, n, i, s, a) { var o = Iv(r, t), l = Iv(e, t), u = a.get(l); if (u) { _v(r, t, u); return } var d = s ? s(o, l, t + "", r, e, a) : void 0, h = d === void 0; if (h) { var g = Tv(l), m = !g && nF(l), b = !g && !m && aF(l); d = l, g || m || b ? Tv(o) ? d = o : tF(o) ? d = Q2(o) : m ? (h = !1, d = Z2(l, !0)) : b ? (h = !1, d = J2(l, !0)) : d = [] : sF(l) || Ov(l) ? (d = o, Ov(o) ? d = oF(o) : (!iF(o) || rF(o)) && (d = eF(l))) : h = !1 } h && (a.set(l, d), i(d, l, n, s, a), a.delete(l)), _v(r, t, d) } var cF = lF, uF = jd, dF = T1, hF = I1, pF = cF, fF = Er, gF = pc, mF = L1; function V1(r, e, t, n, i) { r !== e && hF(e, function (s, a) { if (i || (i = new uF), fF(s)) pF(r, e, a, t, V1, n, i); else { var o = n ? n(mF(r, a), s, a + "", r, e, i) : void 0; o === void 0 && (o = s), dF(r, a, o) } }, gF) } var yF = V1; function bF(r) { return r } var fc = bF; function vF(r, e, t) { switch (t.length) { case 0: return r.call(e); case 1: return r.call(e, t[0]); case 2: return r.call(e, t[0], t[1]); case 3: return r.call(e, t[0], t[1], t[2]) }return r.apply(e, t) } var xF = vF, wF = xF, Pv = Math.max; function CF(r, e, t) { return e = Pv(e === void 0 ? r.length - 1 : e, 0), function () { for (var n = arguments, i = -1, s = Pv(n.length - e, 0), a = Array(s); ++i < s;)a[i] = n[e + i]; i = -1; for (var o = Array(e + 1); ++i < e;)o[i] = n[i]; return o[e] = t(a), wF(r, this, o) } } var B1 = CF; function SF(r) { return function () { return r } } var EF = SF, _F = EF, kv = O1, OF = fc, TF = kv ? function (r, e) { return kv(r, "toString", { configurable: !0, enumerable: !1, value: _F(e), writable: !0 }) } : OF, IF = TF, PF = 800, kF = 16, RF = Date.now; function DF(r) { var e = 0, t = 0; return function () { var n = RF(), i = kF - (n - t); if (t = n, i > 0) { if (++e >= PF) return arguments[0] } else e = 0; return r.apply(void 0, arguments) } } var AF = DF, NF = IF, FF = AF, $F = FF(NF), z1 = $F, LF = fc, MF = B1, jF = z1; function VF(r, e) { return jF(MF(r, e, LF), r + "") } var Hd = VF, BF = ac, zF = Ei, HF = hc, KF = Er; function UF(r, e, t) { if (!KF(t)) return !1; var n = typeof e; return (n == "number" ? zF(t) && HF(e, t.length) : n == "string" && e in t) ? BF(t[e], r) : !1 } var Kd = UF, WF = Hd, GF = Kd; function YF(r) { return WF(function (e, t) { var n = -1, i = t.length, s = i > 1 ? t[i - 1] : void 0, a = i > 2 ? t[2] : void 0; for (s = r.length > 3 && typeof s == "function" ? (i--, s) : void 0, a && GF(t[0], t[1], a) && (s = i < 3 ? void 0 : s, i = 1), e = Object(e); ++n < i;) { var o = t[n]; o && r(e, o, n, s) } return e }) } var H1 = YF, XF = yF, qF = H1, ZF = qF(function (r, e, t) { XF(r, e, t) }), JF = ZF; const gc = _e(JF); function QF(r, e) { for (var t = -1, n = r == null ? 0 : r.length; ++t < n && e(r[t], t, r) !== !1;); return r } var K1 = QF, e$ = D1, t$ = e$(Object.keys, Object), n$ = t$, r$ = lc, i$ = n$, s$ = Object.prototype, a$ = s$.hasOwnProperty; function o$(r) { if (!r$(r)) return i$(r); var e = []; for (var t in Object(r)) a$.call(r, t) && t != "constructor" && e.push(t); return e } var Em = o$, l$ = j1, c$ = Em, u$ = Ei; function d$(r) { return u$(r) ? l$(r) : c$(r) } var zs = d$, h$ = _a, p$ = zs; function f$(r, e) { return r && h$(e, p$(e), r) } var g$ = f$, m$ = _a, y$ = pc; function b$(r, e) { return r && m$(e, y$(e), r) } var v$ = b$; function x$(r, e) { for (var t = -1, n = r == null ? 0 : r.length, i = 0, s = []; ++t < n;) { var a = r[t]; e(a, t, r) && (s[i++] = a) } return s } var U1 = x$; function w$() { return [] } var W1 = w$, C$ = U1, S$ = W1, E$ = Object.prototype, _$ = E$.propertyIsEnumerable, Rv = Object.getOwnPropertySymbols, O$ = Rv ? function (r) { return r == null ? [] : (r = Object(r), C$(Rv(r), function (e) { return _$.call(r, e) })) } : S$, _m = O$, T$ = _a, I$ = _m; function P$(r, e) { return T$(r, I$(r), e) } var k$ = P$; function R$(r, e) { for (var t = -1, n = e.length, i = r.length; ++t < n;)r[i + t] = e[t]; return r } var Om = R$, D$ = Om, A$ = xm, N$ = _m, F$ = W1, $$ = Object.getOwnPropertySymbols, L$ = $$ ? function (r) { for (var e = []; r;)D$(e, N$(r)), r = A$(r); return e } : F$, G1 = L$, M$ = _a, j$ = G1; function V$(r, e) { return M$(r, j$(r), e) } var B$ = V$, z$ = Om, H$ = Dn; function K$(r, e, t) { var n = e(r); return H$(r) ? n : z$(n, t(r)) } var Y1 = K$, U$ = Y1, W$ = _m, G$ = zs; function Y$(r) { return U$(r, G$, W$) } var X1 = Y$, X$ = Y1, q$ = G1, Z$ = pc; function J$(r) { return X$(r, Z$, q$) } var q1 = J$, Q$ = wa, eL = Ci, tL = Q$(eL, "DataView"), nL = tL, rL = wa, iL = Ci, sL = rL(iL, "Promise"), aL = sL, oL = wa, lL = Ci, cL = oL(lL, "Set"), Z1 = cL, uL = wa, dL = Ci, hL = uL(dL, "WeakMap"), pL = hL, ff = nL, gf = pm, mf = aL, yf = Z1, bf = pL, J1 = Si, zo = p1, Dv = "[object Map]", fL = "[object Object]", Av = "[object Promise]", Nv = "[object Set]", Fv = "[object WeakMap]", $v = "[object DataView]", gL = zo(ff), mL = zo(gf), yL = zo(mf), bL = zo(yf), vL = zo(bf), Qs = J1; (ff && Qs(new ff(new ArrayBuffer(1))) != $v || gf && Qs(new gf) != Dv || mf && Qs(mf.resolve()) != Av || yf && Qs(new yf) != Nv || bf && Qs(new bf) != Fv) && (Qs = function (r) { var e = J1(r), t = e == fL ? r.constructor : void 0, n = t ? zo(t) : ""; if (n) switch (n) { case gL: return $v; case mL: return Dv; case yL: return Av; case bL: return Nv; case vL: return Fv }return e }); var Ho = Qs, xL = Object.prototype, wL = xL.hasOwnProperty; function CL(r) { var e = r.length, t = new r.constructor(e); return e && typeof r[0] == "string" && wL.call(r, "index") && (t.index = r.index, t.input = r.input), t } var SL = CL, EL = vm; function _L(r, e) { var t = e ? EL(r.buffer) : r.buffer; return new r.constructor(t, r.byteOffset, r.byteLength) } var OL = _L, TL = /\w*$/; function IL(r) { var e = new r.constructor(r.source, TL.exec(r)); return e.lastIndex = r.lastIndex, e } var PL = IL, Lv = No, Mv = Lv ? Lv.prototype : void 0, jv = Mv ? Mv.valueOf : void 0; function kL(r) { return jv ? Object(jv.call(r)) : {} } var RL = kL, DL = vm, AL = OL, NL = PL, FL = RL, $L = R1, LL = "[object Boolean]", ML = "[object Date]", jL = "[object Map]", VL = "[object Number]", BL = "[object RegExp]", zL = "[object Set]", HL = "[object String]", KL = "[object Symbol]", UL = "[object ArrayBuffer]", WL = "[object DataView]", GL = "[object Float32Array]", YL = "[object Float64Array]", XL = "[object Int8Array]", qL = "[object Int16Array]", ZL = "[object Int32Array]", JL = "[object Uint8Array]", QL = "[object Uint8ClampedArray]", eM = "[object Uint16Array]", tM = "[object Uint32Array]"; function nM(r, e, t) { var n = r.constructor; switch (e) { case UL: return DL(r); case LL: case ML: return new n(+r); case WL: return AL(r, t); case GL: case YL: case XL: case qL: case ZL: case JL: case QL: case eM: case tM: return $L(r, t); case jL: return new n; case VL: case HL: return new n(r); case BL: return NL(r); case zL: return new n; case KL: return FL(r) } } var rM = nM, iM = Ho, sM = Sr, aM = "[object Map]"; function oM(r) { return sM(r) && iM(r) == aM } var lM = oM, cM = lM, uM = Ea, Vv = dc, Bv = Vv && Vv.isMap, dM = Bv ? uM(Bv) : cM, Q1 = dM; const Vl = _e(Q1); var hM = Ho, pM = Sr, fM = "[object Set]"; function gM(r) { return pM(r) && hM(r) == fM } var mM = gM, yM = mM, bM = Ea, zv = dc, Hv = zv && zv.isSet, vM = Hv ? bM(Hv) : yM, eS = vM; const Ri = _e(eS); var xM = jd, wM = K1, CM = zd, SM = g$, EM = v$, _M = P1, OM = Vd, TM = k$, IM = B$, PM = X1, kM = q1, RM = Ho, DM = SL, AM = rM, NM = A1, FM = Dn, $M = uc, LM = Q1, MM = Er, jM = eS, VM = zs, BM = pc, zM = 1, HM = 2, KM = 4, tS = "[object Arguments]", UM = "[object Array]", WM = "[object Boolean]", GM = "[object Date]", YM = "[object Error]", nS = "[object Function]", XM = "[object GeneratorFunction]", qM = "[object Map]", ZM = "[object Number]", rS = "[object Object]", JM = "[object RegExp]", QM = "[object Set]", ej = "[object String]", tj = "[object Symbol]", nj = "[object WeakMap]", rj = "[object ArrayBuffer]", ij = "[object DataView]", sj = "[object Float32Array]", aj = "[object Float64Array]", oj = "[object Int8Array]", lj = "[object Int16Array]", cj = "[object Int32Array]", uj = "[object Uint8Array]", dj = "[object Uint8ClampedArray]", hj = "[object Uint16Array]", pj = "[object Uint32Array]", Mt = {}; Mt[tS] = Mt[UM] = Mt[rj] = Mt[ij] = Mt[WM] = Mt[GM] = Mt[sj] = Mt[aj] = Mt[oj] = Mt[lj] = Mt[cj] = Mt[qM] = Mt[ZM] = Mt[rS] = Mt[JM] = Mt[QM] = Mt[ej] = Mt[tj] = Mt[uj] = Mt[dj] = Mt[hj] = Mt[pj] = !0; Mt[YM] = Mt[nS] = Mt[nj] = !1; function Ou(r, e, t, n, i, s) { var a, o = e & zM, l = e & HM, u = e & KM; if (t && (a = i ? t(r, n, i, s) : t(r)), a !== void 0) return a; if (!MM(r)) return r; var d = FM(r); if (d) { if (a = DM(r), !o) return OM(r, a) } else { var h = RM(r), g = h == nS || h == XM; if ($M(r)) return _M(r, o); if (h == rS || h == tS || g && !i) { if (a = l || g ? {} : NM(r), !o) return l ? IM(r, EM(a, r)) : TM(r, SM(a, r)) } else { if (!Mt[h]) return i ? r : {}; a = AM(r, h, o) } } s || (s = new xM); var m = s.get(r); if (m) return m; s.set(r, a), jM(r) ? r.forEach(function (w) { a.add(Ou(w, e, t, w, r, s)) }) : LM(r) && r.forEach(function (w, x) { a.set(x, Ou(w, e, t, x, r, s)) }); var b = u ? l ? kM : PM : l ? BM : VM, y = d ? void 0 : b(r); return wM(y || r, function (w, x) { y && (x = w, w = r[x]), CM(a, x, Ou(w, e, t, x, r, s)) }), a } var Tm = Ou; function fj(r) { var e = r == null ? 0 : r.length; return e ? r[e - 1] : void 0 } var gj = fj; function mj(r, e, t) { var n = -1, i = r.length; e < 0 && (e = -e > i ? 0 : i + e), t = t > i ? i : t, t < 0 && (t += i), i = e > t ? 0 : t - e >>> 0, e >>>= 0; for (var s = Array(i); ++n < i;)s[n] = r[n + e]; return s } var Im = mj, yj = Fd, bj = Im; function vj(r, e) { return e.length < 2 ? r : yj(r, bj(e, 0, -1)) } var xj = vj, wj = jo, Cj = gj, Sj = xj, Ej = Sa; function _j(r, e) { return e = wj(e, r), r = Sj(r, e), r == null || delete r[Ej(Cj(e))] } var iS = _j, Oj = Sm; function Tj(r) { return Oj(r) ? void 0 : r } var Ij = Tj, Kv = No, Pj = cc, kj = Dn, Uv = Kv ? Kv.isConcatSpreadable : void 0; function Rj(r) { return kj(r) || Pj(r) || !!(Uv && r && r[Uv]) } var Dj = Rj, Aj = Om, Nj = Dj; function sS(r, e, t, n, i) { var s = -1, a = r.length; for (t || (t = Nj), i || (i = []); ++s < a;) { var o = r[s]; e > 0 && t(o) ? e > 1 ? sS(o, e - 1, t, n, i) : Aj(i, o) : n || (i[i.length] = o) } return i } var Pm = sS, Fj = Pm; function $j(r) { var e = r == null ? 0 : r.length; return e ? Fj(r, 1) : [] } var Lj = $j, Mj = Lj, jj = B1, Vj = z1; function Bj(r) { return Vj(jj(r, void 0, Mj), r + "") } var aS = Bj, zj = Ca, Hj = Tm, Kj = iS, Uj = jo, Wj = _a, Gj = Ij, Yj = aS, Xj = q1, qj = 1, Zj = 2, Jj = 4, Qj = Yj(function (r, e) { var t = {}; if (r == null) return t; var n = !1; e = zj(e, function (s) { return s = Uj(s, r), n || (n = s.length > 1), s }), Wj(r, Xj(r), t), n && (t = Hj(t, qj | Zj | Jj, Gj)); for (var i = e.length; i--;)Kj(t, e[i]); return t }), e5 = Qj; const Ht = _e(e5); function t5(r) { return r === void 0 } var n5 = t5; const st = _e(n5); var r5 = "__lodash_hash_undefined__"; function i5(r) { return this.__data__.set(r, r5), this } var s5 = i5; function a5(r) { return this.__data__.has(r) } var o5 = a5, l5 = fm, c5 = s5, u5 = o5; function Yu(r) { var e = -1, t = r == null ? 0 : r.length; for (this.__data__ = new l5; ++e < t;)this.add(r[e]) } Yu.prototype.add = Yu.prototype.push = c5; Yu.prototype.has = u5; var km = Yu; function d5(r, e) { for (var t = -1, n = r == null ? 0 : r.length; ++t < n;)if (e(r[t], t, r)) return !0; return !1 } var oS = d5; function h5(r, e) { return r.has(e) } var Rm = h5, p5 = km, f5 = oS, g5 = Rm, m5 = 1, y5 = 2; function b5(r, e, t, n, i, s) { var a = t & m5, o = r.length, l = e.length; if (o != l && !(a && l > o)) return !1; var u = s.get(r), d = s.get(e); if (u && d) return u == e && d == r; var h = -1, g = !0, m = t & y5 ? new p5 : void 0; for (s.set(r, e), s.set(e, r); ++h < o;) { var b = r[h], y = e[h]; if (n) var w = a ? n(y, b, h, e, r, s) : n(b, y, h, r, e, s); if (w !== void 0) { if (w) continue; g = !1; break } if (m) { if (!f5(e, function (x, S) { if (!g5(m, S) && (b === x || i(b, x, t, n, s))) return m.push(S) })) { g = !1; break } } else if (!(b === y || i(b, y, t, n, s))) { g = !1; break } } return s.delete(r), s.delete(e), g } var lS = b5; function v5(r) { var e = -1, t = Array(r.size); return r.forEach(function (n, i) { t[++e] = [i, n] }), t } var x5 = v5; function w5(r) { var e = -1, t = Array(r.size); return r.forEach(function (n) { t[++e] = n }), t } var Dm = w5, Wv = No, Gv = k1, C5 = ac, S5 = lS, E5 = x5, _5 = Dm, O5 = 1, T5 = 2, I5 = "[object Boolean]", P5 = "[object Date]", k5 = "[object Error]", R5 = "[object Map]", D5 = "[object Number]", A5 = "[object RegExp]", N5 = "[object Set]", F5 = "[object String]", $5 = "[object Symbol]", L5 = "[object ArrayBuffer]", M5 = "[object DataView]", Yv = Wv ? Wv.prototype : void 0, Yh = Yv ? Yv.valueOf : void 0; function j5(r, e, t, n, i, s, a) { switch (t) { case M5: if (r.byteLength != e.byteLength || r.byteOffset != e.byteOffset) return !1; r = r.buffer, e = e.buffer; case L5: return !(r.byteLength != e.byteLength || !s(new Gv(r), new Gv(e))); case I5: case P5: case D5: return C5(+r, +e); case k5: return r.name == e.name && r.message == e.message; case A5: case F5: return r == e + ""; case R5: var o = E5; case N5: var l = n & O5; if (o || (o = _5), r.size != e.size && !l) return !1; var u = a.get(r); if (u) return u == e; n |= T5, a.set(r, e); var d = S5(o(r), o(e), n, i, s, a); return a.delete(r), d; case $5: if (Yh) return Yh.call(r) == Yh.call(e) }return !1 } var V5 = j5, Xv = X1, B5 = 1, z5 = Object.prototype, H5 = z5.hasOwnProperty; function K5(r, e, t, n, i, s) { var a = t & B5, o = Xv(r), l = o.length, u = Xv(e), d = u.length; if (l != d && !a) return !1; for (var h = l; h--;) { var g = o[h]; if (!(a ? g in e : H5.call(e, g))) return !1 } var m = s.get(r), b = s.get(e); if (m && b) return m == e && b == r; var y = !0; s.set(r, e), s.set(e, r); for (var w = a; ++h < l;) { g = o[h]; var x = r[g], S = e[g]; if (n) var C = a ? n(S, x, g, e, r, s) : n(x, S, g, r, e, s); if (!(C === void 0 ? x === S || i(x, S, t, n, s) : C)) { y = !1; break } w || (w = g == "constructor") } if (y && !w) { var O = r.constructor, E = e.constructor; O != E && "constructor" in r && "constructor" in e && !(typeof O == "function" && O instanceof O && typeof E == "function" && E instanceof E) && (y = !1) } return s.delete(r), s.delete(e), y } var U5 = K5, Xh = jd, W5 = lS, G5 = V5, Y5 = U5, qv = Ho, Zv = Dn, Jv = uc, X5 = Bd, q5 = 1, Qv = "[object Arguments]", ex = "[object Array]", Jc = "[object Object]", Z5 = Object.prototype, tx = Z5.hasOwnProperty; function J5(r, e, t, n, i, s) { var a = Zv(r), o = Zv(e), l = a ? ex : qv(r), u = o ? ex : qv(e); l = l == Qv ? Jc : l, u = u == Qv ? Jc : u; var d = l == Jc, h = u == Jc, g = l == u; if (g && Jv(r)) { if (!Jv(e)) return !1; a = !0, d = !1 } if (g && !d) return s || (s = new Xh), a || X5(r) ? W5(r, e, t, n, i, s) : G5(r, e, l, t, n, i, s); if (!(t & q5)) { var m = d && tx.call(r, "__wrapped__"), b = h && tx.call(e, "__wrapped__"); if (m || b) { var y = m ? r.value() : r, w = b ? e.value() : e; return s || (s = new Xh), i(y, w, t, n, s) } } return g ? (s || (s = new Xh), Y5(r, e, t, n, i, s)) : !1 } var Q5 = J5, e3 = Q5, nx = Sr; function cS(r, e, t, n, i) { return r === e ? !0 : r == null || e == null || !nx(r) && !nx(e) ? r !== r && e !== e : e3(r, e, t, n, cS, i) } var Ud = cS, t3 = Ud; function n3(r, e) { return t3(r, e) } var r3 = n3; const ke = _e(r3); var i3 = Em, s3 = Ho, a3 = cc, o3 = Dn, l3 = Ei, c3 = uc, u3 = lc, d3 = Bd, h3 = "[object Map]", p3 = "[object Set]", f3 = Object.prototype, g3 = f3.hasOwnProperty; function m3(r) { if (r == null) return !0; if (l3(r) && (o3(r) || typeof r == "string" || typeof r.splice == "function" || c3(r) || d3(r) || a3(r))) return !r.length; var e = s3(r); if (e == h3 || e == p3) return !r.size; if (u3(r)) return !i3(r).length; for (var t in r) if (g3.call(r, t)) return !1; return !0 } var y3 = m3; const kt = _e(y3); var b3 = I1, v3 = zs; function x3(r, e) { return r && b3(r, e, v3) } var w3 = x3, C3 = Ei; function S3(r, e) { return function (t, n) { if (t == null) return t; if (!C3(t)) return r(t, n); for (var i = t.length, s = e ? i : -1, a = Object(t); (e ? s-- : ++s < i) && n(a[s], s, a) !== !1;); return t } } var E3 = S3, _3 = w3, O3 = E3, T3 = O3(_3), Wd = T3, I3 = fc; function P3(r) { return typeof r == "function" ? r : I3 } var uS = P3, k3 = K1, R3 = Wd, D3 = uS, A3 = Dn; function N3(r, e) { var t = A3(r) ? k3 : R3; return t(r, D3(e)) } var F3 = N3, $3 = F3; const Vn = _e($3); function Nt(r, e) { r && console.warn(`Warning: ${e}`) } function ze(r) { return r == null } let dS = class { constructor() { this._eventMap = new Map } on(e, t) { return e && typeof t == "function" && (this._eventMap.has(e) || this._eventMap.set(e, []), this._eventMap.get(e).push(t)), this } once(e, t) { var n = this; if (e && typeof t == "function") { const i = function () { t(...arguments), n.off(e, i) }; this.on(e, i) } } off(e, t) { if (e) if (typeof t == "function") { const n = this._eventMap.get(e); if (Array.isArray(n) && n.length) { let i = -1; for (; (i = n.findIndex(s => s === t)) > -1;)n.splice(i, 1) } } else ze(t) && this._eventMap.delete(e); return this } emit(e) { for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), i = 1; i < t; i++)n[i - 1] = arguments[i]; return this._eventMap.has(e) ? ([...this._eventMap.get(e)].forEach(a => a(...n)), !0) : !1 } }; function ct(r) { try { return r instanceof HTMLElement } catch { return typeof r == "object" && r.nodeType === 1 && typeof r.style == "object" && typeof r.ownerDocument == "object" } } function hS(r) { for (var e = arguments.length, t = new Array(e > 1 ? e - 1 : 0), n = 1; n < e; n++)t[n - 1] = arguments[n]; for (const i of t) r.appendChild(i); return r } function L3(r) { for (var e = arguments.length, t = new Array(e > 1 ? e - 1 : 0), n = 1; n < e; n++)t[n - 1] = arguments[n]; if (r.children && r.children.length) { const i = r.children[0]; for (const s of t) r.insertBefore(s, i) } else hS(r, ...t); return r } function M3(r) { if (r && typeof r == "object") return typeof r.toJSON == "function" ? r.toJSON() : ["left", "top", "right", "bottom", "width", "height"].reduce((t, n) => (t[n] = r[n], t), {}) } function yn(r) { r.stopPropagation(), r.preventDefault() } function j3(r) { return r.length === 1 && r.match(/\S/) } function mc(r, e) { for (let t = 0; t < r.length; t++)r[t] === e ? (r[t].tabIndex = 0, r[t].focus()) : r[t].tabIndex = -1 } function V3(r) { r.length > 0 && mc(r, r[0]) } function B3(r) { r.length > 0 && mc(r, r[r.length - 1]) } function z3(r, e) { let t, n; r.length > 0 && (e === r[0] ? t = r[r.length - 1] : (n = r.indexOf(e), t = r[n - 1]), mc(r, t)) } function H3(r, e) { let t, n; r.length > 0 && (e === r[r.length - 1] ? t = r[0] : (n = r.indexOf(e), t = r[n + 1]), mc(r, t)) } function K3(r, e, t, n) { let i, s; return !r || !t || !n || n.length > 1 ? -1 : (n = n.toLowerCase(), i = r.indexOf(e) + 1, i >= r.length && (i = 0), s = t.indexOf(n, i), s === -1 && (s = t.indexOf(n, 0)), s >= 0 ? s : -1) } function U3(r, e) { if (!r) return null; for (; r.parentElement && H(r.parentElement, "attributes.role.value", "") !== e;)r = r.parentElement; return r.parentElement } function W3(r, e) { for (let t = 0; t < r.length; t++) { const n = r[t].attributes["data-popupid"]; if (n && n.value === e) return r[t] } return null } const Qc = { TOP: /top/i, RIGHT: /right/i, BOTTOM: /bottom/i, LEFT: /left/i }, Ba = { left: 0, top: 0, height: 0, width: 0, scrollLeft: 0, scrollTop: 0 }; let G3 = class extends ve { constructor(e) { var t; super(Object.assign({}, e)), t = this, this.removePortal = () => { this._adapter.removePortal() }, this.setDisplayNone = (n, i) => { this._adapter.setDisplayNone(n, i) }, this.updateStateIfCursorOnTrigger = n => { var i, s; if (!((i = n == null ? void 0 : n.matches) === null || i === void 0) && i.call(n, ":hover")) { const a = this._adapter.getEventName(), o = this.getState("triggerEventSet"); (s = o[a.mouseEnter]) === null || s === void 0 || s.call(o) } }, this.onResize = () => { this.getState("visible") && this.calcPosition() }, this.delayShow = () => { const n = this.getProp("mouseEnterDelay"); this.clearDelayTimer(), n > 0 ? this._timer = setTimeout(() => { this.show(), this.clearDelayTimer() }, n) : this.show() }, this.show = () => { if (this._adapter.getAnimatingState()) return; const n = this.getProp("content"), i = this.getProp("trigger"), s = this.getProp("clickTriggerToHide"), { visible: a, displayNone: o } = this.getStates(); if (o && this.setDisplayNone(!1), !a) { if (this.clearDelayTimer(), this._adapter.on("portalInserted", () => { this.calcPosition() }), i === "hover") { const l = () => { var u; const d = this._adapter.getTriggerDOM(); i && !(!((u = d == null ? void 0 : d.matches) === null || u === void 0) && u.call(d, ":hover")) && this.hide(), this._adapter.off("portalInserted", l) }; this._adapter.on("portalInserted", l) } this._adapter.on("positionUpdated", () => { this._togglePortalVisible(!0) }), this._adapter.insertPortal(n, { left: -9999, top: -9999 }), i === "custom" && this._adapter.registerClickOutsideHandler(() => { }), (i === "click" || s || i === "contextMenu") && this._adapter.registerClickOutsideHandler(this.hide), this._bindScrollEvent(), this._bindResizeEvent() } }, this.calcPosition = function (n, i, s) { let a = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : !0; n = (kt(n) ? t._adapter.getTriggerBounding() : n) || Object.assign({}, Ba), s = (kt(s) ? t._adapter.getPopupContainerRect() : s) || Object.assign({}, Ba), i = (kt(i) ? t._adapter.getWrapperBounding() : i) || Object.assign({}, Ba); let o = t.calcPosStyle({ triggerRect: n, wrapperRect: i, containerRect: s }), l = t.getProp("position"); if (t.getProp("autoAdjustOverflow")) { const { position: u, isHeightOverFlow: d, isWidthOverFlow: h } = t.adjustPosIfNeed(l, o, n, i, s); (l !== u || d || h) && (l = u, o = t.calcPosStyle({ triggerRect: n, wrapperRect: i, containerRect: s, position: l, spacing: null, isOverFlow: [d, h] })) } return a && t._mounted && t._adapter.setPosition(Object.assign(Object.assign({}, o), { position: l })), o }, this.delayHide = () => { const n = this.getProp("mouseLeaveDelay"); this.clearDelayTimer(), n > 0 ? this._timer = setTimeout(() => { this.hide(), this.clearDelayTimer() }, n) : this.hide() }, this.hide = () => { this.clearDelayTimer(), this._togglePortalVisible(!1), this._adapter.off("portalInserted"), this._adapter.off("positionUpdated") }, this.handleContainerKeydown = n => { const { guardFocus: i, closeOnEsc: s } = this.getProps(); switch (n && n.key) { case "Escape": s && this._handleEscKeyDown(n); break; case "Tab": if (i) { const a = this._adapter.getContainer(), o = this._adapter.getFocusableElements(a); o.length && (n.shiftKey ? this._handleContainerShiftTabKeyDown(o, n) : this._handleContainerTabKeyDown(o, n)) } break } }, this._timer = null } init() { const { wrapperId: e } = this.getProps(); this._mounted = !0, this._bindEvent(), this._shouldShow(), this._initContainerPosition(), e || this._adapter.setId() } destroy() { this._mounted = !1, this.unBindEvent() } _bindEvent() { const e = this.getProp("trigger"), { triggerEventSet: t, portalEventSet: n } = this._generateEvent(e); this._bindTriggerEvent(t), this._bindPortalEvent(n), this._bindResizeEvent() } unBindEvent() { this._adapter.unregisterClickOutsideHandler(), this.unBindResizeEvent(), this.unBindScrollEvent(), clearTimeout(this._timer) } _bindTriggerEvent(e) { this._adapter.registerTriggerEvent(e) } _bindPortalEvent(e) { this._adapter.registerPortalEvent(e) } _bindResizeEvent() { this._adapter.registerResizeHandler(this.onResize) } unBindResizeEvent() { this._adapter.unregisterResizeHandler(this.onResize) } _adjustPos() { let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "", t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1, n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "reverse", i = arguments.length > 3 ? arguments[3] : void 0; switch (n) { case "reverse": return this._reversePos(e, t); case "expand": return this._expandPos(e, i); case "reduce": return this._reducePos(e); default: return this._reversePos(e, t) } } _reversePos() { let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : ""; if (arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1) { if (Qc.TOP.test(e)) return e.replace("top", "bottom").replace("Top", "Bottom"); if (Qc.BOTTOM.test(e)) return e.replace("bottom", "top").replace("Bottom", "Top") } else { if (Qc.LEFT.test(e)) return e.replace("left", "right").replace("Left", "Right"); if (Qc.RIGHT.test(e)) return e.replace("right", "left").replace("Right", "Left") } return e } _expandPos() { let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "", t = arguments.length > 1 ? arguments[1] : void 0; return e.concat(t) } _reducePos() { let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : ""; const t = ["Top", "Bottom", "Left", "Right"].find(n => e.endsWith(n)); return t ? e.replace(t, "") : e } clearDelayTimer() { this._timer && (clearTimeout(this._timer), this._timer = null) } _generateEvent(e) { const t = this._adapter.getEventName(), n = { [t.keydown]: s => { this._handleTriggerKeydown(s) } }; let i = {}; switch (e) { case "focus": n[t.focus] = () => { this.delayShow() }, n[t.blur] = () => { this.delayHide() }, i = n; break; case "click": n[t.click] = () => { this.show() }, i = {}; break; case "hover": n[t.mouseEnter] = () => { this.setCache("isClickToHide", !1), this.delayShow() }, n[t.mouseLeave] = () => { this.delayHide() }, n[t.focus] = () => { const { disableFocusListener: s } = this.getProps(); !s && this.delayShow() }, n[t.blur] = () => { const { disableFocusListener: s } = this.getProps(); !s && this.delayHide() }, i = Object.assign({}, n), this.getProp("clickToHide") && (i[t.click] = () => { this.setCache("isClickToHide", !0), this.hide() }, i[t.mouseEnter] = () => { this.getCache("isClickToHide") || this.delayShow() }); break; case "custom": break; case "contextMenu": n[t.contextMenu] = s => { s.preventDefault(), this.show() }; break }return { triggerEventSet: n, portalEventSet: i } } _shouldShow() { this.getProp("visible") && this.show() } _togglePortalVisible(e) { const t = this.getState("visible"), n = this.getState("isInsert"); (t !== e || n !== e) && this._adapter.togglePortalVisible(e, () => { e && this._adapter.setInitialFocus(), this._adapter.notifyVisibleChange(e) }) } _roundPixel(e) { return typeof e == "number" ? Math.round(e) : e } calcTransformOrigin(e, t, n, i) { if (e && t && n != null && i != null) { if (this.getProp("transformFromCenter")) { if (["topLeft", "bottomLeft"].includes(e)) return `${this._roundPixel(t.width / 2)}px ${-i * 100}%`; if (["topRight", "bottomRight"].includes(e)) return `calc(100% - ${this._roundPixel(t.width / 2)}px) ${-i * 100}%`; if (["leftTop", "rightTop"].includes(e)) return `${-n * 100}% ${this._roundPixel(t.height / 2)}px`; if (["leftBottom", "rightBottom"].includes(e)) return `${-n * 100}% calc(100% - ${this._roundPixel(t.height / 2)}px)` } return `${-n * 100}% ${-i * 100}%` } return null } calcPosStyle(e) { var t; const { spacing: n, isOverFlow: i } = e, { innerWidth: s } = window, a = (kt(e.triggerRect) ? e.triggerRect : this._adapter.getTriggerBounding()) || Object.assign({}, Ba), o = (kt(e.containerRect) ? e.containerRect : this._adapter.getPopupContainerRect()) || Object.assign({}, Ba), l = (kt(e.wrapperRect) ? e.wrapperRect : this._adapter.getWrapperBounding()) || Object.assign({}, Ba), u = e.position != null ? e.position : this.getProp("position"), d = n ?? this.getProp("spacing"), { arrowPointAtCenter: h, showArrow: g, arrowBounding: m } = this.getProps(), b = g && h; let y = d, w = 0; if (typeof d != "number") { const te = u.includes("top") || u.includes("bottom"); y = te ? d.y : d.x, w = te ? d.x : d.y } const x = H(m, "width", 24), S = H(m, "width", 24), C = H(m, "offsetY", 0), O = 6, E = 6; let v, T, I = 0, k = 0; const P = a.left + a.width / 2, N = a.top + a.height / 2, M = O + x / 2, B = E + S / 2, K = l.height - o.height, U = l.width - o.width, W = K > 0 ? K : 0, Z = U > 0 ? U : 0, J = i && i[0], ee = i && i[1], $ = P - o.left < o.right - P, pe = N - o.top < o.bottom - N, re = l.width > s, j = Math.abs((l == null ? void 0 : l.width) - ((t = this._adapter.getContainer()) === null || t === void 0 ? void 0 : t.clientWidth)) > 1; switch (j && (y = y * l.width / this._adapter.getContainer().clientWidth), u) { case "top": v = ee ? $ ? o.left + l.width / 2 : o.right - l.width / 2 + Z : P + w, T = J ? o.bottom + W : a.top - y, I = -.5, k = -1; break; case "topLeft": v = ee ? re ? o.left : o.right - l.width : b ? P - M + w : a.left + w, T = J ? o.bottom + W : a.top - y, k = -1; break; case "topRight": v = ee ? o.right + Z : b ? P + M + w : a.right + w, T = J ? o.bottom + W : a.top - y, k = -1, I = -1; break; case "left": v = ee ? o.right + Z - y + M : a.left - y, T = J ? pe ? o.top + l.height / 2 : o.bottom - l.height / 2 + W : N + w, I = -1, k = -.5; break; case "leftTop": v = ee ? o.right + Z - y + M : a.left - y, T = J ? o.top : b ? N - B + w : a.top + w, I = -1; break; case "leftBottom": v = ee ? o.right + Z - y + M : a.left - y, T = J ? o.bottom + W : b ? N + B + w : a.bottom + w, I = -1, k = -1; break; case "bottom": v = ee ? $ ? o.left + l.width / 2 : o.right - l.width / 2 + Z : P + w, T = J ? o.top + B - y : a.top + a.height + y, I = -.5; break; case "bottomLeft": v = ee ? re ? o.left : o.right - l.width : b ? P - M + w : a.left + w, T = J ? o.top + B - y : a.top + a.height + y; break; case "bottomRight": v = ee ? o.right + Z : b ? P + M + w : a.right + w, T = J ? o.top + B - y : a.top + a.height + y, I = -1; break; case "right": v = ee ? o.left - y + M : a.right + y, T = J ? pe ? o.top + l.height / 2 : o.bottom - l.height / 2 + W : N + w, k = -.5; break; case "rightTop": v = ee ? o.left - y + M : a.right + y, T = J ? o.top : b ? N - B + w : a.top + w; break; case "rightBottom": v = ee ? o.left - y + M : a.right + y, T = J ? o.bottom + W : b ? N + B + w : a.bottom + w, k = -1; break; case "leftTopOver": v = a.left - y, T = a.top - y; break; case "rightTopOver": v = a.right + y, T = a.top - y, I = -1; break; case "leftBottomOver": v = a.left - y, T = a.bottom + y, k = -1; break; case "rightBottomOver": v = a.right + y, T = a.bottom + y, I = -1, k = -1; break }const ae = this.calcTransformOrigin(u, a, I, k), be = this._adapter.containerIsBody(); if (v = v - o.left, T = T - o.top, j && (v /= l.width / this._adapter.getContainer().clientWidth), j && (T /= l.height / this._adapter.getContainer().clientHeight), be && !this._adapter.containerIsRelativeOrAbsolute()) { const te = this._adapter.getDocumentElementBounding(); v += o.left - te.left, T += o.top - te.top } v = be ? v : v + o.scrollLeft, T = be ? T : T + o.scrollTop; const fe = a.height; if (this.getProp("showArrow") && !h && fe <= (S / 2 + C) * 2) { const te = fe / 2 - (C + S / 2); (u.includes("Top") || u.includes("Bottom")) && !u.includes("Over") && (T = u.includes("Top") ? T + te : T - te) } const Ce = { left: this._roundPixel(v), top: this._roundPixel(T) }; let ue = ""; return I != null && (ue += `translateX(${I * 100}%) `, Object.defineProperty(Ce, "translateX", { enumerable: !1, value: I })), k != null && (ue += `translateY(${k * 100}%) `, Object.defineProperty(Ce, "translateY", { enumerable: !1, value: k })), ae != null && (Ce.transformOrigin = ae), ue && (Ce.transform = ue), Ce } isLR() { let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : ""; return e.includes("left") || e.includes("right") } isTB() { let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : ""; return e.includes("top") || e.includes("bottom") } isReverse(e, t, n) { return e < n && t > n } isOverFlow(e, t, n) { return e < n && t < n } isHalfOverFlow(e, t, n) { return e < n || t < n } isHalfAllEnough(e, t, n) { return e >= n || t >= n } getReverse(e, t, n, i) { return e && i || n } adjustPosIfNeed(e, t, n, i, s) { const { innerWidth: a, innerHeight: o } = window, { margin: l } = this.getProps(), u = typeof l == "number" ? l : l.marginLeft, d = typeof l == "number" ? l : l.marginTop, h = typeof l == "number" ? l : l.marginRight, g = typeof l == "number" ? l : l.marginBottom; let m = !1, b = !1; const y = this.getProp("spacing"); let w = y, x = 0; if (typeof y != "number") { const S = e.includes("top") || e.includes("bottom"); w = S ? y.y : y.x, x = S ? y.x : y.y } if (i.width > 0 && i.height > 0) { const S = n.left, C = n.right, O = n.top, E = n.bottom, v = a - S, T = o - O, I = a - C, k = o - E, P = i.width > n.width, N = i.height > n.height, M = O - d < i.height + w && k - g > i.height + w, B = S - u < i.width + w && I - h > i.width + w, K = k - g < i.height + w && O - d > i.height + w, U = I - h < i.width + w && S - u > i.width + w; T - g < i.height + w && E - d > i.height + w, E - d < i.height + w && T - g > i.height + w; const W = T < i.height + x && E > i.height + x, Z = E < i.height + x && T > i.height + x, J = v < i.width + x && C > i.width + x, ee = C < i.width + x && v > i.width + x, $ = T < i.height + w && E > i.height + w, pe = E < i.height + w && T > i.height + w, re = v < i.width && C > i.width, j = C < i.width && v > i.width, ae = O - s.top, be = S - s.left, fe = ae + n.height, Ce = be + n.width, ue = s.bottom - E, te = s.right - C, le = ue + n.height, Re = te + n.width, at = this.isReverse(ae - d, ue - g, i.height + w), yt = this.isReverse(be - u, te - h, i.width + w), ht = this.isReverse(ue - g, ae - d, i.height + w), Ft = this.isReverse(te - h, be - u, i.width + w); this.isReverse(le - g, fe - d, i.height + w), this.isReverse(fe - d, le - g, i.height + w); const qe = this.isReverse(le, fe, i.height + x), $t = this.isReverse(fe, le, i.height + x), gn = this.isReverse(Re, Ce, i.width + x), Hn = this.isReverse(Ce, Re, i.width + x), ot = n.height / 2, Ut = n.width / 2, Wt = this.isOverFlow(O - d, k - g, i.height + w), wn = this.isOverFlow(S - u, I - h, i.width + w), Ze = this.isOverFlow(E - d, T - g, i.height + w), hr = this.isOverFlow(C - u, v - h, i.width + w), X = this.isHalfOverFlow(E - ot, T - ot, (i.height + x) / 2), Q = this.isHalfOverFlow(C - Ut, v - Ut, (i.width + x) / 2), L = this.isHalfAllEnough(E - ot, T - ot, (i.height + x) / 2), Oe = this.isHalfAllEnough(C - Ut, v - Ut, (i.width + x) / 2), De = this.isOverFlow(ae - d, ue - g, i.height + w), ie = this.isOverFlow(be - u, te - h, i.width + w), un = this.isOverFlow(fe - d, le - g, i.height + w), Qt = this.isOverFlow(Ce - u, Re - h, i.width + w), jn = this.isHalfOverFlow(fe - ot, le - ot, (i.height + x) / 2), Et = this.isHalfOverFlow(Ce - Ut, Re - Ut, (i.width + x) / 2), _t = this.isHalfAllEnough(fe - ot, le - ot, (i.height + x) / 2), Nn = this.isHalfAllEnough(Ce - Ut, Re - Ut, (i.width + x) / 2), Cn = this.getReverse(Wt, De, M, at), Ar = this.getReverse(wn, ie, B, yt), en = this.getReverse(Wt, De, K, ht), Sn = this.getReverse(wn, ie, U, Ft), Ie = this.getReverse(Ze, un, W, qe), Dt = this.getReverse(Ze, un, Z, $t), me = this.getReverse(hr, Qt, J, gn), tn = this.getReverse(hr, Qt, ee, Hn), Gt = X && jn, nn = Q && Et; switch (e) { case "top": Cn && (e = this._adjustPos(e, !0)), nn && (me || tn) && (e = this._adjustPos(e, !0, "expand", me ? "Right" : "Left")); break; case "topLeft": Cn && (e = this._adjustPos(e, !0)), me && P && (e = this._adjustPos(e)), b && (Oe || Nn) && (e = this._adjustPos(e, !0, "reduce")); break; case "topRight": Cn && (e = this._adjustPos(e, !0)), tn && P && (e = this._adjustPos(e)), b && (Oe || Nn) && (e = this._adjustPos(e, !0, "reduce")); break; case "left": Ar && (e = this._adjustPos(e)), Gt && (Ie || Dt) && (e = this._adjustPos(e, !1, "expand", Ie ? "Bottom" : "Top")); break; case "leftTop": Ar && (e = this._adjustPos(e)), Ie && N && (e = this._adjustPos(e, !0)), m && (L || _t) && (e = this._adjustPos(e, !1, "reduce")); break; case "leftBottom": Ar && (e = this._adjustPos(e)), Dt && N && (e = this._adjustPos(e, !0)), m && (L || _t) && (e = this._adjustPos(e, !1, "reduce")); break; case "bottom": en && (e = this._adjustPos(e, !0)), nn && (me || tn) && (e = this._adjustPos(e, !0, "expand", me ? "Right" : "Left")); break; case "bottomLeft": en && (e = this._adjustPos(e, !0)), me && P && (e = this._adjustPos(e)), b && (Oe || Nn) && (e = this._adjustPos(e, !0, "reduce")); break; case "bottomRight": en && (e = this._adjustPos(e, !0)), tn && P && (e = this._adjustPos(e)), b && (Oe || Nn) && (e = this._adjustPos(e, !0, "reduce")); break; case "right": Sn && (e = this._adjustPos(e)), Gt && (Ie || Dt) && (e = this._adjustPos(e, !1, "expand", Ie ? "Bottom" : "Top")); break; case "rightTop": Sn && (e = this._adjustPos(e)), Ie && N && (e = this._adjustPos(e, !0)), m && (L || _t) && (e = this._adjustPos(e, !1, "reduce")); break; case "rightBottom": Sn && (e = this._adjustPos(e)), Dt && N && (e = this._adjustPos(e, !0)), m && (L || _t) && (e = this._adjustPos(e, !1, "reduce")); break; case "leftTopOver": $ && (e = this._adjustPos(e, !0)), re && (e = this._adjustPos(e)); break; case "leftBottomOver": pe && (e = this._adjustPos(e, !0)), re && (e = this._adjustPos(e)); break; case "rightTopOver": $ && (e = this._adjustPos(e, !0)), j && (e = this._adjustPos(e)); break; case "rightBottomOver": pe && (e = this._adjustPos(e, !0)), j && (e = this._adjustPos(e)); break }this.isTB(e) && (m = Wt && De, e === "top" || e === "bottom" ? b = Q && Et || C < 0 || I < 0 : b = hr && Qt || C < 0 || I < 0), this.isLR(e) && (b = wn && ie, e === "left" || e === "right" ? m = X && jn || O < 0 || T < 0 : m = Ze && un || O < 0 || T < 0) } return { position: e, isHeightOverFlow: m, isWidthOverFlow: b } } _bindScrollEvent() { this._adapter.registerScrollHandler(() => this.calcPosition()) } unBindScrollEvent() { this._adapter.unregisterScrollHandler() } _initContainerPosition() { this._adapter.updateContainerPosition() } _handleTriggerKeydown(e) { const { closeOnEsc: t, disableArrowKeyDown: n } = this.getProps(), i = this._adapter.getContainer(), s = this._adapter.getFocusableElements(i), a = s.length; switch (e && e.key) { case "Escape": yn(e), t && this._handleEscKeyDown(e); break; case "ArrowUp": !n && a && this._handleTriggerArrowUpKeydown(s, e); break; case "ArrowDown": !n && a && this._handleTriggerArrowDownKeydown(s, e); break } } focusTrigger() { const { trigger: e, returnFocusOnClose: t, preventScroll: n } = this.getProps(); if (t && e !== "custom") { const i = this._adapter.getTriggerNode(); i && "focus" in i && i.focus({ preventScroll: n }) } } _handleEscKeyDown(e) { const { trigger: t } = this.getProps(); t !== "custom" && (this.focusTrigger(), this.hide()), this._adapter.notifyEscKeydown(e) } _handleContainerTabKeyDown(e, t) { const { preventScroll: n } = this.getProps(), i = this._adapter.getActiveElement(); e[e.length - 1] === i && (e[0].focus({ preventScroll: n }), t.preventDefault()) } _handleContainerShiftTabKeyDown(e, t) { const { preventScroll: n } = this.getProps(), i = this._adapter.getActiveElement(); e[0] === i && (e[e.length - 1].focus({ preventScroll: n }), t.preventDefault()) } _handleTriggerArrowDownKeydown(e, t) { const { preventScroll: n } = this.getProps(); e[0].focus({ preventScroll: n }), t.preventDefault() } _handleTriggerArrowUpKeydown(e, t) { const { preventScroll: n } = this.getProps(); e[e.length - 1].focus({ preventScroll: n }), t.preventDefault() } }; const Y3 = { PREFIX: `${G}-tooltip` }, Ds = { POSITION_SET: ["top", "topLeft", "topRight", "left", "leftTop", "leftBottom", "right", "rightTop", "rightBottom", "bottom", "bottomLeft", "bottomRight", "leftTopOver", "rightTopOver", "leftBottomOver", "rightBottomOver"], TRIGGER_SET: ["hover", "focus", "click", "custom", "contextMenu"], STATUS_DISABLED: "disabled", STATUS_LOADING: "loading" }, Es = { ARROW_BOUNDING: { offsetX: 0, offsetY: 2, width: 24, height: 7 }, DEFAULT_Z_INDEX: 1060, MOUSE_ENTER_DELAY: 50, MOUSE_LEAVE_DELAY: 50, SPACING: 8, MARGIN: 0 }; function Xu(r) { return `${r}-${new Date().getTime()}-${Math.random()}` } function es() { var r, e; try { return (e = (r = crypto == null ? void 0 : crypto.randomUUID) === null || r === void 0 ? void 0 : r.call(crypto)) !== null && e !== void 0 ? e : String(9987e3 + -1e11).replace(/[018]/g, t => (Number(t) ^ crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> Number(t) / 4).toString(16)) } catch { return Xu("semi") } } function zi() { let r = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}; const { prefix: e = "", length: t = 7 } = r, n = "0123456789abcdefghijklmnopqrstuvwxyz", i = n.length; let s = ""; for (let a = 0; a < t; a++) { const o = Math.floor(Math.random() * i); s += n.charAt(o) } return e ? `${e}-${s}` : s } function vf(r) { return f.isValidElement(r) } function rx(r) { return f.Children.count(r) === 0 } var X3 = zd, q3 = jo, Z3 = hc, ix = Er, J3 = Sa; function Q3(r, e, t, n) { if (!ix(r)) return r; e = q3(e, r); for (var i = -1, s = e.length, a = s - 1, o = r; o != null && ++i < s;) { var l = J3(e[i]), u = t; if (l === "__proto__" || l === "constructor" || l === "prototype") return r; if (i != a) { var d = o[l]; u = n ? n(d, l, o) : void 0, u === void 0 && (u = ix(d) ? d : Z3(e[i + 1]) ? [] : {}) } X3(o, l, u), o = o[l] } return r } var pS = Q3, eV = pS; function tV(r, e, t) { return r == null ? r : eV(r, e, t) } var nV = tV; const yr = _e(nV); var rV = Tm, iV = 1, sV = 4; function aV(r, e) { return e = typeof e == "function" ? e : void 0, rV(r, iV | sV, e) } var oV = aV; const fS = _e(oV); class lV { constructor() { this.config = {} } } const qh = new lV; var sx = function (r, e, t, n) { function i(s) { return s instanceof t ? s : new t(function (a) { a(s) }) } return new (t || (t = Promise))(function (s, a) { function o(d) { try { u(n.next(d)) } catch (h) { a(h) } } function l(d) { try { u(n.throw(d)) } catch (h) { a(h) } } function u(d) { d.done ? s(d.value) : i(d.value).then(o, l) } u((n = n.apply(r, e || [])).next()) }) }; function eu(r, e) { r && typeof r.stopPropagation == "function" && r.stopPropagation(), r.nativeEvent && typeof r.nativeEvent.stopImmediatePropagation == "function" && r.nativeEvent.stopImmediatePropagation() } function Hr(r, e) {
  return fS(r, t => {
    if (typeof e == "function") return e(t); if (typeof t == "function" || f.isValidElement(t) || Object.prototype.toString.call(t) === "[object Error]") return t; if (Array.isArray(t) && t.length === 0) {
      const n = Object.keys(t); if (n.length) {
        const i = []; n.forEach(s => { yr(i, s, t[s]) }); try {
          Nt(H(process, "env.NODE_ENV") !== "production", `[Semi] You may use an out-of-bounds array. In some cases, your program may not behave as expected.
                    The maximum length of an array is 4294967295.
                    Please check whether the array subscript in your data exceeds the maximum value of the JS array subscript`)
        } catch { } return i
      } else return
    }
  })
} const gS = (r, e) => { let { match: t, unmatch: n, callInInit: i = !0 } = e; if (typeof window < "u") { let a = function (o) { o.matches ? t && t(o) : n && n(o) }; const s = window.matchMedia(r); return i && a(s), Object.prototype.hasOwnProperty.call(s, "addEventListener") ? (s.addEventListener("change", a), () => s.removeEventListener("change", a)) : (s.addListener(a), () => s.removeListener(a)) } return () => { } }, Bn = r => f.isValidElement(r) && H(r.type, "elementType") === "Icon"; function mS() { return document ? document.activeElement : null } function yS(r) { if (!ct(r)) return []; const t = ["input:not([disabled]):not([tabindex='-1'])", "textarea:not([disabled]):not([tabindex='-1'])", "button:not([disabled]):not([tabindex='-1'])", "a[href]:not([tabindex='-1'])", "select:not([disabled]):not([tabindex='-1'])", "area[href]:not([tabindex='-1'])", "iframe:not([tabindex='-1'])", "object:not([tabindex='-1'])", "*[tabindex]:not([tabindex='-1'])", "*[contenteditable]:not([tabindex='-1'])"].join(","); return Array.from(r.querySelectorAll(t)) } function Am(r, e) { return sx(this, void 0, void 0, function* () { if (e === 0) { yield r(); return } else { yield new Promise(t => { setTimeout(() => sx(this, void 0, void 0, function* () { yield Am(r, e - 1), t() }), 0) }); return } }) } function Nm() { return globalThis && Object.prototype.toString.call(globalThis) === "[object Window]" ? window.innerWidth - document.documentElement.clientWidth : 0 } function xn(r) { let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}; const t = () => { var n, i; return ((i = (n = qh == null ? void 0 : qh.config) === null || n === void 0 ? void 0 : n.overrideDefaultProps) === null || i === void 0 ? void 0 : i[r]) || {} }; return new Proxy(Object.assign({}, e), { get(n, i, s) { const a = t(); return i in a ? a[i] : Reflect.get(n, i, s) }, set(n, i, s, a) { return Reflect.set(n, i, s, a) }, ownKeys() { const n = t(); return Array.from(new Set([...Reflect.ownKeys(e), ...Object.keys(n)])) }, getOwnPropertyDescriptor(n, i) { const s = t(); return i in s ? Reflect.getOwnPropertyDescriptor(s, i) : Reflect.getOwnPropertyDescriptor(n, i) } }) } const An = f.createContext({}), cV = () => document.body; class Oa extends R.PureComponent { constructor(e, t) { var n; super(e), n = this, this.initContainer = function (i) { let s = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1; var a, o; try { let l; if (!n.el || !(!((a = n.state) === null || a === void 0) && a.container) || !Array.from(n.state.container.childNodes).includes(n.el)) { n.el = document.createElement("div"); const d = (n.props.getPopupContainer || i.getPopupContainer || cV)(); return d.appendChild(n.el), n.addStyle(n.props.style), n.addClass(n.props.prefixCls, i, n.props.className), l = d, l } } catch (l) { if (!s) throw l } return (o = n.state) === null || o === void 0 ? void 0 : o.container }, this.addStyle = function () { let i = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}; if (n.el) for (const s of Object.keys(i)) n.el.style[s] = i[s] }, this.addClass = function (i) { let s = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : n.context; const { direction: a } = s; for (var o = arguments.length, l = new Array(o > 2 ? o - 2 : 0), u = 2; u < o; u++)l[u - 2] = arguments[u]; const d = F(i, ...l, { [`${i}-rtl`]: a === "rtl" }); n.el && (n.el.className = d) }, this.state = { container: this.initContainer(t, !0) } } componentDidMount() { const e = this.initContainer(this.context); e !== this.state.container && this.setState({ container: e }) } componentDidUpdate(e) { const { didUpdate: t } = this.props; t && t(e) } componentWillUnmount() { const { container: e } = this.state; e && e.removeChild(this.el) } render() { const { state: e, props: t } = this; return e.container ? di.createPortal(t.children, this.el) : null } } Oa.contextType = An; Oa.defaultProps = { prefixCls: `${G}-portal` }; Oa.propTypes = { children: c.node, prefixCls: c.string, getPopupContainer: c.func, className: c.string, didUpdate: c.func }; var uV = function (r, e) { var t = {}; for (var n in r) Object.prototype.hasOwnProperty.call(r, n) && e.indexOf(n) < 0 && (t[n] = r[n]); if (r != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, n = Object.getOwnPropertySymbols(r); i < n.length; i++)e.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(r, n[i]) && (t[n[i]] = r[n[i]]); return t }; const dV = r => { const { className: e, style: t } = r, n = uV(r, ["className", "style"]); return f.createElement("svg", Object.assign({ "aria-hidden": !0, className: e, style: t }, n, { width: "24", height: "7", viewBox: "0 0 24 7", fill: "currentColor", xmlns: "http://www.w3.org/2000/svg" }), f.createElement("path", { d: "M24 0V1C20 1 18.5 2 16.5 4C14.5 6 14 7 12 7C10 7 9.5 6 7.5 4C5.5 2 4 1 0 1V0H24Z" })) }; var hV = function (r, e) { var t = {}; for (var n in r) Object.prototype.hasOwnProperty.call(r, n) && e.indexOf(n) < 0 && (t[n] = r[n]); if (r != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, n = Object.getOwnPropertySymbols(r); i < n.length; i++)e.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(r, n[i]) && (t[n[i]] = r[n[i]]); return t }; const pV = r => { const { className: e, style: t } = r, n = hV(r, ["className", "style"]); return f.createElement("svg", Object.assign({ "aria-hidden": !0, className: e, style: t }, n, { width: "7", height: "24", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }), f.createElement("path", { d: "M0 0L1 0C1 4, 2 5.5, 4 7.5S7,10 7,12S6 14.5, 4 16.5S1,20 1,24L0 24L0 0z" })) }, fV = c.shape({ offsetX: c.number, offsetY: c.number, width: c.number, height: c.number }); class Hi extends f.Component { constructor(e) { super(e), this.handleAnimationStart = () => { var t, n; (n = (t = this.props).onAnimationStart) === null || n === void 0 || n.call(t) }, this.handleAnimationEnd = () => { this.setState({ currentClassName: this.props.endClassName, extraStyle: { animationFillMode: this.props.fillMode }, isAnimating: !1 }, () => { var t, n; (n = (t = this.props).onAnimationEnd) === null || n === void 0 || n.call(t, !1) }) }, this.state = { currentClassName: this.props.startClassName, extraStyle: { animationFillMode: this.props.fillMode }, isAnimating: !0 } } componentDidMount() { var e, t, n, i; (t = (e = this.props).onAnimationStart) === null || t === void 0 || t.call(e), this.props.motion || ((i = (n = this.props).onAnimationEnd) === null || i === void 0 || i.call(n, !1), this.setState({ isAnimating: !1 })) } componentDidUpdate(e, t, n) { const i = Object.keys(this.props).filter(s => !ke(this.props[s], e[s])); i.includes("animationState"), (i.includes("startClassName") || i.includes("replayKey") || i.includes("motion")) && this.setState({ currentClassName: this.props.startClassName, extraStyle: { animationFillMode: this.props.fillMode }, isAnimating: !0 }, () => { var s, a, o, l; (a = (s = this.props).onAnimationStart) === null || a === void 0 || a.call(s), this.props.motion || ((l = (o = this.props).onAnimationEnd) === null || l === void 0 || l.call(o, this.state.isAnimating), this.setState({ isAnimating: !1 })) }) } render() { var e; return this.props.motion ? this.props.children({ animationClassName: (e = this.state.currentClassName) !== null && e !== void 0 ? e : "", animationStyle: this.state.extraStyle, animationEventsNeedBind: { onAnimationStart: this.handleAnimationStart, onAnimationEnd: this.handleAnimationEnd }, isAnimating: this.state.isAnimating }) : this.props.children({ animationClassName: "", animationStyle: {}, animationEventsNeedBind: {}, isAnimating: this.state.isAnimating }) } } Hi.defaultProps = { motion: !0, replayKey: "" }; var ax = function (r, e) { var t = {}; for (var n in r) Object.prototype.hasOwnProperty.call(r, n) && e.indexOf(n) < 0 && (t[n] = r[n]); if (r != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, n = Object.getOwnPropertySymbols(r); i < n.length; i++)e.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(r, n[i]) && (t[n[i]] = r[n[i]]); return t }; const Tu = Y3.PREFIX, gV = Ds.POSITION_SET, mV = Ds.TRIGGER_SET, yV = ["flex", "block", "table", "flow-root", "grid"], bV = () => document.body; class ln extends de { constructor(e) { super(e), this.isAnimating = !1, this.setContainerEl = t => this.containerEl = { current: t }, this.isSpecial = t => { if (ct(t)) return !!t.disabled; if (R.isValidElement(t)) { if (H(t, "props.disabled")) return Ds.STATUS_DISABLED; const i = H(t, "props.loading"), s = !kt(t) && !kt(t.type) && (H(t, "type.elementType") === "Button" || H(t, "type.elementType") === "IconButton"); if (i && s) return Ds.STATUS_LOADING } return !1 }, this.didLeave = () => { this.props.keepDOM ? this.foundation.setDisplayNone(!0) : this.foundation.removePortal(), this.foundation.unBindEvent() }, this.renderIcon = () => { const { placement: t } = this.state, { showArrow: n, prefixCls: i, style: s } = this.props; let a = null; const o = F([`${i}-icon-arrow`]), l = H(s, "backgroundColor"), u = t != null && t.includes("left") || t != null && t.includes("right") ? f.createElement(pV, null) : f.createElement(dV, null); return n && (R.isValidElement(n) ? a = n : a = f.cloneElement(u, { className: o, style: { color: l, fill: "currentColor" } })), a }, this.handlePortalInnerClick = t => { this.props.clickToHide && this.foundation.hide(), this.props.stopPropagation && eu(t) }, this.handlePortalMouseDown = t => { this.props.stopPropagation && eu(t) }, this.handlePortalFocus = t => { this.props.stopPropagation && eu(t) }, this.handlePortalBlur = t => { this.props.stopPropagation && eu(t) }, this.handlePortalInnerKeyDown = t => { this.foundation.handleContainerKeydown(t) }, this.renderContentNode = t => { const n = { initialFocusRef: this.initialFocusRef }; return we(t) ? t(n) : t }, this.renderPortal = () => { const { containerStyle: t = {}, visible: n, portalEventSet: i, placement: s, displayNone: a, transitionState: o, id: l, isPositionUpdated: u } = this.state, { prefixCls: d, content: h, showArrow: g, style: m, motion: b, role: y, zIndex: w } = this.props, x = this.renderContentNode(h), { className: S } = this.props, C = this.context.direction, O = F(S, { [`${d}-wrapper`]: !0, [`${d}-wrapper-show`]: n, [`${d}-with-arrow`]: !!g, [`${d}-rtl`]: C === "rtl" }), E = this.renderIcon(), v = Ht(t, b ? ["transformOrigin"] : void 0), T = H(t, "transformOrigin"), I = H(m, "opacity", null), k = I || 1, P = f.createElement(Hi, { fillMode: "forwards", animationState: o, motion: b && u, startClassName: o === "enter" ? `${Tu}-animation-show` : `${Tu}-animation-hide`, onAnimationStart: () => this.isAnimating = !0, onAnimationEnd: () => { var N, M; o === "leave" && (this.didLeave(), (M = (N = this.props).afterClose) === null || M === void 0 || M.call(N)), this.isAnimating = !1 } }, N => { let { animationStyle: M, animationClassName: B, animationEventsNeedBind: K } = N; return f.createElement("div", Object.assign({ className: F(O, B), style: Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, M), a ? { display: "none" } : {}), { transformOrigin: T }), m), I ? { opacity: u ? k : "0" } : {}) }, i, K, { role: y, "x-placement": s, id: l }), f.createElement("div", { className: `${Tu}-content` }, x), E) }); return f.createElement(Oa, { getPopupContainer: this.props.getPopupContainer, style: { zIndex: w } }, f.createElement("div", { tabIndex: -1, className: `${G}-portal-inner`, style: v, ref: this.setContainerEl, onClick: this.handlePortalInnerClick, onFocus: this.handlePortalFocus, onBlur: this.handlePortalBlur, onMouseDown: this.handlePortalMouseDown, onKeyDown: this.handlePortalInnerKeyDown }, P)) }, this.wrapSpan = t => { const { wrapperClassName: n } = this.props, i = H(t, "props.style.display"), s = H(t, "props.block"), a = typeof t == "string", o = {}; return a || (o.display = "inline-block"), (s || yV.includes(i)) && (o.width = "100%"), f.createElement("span", { className: n, style: o }, t) }, this.mergeEvents = (t, n) => { const i = {}; return Vn(n, (s, a) => { typeof s == "function" && (i[a] = function () { s(...arguments), t && typeof t[a] == "function" && t[a](...arguments) }) }), i }, this.getPopupId = () => this.state.id, this.state = { visible: !1, transitionState: "", triggerEventSet: {}, portalEventSet: {}, containerStyle: {}, isInsert: !1, placement: e.position || "top", transitionStyle: {}, isPositionUpdated: !1, id: e.wrapperId, displayNone: !1 }, this.foundation = new G3(this.adapter), this.eventManager = new dS, this.triggerEl = f.createRef(), this.containerEl = f.createRef(), this.initialFocusRef = f.createRef(), this.clickOutsideHandler = null, this.resizeHandler = null, this.isWrapped = !1, this.containerPosition = void 0 } get adapter() { var e = this; return Object.assign(Object.assign({}, super.adapter), { on: function () { return e.eventManager.on(...arguments) }, off: function () { return e.eventManager.off(...arguments) }, getAnimatingState: () => this.isAnimating, insertPortal: (t, n) => { var i = ax(n, ["position"]); this.setState({ isInsert: !0, transitionState: "enter", containerStyle: Object.assign(Object.assign({}, this.state.containerStyle), i) }, () => { setTimeout(() => { this.setState(s => (s.transitionState === "enter" && this.eventManager.emit("portalInserted"), {})) }, 0) }) }, removePortal: () => { this.setState({ isInsert: !1, isPositionUpdated: !1 }) }, getEventName: () => ({ mouseEnter: "onMouseEnter", mouseLeave: "onMouseLeave", mouseOut: "onMouseOut", mouseOver: "onMouseOver", click: "onClick", focus: "onFocus", blur: "onBlur", keydown: "onKeyDown", contextMenu: "onContextMenu" }), registerTriggerEvent: t => { this.setState({ triggerEventSet: t }) }, registerPortalEvent: t => { this.setState({ portalEventSet: t }) }, getTriggerBounding: () => { const t = this.adapter.getTriggerNode(); return this.triggerEl.current = t, t && t.getBoundingClientRect() }, getPopupContainerRect: () => { const t = this.getPopupContainer(); let n = null; if (t && ct(t)) { const i = M3(t.getBoundingClientRect()); n = Object.assign(Object.assign({}, i), { scrollLeft: t.scrollLeft, scrollTop: t.scrollTop }) } return n }, containerIsBody: () => this.getPopupContainer() === document.body, containerIsRelative: () => { const t = this.getPopupContainer(); return window.getComputedStyle(t).getPropertyValue("position") === "relative" }, containerIsRelativeOrAbsolute: () => ["relative", "absolute"].includes(this.containerPosition), getWrapperBounding: () => { const t = this.containerEl && this.containerEl.current; return t && t.getBoundingClientRect() }, getDocumentElementBounding: () => document.documentElement.getBoundingClientRect(), setPosition: t => { var { position: n } = t, i = ax(t, ["position"]); this.setState({ containerStyle: Object.assign(Object.assign({}, this.state.containerStyle), i), placement: n, isPositionUpdated: !0 }, () => { this.eventManager.emit("positionUpdated") }) }, setDisplayNone: (t, n) => { this.setState({ displayNone: t }, n) }, updatePlacementAttr: t => { this.setState({ placement: t }) }, togglePortalVisible: (t, n) => { const i = {}; i.transitionState = t ? "enter" : "leave", i.visible = t, this.mounted && this.setState(i, () => { n() }) }, registerClickOutsideHandler: t => { this.clickOutsideHandler && this.adapter.unregisterClickOutsideHandler(), this.clickOutsideHandler = n => { if (!this.mounted) return !1; let i = this.triggerEl && this.triggerEl.current, s = this.containerEl && this.containerEl.current; i = lr.findDOMNode(i), s = lr.findDOMNode(s); const a = n.target, o = n.composedPath && n.composedPath() || [a], l = this.props.clickTriggerToHide ? i && i.contains(a) || o.includes(i) : !1; (i && !i.contains(a) && s && !s.contains(a) && !(o.includes(s) || o.includes(i)) || l) && (this.props.onClickOutSide(n), t()) }, window.addEventListener("mousedown", this.clickOutsideHandler) }, unregisterClickOutsideHandler: () => { this.clickOutsideHandler && (window.removeEventListener("mousedown", this.clickOutsideHandler), this.clickOutsideHandler = null) }, registerResizeHandler: t => { this.resizeHandler && this.adapter.unregisterResizeHandler(), this.resizeHandler = xo(n => { if (!this.mounted) return !1; t(n) }, 10), window.addEventListener("resize", this.resizeHandler, !1) }, unregisterResizeHandler: () => { this.resizeHandler && (window.removeEventListener("resize", this.resizeHandler, !1), this.resizeHandler = null) }, notifyVisibleChange: t => { this.props.onVisibleChange(t) }, registerScrollHandler: t => { this.scrollHandler && this.adapter.unregisterScrollHandler(), this.scrollHandler = xo(n => { if (!this.mounted) return !1; const i = this.adapter.getTriggerNode(); if (n.target.contains(i)) { const a = { x: n.target.scrollLeft, y: n.target.scrollTop }; t(a) } }, 10), window.addEventListener("scroll", this.scrollHandler, !0) }, unregisterScrollHandler: () => { this.scrollHandler && (window.removeEventListener("scroll", this.scrollHandler, !0), this.scrollHandler = null) }, canMotion: () => !!this.props.motion, updateContainerPosition: () => { const t = this.getPopupContainer(); if (t && ct(t)) { const i = window.getComputedStyle(t).getPropertyValue("position"); this.containerPosition = i } }, getContainerPosition: () => this.containerPosition, getContainer: () => this.containerEl && this.containerEl.current, getTriggerNode: () => { let t = this.triggerEl.current; return ct(this.triggerEl.current) || (t = lr.findDOMNode(this.triggerEl.current)), t }, getFocusableElements: t => yS(t), getActiveElement: () => mS(), setInitialFocus: () => { const { preventScroll: t } = this.props, n = H(this, "initialFocusRef.current"); n && "focus" in n && n.focus({ preventScroll: t }) }, notifyEscKeydown: t => { this.props.onEscKeyDown(t) }, setId: () => { this.setState({ id: zi() }) }, getTriggerDOM: () => this.triggerEl.current ? lr.findDOMNode(this.triggerEl.current) : null }) } componentDidMount() { this.mounted = !0, this.getPopupContainer = this.props.getPopupContainer || this.context.getPopupContainer || bV, this.foundation.init(), Am(() => { let e = this.triggerEl.current; e && (e instanceof HTMLElement || (e = di.findDOMNode(e))), this.foundation.updateStateIfCursorOnTrigger(e) }, 1) } componentWillUnmount() { this.mounted = !1, this.foundation.destroy() } focusTrigger() { this.foundation.focusTrigger() } rePosition() { return this.foundation.calcPosition() } componentDidUpdate(e, t) { Nt(this.props.mouseLeaveDelay < this.props.mouseEnterDelay, "[Semi Tooltip] 'mouseLeaveDelay' cannot be less than 'mouseEnterDelay', which may cause the dropdown layer to not be hidden."), e.visible !== this.props.visible && (["hover", "focus"].includes(this.props.trigger) ? this.props.visible ? this.foundation.delayShow() : this.foundation.delayHide() : this.props.visible ? this.foundation.show() : this.foundation.hide()), ke(e.rePosKey, this.props.rePosKey) || this.rePosition() } render() { const { isInsert: e, triggerEventSet: t, visible: n, id: i } = this.state, { wrapWhenSpecial: s, role: a, trigger: o } = this.props; let { children: l } = this.props; const u = Object.assign({}, H(l, "props.style")), d = {}; if (s) { const m = this.isSpecial(l); m ? (u.pointerEvents = "none", m === Ds.STATUS_DISABLED && (d.cursor = "not-allowed"), l = R.cloneElement(l, { style: u }), o !== "custom" && (l = this.wrapSpan(l)), this.isWrapped = !0) : R.isValidElement(l) || (l = this.wrapSpan(l), this.isWrapped = !0) } let h = {}; a === "dialog" ? (h["aria-expanded"] = n ? "true" : "false", h["aria-haspopup"] = "dialog", h["aria-controls"] = i) : h["aria-describedby"] = i; const g = f.cloneElement(l, Object.assign(Object.assign(Object.assign(Object.assign({}, h), l.props), this.mergeEvents(l.props, t)), { style: Object.assign(Object.assign({}, H(l, "props.style")), d), className: F(H(l, "props.className")), ref: m => { this.triggerEl.current = m; const { ref: b } = l; typeof b == "function" ? b(m) : b && typeof b == "object" && (b.current = m) }, tabIndex: l.props.tabIndex || 0, "data-popupid": i })); return f.createElement(f.Fragment, null, e ? this.renderPortal() : null, g) } } ln.contextType = An; ln.propTypes = { children: c.node, motion: c.bool, autoAdjustOverflow: c.bool, position: c.oneOf(gV), getPopupContainer: c.func, mouseEnterDelay: c.number, mouseLeaveDelay: c.number, trigger: c.oneOf(mV).isRequired, className: c.string, wrapperClassName: c.string, clickToHide: c.bool, clickTriggerToHide: c.bool, visible: c.bool, style: c.object, content: c.oneOfType([c.node, c.func]), prefixCls: c.string, onVisibleChange: c.func, onClickOutSide: c.func, spacing: c.oneOfType([c.number, c.object]), margin: c.oneOfType([c.number, c.object]), showArrow: c.oneOfType([c.bool, c.node]), zIndex: c.number, rePosKey: c.oneOfType([c.string, c.number]), arrowBounding: fV, transformFromCenter: c.bool, arrowPointAtCenter: c.bool, stopPropagation: c.bool, role: c.string, wrapWhenSpecial: c.bool, guardFocus: c.bool, returnFocusOnClose: c.bool, preventScroll: c.bool, keepDOM: c.bool }; ln.__SemiComponentName__ = "Tooltip"; ln.defaultProps = xn(ln.__SemiComponentName__, { arrowBounding: Es.ARROW_BOUNDING, autoAdjustOverflow: !0, arrowPointAtCenter: !0, trigger: "hover", transformFromCenter: !0, position: "top", prefixCls: Tu, role: "tooltip", mouseEnterDelay: Es.MOUSE_ENTER_DELAY, mouseLeaveDelay: Es.MOUSE_LEAVE_DELAY, motion: !0, onVisibleChange: z, onClickOutSide: z, spacing: Es.SPACING, margin: Es.MARGIN, showArrow: !0, wrapWhenSpecial: !0, zIndex: Es.DEFAULT_Z_INDEX, closeOnEsc: !1, guardFocus: !1, returnFocusOnClose: !1, onEscKeyDown: z, disableFocusListener: !1, disableArrowKeyDown: !1, keepDOM: !1 }); var Fm = { exports: {} }; const bS = (r, { target: e = document.body } = {}) => { const t = document.createElement("textarea"), n = document.activeElement; t.value = r, t.setAttribute("readonly", ""), t.style.contain = "strict", t.style.position = "absolute", t.style.left = "-9999px", t.style.fontSize = "12pt"; const i = document.getSelection(); let s = !1; i.rangeCount > 0 && (s = i.getRangeAt(0)), e.append(t), t.select(), t.selectionStart = 0, t.selectionEnd = r.length; let a = !1; try { a = document.execCommand("copy") } catch { } return t.remove(), s && (i.removeAllRanges(), i.addRange(s)), n && n.focus(), a }; Fm.exports = bS; Fm.exports.default = bS; var vV = Fm.exports; const qu = _e(vV); function Ct() { } const xV = f.createContext(null); function ho(r) { return function () { var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, t = e.width ? String(e.width) : r.defaultWidth, n = r.formats[t] || r.formats[r.defaultWidth]; return n } } function Di(r) { return function (e, t) { var n = t != null && t.context ? String(t.context) : "standalone", i; if (n === "formatting" && r.formattingValues) { var s = r.defaultFormattingWidth || r.defaultWidth, a = t != null && t.width ? String(t.width) : s; i = r.formattingValues[a] || r.formattingValues[s] } else { var o = r.defaultWidth, l = t != null && t.width ? String(t.width) : r.defaultWidth; i = r.values[l] || r.values[o] } var u = r.argumentCallback ? r.argumentCallback(e) : e; return i[u] } } function Ai(r) { return function (e) { var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, n = t.width, i = n && r.matchPatterns[n] || r.matchPatterns[r.defaultMatchWidth], s = e.match(i); if (!s) return null; var a = s[0], o = n && r.parsePatterns[n] || r.parsePatterns[r.defaultParseWidth], l = Array.isArray(o) ? CV(o, function (h) { return h.test(a) }) : wV(o, function (h) { return h.test(a) }), u; u = r.valueCallback ? r.valueCallback(l) : l, u = t.valueCallback ? t.valueCallback(u) : u; var d = e.slice(a.length); return { value: u, rest: d } } } function wV(r, e) { for (var t in r) if (r.hasOwnProperty(t) && e(r[t])) return t } function CV(r, e) { for (var t = 0; t < r.length; t++)if (e(r[t])) return t } function vS(r) { return function (e) { var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, n = e.match(r.matchPattern); if (!n) return null; var i = n[0], s = e.match(r.parsePattern); if (!s) return null; var a = r.valueCallback ? r.valueCallback(s[0]) : s[0]; a = t.valueCallback ? t.valueCallback(a) : a; var o = e.slice(i.length); return { value: a, rest: o } } } function Ki(r) { "@babel/helpers - typeof"; return Ki = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function (e) { return typeof e } : function (e) { return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e }, Ki(r) } function Vt(r) { if (r === null || r === !0 || r === !1) return NaN; var e = Number(r); return isNaN(e) ? e : e < 0 ? Math.ceil(e) : Math.floor(e) } function $e(r, e) { if (e.length < r) throw new TypeError(r + " argument" + (r > 1 ? "s" : "") + " required, but only " + e.length + " present") } function He(r) { $e(1, arguments); var e = Object.prototype.toString.call(r); return r instanceof Date || Ki(r) === "object" && e === "[object Date]" ? new Date(r.getTime()) : typeof r == "number" || e === "[object Number]" ? new Date(r) : ((typeof r == "string" || e === "[object String]") && typeof console < "u" && (console.warn("Starting with v2.0.0-beta.1 date-fns doesn't accept strings as date arguments. Please use `parseISO` to parse strings. See: https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#string-arguments"), console.warn(new Error().stack)), new Date(NaN)) } function Is(r, e) { $e(2, arguments); var t = He(r), n = Vt(e); if (isNaN(n)) return new Date(NaN); if (!n) return t; var i = t.getDate(), s = new Date(t.getTime()); s.setMonth(t.getMonth() + n + 1, 0); var a = s.getDate(); return i >= a ? s : (t.setFullYear(s.getFullYear(), s.getMonth(), i), t) } function SV(r, e) { $e(2, arguments); var t = He(r).getTime(), n = Vt(e); return new Date(t + n) } var EV = {}; function Ko() { return EV } function xS(r) { var e = new Date(Date.UTC(r.getFullYear(), r.getMonth(), r.getDate(), r.getHours(), r.getMinutes(), r.getSeconds(), r.getMilliseconds())); return e.setUTCFullYear(r.getFullYear()), r.getTime() - e.getTime() } function ox(r) { $e(1, arguments); var e = He(r); return e.setHours(0, 0, 0, 0), e } function Zu(r, e) { $e(2, arguments); var t = Vt(e); return Is(r, t * 12) } var $m = 6e4, Lm = 36e5, _V = 1e3; function Mm(r, e) { $e(2, arguments); var t = ox(r), n = ox(e); return t.getTime() === n.getTime() } function xf(r) { return $e(1, arguments), r instanceof Date || Ki(r) === "object" && Object.prototype.toString.call(r) === "[object Date]" } function Kr(r) { if ($e(1, arguments), !xf(r) && typeof r != "number") return !1; var e = He(r); return !isNaN(Number(e)) } function ea(r, e) { $e(2, arguments); var t = He(r), n = He(e), i = t.getFullYear() - n.getFullYear(), s = t.getMonth() - n.getMonth(); return i * 12 + s } function OV(r, e) { $e(2, arguments); var t = He(r), n = He(e); return t.getFullYear() - n.getFullYear() } function TV(r) { $e(1, arguments); var e = He(r); return e.setDate(1), e.setHours(0, 0, 0, 0), e } function wS(r, e) { $e(2, arguments); var t = Vt(e); return SV(r, -t) } var IV = 864e5; function PV(r) { $e(1, arguments); var e = He(r), t = e.getTime(); e.setUTCMonth(0, 1), e.setUTCHours(0, 0, 0, 0); var n = e.getTime(), i = t - n; return Math.floor(i / IV) + 1 } function wo(r) { $e(1, arguments); var e = 1, t = He(r), n = t.getUTCDay(), i = (n < e ? 7 : 0) + n - e; return t.setUTCDate(t.getUTCDate() - i), t.setUTCHours(0, 0, 0, 0), t } function CS(r) { $e(1, arguments); var e = He(r), t = e.getUTCFullYear(), n = new Date(0); n.setUTCFullYear(t + 1, 0, 4), n.setUTCHours(0, 0, 0, 0); var i = wo(n), s = new Date(0); s.setUTCFullYear(t, 0, 4), s.setUTCHours(0, 0, 0, 0); var a = wo(s); return e.getTime() >= i.getTime() ? t + 1 : e.getTime() >= a.getTime() ? t : t - 1 } function kV(r) { $e(1, arguments); var e = CS(r), t = new Date(0); t.setUTCFullYear(e, 0, 4), t.setUTCHours(0, 0, 0, 0); var n = wo(t); return n } var RV = 6048e5; function SS(r) { $e(1, arguments); var e = He(r), t = wo(e).getTime() - kV(e).getTime(); return Math.round(t / RV) + 1 } function as(r, e) { var t, n, i, s, a, o, l, u; $e(1, arguments); var d = Ko(), h = Vt((t = (n = (i = (s = e == null ? void 0 : e.weekStartsOn) !== null && s !== void 0 ? s : e == null || (a = e.locale) === null || a === void 0 || (o = a.options) === null || o === void 0 ? void 0 : o.weekStartsOn) !== null && i !== void 0 ? i : d.weekStartsOn) !== null && n !== void 0 ? n : (l = d.locale) === null || l === void 0 || (u = l.options) === null || u === void 0 ? void 0 : u.weekStartsOn) !== null && t !== void 0 ? t : 0); if (!(h >= 0 && h <= 6)) throw new RangeError("weekStartsOn must be between 0 and 6 inclusively"); var g = He(r), m = g.getUTCDay(), b = (m < h ? 7 : 0) + m - h; return g.setUTCDate(g.getUTCDate() - b), g.setUTCHours(0, 0, 0, 0), g } function jm(r, e) { var t, n, i, s, a, o, l, u; $e(1, arguments); var d = He(r), h = d.getUTCFullYear(), g = Ko(), m = Vt((t = (n = (i = (s = e == null ? void 0 : e.firstWeekContainsDate) !== null && s !== void 0 ? s : e == null || (a = e.locale) === null || a === void 0 || (o = a.options) === null || o === void 0 ? void 0 : o.firstWeekContainsDate) !== null && i !== void 0 ? i : g.firstWeekContainsDate) !== null && n !== void 0 ? n : (l = g.locale) === null || l === void 0 || (u = l.options) === null || u === void 0 ? void 0 : u.firstWeekContainsDate) !== null && t !== void 0 ? t : 1); if (!(m >= 1 && m <= 7)) throw new RangeError("firstWeekContainsDate must be between 1 and 7 inclusively"); var b = new Date(0); b.setUTCFullYear(h + 1, 0, m), b.setUTCHours(0, 0, 0, 0); var y = as(b, e), w = new Date(0); w.setUTCFullYear(h, 0, m), w.setUTCHours(0, 0, 0, 0); var x = as(w, e); return d.getTime() >= y.getTime() ? h + 1 : d.getTime() >= x.getTime() ? h : h - 1 } function DV(r, e) { var t, n, i, s, a, o, l, u; $e(1, arguments); var d = Ko(), h = Vt((t = (n = (i = (s = e == null ? void 0 : e.firstWeekContainsDate) !== null && s !== void 0 ? s : e == null || (a = e.locale) === null || a === void 0 || (o = a.options) === null || o === void 0 ? void 0 : o.firstWeekContainsDate) !== null && i !== void 0 ? i : d.firstWeekContainsDate) !== null && n !== void 0 ? n : (l = d.locale) === null || l === void 0 || (u = l.options) === null || u === void 0 ? void 0 : u.firstWeekContainsDate) !== null && t !== void 0 ? t : 1), g = jm(r, e), m = new Date(0); m.setUTCFullYear(g, 0, h), m.setUTCHours(0, 0, 0, 0); var b = as(m, e); return b } var AV = 6048e5; function ES(r, e) { $e(1, arguments); var t = He(r), n = as(t, e).getTime() - DV(t, e).getTime(); return Math.round(n / AV) + 1 } function It(r, e) { for (var t = r < 0 ? "-" : "", n = Math.abs(r).toString(); n.length < e;)n = "0" + n; return t + n } var gs = { y: function (e, t) { var n = e.getUTCFullYear(), i = n > 0 ? n : 1 - n; return It(t === "yy" ? i % 100 : i, t.length) }, M: function (e, t) { var n = e.getUTCMonth(); return t === "M" ? String(n + 1) : It(n + 1, 2) }, d: function (e, t) { return It(e.getUTCDate(), t.length) }, a: function (e, t) { var n = e.getUTCHours() / 12 >= 1 ? "pm" : "am"; switch (t) { case "a": case "aa": return n.toUpperCase(); case "aaa": return n; case "aaaaa": return n[0]; case "aaaa": default: return n === "am" ? "a.m." : "p.m." } }, h: function (e, t) { return It(e.getUTCHours() % 12 || 12, t.length) }, H: function (e, t) { return It(e.getUTCHours(), t.length) }, m: function (e, t) { return It(e.getUTCMinutes(), t.length) }, s: function (e, t) { return It(e.getUTCSeconds(), t.length) }, S: function (e, t) { var n = t.length, i = e.getUTCMilliseconds(), s = Math.floor(i * Math.pow(10, n - 3)); return It(s, t.length) } }, za = { am: "am", pm: "pm", midnight: "midnight", noon: "noon", morning: "morning", afternoon: "afternoon", evening: "evening", night: "night" }, NV = { G: function (e, t, n) { var i = e.getUTCFullYear() > 0 ? 1 : 0; switch (t) { case "G": case "GG": case "GGG": return n.era(i, { width: "abbreviated" }); case "GGGGG": return n.era(i, { width: "narrow" }); case "GGGG": default: return n.era(i, { width: "wide" }) } }, y: function (e, t, n) { if (t === "yo") { var i = e.getUTCFullYear(), s = i > 0 ? i : 1 - i; return n.ordinalNumber(s, { unit: "year" }) } return gs.y(e, t) }, Y: function (e, t, n, i) { var s = jm(e, i), a = s > 0 ? s : 1 - s; if (t === "YY") { var o = a % 100; return It(o, 2) } return t === "Yo" ? n.ordinalNumber(a, { unit: "year" }) : It(a, t.length) }, R: function (e, t) { var n = CS(e); return It(n, t.length) }, u: function (e, t) { var n = e.getUTCFullYear(); return It(n, t.length) }, Q: function (e, t, n) { var i = Math.ceil((e.getUTCMonth() + 1) / 3); switch (t) { case "Q": return String(i); case "QQ": return It(i, 2); case "Qo": return n.ordinalNumber(i, { unit: "quarter" }); case "QQQ": return n.quarter(i, { width: "abbreviated", context: "formatting" }); case "QQQQQ": return n.quarter(i, { width: "narrow", context: "formatting" }); case "QQQQ": default: return n.quarter(i, { width: "wide", context: "formatting" }) } }, q: function (e, t, n) { var i = Math.ceil((e.getUTCMonth() + 1) / 3); switch (t) { case "q": return String(i); case "qq": return It(i, 2); case "qo": return n.ordinalNumber(i, { unit: "quarter" }); case "qqq": return n.quarter(i, { width: "abbreviated", context: "standalone" }); case "qqqqq": return n.quarter(i, { width: "narrow", context: "standalone" }); case "qqqq": default: return n.quarter(i, { width: "wide", context: "standalone" }) } }, M: function (e, t, n) { var i = e.getUTCMonth(); switch (t) { case "M": case "MM": return gs.M(e, t); case "Mo": return n.ordinalNumber(i + 1, { unit: "month" }); case "MMM": return n.month(i, { width: "abbreviated", context: "formatting" }); case "MMMMM": return n.month(i, { width: "narrow", context: "formatting" }); case "MMMM": default: return n.month(i, { width: "wide", context: "formatting" }) } }, L: function (e, t, n) { var i = e.getUTCMonth(); switch (t) { case "L": return String(i + 1); case "LL": return It(i + 1, 2); case "Lo": return n.ordinalNumber(i + 1, { unit: "month" }); case "LLL": return n.month(i, { width: "abbreviated", context: "standalone" }); case "LLLLL": return n.month(i, { width: "narrow", context: "standalone" }); case "LLLL": default: return n.month(i, { width: "wide", context: "standalone" }) } }, w: function (e, t, n, i) { var s = ES(e, i); return t === "wo" ? n.ordinalNumber(s, { unit: "week" }) : It(s, t.length) }, I: function (e, t, n) { var i = SS(e); return t === "Io" ? n.ordinalNumber(i, { unit: "week" }) : It(i, t.length) }, d: function (e, t, n) { return t === "do" ? n.ordinalNumber(e.getUTCDate(), { unit: "date" }) : gs.d(e, t) }, D: function (e, t, n) { var i = PV(e); return t === "Do" ? n.ordinalNumber(i, { unit: "dayOfYear" }) : It(i, t.length) }, E: function (e, t, n) { var i = e.getUTCDay(); switch (t) { case "E": case "EE": case "EEE": return n.day(i, { width: "abbreviated", context: "formatting" }); case "EEEEE": return n.day(i, { width: "narrow", context: "formatting" }); case "EEEEEE": return n.day(i, { width: "short", context: "formatting" }); case "EEEE": default: return n.day(i, { width: "wide", context: "formatting" }) } }, e: function (e, t, n, i) { var s = e.getUTCDay(), a = (s - i.weekStartsOn + 8) % 7 || 7; switch (t) { case "e": return String(a); case "ee": return It(a, 2); case "eo": return n.ordinalNumber(a, { unit: "day" }); case "eee": return n.day(s, { width: "abbreviated", context: "formatting" }); case "eeeee": return n.day(s, { width: "narrow", context: "formatting" }); case "eeeeee": return n.day(s, { width: "short", context: "formatting" }); case "eeee": default: return n.day(s, { width: "wide", context: "formatting" }) } }, c: function (e, t, n, i) { var s = e.getUTCDay(), a = (s - i.weekStartsOn + 8) % 7 || 7; switch (t) { case "c": return String(a); case "cc": return It(a, t.length); case "co": return n.ordinalNumber(a, { unit: "day" }); case "ccc": return n.day(s, { width: "abbreviated", context: "standalone" }); case "ccccc": return n.day(s, { width: "narrow", context: "standalone" }); case "cccccc": return n.day(s, { width: "short", context: "standalone" }); case "cccc": default: return n.day(s, { width: "wide", context: "standalone" }) } }, i: function (e, t, n) { var i = e.getUTCDay(), s = i === 0 ? 7 : i; switch (t) { case "i": return String(s); case "ii": return It(s, t.length); case "io": return n.ordinalNumber(s, { unit: "day" }); case "iii": return n.day(i, { width: "abbreviated", context: "formatting" }); case "iiiii": return n.day(i, { width: "narrow", context: "formatting" }); case "iiiiii": return n.day(i, { width: "short", context: "formatting" }); case "iiii": default: return n.day(i, { width: "wide", context: "formatting" }) } }, a: function (e, t, n) { var i = e.getUTCHours(), s = i / 12 >= 1 ? "pm" : "am"; switch (t) { case "a": case "aa": return n.dayPeriod(s, { width: "abbreviated", context: "formatting" }); case "aaa": return n.dayPeriod(s, { width: "abbreviated", context: "formatting" }).toLowerCase(); case "aaaaa": return n.dayPeriod(s, { width: "narrow", context: "formatting" }); case "aaaa": default: return n.dayPeriod(s, { width: "wide", context: "formatting" }) } }, b: function (e, t, n) { var i = e.getUTCHours(), s; switch (i === 12 ? s = za.noon : i === 0 ? s = za.midnight : s = i / 12 >= 1 ? "pm" : "am", t) { case "b": case "bb": return n.dayPeriod(s, { width: "abbreviated", context: "formatting" }); case "bbb": return n.dayPeriod(s, { width: "abbreviated", context: "formatting" }).toLowerCase(); case "bbbbb": return n.dayPeriod(s, { width: "narrow", context: "formatting" }); case "bbbb": default: return n.dayPeriod(s, { width: "wide", context: "formatting" }) } }, B: function (e, t, n) { var i = e.getUTCHours(), s; switch (i >= 17 ? s = za.evening : i >= 12 ? s = za.afternoon : i >= 4 ? s = za.morning : s = za.night, t) { case "B": case "BB": case "BBB": return n.dayPeriod(s, { width: "abbreviated", context: "formatting" }); case "BBBBB": return n.dayPeriod(s, { width: "narrow", context: "formatting" }); case "BBBB": default: return n.dayPeriod(s, { width: "wide", context: "formatting" }) } }, h: function (e, t, n) { if (t === "ho") { var i = e.getUTCHours() % 12; return i === 0 && (i = 12), n.ordinalNumber(i, { unit: "hour" }) } return gs.h(e, t) }, H: function (e, t, n) { return t === "Ho" ? n.ordinalNumber(e.getUTCHours(), { unit: "hour" }) : gs.H(e, t) }, K: function (e, t, n) { var i = e.getUTCHours() % 12; return t === "Ko" ? n.ordinalNumber(i, { unit: "hour" }) : It(i, t.length) }, k: function (e, t, n) { var i = e.getUTCHours(); return i === 0 && (i = 24), t === "ko" ? n.ordinalNumber(i, { unit: "hour" }) : It(i, t.length) }, m: function (e, t, n) { return t === "mo" ? n.ordinalNumber(e.getUTCMinutes(), { unit: "minute" }) : gs.m(e, t) }, s: function (e, t, n) { return t === "so" ? n.ordinalNumber(e.getUTCSeconds(), { unit: "second" }) : gs.s(e, t) }, S: function (e, t) { return gs.S(e, t) }, X: function (e, t, n, i) { var s = i._originalDate || e, a = s.getTimezoneOffset(); if (a === 0) return "Z"; switch (t) { case "X": return cx(a); case "XXXX": case "XX": return ta(a); case "XXXXX": case "XXX": default: return ta(a, ":") } }, x: function (e, t, n, i) { var s = i._originalDate || e, a = s.getTimezoneOffset(); switch (t) { case "x": return cx(a); case "xxxx": case "xx": return ta(a); case "xxxxx": case "xxx": default: return ta(a, ":") } }, O: function (e, t, n, i) { var s = i._originalDate || e, a = s.getTimezoneOffset(); switch (t) { case "O": case "OO": case "OOO": return "GMT" + lx(a, ":"); case "OOOO": default: return "GMT" + ta(a, ":") } }, z: function (e, t, n, i) { var s = i._originalDate || e, a = s.getTimezoneOffset(); switch (t) { case "z": case "zz": case "zzz": return "GMT" + lx(a, ":"); case "zzzz": default: return "GMT" + ta(a, ":") } }, t: function (e, t, n, i) { var s = i._originalDate || e, a = Math.floor(s.getTime() / 1e3); return It(a, t.length) }, T: function (e, t, n, i) { var s = i._originalDate || e, a = s.getTime(); return It(a, t.length) } }; function lx(r, e) { var t = r > 0 ? "-" : "+", n = Math.abs(r), i = Math.floor(n / 60), s = n % 60; if (s === 0) return t + String(i); var a = e; return t + String(i) + a + It(s, 2) } function cx(r, e) { if (r % 60 === 0) { var t = r > 0 ? "-" : "+"; return t + It(Math.abs(r) / 60, 2) } return ta(r, e) } function ta(r, e) { var t = e || "", n = r > 0 ? "-" : "+", i = Math.abs(r), s = It(Math.floor(i / 60), 2), a = It(i % 60, 2); return n + s + t + a } var ux = function (e, t) { switch (e) { case "P": return t.date({ width: "short" }); case "PP": return t.date({ width: "medium" }); case "PPP": return t.date({ width: "long" }); case "PPPP": default: return t.date({ width: "full" }) } }, _S = function (e, t) { switch (e) { case "p": return t.time({ width: "short" }); case "pp": return t.time({ width: "medium" }); case "ppp": return t.time({ width: "long" }); case "pppp": default: return t.time({ width: "full" }) } }, FV = function (e, t) { var n = e.match(/(P+)(p+)?/) || [], i = n[1], s = n[2]; if (!s) return ux(e, t); var a; switch (i) { case "P": a = t.dateTime({ width: "short" }); break; case "PP": a = t.dateTime({ width: "medium" }); break; case "PPP": a = t.dateTime({ width: "long" }); break; case "PPPP": default: a = t.dateTime({ width: "full" }); break }return a.replace("{{date}}", ux(i, t)).replace("{{time}}", _S(s, t)) }, wf = { p: _S, P: FV }, $V = ["D", "DD"], LV = ["YY", "YYYY"]; function OS(r) { return $V.indexOf(r) !== -1 } function TS(r) { return LV.indexOf(r) !== -1 } function Ju(r, e, t) { if (r === "YYYY") throw new RangeError("Use `yyyy` instead of `YYYY` (in `".concat(e, "`) for formatting years to the input `").concat(t, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md")); if (r === "YY") throw new RangeError("Use `yy` instead of `YY` (in `".concat(e, "`) for formatting years to the input `").concat(t, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md")); if (r === "D") throw new RangeError("Use `d` instead of `D` (in `".concat(e, "`) for formatting days of the month to the input `").concat(t, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md")); if (r === "DD") throw new RangeError("Use `dd` instead of `DD` (in `".concat(e, "`) for formatting days of the month to the input `").concat(t, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md")) } var MV = { lessThanXSeconds: { one: "less than a second", other: "less than {{count}} seconds" }, xSeconds: { one: "1 second", other: "{{count}} seconds" }, halfAMinute: "half a minute", lessThanXMinutes: { one: "less than a minute", other: "less than {{count}} minutes" }, xMinutes: { one: "1 minute", other: "{{count}} minutes" }, aboutXHours: { one: "about 1 hour", other: "about {{count}} hours" }, xHours: { one: "1 hour", other: "{{count}} hours" }, xDays: { one: "1 day", other: "{{count}} days" }, aboutXWeeks: { one: "about 1 week", other: "about {{count}} weeks" }, xWeeks: { one: "1 week", other: "{{count}} weeks" }, aboutXMonths: { one: "about 1 month", other: "about {{count}} months" }, xMonths: { one: "1 month", other: "{{count}} months" }, aboutXYears: { one: "about 1 year", other: "about {{count}} years" }, xYears: { one: "1 year", other: "{{count}} years" }, overXYears: { one: "over 1 year", other: "over {{count}} years" }, almostXYears: { one: "almost 1 year", other: "almost {{count}} years" } }, jV = function (e, t, n) { var i, s = MV[e]; return typeof s == "string" ? i = s : t === 1 ? i = s.one : i = s.other.replace("{{count}}", t.toString()), n != null && n.addSuffix ? n.comparison && n.comparison > 0 ? "in " + i : i + " ago" : i }, VV = { full: "EEEE, MMMM do, y", long: "MMMM do, y", medium: "MMM d, y", short: "MM/dd/yyyy" }, BV = { full: "h:mm:ss a zzzz", long: "h:mm:ss a z", medium: "h:mm:ss a", short: "h:mm a" }, zV = { full: "{{date}} 'at' {{time}}", long: "{{date}} 'at' {{time}}", medium: "{{date}}, {{time}}", short: "{{date}}, {{time}}" }, HV = { date: ho({ formats: VV, defaultWidth: "full" }), time: ho({ formats: BV, defaultWidth: "full" }), dateTime: ho({ formats: zV, defaultWidth: "full" }) }, KV = { lastWeek: "'last' eeee 'at' p", yesterday: "'yesterday at' p", today: "'today at' p", tomorrow: "'tomorrow at' p", nextWeek: "eeee 'at' p", other: "P" }, UV = function (e, t, n, i) { return KV[e] }, WV = { narrow: ["B", "A"], abbreviated: ["BC", "AD"], wide: ["Before Christ", "Anno Domini"] }, GV = { narrow: ["1", "2", "3", "4"], abbreviated: ["Q1", "Q2", "Q3", "Q4"], wide: ["1st quarter", "2nd quarter", "3rd quarter", "4th quarter"] }, YV = { narrow: ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"], abbreviated: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"], wide: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"] }, XV = { narrow: ["S", "M", "T", "W", "T", "F", "S"], short: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"], abbreviated: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"], wide: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"] }, qV = { narrow: { am: "a", pm: "p", midnight: "mi", noon: "n", morning: "morning", afternoon: "afternoon", evening: "evening", night: "night" }, abbreviated: { am: "AM", pm: "PM", midnight: "midnight", noon: "noon", morning: "morning", afternoon: "afternoon", evening: "evening", night: "night" }, wide: { am: "a.m.", pm: "p.m.", midnight: "midnight", noon: "noon", morning: "morning", afternoon: "afternoon", evening: "evening", night: "night" } }, ZV = { narrow: { am: "a", pm: "p", midnight: "mi", noon: "n", morning: "in the morning", afternoon: "in the afternoon", evening: "in the evening", night: "at night" }, abbreviated: { am: "AM", pm: "PM", midnight: "midnight", noon: "noon", morning: "in the morning", afternoon: "in the afternoon", evening: "in the evening", night: "at night" }, wide: { am: "a.m.", pm: "p.m.", midnight: "midnight", noon: "noon", morning: "in the morning", afternoon: "in the afternoon", evening: "in the evening", night: "at night" } }, JV = function (e, t) { var n = Number(e), i = n % 100; if (i > 20 || i < 10) switch (i % 10) { case 1: return n + "st"; case 2: return n + "nd"; case 3: return n + "rd" }return n + "th" }, QV = { ordinalNumber: JV, era: Di({ values: WV, defaultWidth: "wide" }), quarter: Di({ values: GV, defaultWidth: "wide", argumentCallback: function (e) { return e - 1 } }), month: Di({ values: YV, defaultWidth: "wide" }), day: Di({ values: XV, defaultWidth: "wide" }), dayPeriod: Di({ values: qV, defaultWidth: "wide", formattingValues: ZV, defaultFormattingWidth: "wide" }) }, eB = /^(\d+)(th|st|nd|rd)?/i, tB = /\d+/i, nB = { narrow: /^(b|a)/i, abbreviated: /^(b\.?\s?c\.?|b\.?\s?c\.?\s?e\.?|a\.?\s?d\.?|c\.?\s?e\.?)/i, wide: /^(before christ|before common era|anno domini|common era)/i }, rB = { any: [/^b/i, /^(a|c)/i] }, iB = { narrow: /^[1234]/i, abbreviated: /^q[1234]/i, wide: /^[1234](th|st|nd|rd)? quarter/i }, sB = { any: [/1/i, /2/i, /3/i, /4/i] }, aB = { narrow: /^[jfmasond]/i, abbreviated: /^(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)/i, wide: /^(january|february|march|april|may|june|july|august|september|october|november|december)/i }, oB = { narrow: [/^j/i, /^f/i, /^m/i, /^a/i, /^m/i, /^j/i, /^j/i, /^a/i, /^s/i, /^o/i, /^n/i, /^d/i], any: [/^ja/i, /^f/i, /^mar/i, /^ap/i, /^may/i, /^jun/i, /^jul/i, /^au/i, /^s/i, /^o/i, /^n/i, /^d/i] }, lB = { narrow: /^[smtwf]/i, short: /^(su|mo|tu|we|th|fr|sa)/i, abbreviated: /^(sun|mon|tue|wed|thu|fri|sat)/i, wide: /^(sunday|monday|tuesday|wednesday|thursday|friday|saturday)/i }, cB = { narrow: [/^s/i, /^m/i, /^t/i, /^w/i, /^t/i, /^f/i, /^s/i], any: [/^su/i, /^m/i, /^tu/i, /^w/i, /^th/i, /^f/i, /^sa/i] }, uB = { narrow: /^(a|p|mi|n|(in the|at) (morning|afternoon|evening|night))/i, any: /^([ap]\.?\s?m\.?|midnight|noon|(in the|at) (morning|afternoon|evening|night))/i }, dB = { any: { am: /^a/i, pm: /^p/i, midnight: /^mi/i, noon: /^no/i, morning: /morning/i, afternoon: /afternoon/i, evening: /evening/i, night: /night/i } }, hB = { ordinalNumber: vS({ matchPattern: eB, parsePattern: tB, valueCallback: function (e) { return parseInt(e, 10) } }), era: Ai({ matchPatterns: nB, defaultMatchWidth: "wide", parsePatterns: rB, defaultParseWidth: "any" }), quarter: Ai({ matchPatterns: iB, defaultMatchWidth: "wide", parsePatterns: sB, defaultParseWidth: "any", valueCallback: function (e) { return e + 1 } }), month: Ai({ matchPatterns: aB, defaultMatchWidth: "wide", parsePatterns: oB, defaultParseWidth: "any" }), day: Ai({ matchPatterns: lB, defaultMatchWidth: "wide", parsePatterns: cB, defaultParseWidth: "any" }), dayPeriod: Ai({ matchPatterns: uB, defaultMatchWidth: "any", parsePatterns: dB, defaultParseWidth: "any" }) }, IS = { code: "en-US", formatDistance: jV, formatLong: HV, formatRelative: UV, localize: QV, match: hB, options: { weekStartsOn: 0, firstWeekContainsDate: 1 } }, pB = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g, fB = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g, gB = /^'([^]*?)'?$/, mB = /''/g, yB = /[a-zA-Z]/; function mt(r, e, t) { var n, i, s, a, o, l, u, d, h, g, m, b, y, w, x, S, C, O; $e(2, arguments); var E = String(e), v = Ko(), T = (n = (i = t == null ? void 0 : t.locale) !== null && i !== void 0 ? i : v.locale) !== null && n !== void 0 ? n : IS, I = Vt((s = (a = (o = (l = t == null ? void 0 : t.firstWeekContainsDate) !== null && l !== void 0 ? l : t == null || (u = t.locale) === null || u === void 0 || (d = u.options) === null || d === void 0 ? void 0 : d.firstWeekContainsDate) !== null && o !== void 0 ? o : v.firstWeekContainsDate) !== null && a !== void 0 ? a : (h = v.locale) === null || h === void 0 || (g = h.options) === null || g === void 0 ? void 0 : g.firstWeekContainsDate) !== null && s !== void 0 ? s : 1); if (!(I >= 1 && I <= 7)) throw new RangeError("firstWeekContainsDate must be between 1 and 7 inclusively"); var k = Vt((m = (b = (y = (w = t == null ? void 0 : t.weekStartsOn) !== null && w !== void 0 ? w : t == null || (x = t.locale) === null || x === void 0 || (S = x.options) === null || S === void 0 ? void 0 : S.weekStartsOn) !== null && y !== void 0 ? y : v.weekStartsOn) !== null && b !== void 0 ? b : (C = v.locale) === null || C === void 0 || (O = C.options) === null || O === void 0 ? void 0 : O.weekStartsOn) !== null && m !== void 0 ? m : 0); if (!(k >= 0 && k <= 6)) throw new RangeError("weekStartsOn must be between 0 and 6 inclusively"); if (!T.localize) throw new RangeError("locale must contain localize property"); if (!T.formatLong) throw new RangeError("locale must contain formatLong property"); var P = He(r); if (!Kr(P)) throw new RangeError("Invalid time value"); var N = xS(P), M = wS(P, N), B = { firstWeekContainsDate: I, weekStartsOn: k, locale: T, _originalDate: P }, K = E.match(fB).map(function (U) { var W = U[0]; if (W === "p" || W === "P") { var Z = wf[W]; return Z(U, T.formatLong) } return U }).join("").match(pB).map(function (U) { if (U === "''") return "'"; var W = U[0]; if (W === "'") return bB(U); var Z = NV[W]; if (Z) return !(t != null && t.useAdditionalWeekYearTokens) && TS(U) && Ju(U, e, String(r)), !(t != null && t.useAdditionalDayOfYearTokens) && OS(U) && Ju(U, e, String(r)), Z(M, U, T.localize, B); if (W.match(yB)) throw new RangeError("Format string contains an unescaped latin alphabet character `" + W + "`"); return U }).join(""); return K } function bB(r) { var e = r.match(gB); return e ? e[1].replace(mB, "'") : r } function vB(r, e) { if (r == null) throw new TypeError("assign requires that input parameter not be null or undefined"); for (var t in e) Object.prototype.hasOwnProperty.call(e, t) && (r[t] = e[t]); return r } function PS(r) { $e(1, arguments); var e = He(r), t = e.getFullYear(), n = e.getMonth(), i = new Date(0); return i.setFullYear(t, n + 1, 0), i.setHours(0, 0, 0, 0), i.getDate() } function xB(r) { $e(1, arguments); var e = He(r), t = e.getHours(); return t } function wB(r) { $e(1, arguments); var e = He(r), t = e.getMonth(); return e.setFullYear(e.getFullYear(), t + 1, 0), e.setHours(0, 0, 0, 0), e } function CB(r, e) { $e(2, arguments); var t = He(r), n = He(e); return t.getTime() > n.getTime() } function kS(r, e) { $e(2, arguments); var t = He(r), n = He(e); return t.getTime() < n.getTime() } function Qu(r, e) { $e(2, arguments); var t = He(r), n = He(e); return t.getTime() === n.getTime() } function dx(r, e) { (e == null || e > r.length) && (e = r.length); for (var t = 0, n = Array(e); t < e; t++)n[t] = r[t]; return n } function SB(r, e) { if (r) { if (typeof r == "string") return dx(r, e); var t = {}.toString.call(r).slice(8, -1); return t === "Object" && r.constructor && (t = r.constructor.name), t === "Map" || t === "Set" ? Array.from(r) : t === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? dx(r, e) : void 0 } } function hx(r, e) {
  var t = typeof Symbol < "u" && r[Symbol.iterator] || r["@@iterator"]; if (!t) {
    if (Array.isArray(r) || (t = SB(r)) || e) { t && (r = t); var n = 0, i = function () { }; return { s: i, n: function () { return n >= r.length ? { done: !0 } : { done: !1, value: r[n++] } }, e: function (u) { throw u }, f: i } } throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
  } var s, a = !0, o = !1; return { s: function () { t = t.call(r) }, n: function () { var u = t.next(); return a = u.done, u }, e: function (u) { o = !0, s = u }, f: function () { try { a || t.return == null || t.return() } finally { if (o) throw s } } }
} function ye(r) { if (r === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return r } function ed(r, e) { return ed = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, n) { return t.__proto__ = n, t }, ed(r, e) } function ut(r, e) { if (typeof e != "function" && e !== null) throw new TypeError("Super expression must either be null or a function"); r.prototype = Object.create(e && e.prototype, { constructor: { value: r, writable: !0, configurable: !0 } }), Object.defineProperty(r, "prototype", { writable: !1 }), e && ed(r, e) } function td(r) { return td = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (e) { return e.__proto__ || Object.getPrototypeOf(e) }, td(r) } function RS() { try { var r = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () { })) } catch { } return (RS = function () { return !!r })() } function EB(r, e) { if (e && (Ki(e) == "object" || typeof e == "function")) return e; if (e !== void 0) throw new TypeError("Derived constructors may only return object or undefined"); return ye(r) } function dt(r) { var e = RS(); return function () { var t, n = td(r); if (e) { var i = td(this).constructor; t = Reflect.construct(n, arguments, i) } else t = n.apply(this, arguments); return EB(this, t) } } function nt(r, e) { if (!(r instanceof e)) throw new TypeError("Cannot call a class as a function") } function _B(r, e) { if (Ki(r) != "object" || !r) return r; var t = r[Symbol.toPrimitive]; if (t !== void 0) { var n = t.call(r, e); if (Ki(n) != "object") return n; throw new TypeError("@@toPrimitive must return a primitive value.") } return String(r) } function DS(r) { var e = _B(r, "string"); return Ki(e) == "symbol" ? e : e + "" } function OB(r, e) { for (var t = 0; t < e.length; t++) { var n = e[t]; n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(r, DS(n.key), n) } } function rt(r, e, t) { return e && OB(r.prototype, e), Object.defineProperty(r, "prototype", { writable: !1 }), r } function ge(r, e, t) { return (e = DS(e)) in r ? Object.defineProperty(r, e, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : r[e] = t, r } var TB = 10, AS = function () { function r() { nt(this, r), ge(this, "priority", void 0), ge(this, "subPriority", 0) } return rt(r, [{ key: "validate", value: function (t, n) { return !0 } }]), r }(), IB = function (r) { ut(t, r); var e = dt(t); function t(n, i, s, a, o) { var l; return nt(this, t), l = e.call(this), l.value = n, l.validateValue = i, l.setValue = s, l.priority = a, o && (l.subPriority = o), l } return rt(t, [{ key: "validate", value: function (i, s) { return this.validateValue(i, this.value, s) } }, { key: "set", value: function (i, s, a) { return this.setValue(i, s, this.value, a) } }]), t }(AS), PB = function (r) { ut(t, r); var e = dt(t); function t() { var n; nt(this, t); for (var i = arguments.length, s = new Array(i), a = 0; a < i; a++)s[a] = arguments[a]; return n = e.call.apply(e, [this].concat(s)), ge(ye(n), "priority", TB), ge(ye(n), "subPriority", -1), n } return rt(t, [{ key: "set", value: function (i, s) { if (s.timestampIsSet) return i; var a = new Date(0); return a.setFullYear(i.getUTCFullYear(), i.getUTCMonth(), i.getUTCDate()), a.setHours(i.getUTCHours(), i.getUTCMinutes(), i.getUTCSeconds(), i.getUTCMilliseconds()), a } }]), t }(AS), xt = function () { function r() { nt(this, r), ge(this, "incompatibleTokens", void 0), ge(this, "priority", void 0), ge(this, "subPriority", void 0) } return rt(r, [{ key: "run", value: function (t, n, i, s) { var a = this.parse(t, n, i, s); return a ? { setter: new IB(a.value, this.validate, this.set, this.priority, this.subPriority), rest: a.rest } : null } }, { key: "validate", value: function (t, n, i) { return !0 } }]), r }(), kB = function (r) { ut(t, r); var e = dt(t); function t() { var n; nt(this, t); for (var i = arguments.length, s = new Array(i), a = 0; a < i; a++)s[a] = arguments[a]; return n = e.call.apply(e, [this].concat(s)), ge(ye(n), "priority", 140), ge(ye(n), "incompatibleTokens", ["R", "u", "t", "T"]), n } return rt(t, [{ key: "parse", value: function (i, s, a) { switch (s) { case "G": case "GG": case "GGG": return a.era(i, { width: "abbreviated" }) || a.era(i, { width: "narrow" }); case "GGGGG": return a.era(i, { width: "narrow" }); case "GGGG": default: return a.era(i, { width: "wide" }) || a.era(i, { width: "abbreviated" }) || a.era(i, { width: "narrow" }) } } }, { key: "set", value: function (i, s, a) { return s.era = a, i.setUTCFullYear(a, 0, 1), i.setUTCHours(0, 0, 0, 0), i } }]), t }(xt), bn = { month: /^(1[0-2]|0?\d)/, date: /^(3[0-1]|[0-2]?\d)/, dayOfYear: /^(36[0-6]|3[0-5]\d|[0-2]?\d?\d)/, week: /^(5[0-3]|[0-4]?\d)/, hour23h: /^(2[0-3]|[0-1]?\d)/, hour24h: /^(2[0-4]|[0-1]?\d)/, hour11h: /^(1[0-1]|0?\d)/, hour12h: /^(1[0-2]|0?\d)/, minute: /^[0-5]?\d/, second: /^[0-5]?\d/, singleDigit: /^\d/, twoDigits: /^\d{1,2}/, threeDigits: /^\d{1,3}/, fourDigits: /^\d{1,4}/, anyDigitsSigned: /^-?\d+/, singleDigitSigned: /^-?\d/, twoDigitsSigned: /^-?\d{1,2}/, threeDigitsSigned: /^-?\d{1,3}/, fourDigitsSigned: /^-?\d{1,4}/ }, Ni = { basicOptionalMinutes: /^([+-])(\d{2})(\d{2})?|Z/, basic: /^([+-])(\d{2})(\d{2})|Z/, basicOptionalSeconds: /^([+-])(\d{2})(\d{2})((\d{2}))?|Z/, extended: /^([+-])(\d{2}):(\d{2})|Z/, extendedOptionalSeconds: /^([+-])(\d{2}):(\d{2})(:(\d{2}))?|Z/ }; function vn(r, e) { return r && { value: e(r.value), rest: r.rest } } function on(r, e) { var t = e.match(r); return t ? { value: parseInt(t[0], 10), rest: e.slice(t[0].length) } : null } function Fi(r, e) { var t = e.match(r); if (!t) return null; if (t[0] === "Z") return { value: 0, rest: e.slice(1) }; var n = t[1] === "+" ? 1 : -1, i = t[2] ? parseInt(t[2], 10) : 0, s = t[3] ? parseInt(t[3], 10) : 0, a = t[5] ? parseInt(t[5], 10) : 0; return { value: n * (i * Lm + s * $m + a * _V), rest: e.slice(t[0].length) } } function NS(r) { return on(bn.anyDigitsSigned, r) } function pn(r, e) { switch (r) { case 1: return on(bn.singleDigit, e); case 2: return on(bn.twoDigits, e); case 3: return on(bn.threeDigits, e); case 4: return on(bn.fourDigits, e); default: return on(new RegExp("^\\d{1," + r + "}"), e) } } function nd(r, e) { switch (r) { case 1: return on(bn.singleDigitSigned, e); case 2: return on(bn.twoDigitsSigned, e); case 3: return on(bn.threeDigitsSigned, e); case 4: return on(bn.fourDigitsSigned, e); default: return on(new RegExp("^-?\\d{1," + r + "}"), e) } } function Vm(r) { switch (r) { case "morning": return 4; case "evening": return 17; case "pm": case "noon": case "afternoon": return 12; case "am": case "midnight": case "night": default: return 0 } } function FS(r, e) { var t = e > 0, n = t ? e : 1 - e, i; if (n <= 50) i = r || 100; else { var s = n + 50, a = Math.floor(s / 100) * 100, o = r >= s % 100; i = r + a - (o ? 100 : 0) } return t ? i : 1 - i } function $S(r) { return r % 400 === 0 || r % 4 === 0 && r % 100 !== 0 } var RB = function (r) { ut(t, r); var e = dt(t); function t() { var n; nt(this, t); for (var i = arguments.length, s = new Array(i), a = 0; a < i; a++)s[a] = arguments[a]; return n = e.call.apply(e, [this].concat(s)), ge(ye(n), "priority", 130), ge(ye(n), "incompatibleTokens", ["Y", "R", "u", "w", "I", "i", "e", "c", "t", "T"]), n } return rt(t, [{ key: "parse", value: function (i, s, a) { var o = function (u) { return { year: u, isTwoDigitYear: s === "yy" } }; switch (s) { case "y": return vn(pn(4, i), o); case "yo": return vn(a.ordinalNumber(i, { unit: "year" }), o); default: return vn(pn(s.length, i), o) } } }, { key: "validate", value: function (i, s) { return s.isTwoDigitYear || s.year > 0 } }, { key: "set", value: function (i, s, a) { var o = i.getUTCFullYear(); if (a.isTwoDigitYear) { var l = FS(a.year, o); return i.setUTCFullYear(l, 0, 1), i.setUTCHours(0, 0, 0, 0), i } var u = !("era" in s) || s.era === 1 ? a.year : 1 - a.year; return i.setUTCFullYear(u, 0, 1), i.setUTCHours(0, 0, 0, 0), i } }]), t }(xt), DB = function (r) { ut(t, r); var e = dt(t); function t() { var n; nt(this, t); for (var i = arguments.length, s = new Array(i), a = 0; a < i; a++)s[a] = arguments[a]; return n = e.call.apply(e, [this].concat(s)), ge(ye(n), "priority", 130), ge(ye(n), "incompatibleTokens", ["y", "R", "u", "Q", "q", "M", "L", "I", "d", "D", "i", "t", "T"]), n } return rt(t, [{ key: "parse", value: function (i, s, a) { var o = function (u) { return { year: u, isTwoDigitYear: s === "YY" } }; switch (s) { case "Y": return vn(pn(4, i), o); case "Yo": return vn(a.ordinalNumber(i, { unit: "year" }), o); default: return vn(pn(s.length, i), o) } } }, { key: "validate", value: function (i, s) { return s.isTwoDigitYear || s.year > 0 } }, { key: "set", value: function (i, s, a, o) { var l = jm(i, o); if (a.isTwoDigitYear) { var u = FS(a.year, l); return i.setUTCFullYear(u, 0, o.firstWeekContainsDate), i.setUTCHours(0, 0, 0, 0), as(i, o) } var d = !("era" in s) || s.era === 1 ? a.year : 1 - a.year; return i.setUTCFullYear(d, 0, o.firstWeekContainsDate), i.setUTCHours(0, 0, 0, 0), as(i, o) } }]), t }(xt), AB = function (r) { ut(t, r); var e = dt(t); function t() { var n; nt(this, t); for (var i = arguments.length, s = new Array(i), a = 0; a < i; a++)s[a] = arguments[a]; return n = e.call.apply(e, [this].concat(s)), ge(ye(n), "priority", 130), ge(ye(n), "incompatibleTokens", ["G", "y", "Y", "u", "Q", "q", "M", "L", "w", "d", "D", "e", "c", "t", "T"]), n } return rt(t, [{ key: "parse", value: function (i, s) { return nd(s === "R" ? 4 : s.length, i) } }, { key: "set", value: function (i, s, a) { var o = new Date(0); return o.setUTCFullYear(a, 0, 4), o.setUTCHours(0, 0, 0, 0), wo(o) } }]), t }(xt), NB = function (r) { ut(t, r); var e = dt(t); function t() { var n; nt(this, t); for (var i = arguments.length, s = new Array(i), a = 0; a < i; a++)s[a] = arguments[a]; return n = e.call.apply(e, [this].concat(s)), ge(ye(n), "priority", 130), ge(ye(n), "incompatibleTokens", ["G", "y", "Y", "R", "w", "I", "i", "e", "c", "t", "T"]), n } return rt(t, [{ key: "parse", value: function (i, s) { return nd(s === "u" ? 4 : s.length, i) } }, { key: "set", value: function (i, s, a) { return i.setUTCFullYear(a, 0, 1), i.setUTCHours(0, 0, 0, 0), i } }]), t }(xt), FB = function (r) { ut(t, r); var e = dt(t); function t() { var n; nt(this, t); for (var i = arguments.length, s = new Array(i), a = 0; a < i; a++)s[a] = arguments[a]; return n = e.call.apply(e, [this].concat(s)), ge(ye(n), "priority", 120), ge(ye(n), "incompatibleTokens", ["Y", "R", "q", "M", "L", "w", "I", "d", "D", "i", "e", "c", "t", "T"]), n } return rt(t, [{ key: "parse", value: function (i, s, a) { switch (s) { case "Q": case "QQ": return pn(s.length, i); case "Qo": return a.ordinalNumber(i, { unit: "quarter" }); case "QQQ": return a.quarter(i, { width: "abbreviated", context: "formatting" }) || a.quarter(i, { width: "narrow", context: "formatting" }); case "QQQQQ": return a.quarter(i, { width: "narrow", context: "formatting" }); case "QQQQ": default: return a.quarter(i, { width: "wide", context: "formatting" }) || a.quarter(i, { width: "abbreviated", context: "formatting" }) || a.quarter(i, { width: "narrow", context: "formatting" }) } } }, { key: "validate", value: function (i, s) { return s >= 1 && s <= 4 } }, { key: "set", value: function (i, s, a) { return i.setUTCMonth((a - 1) * 3, 1), i.setUTCHours(0, 0, 0, 0), i } }]), t }(xt), $B = function (r) { ut(t, r); var e = dt(t); function t() { var n; nt(this, t); for (var i = arguments.length, s = new Array(i), a = 0; a < i; a++)s[a] = arguments[a]; return n = e.call.apply(e, [this].concat(s)), ge(ye(n), "priority", 120), ge(ye(n), "incompatibleTokens", ["Y", "R", "Q", "M", "L", "w", "I", "d", "D", "i", "e", "c", "t", "T"]), n } return rt(t, [{ key: "parse", value: function (i, s, a) { switch (s) { case "q": case "qq": return pn(s.length, i); case "qo": return a.ordinalNumber(i, { unit: "quarter" }); case "qqq": return a.quarter(i, { width: "abbreviated", context: "standalone" }) || a.quarter(i, { width: "narrow", context: "standalone" }); case "qqqqq": return a.quarter(i, { width: "narrow", context: "standalone" }); case "qqqq": default: return a.quarter(i, { width: "wide", context: "standalone" }) || a.quarter(i, { width: "abbreviated", context: "standalone" }) || a.quarter(i, { width: "narrow", context: "standalone" }) } } }, { key: "validate", value: function (i, s) { return s >= 1 && s <= 4 } }, { key: "set", value: function (i, s, a) { return i.setUTCMonth((a - 1) * 3, 1), i.setUTCHours(0, 0, 0, 0), i } }]), t }(xt), LB = function (r) { ut(t, r); var e = dt(t); function t() { var n; nt(this, t); for (var i = arguments.length, s = new Array(i), a = 0; a < i; a++)s[a] = arguments[a]; return n = e.call.apply(e, [this].concat(s)), ge(ye(n), "incompatibleTokens", ["Y", "R", "q", "Q", "L", "w", "I", "D", "i", "e", "c", "t", "T"]), ge(ye(n), "priority", 110), n } return rt(t, [{ key: "parse", value: function (i, s, a) { var o = function (u) { return u - 1 }; switch (s) { case "M": return vn(on(bn.month, i), o); case "MM": return vn(pn(2, i), o); case "Mo": return vn(a.ordinalNumber(i, { unit: "month" }), o); case "MMM": return a.month(i, { width: "abbreviated", context: "formatting" }) || a.month(i, { width: "narrow", context: "formatting" }); case "MMMMM": return a.month(i, { width: "narrow", context: "formatting" }); case "MMMM": default: return a.month(i, { width: "wide", context: "formatting" }) || a.month(i, { width: "abbreviated", context: "formatting" }) || a.month(i, { width: "narrow", context: "formatting" }) } } }, { key: "validate", value: function (i, s) { return s >= 0 && s <= 11 } }, { key: "set", value: function (i, s, a) { return i.setUTCMonth(a, 1), i.setUTCHours(0, 0, 0, 0), i } }]), t }(xt), MB = function (r) { ut(t, r); var e = dt(t); function t() { var n; nt(this, t); for (var i = arguments.length, s = new Array(i), a = 0; a < i; a++)s[a] = arguments[a]; return n = e.call.apply(e, [this].concat(s)), ge(ye(n), "priority", 110), ge(ye(n), "incompatibleTokens", ["Y", "R", "q", "Q", "M", "w", "I", "D", "i", "e", "c", "t", "T"]), n } return rt(t, [{ key: "parse", value: function (i, s, a) { var o = function (u) { return u - 1 }; switch (s) { case "L": return vn(on(bn.month, i), o); case "LL": return vn(pn(2, i), o); case "Lo": return vn(a.ordinalNumber(i, { unit: "month" }), o); case "LLL": return a.month(i, { width: "abbreviated", context: "standalone" }) || a.month(i, { width: "narrow", context: "standalone" }); case "LLLLL": return a.month(i, { width: "narrow", context: "standalone" }); case "LLLL": default: return a.month(i, { width: "wide", context: "standalone" }) || a.month(i, { width: "abbreviated", context: "standalone" }) || a.month(i, { width: "narrow", context: "standalone" }) } } }, { key: "validate", value: function (i, s) { return s >= 0 && s <= 11 } }, { key: "set", value: function (i, s, a) { return i.setUTCMonth(a, 1), i.setUTCHours(0, 0, 0, 0), i } }]), t }(xt); function jB(r, e, t) { $e(2, arguments); var n = He(r), i = Vt(e), s = ES(n, t) - i; return n.setUTCDate(n.getUTCDate() - s * 7), n } var VB = function (r) { ut(t, r); var e = dt(t); function t() { var n; nt(this, t); for (var i = arguments.length, s = new Array(i), a = 0; a < i; a++)s[a] = arguments[a]; return n = e.call.apply(e, [this].concat(s)), ge(ye(n), "priority", 100), ge(ye(n), "incompatibleTokens", ["y", "R", "u", "q", "Q", "M", "L", "I", "d", "D", "i", "t", "T"]), n } return rt(t, [{ key: "parse", value: function (i, s, a) { switch (s) { case "w": return on(bn.week, i); case "wo": return a.ordinalNumber(i, { unit: "week" }); default: return pn(s.length, i) } } }, { key: "validate", value: function (i, s) { return s >= 1 && s <= 53 } }, { key: "set", value: function (i, s, a, o) { return as(jB(i, a, o), o) } }]), t }(xt); function BB(r, e) { $e(2, arguments); var t = He(r), n = Vt(e), i = SS(t) - n; return t.setUTCDate(t.getUTCDate() - i * 7), t } var zB = function (r) { ut(t, r); var e = dt(t); function t() { var n; nt(this, t); for (var i = arguments.length, s = new Array(i), a = 0; a < i; a++)s[a] = arguments[a]; return n = e.call.apply(e, [this].concat(s)), ge(ye(n), "priority", 100), ge(ye(n), "incompatibleTokens", ["y", "Y", "u", "q", "Q", "M", "L", "w", "d", "D", "e", "c", "t", "T"]), n } return rt(t, [{ key: "parse", value: function (i, s, a) { switch (s) { case "I": return on(bn.week, i); case "Io": return a.ordinalNumber(i, { unit: "week" }); default: return pn(s.length, i) } } }, { key: "validate", value: function (i, s) { return s >= 1 && s <= 53 } }, { key: "set", value: function (i, s, a) { return wo(BB(i, a)) } }]), t }(xt), HB = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31], KB = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31], UB = function (r) { ut(t, r); var e = dt(t); function t() { var n; nt(this, t); for (var i = arguments.length, s = new Array(i), a = 0; a < i; a++)s[a] = arguments[a]; return n = e.call.apply(e, [this].concat(s)), ge(ye(n), "priority", 90), ge(ye(n), "subPriority", 1), ge(ye(n), "incompatibleTokens", ["Y", "R", "q", "Q", "w", "I", "D", "i", "e", "c", "t", "T"]), n } return rt(t, [{ key: "parse", value: function (i, s, a) { switch (s) { case "d": return on(bn.date, i); case "do": return a.ordinalNumber(i, { unit: "date" }); default: return pn(s.length, i) } } }, { key: "validate", value: function (i, s) { var a = i.getUTCFullYear(), o = $S(a), l = i.getUTCMonth(); return o ? s >= 1 && s <= KB[l] : s >= 1 && s <= HB[l] } }, { key: "set", value: function (i, s, a) { return i.setUTCDate(a), i.setUTCHours(0, 0, 0, 0), i } }]), t }(xt), WB = function (r) { ut(t, r); var e = dt(t); function t() { var n; nt(this, t); for (var i = arguments.length, s = new Array(i), a = 0; a < i; a++)s[a] = arguments[a]; return n = e.call.apply(e, [this].concat(s)), ge(ye(n), "priority", 90), ge(ye(n), "subpriority", 1), ge(ye(n), "incompatibleTokens", ["Y", "R", "q", "Q", "M", "L", "w", "I", "d", "E", "i", "e", "c", "t", "T"]), n } return rt(t, [{ key: "parse", value: function (i, s, a) { switch (s) { case "D": case "DD": return on(bn.dayOfYear, i); case "Do": return a.ordinalNumber(i, { unit: "date" }); default: return pn(s.length, i) } } }, { key: "validate", value: function (i, s) { var a = i.getUTCFullYear(), o = $S(a); return o ? s >= 1 && s <= 366 : s >= 1 && s <= 365 } }, { key: "set", value: function (i, s, a) { return i.setUTCMonth(0, a), i.setUTCHours(0, 0, 0, 0), i } }]), t }(xt); function Bm(r, e, t) { var n, i, s, a, o, l, u, d; $e(2, arguments); var h = Ko(), g = Vt((n = (i = (s = (a = t == null ? void 0 : t.weekStartsOn) !== null && a !== void 0 ? a : t == null || (o = t.locale) === null || o === void 0 || (l = o.options) === null || l === void 0 ? void 0 : l.weekStartsOn) !== null && s !== void 0 ? s : h.weekStartsOn) !== null && i !== void 0 ? i : (u = h.locale) === null || u === void 0 || (d = u.options) === null || d === void 0 ? void 0 : d.weekStartsOn) !== null && n !== void 0 ? n : 0); if (!(g >= 0 && g <= 6)) throw new RangeError("weekStartsOn must be between 0 and 6 inclusively"); var m = He(r), b = Vt(e), y = m.getUTCDay(), w = b % 7, x = (w + 7) % 7, S = (x < g ? 7 : 0) + b - y; return m.setUTCDate(m.getUTCDate() + S), m } var GB = function (r) { ut(t, r); var e = dt(t); function t() { var n; nt(this, t); for (var i = arguments.length, s = new Array(i), a = 0; a < i; a++)s[a] = arguments[a]; return n = e.call.apply(e, [this].concat(s)), ge(ye(n), "priority", 90), ge(ye(n), "incompatibleTokens", ["D", "i", "e", "c", "t", "T"]), n } return rt(t, [{ key: "parse", value: function (i, s, a) { switch (s) { case "E": case "EE": case "EEE": return a.day(i, { width: "abbreviated", context: "formatting" }) || a.day(i, { width: "short", context: "formatting" }) || a.day(i, { width: "narrow", context: "formatting" }); case "EEEEE": return a.day(i, { width: "narrow", context: "formatting" }); case "EEEEEE": return a.day(i, { width: "short", context: "formatting" }) || a.day(i, { width: "narrow", context: "formatting" }); case "EEEE": default: return a.day(i, { width: "wide", context: "formatting" }) || a.day(i, { width: "abbreviated", context: "formatting" }) || a.day(i, { width: "short", context: "formatting" }) || a.day(i, { width: "narrow", context: "formatting" }) } } }, { key: "validate", value: function (i, s) { return s >= 0 && s <= 6 } }, { key: "set", value: function (i, s, a, o) { return i = Bm(i, a, o), i.setUTCHours(0, 0, 0, 0), i } }]), t }(xt), YB = function (r) { ut(t, r); var e = dt(t); function t() { var n; nt(this, t); for (var i = arguments.length, s = new Array(i), a = 0; a < i; a++)s[a] = arguments[a]; return n = e.call.apply(e, [this].concat(s)), ge(ye(n), "priority", 90), ge(ye(n), "incompatibleTokens", ["y", "R", "u", "q", "Q", "M", "L", "I", "d", "D", "E", "i", "c", "t", "T"]), n } return rt(t, [{ key: "parse", value: function (i, s, a, o) { var l = function (d) { var h = Math.floor((d - 1) / 7) * 7; return (d + o.weekStartsOn + 6) % 7 + h }; switch (s) { case "e": case "ee": return vn(pn(s.length, i), l); case "eo": return vn(a.ordinalNumber(i, { unit: "day" }), l); case "eee": return a.day(i, { width: "abbreviated", context: "formatting" }) || a.day(i, { width: "short", context: "formatting" }) || a.day(i, { width: "narrow", context: "formatting" }); case "eeeee": return a.day(i, { width: "narrow", context: "formatting" }); case "eeeeee": return a.day(i, { width: "short", context: "formatting" }) || a.day(i, { width: "narrow", context: "formatting" }); case "eeee": default: return a.day(i, { width: "wide", context: "formatting" }) || a.day(i, { width: "abbreviated", context: "formatting" }) || a.day(i, { width: "short", context: "formatting" }) || a.day(i, { width: "narrow", context: "formatting" }) } } }, { key: "validate", value: function (i, s) { return s >= 0 && s <= 6 } }, { key: "set", value: function (i, s, a, o) { return i = Bm(i, a, o), i.setUTCHours(0, 0, 0, 0), i } }]), t }(xt), XB = function (r) { ut(t, r); var e = dt(t); function t() { var n; nt(this, t); for (var i = arguments.length, s = new Array(i), a = 0; a < i; a++)s[a] = arguments[a]; return n = e.call.apply(e, [this].concat(s)), ge(ye(n), "priority", 90), ge(ye(n), "incompatibleTokens", ["y", "R", "u", "q", "Q", "M", "L", "I", "d", "D", "E", "i", "e", "t", "T"]), n } return rt(t, [{ key: "parse", value: function (i, s, a, o) { var l = function (d) { var h = Math.floor((d - 1) / 7) * 7; return (d + o.weekStartsOn + 6) % 7 + h }; switch (s) { case "c": case "cc": return vn(pn(s.length, i), l); case "co": return vn(a.ordinalNumber(i, { unit: "day" }), l); case "ccc": return a.day(i, { width: "abbreviated", context: "standalone" }) || a.day(i, { width: "short", context: "standalone" }) || a.day(i, { width: "narrow", context: "standalone" }); case "ccccc": return a.day(i, { width: "narrow", context: "standalone" }); case "cccccc": return a.day(i, { width: "short", context: "standalone" }) || a.day(i, { width: "narrow", context: "standalone" }); case "cccc": default: return a.day(i, { width: "wide", context: "standalone" }) || a.day(i, { width: "abbreviated", context: "standalone" }) || a.day(i, { width: "short", context: "standalone" }) || a.day(i, { width: "narrow", context: "standalone" }) } } }, { key: "validate", value: function (i, s) { return s >= 0 && s <= 6 } }, { key: "set", value: function (i, s, a, o) { return i = Bm(i, a, o), i.setUTCHours(0, 0, 0, 0), i } }]), t }(xt); function qB(r, e) { $e(2, arguments); var t = Vt(e); t % 7 === 0 && (t = t - 7); var n = 1, i = He(r), s = i.getUTCDay(), a = t % 7, o = (a + 7) % 7, l = (o < n ? 7 : 0) + t - s; return i.setUTCDate(i.getUTCDate() + l), i } var ZB = function (r) { ut(t, r); var e = dt(t); function t() { var n; nt(this, t); for (var i = arguments.length, s = new Array(i), a = 0; a < i; a++)s[a] = arguments[a]; return n = e.call.apply(e, [this].concat(s)), ge(ye(n), "priority", 90), ge(ye(n), "incompatibleTokens", ["y", "Y", "u", "q", "Q", "M", "L", "w", "d", "D", "E", "e", "c", "t", "T"]), n } return rt(t, [{ key: "parse", value: function (i, s, a) { var o = function (u) { return u === 0 ? 7 : u }; switch (s) { case "i": case "ii": return pn(s.length, i); case "io": return a.ordinalNumber(i, { unit: "day" }); case "iii": return vn(a.day(i, { width: "abbreviated", context: "formatting" }) || a.day(i, { width: "short", context: "formatting" }) || a.day(i, { width: "narrow", context: "formatting" }), o); case "iiiii": return vn(a.day(i, { width: "narrow", context: "formatting" }), o); case "iiiiii": return vn(a.day(i, { width: "short", context: "formatting" }) || a.day(i, { width: "narrow", context: "formatting" }), o); case "iiii": default: return vn(a.day(i, { width: "wide", context: "formatting" }) || a.day(i, { width: "abbreviated", context: "formatting" }) || a.day(i, { width: "short", context: "formatting" }) || a.day(i, { width: "narrow", context: "formatting" }), o) } } }, { key: "validate", value: function (i, s) { return s >= 1 && s <= 7 } }, { key: "set", value: function (i, s, a) { return i = qB(i, a), i.setUTCHours(0, 0, 0, 0), i } }]), t }(xt), JB = function (r) { ut(t, r); var e = dt(t); function t() { var n; nt(this, t); for (var i = arguments.length, s = new Array(i), a = 0; a < i; a++)s[a] = arguments[a]; return n = e.call.apply(e, [this].concat(s)), ge(ye(n), "priority", 80), ge(ye(n), "incompatibleTokens", ["b", "B", "H", "k", "t", "T"]), n } return rt(t, [{ key: "parse", value: function (i, s, a) { switch (s) { case "a": case "aa": case "aaa": return a.dayPeriod(i, { width: "abbreviated", context: "formatting" }) || a.dayPeriod(i, { width: "narrow", context: "formatting" }); case "aaaaa": return a.dayPeriod(i, { width: "narrow", context: "formatting" }); case "aaaa": default: return a.dayPeriod(i, { width: "wide", context: "formatting" }) || a.dayPeriod(i, { width: "abbreviated", context: "formatting" }) || a.dayPeriod(i, { width: "narrow", context: "formatting" }) } } }, { key: "set", value: function (i, s, a) { return i.setUTCHours(Vm(a), 0, 0, 0), i } }]), t }(xt), QB = function (r) { ut(t, r); var e = dt(t); function t() { var n; nt(this, t); for (var i = arguments.length, s = new Array(i), a = 0; a < i; a++)s[a] = arguments[a]; return n = e.call.apply(e, [this].concat(s)), ge(ye(n), "priority", 80), ge(ye(n), "incompatibleTokens", ["a", "B", "H", "k", "t", "T"]), n } return rt(t, [{ key: "parse", value: function (i, s, a) { switch (s) { case "b": case "bb": case "bbb": return a.dayPeriod(i, { width: "abbreviated", context: "formatting" }) || a.dayPeriod(i, { width: "narrow", context: "formatting" }); case "bbbbb": return a.dayPeriod(i, { width: "narrow", context: "formatting" }); case "bbbb": default: return a.dayPeriod(i, { width: "wide", context: "formatting" }) || a.dayPeriod(i, { width: "abbreviated", context: "formatting" }) || a.dayPeriod(i, { width: "narrow", context: "formatting" }) } } }, { key: "set", value: function (i, s, a) { return i.setUTCHours(Vm(a), 0, 0, 0), i } }]), t }(xt), e4 = function (r) { ut(t, r); var e = dt(t); function t() { var n; nt(this, t); for (var i = arguments.length, s = new Array(i), a = 0; a < i; a++)s[a] = arguments[a]; return n = e.call.apply(e, [this].concat(s)), ge(ye(n), "priority", 80), ge(ye(n), "incompatibleTokens", ["a", "b", "t", "T"]), n } return rt(t, [{ key: "parse", value: function (i, s, a) { switch (s) { case "B": case "BB": case "BBB": return a.dayPeriod(i, { width: "abbreviated", context: "formatting" }) || a.dayPeriod(i, { width: "narrow", context: "formatting" }); case "BBBBB": return a.dayPeriod(i, { width: "narrow", context: "formatting" }); case "BBBB": default: return a.dayPeriod(i, { width: "wide", context: "formatting" }) || a.dayPeriod(i, { width: "abbreviated", context: "formatting" }) || a.dayPeriod(i, { width: "narrow", context: "formatting" }) } } }, { key: "set", value: function (i, s, a) { return i.setUTCHours(Vm(a), 0, 0, 0), i } }]), t }(xt), t4 = function (r) { ut(t, r); var e = dt(t); function t() { var n; nt(this, t); for (var i = arguments.length, s = new Array(i), a = 0; a < i; a++)s[a] = arguments[a]; return n = e.call.apply(e, [this].concat(s)), ge(ye(n), "priority", 70), ge(ye(n), "incompatibleTokens", ["H", "K", "k", "t", "T"]), n } return rt(t, [{ key: "parse", value: function (i, s, a) { switch (s) { case "h": return on(bn.hour12h, i); case "ho": return a.ordinalNumber(i, { unit: "hour" }); default: return pn(s.length, i) } } }, { key: "validate", value: function (i, s) { return s >= 1 && s <= 12 } }, { key: "set", value: function (i, s, a) { var o = i.getUTCHours() >= 12; return o && a < 12 ? i.setUTCHours(a + 12, 0, 0, 0) : !o && a === 12 ? i.setUTCHours(0, 0, 0, 0) : i.setUTCHours(a, 0, 0, 0), i } }]), t }(xt), n4 = function (r) { ut(t, r); var e = dt(t); function t() { var n; nt(this, t); for (var i = arguments.length, s = new Array(i), a = 0; a < i; a++)s[a] = arguments[a]; return n = e.call.apply(e, [this].concat(s)), ge(ye(n), "priority", 70), ge(ye(n), "incompatibleTokens", ["a", "b", "h", "K", "k", "t", "T"]), n } return rt(t, [{ key: "parse", value: function (i, s, a) { switch (s) { case "H": return on(bn.hour23h, i); case "Ho": return a.ordinalNumber(i, { unit: "hour" }); default: return pn(s.length, i) } } }, { key: "validate", value: function (i, s) { return s >= 0 && s <= 23 } }, { key: "set", value: function (i, s, a) { return i.setUTCHours(a, 0, 0, 0), i } }]), t }(xt), r4 = function (r) { ut(t, r); var e = dt(t); function t() { var n; nt(this, t); for (var i = arguments.length, s = new Array(i), a = 0; a < i; a++)s[a] = arguments[a]; return n = e.call.apply(e, [this].concat(s)), ge(ye(n), "priority", 70), ge(ye(n), "incompatibleTokens", ["h", "H", "k", "t", "T"]), n } return rt(t, [{ key: "parse", value: function (i, s, a) { switch (s) { case "K": return on(bn.hour11h, i); case "Ko": return a.ordinalNumber(i, { unit: "hour" }); default: return pn(s.length, i) } } }, { key: "validate", value: function (i, s) { return s >= 0 && s <= 11 } }, { key: "set", value: function (i, s, a) { var o = i.getUTCHours() >= 12; return o && a < 12 ? i.setUTCHours(a + 12, 0, 0, 0) : i.setUTCHours(a, 0, 0, 0), i } }]), t }(xt), i4 = function (r) { ut(t, r); var e = dt(t); function t() { var n; nt(this, t); for (var i = arguments.length, s = new Array(i), a = 0; a < i; a++)s[a] = arguments[a]; return n = e.call.apply(e, [this].concat(s)), ge(ye(n), "priority", 70), ge(ye(n), "incompatibleTokens", ["a", "b", "h", "H", "K", "t", "T"]), n } return rt(t, [{ key: "parse", value: function (i, s, a) { switch (s) { case "k": return on(bn.hour24h, i); case "ko": return a.ordinalNumber(i, { unit: "hour" }); default: return pn(s.length, i) } } }, { key: "validate", value: function (i, s) { return s >= 1 && s <= 24 } }, { key: "set", value: function (i, s, a) { var o = a <= 24 ? a % 24 : a; return i.setUTCHours(o, 0, 0, 0), i } }]), t }(xt), s4 = function (r) { ut(t, r); var e = dt(t); function t() { var n; nt(this, t); for (var i = arguments.length, s = new Array(i), a = 0; a < i; a++)s[a] = arguments[a]; return n = e.call.apply(e, [this].concat(s)), ge(ye(n), "priority", 60), ge(ye(n), "incompatibleTokens", ["t", "T"]), n } return rt(t, [{ key: "parse", value: function (i, s, a) { switch (s) { case "m": return on(bn.minute, i); case "mo": return a.ordinalNumber(i, { unit: "minute" }); default: return pn(s.length, i) } } }, { key: "validate", value: function (i, s) { return s >= 0 && s <= 59 } }, { key: "set", value: function (i, s, a) { return i.setUTCMinutes(a, 0, 0), i } }]), t }(xt), a4 = function (r) { ut(t, r); var e = dt(t); function t() { var n; nt(this, t); for (var i = arguments.length, s = new Array(i), a = 0; a < i; a++)s[a] = arguments[a]; return n = e.call.apply(e, [this].concat(s)), ge(ye(n), "priority", 50), ge(ye(n), "incompatibleTokens", ["t", "T"]), n } return rt(t, [{ key: "parse", value: function (i, s, a) { switch (s) { case "s": return on(bn.second, i); case "so": return a.ordinalNumber(i, { unit: "second" }); default: return pn(s.length, i) } } }, { key: "validate", value: function (i, s) { return s >= 0 && s <= 59 } }, { key: "set", value: function (i, s, a) { return i.setUTCSeconds(a, 0), i } }]), t }(xt), o4 = function (r) { ut(t, r); var e = dt(t); function t() { var n; nt(this, t); for (var i = arguments.length, s = new Array(i), a = 0; a < i; a++)s[a] = arguments[a]; return n = e.call.apply(e, [this].concat(s)), ge(ye(n), "priority", 30), ge(ye(n), "incompatibleTokens", ["t", "T"]), n } return rt(t, [{ key: "parse", value: function (i, s) { var a = function (l) { return Math.floor(l * Math.pow(10, -s.length + 3)) }; return vn(pn(s.length, i), a) } }, { key: "set", value: function (i, s, a) { return i.setUTCMilliseconds(a), i } }]), t }(xt), l4 = function (r) { ut(t, r); var e = dt(t); function t() { var n; nt(this, t); for (var i = arguments.length, s = new Array(i), a = 0; a < i; a++)s[a] = arguments[a]; return n = e.call.apply(e, [this].concat(s)), ge(ye(n), "priority", 10), ge(ye(n), "incompatibleTokens", ["t", "T", "x"]), n } return rt(t, [{ key: "parse", value: function (i, s) { switch (s) { case "X": return Fi(Ni.basicOptionalMinutes, i); case "XX": return Fi(Ni.basic, i); case "XXXX": return Fi(Ni.basicOptionalSeconds, i); case "XXXXX": return Fi(Ni.extendedOptionalSeconds, i); case "XXX": default: return Fi(Ni.extended, i) } } }, { key: "set", value: function (i, s, a) { return s.timestampIsSet ? i : new Date(i.getTime() - a) } }]), t }(xt), c4 = function (r) { ut(t, r); var e = dt(t); function t() { var n; nt(this, t); for (var i = arguments.length, s = new Array(i), a = 0; a < i; a++)s[a] = arguments[a]; return n = e.call.apply(e, [this].concat(s)), ge(ye(n), "priority", 10), ge(ye(n), "incompatibleTokens", ["t", "T", "X"]), n } return rt(t, [{ key: "parse", value: function (i, s) { switch (s) { case "x": return Fi(Ni.basicOptionalMinutes, i); case "xx": return Fi(Ni.basic, i); case "xxxx": return Fi(Ni.basicOptionalSeconds, i); case "xxxxx": return Fi(Ni.extendedOptionalSeconds, i); case "xxx": default: return Fi(Ni.extended, i) } } }, { key: "set", value: function (i, s, a) { return s.timestampIsSet ? i : new Date(i.getTime() - a) } }]), t }(xt), u4 = function (r) { ut(t, r); var e = dt(t); function t() { var n; nt(this, t); for (var i = arguments.length, s = new Array(i), a = 0; a < i; a++)s[a] = arguments[a]; return n = e.call.apply(e, [this].concat(s)), ge(ye(n), "priority", 40), ge(ye(n), "incompatibleTokens", "*"), n } return rt(t, [{ key: "parse", value: function (i) { return NS(i) } }, { key: "set", value: function (i, s, a) { return [new Date(a * 1e3), { timestampIsSet: !0 }] } }]), t }(xt), d4 = function (r) { ut(t, r); var e = dt(t); function t() { var n; nt(this, t); for (var i = arguments.length, s = new Array(i), a = 0; a < i; a++)s[a] = arguments[a]; return n = e.call.apply(e, [this].concat(s)), ge(ye(n), "priority", 20), ge(ye(n), "incompatibleTokens", "*"), n } return rt(t, [{ key: "parse", value: function (i) { return NS(i) } }, { key: "set", value: function (i, s, a) { return [new Date(a), { timestampIsSet: !0 }] } }]), t }(xt), h4 = { G: new kB, y: new RB, Y: new DB, R: new AB, u: new NB, Q: new FB, q: new $B, M: new LB, L: new MB, w: new VB, I: new zB, d: new UB, D: new WB, E: new GB, e: new YB, c: new XB, i: new ZB, a: new JB, b: new QB, B: new e4, h: new t4, H: new n4, K: new r4, k: new i4, m: new s4, s: new a4, S: new o4, X: new l4, x: new c4, t: new u4, T: new d4 }, p4 = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g, f4 = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g, g4 = /^'([^]*?)'?$/, m4 = /''/g, y4 = /\S/, b4 = /[a-zA-Z]/; function LS(r, e, t, n) { var i, s, a, o, l, u, d, h, g, m, b, y, w, x, S, C, O, E; $e(3, arguments); var v = String(r), T = String(e), I = Ko(), k = (i = (s = n == null ? void 0 : n.locale) !== null && s !== void 0 ? s : I.locale) !== null && i !== void 0 ? i : IS; if (!k.match) throw new RangeError("locale must contain match property"); var P = Vt((a = (o = (l = (u = n == null ? void 0 : n.firstWeekContainsDate) !== null && u !== void 0 ? u : n == null || (d = n.locale) === null || d === void 0 || (h = d.options) === null || h === void 0 ? void 0 : h.firstWeekContainsDate) !== null && l !== void 0 ? l : I.firstWeekContainsDate) !== null && o !== void 0 ? o : (g = I.locale) === null || g === void 0 || (m = g.options) === null || m === void 0 ? void 0 : m.firstWeekContainsDate) !== null && a !== void 0 ? a : 1); if (!(P >= 1 && P <= 7)) throw new RangeError("firstWeekContainsDate must be between 1 and 7 inclusively"); var N = Vt((b = (y = (w = (x = n == null ? void 0 : n.weekStartsOn) !== null && x !== void 0 ? x : n == null || (S = n.locale) === null || S === void 0 || (C = S.options) === null || C === void 0 ? void 0 : C.weekStartsOn) !== null && w !== void 0 ? w : I.weekStartsOn) !== null && y !== void 0 ? y : (O = I.locale) === null || O === void 0 || (E = O.options) === null || E === void 0 ? void 0 : E.weekStartsOn) !== null && b !== void 0 ? b : 0); if (!(N >= 0 && N <= 6)) throw new RangeError("weekStartsOn must be between 0 and 6 inclusively"); if (T === "") return v === "" ? He(t) : new Date(NaN); var M = { firstWeekContainsDate: P, weekStartsOn: N, locale: k }, B = [new PB], K = T.match(f4).map(function (ue) { var te = ue[0]; if (te in wf) { var le = wf[te]; return le(ue, k.formatLong) } return ue }).join("").match(p4), U = [], W = hx(K), Z; try { var J = function () { var te = Z.value; !(n != null && n.useAdditionalWeekYearTokens) && TS(te) && Ju(te, T, r), !(n != null && n.useAdditionalDayOfYearTokens) && OS(te) && Ju(te, T, r); var le = te[0], Re = h4[le]; if (Re) { var at = Re.incompatibleTokens; if (Array.isArray(at)) { var yt = U.find(function (Ft) { return at.includes(Ft.token) || Ft.token === le }); if (yt) throw new RangeError("The format string mustn't contain `".concat(yt.fullToken, "` and `").concat(te, "` at the same time")) } else if (Re.incompatibleTokens === "*" && U.length > 0) throw new RangeError("The format string mustn't contain `".concat(te, "` and any other token at the same time")); U.push({ token: le, fullToken: te }); var ht = Re.run(v, te, k.match, M); if (!ht) return { v: new Date(NaN) }; B.push(ht.setter), v = ht.rest } else { if (le.match(b4)) throw new RangeError("Format string contains an unescaped latin alphabet character `" + le + "`"); if (te === "''" ? te = "'" : le === "'" && (te = v4(te)), v.indexOf(te) === 0) v = v.slice(te.length); else return { v: new Date(NaN) } } }; for (W.s(); !(Z = W.n()).done;) { var ee = J(); if (Ki(ee) === "object") return ee.v } } catch (ue) { W.e(ue) } finally { W.f() } if (v.length > 0 && y4.test(v)) return new Date(NaN); var $ = B.map(function (ue) { return ue.priority }).sort(function (ue, te) { return te - ue }).filter(function (ue, te, le) { return le.indexOf(ue) === te }).map(function (ue) { return B.filter(function (te) { return te.priority === ue }).sort(function (te, le) { return le.subPriority - te.subPriority }) }).map(function (ue) { return ue[0] }), pe = He(t); if (isNaN(pe.getTime())) return new Date(NaN); var re = wS(pe, xS(pe)), j = {}, ae = hx($), be; try { for (ae.s(); !(be = ae.n()).done;) { var fe = be.value; if (!fe.validate(re, M)) return new Date(NaN); var Ce = fe.set(re, j, M); Array.isArray(Ce) ? (re = Ce[0], vB(j, Ce[1])) : re = Ce } } catch (ue) { ae.e(ue) } finally { ae.f() } return re } function v4(r) { return r.match(g4)[1].replace(m4, "'") } function px(r) { $e(1, arguments); var e = He(r); return e.setMilliseconds(0), e } function fx(r, e) { $e(2, arguments); var t = px(r), n = px(e); return t.getTime() === n.getTime() } function x4(r, e) { $e(2, arguments); var t = He(r).getTime(), n = He(e.start).getTime(), i = He(e.end).getTime(); if (!(n <= i)) throw new RangeError("Invalid interval"); return t >= n && t <= i } function Gr(r, e) { var t; $e(1, arguments); var n = Vt((t = void 0) !== null && t !== void 0 ? t : 2); if (n !== 2 && n !== 1 && n !== 0) throw new RangeError("additionalDigits must be 0, 1 or 2"); if (!(typeof r == "string" || Object.prototype.toString.call(r) === "[object String]")) return new Date(NaN); var i = E4(r), s; if (i.date) { var a = _4(i.date, n); s = O4(a.restDateString, a.year) } if (!s || isNaN(s.getTime())) return new Date(NaN); var o = s.getTime(), l = 0, u; if (i.time && (l = T4(i.time), isNaN(l))) return new Date(NaN); if (i.timezone) { if (u = I4(i.timezone), isNaN(u)) return new Date(NaN) } else { var d = new Date(o + l), h = new Date(0); return h.setFullYear(d.getUTCFullYear(), d.getUTCMonth(), d.getUTCDate()), h.setHours(d.getUTCHours(), d.getUTCMinutes(), d.getUTCSeconds(), d.getUTCMilliseconds()), h } return new Date(o + l + u) } var tu = { dateTimeDelimiter: /[T ]/, timeZoneDelimiter: /[Z ]/i, timezone: /([Z+-].*)$/ }, w4 = /^-?(?:(\d{3})|(\d{2})(?:-?(\d{2}))?|W(\d{2})(?:-?(\d{1}))?|)$/, C4 = /^(\d{2}(?:[.,]\d*)?)(?::?(\d{2}(?:[.,]\d*)?))?(?::?(\d{2}(?:[.,]\d*)?))?$/, S4 = /^([+-])(\d{2})(?::?(\d{2}))?$/; function E4(r) { var e = {}, t = r.split(tu.dateTimeDelimiter), n; if (t.length > 2) return e; if (/:/.test(t[0]) ? n = t[0] : (e.date = t[0], n = t[1], tu.timeZoneDelimiter.test(e.date) && (e.date = r.split(tu.timeZoneDelimiter)[0], n = r.substr(e.date.length, r.length))), n) { var i = tu.timezone.exec(n); i ? (e.time = n.replace(i[1], ""), e.timezone = i[1]) : e.time = n } return e } function _4(r, e) { var t = new RegExp("^(?:(\\d{4}|[+-]\\d{" + (4 + e) + "})|(\\d{2}|[+-]\\d{" + (2 + e) + "})$)"), n = r.match(t); if (!n) return { year: NaN, restDateString: "" }; var i = n[1] ? parseInt(n[1]) : null, s = n[2] ? parseInt(n[2]) : null; return { year: s === null ? i : s * 100, restDateString: r.slice((n[1] || n[2]).length) } } function O4(r, e) { if (e === null) return new Date(NaN); var t = r.match(w4); if (!t) return new Date(NaN); var n = !!t[4], i = dl(t[1]), s = dl(t[2]) - 1, a = dl(t[3]), o = dl(t[4]), l = dl(t[5]) - 1; if (n) return A4(e, o, l) ? P4(e, o, l) : new Date(NaN); var u = new Date(0); return !R4(e, s, a) || !D4(e, i) ? new Date(NaN) : (u.setUTCFullYear(e, s, Math.max(i, a)), u) } function dl(r) { return r ? parseInt(r) : 1 } function T4(r) { var e = r.match(C4); if (!e) return NaN; var t = Zh(e[1]), n = Zh(e[2]), i = Zh(e[3]); return N4(t, n, i) ? t * Lm + n * $m + i * 1e3 : NaN } function Zh(r) { return r && parseFloat(r.replace(",", ".")) || 0 } function I4(r) { if (r === "Z") return 0; var e = r.match(S4); if (!e) return 0; var t = e[1] === "+" ? -1 : 1, n = parseInt(e[2]), i = e[3] && parseInt(e[3]) || 0; return F4(n, i) ? t * (n * Lm + i * $m) : NaN } function P4(r, e, t) { var n = new Date(0); n.setUTCFullYear(r, 0, 4); var i = n.getUTCDay() || 7, s = (e - 1) * 7 + t + 1 - i; return n.setUTCDate(n.getUTCDate() + s), n } var k4 = [31, null, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]; function MS(r) { return r % 400 === 0 || r % 4 === 0 && r % 100 !== 0 } function R4(r, e, t) { return e >= 0 && e <= 11 && t >= 1 && t <= (k4[e] || (MS(r) ? 29 : 28)) } function D4(r, e) { return e >= 1 && e <= (MS(r) ? 366 : 365) } function A4(r, e, t) { return e >= 1 && e <= 53 && t >= 0 && t <= 6 } function N4(r, e, t) { return r === 24 ? e === 0 && t === 0 : t >= 0 && t < 60 && e >= 0 && e < 60 && r >= 0 && r < 25 } function F4(r, e) { return e >= 0 && e <= 59 } function aa(r, e) { $e(2, arguments); var t = He(r), n = Vt(e), i = t.getFullYear(), s = t.getDate(), a = new Date(0); a.setFullYear(i, n, 15), a.setHours(0, 0, 0, 0); var o = PS(a); return t.setMonth(n, Math.min(s, o)), t } function jS(r, e) { if ($e(2, arguments), Ki(e) !== "object" || e === null) throw new RangeError("values parameter must be an object"); var t = He(r); return isNaN(t.getTime()) ? new Date(NaN) : (e.year != null && t.setFullYear(e.year), e.month != null && (t = aa(t, e.month)), e.date != null && t.setDate(Vt(e.date)), e.hours != null && t.setHours(Vt(e.hours)), e.minutes != null && t.setMinutes(Vt(e.minutes)), e.seconds != null && t.setSeconds(Vt(e.seconds)), e.milliseconds != null && t.setMilliseconds(Vt(e.milliseconds)), t) } function Cf(r, e) { $e(2, arguments); var t = He(r), n = Vt(e); return isNaN(t.getTime()) ? new Date(NaN) : (t.setFullYear(n), t) } function $4(r, e) { $e(2, arguments); var t = Vt(e); return Is(r, -t) } function L4(r, e) { $e(2, arguments); var t = Vt(e); return Zu(r, -t) } function M4(r, e, t) { $e(2, arguments); var n = as(r, t), i = as(e, t); return n.getTime() === i.getTime() } var j4 = { lessThanXSeconds: { one: "不到 1 秒", other: "不到 {{count}} 秒" }, xSeconds: { one: "1 秒", other: "{{count}} 秒" }, halfAMinute: "半分钟", lessThanXMinutes: { one: "不到 1 分钟", other: "不到 {{count}} 分钟" }, xMinutes: { one: "1 分钟", other: "{{count}} 分钟" }, xHours: { one: "1 小时", other: "{{count}} 小时" }, aboutXHours: { one: "大约 1 小时", other: "大约 {{count}} 小时" }, xDays: { one: "1 天", other: "{{count}} 天" }, aboutXWeeks: { one: "大约 1 个星期", other: "大约 {{count}} 个星期" }, xWeeks: { one: "1 个星期", other: "{{count}} 个星期" }, aboutXMonths: { one: "大约 1 个月", other: "大约 {{count}} 个月" }, xMonths: { one: "1 个月", other: "{{count}} 个月" }, aboutXYears: { one: "大约 1 年", other: "大约 {{count}} 年" }, xYears: { one: "1 年", other: "{{count}} 年" }, overXYears: { one: "超过 1 年", other: "超过 {{count}} 年" }, almostXYears: { one: "将近 1 年", other: "将近 {{count}} 年" } }, V4 = function (e, t, n) { var i, s = j4[e]; return typeof s == "string" ? i = s : t === 1 ? i = s.one : i = s.other.replace("{{count}}", String(t)), n != null && n.addSuffix ? n.comparison && n.comparison > 0 ? i + "内" : i + "前" : i }, B4 = { full: "y'年'M'月'd'日' EEEE", long: "y'年'M'月'd'日'", medium: "yyyy-MM-dd", short: "yy-MM-dd" }, z4 = { full: "zzzz a h:mm:ss", long: "z a h:mm:ss", medium: "a h:mm:ss", short: "a h:mm" }, H4 = { full: "{{date}} {{time}}", long: "{{date}} {{time}}", medium: "{{date}} {{time}}", short: "{{date}} {{time}}" }, K4 = { date: ho({ formats: B4, defaultWidth: "full" }), time: ho({ formats: z4, defaultWidth: "full" }), dateTime: ho({ formats: H4, defaultWidth: "full" }) }; function gx(r, e, t) { var n = "eeee p"; return M4(r, e, t) ? n : r.getTime() > e.getTime() ? "'下个'" + n : "'上个'" + n } var U4 = { lastWeek: gx, yesterday: "'昨天' p", today: "'今天' p", tomorrow: "'明天' p", nextWeek: gx, other: "PP p" }, W4 = function (e, t, n, i) { var s = U4[e]; return typeof s == "function" ? s(t, n, i) : s }, G4 = { narrow: ["前", "公元"], abbreviated: ["前", "公元"], wide: ["公元前", "公元"] }, Y4 = { narrow: ["1", "2", "3", "4"], abbreviated: ["第一季", "第二季", "第三季", "第四季"], wide: ["第一季度", "第二季度", "第三季度", "第四季度"] }, X4 = { narrow: ["一", "二", "三", "四", "五", "六", "七", "八", "九", "十", "十一", "十二"], abbreviated: ["1月", "2月", "3月", "4月", "5月", "6月", "7月", "8月", "9月", "10月", "11月", "12月"], wide: ["一月", "二月", "三月", "四月", "五月", "六月", "七月", "八月", "九月", "十月", "十一月", "十二月"] }, q4 = { narrow: ["日", "一", "二", "三", "四", "五", "六"], short: ["日", "一", "二", "三", "四", "五", "六"], abbreviated: ["周日", "周一", "周二", "周三", "周四", "周五", "周六"], wide: ["星期日", "星期一", "星期二", "星期三", "星期四", "星期五", "星期六"] }, Z4 = { narrow: { am: "上", pm: "下", midnight: "凌晨", noon: "午", morning: "早", afternoon: "下午", evening: "晚", night: "夜" }, abbreviated: { am: "上午", pm: "下午", midnight: "凌晨", noon: "中午", morning: "早晨", afternoon: "中午", evening: "晚上", night: "夜间" }, wide: { am: "上午", pm: "下午", midnight: "凌晨", noon: "中午", morning: "早晨", afternoon: "中午", evening: "晚上", night: "夜间" } }, J4 = { narrow: { am: "上", pm: "下", midnight: "凌晨", noon: "午", morning: "早", afternoon: "下午", evening: "晚", night: "夜" }, abbreviated: { am: "上午", pm: "下午", midnight: "凌晨", noon: "中午", morning: "早晨", afternoon: "中午", evening: "晚上", night: "夜间" }, wide: { am: "上午", pm: "下午", midnight: "凌晨", noon: "中午", morning: "早晨", afternoon: "中午", evening: "晚上", night: "夜间" } }, Q4 = function (e, t) { var n = Number(e); switch (t == null ? void 0 : t.unit) { case "date": return n.toString() + "日"; case "hour": return n.toString() + "时"; case "minute": return n.toString() + "分"; case "second": return n.toString() + "秒"; default: return "第 " + n.toString() } }, ez = { ordinalNumber: Q4, era: Di({ values: G4, defaultWidth: "wide" }), quarter: Di({ values: Y4, defaultWidth: "wide", argumentCallback: function (e) { return e - 1 } }), month: Di({ values: X4, defaultWidth: "wide" }), day: Di({ values: q4, defaultWidth: "wide" }), dayPeriod: Di({ values: Z4, defaultWidth: "wide", formattingValues: J4, defaultFormattingWidth: "wide" }) }, tz = /^(第\s*)?\d+(日|时|分|秒)?/i, nz = /\d+/i, rz = { narrow: /^(前)/i, abbreviated: /^(前)/i, wide: /^(公元前|公元)/i }, iz = { any: [/^(前)/i, /^(公元)/i] }, sz = { narrow: /^[1234]/i, abbreviated: /^第[一二三四]刻/i, wide: /^第[一二三四]刻钟/i }, az = { any: [/(1|一)/i, /(2|二)/i, /(3|三)/i, /(4|四)/i] }, oz = { narrow: /^(一|二|三|四|五|六|七|八|九|十[二一])/i, abbreviated: /^(一|二|三|四|五|六|七|八|九|十[二一]|\d|1[12])月/i, wide: /^(一|二|三|四|五|六|七|八|九|十[二一])月/i }, lz = { narrow: [/^一/i, /^二/i, /^三/i, /^四/i, /^五/i, /^六/i, /^七/i, /^八/i, /^九/i, /^十(?!(一|二))/i, /^十一/i, /^十二/i], any: [/^一|1/i, /^二|2/i, /^三|3/i, /^四|4/i, /^五|5/i, /^六|6/i, /^七|7/i, /^八|8/i, /^九|9/i, /^十(?!(一|二))|10/i, /^十一|11/i, /^十二|12/i] }, cz = { narrow: /^[一二三四五六日]/i, short: /^[一二三四五六日]/i, abbreviated: /^周[一二三四五六日]/i, wide: /^星期[一二三四五六日]/i }, uz = { any: [/日/i, /一/i, /二/i, /三/i, /四/i, /五/i, /六/i] }, dz = { any: /^(上午?|下午?|午夜|[中正]午|早上?|下午|晚上?|凌晨|)/i }, hz = { any: { am: /^上午?/i, pm: /^下午?/i, midnight: /^午夜/i, noon: /^[中正]午/i, morning: /^早上/i, afternoon: /^下午/i, evening: /^晚上?/i, night: /^凌晨/i } }, pz = { ordinalNumber: vS({ matchPattern: tz, parsePattern: nz, valueCallback: function (e) { return parseInt(e, 10) } }), era: Ai({ matchPatterns: rz, defaultMatchWidth: "wide", parsePatterns: iz, defaultParseWidth: "any" }), quarter: Ai({ matchPatterns: sz, defaultMatchWidth: "wide", parsePatterns: az, defaultParseWidth: "any", valueCallback: function (e) { return e + 1 } }), month: Ai({ matchPatterns: oz, defaultMatchWidth: "wide", parsePatterns: lz, defaultParseWidth: "any" }), day: Ai({ matchPatterns: cz, defaultMatchWidth: "wide", parsePatterns: uz, defaultParseWidth: "any" }), dayPeriod: Ai({ matchPatterns: dz, defaultMatchWidth: "any", parsePatterns: hz, defaultParseWidth: "any" }) }, zm = { code: "zh-CN", formatDistance: V4, formatLong: K4, formatRelative: W4, localize: ez, match: pz, options: { weekStartsOn: 1, firstWeekContainsDate: 4 } }; const mx = { code: "zh-CN", dateFnsLocale: zm, Pagination: { pageSize: "每页条数：${pageSize}", total: "总页数：${total}", jumpTo: "跳至", page: "页" }, Modal: { confirm: "确定", cancel: "取消" }, Tabs: { more: "更多" }, TimePicker: { placeholder: { time: "请选择时间", timeRange: "请选择时间范围" }, begin: "开始时间", end: "结束时间", hour: "时", minute: "分", second: "秒", AM: "上午", PM: "下午" }, DatePicker: { placeholder: { date: "请选择日期", dateTime: "请选择日期及时间", dateRange: ["开始日期", "结束日期"], dateTimeRange: ["开始日期", "结束日期"], monthRange: ["开始月份", "结束月份"] }, presets: "快捷选择", footer: { confirm: "确定", cancel: "取消" }, selectDate: "返回选择日期", selectTime: "选择时间", year: "年", month: "月", day: "日", monthText: "${year}年 ${month}", months: { 1: "1月", 2: "2月", 3: "3月", 4: "4月", 5: "5月", 6: "6月", 7: "7月", 8: "8月", 9: "9月", 10: "10月", 11: "11月", 12: "12月" }, fullMonths: { 1: "1", 2: "2", 3: "3", 4: "4", 5: "5", 6: "6", 7: "7", 8: "8", 9: "9", 10: "10", 11: "11", 12: "12" }, weeks: { Mon: "一", Tue: "二", Wed: "三", Thu: "四", Fri: "五", Sat: "六", Sun: "日" }, localeFormatToken: { FORMAT_SWITCH_DATE: "yyyy-MM-dd" } }, Navigation: { collapseText: "收起侧边栏", expandText: "展开侧边栏" }, Popconfirm: { confirm: "确定", cancel: "取消" }, Table: { emptyText: "暂无数据", pageText: "显示第 ${currentStart} 条-第 ${currentEnd} 条，共 ${total} 条", descend: "点击降序", ascend: "点击升序", cancelSort: "取消排序" }, Select: { emptyText: "暂无数据", createText: "创建" }, Cascader: { emptyText: "暂无数据" }, Tree: { emptyText: "暂无数据", searchPlaceholder: "搜索" }, List: { emptyText: "暂无数据" }, Calendar: { allDay: "全天", AM: "上午${time}时", PM: "下午${time}时", datestring: "日", remaining: "还有${remained}项" }, Upload: { mainText: "点击上传文件或拖拽文件到这里", illegalTips: "不支持此类型文件", legalTips: "松手开始上传", retry: "重试", replace: "替换文件", clear: "清空", selectedFiles: "已选择文件", illegalSize: "文件尺寸不合法", fail: "上传失败" }, TreeSelect: { searchPlaceholder: "搜索" }, Typography: { copy: "复制", copied: "复制成功", expand: "展开", collapse: "收起" }, Transfer: { emptyLeft: "暂无数据", emptySearch: "无搜索结果", emptyRight: "暂无内容，可从左侧勾选", placeholder: "搜索", clear: "清空", selectAll: "全选", clearSelectAll: "取消全选", total: "总个数：${total}", selected: "已选个数：${total}" }, Form: { optional: "（可选）" }, Image: { preview: "预览", loading: "加载中", loadError: "加载失败", prevTip: "上一张", nextTip: "下一张", zoomInTip: "放大", zoomOutTip: "缩小", rotateTip: "旋转", downloadTip: "下载", adaptiveTip: "适应页面", originTip: "原始尺寸" }, Chat: { deleteConfirm: "确认删除该会话吗？", clearContext: "上下文已清除", copySuccess: "复制成功", stop: "停止", copy: "复制", copied: "复制成功", dropAreaText: "将文件放到这里" } }; class Ke extends R.Component { renderChildren(e, t) { const { componentName: n } = this.props; let i = e; e != null && e.code || (i = mx); const s = H(mx, "dateFnsLocale"), a = H(i, "dateFnsLocale", s); return t(i[n], i.code, a) } render() { const { children: e } = this.props; return f.createElement(An.Consumer, null, t => { let { locale: n } = t; return f.createElement(xV.Consumer, null, i => this.renderChildren(n || i, e)) }) } } Ke.propTypes = { componentName: c.string.isRequired, children: c.any }; Ke.defaultProps = { componentName: "" }; const fz = "semi"; var gz = function (r, e) { var t = {}; for (var n in r) Object.prototype.hasOwnProperty.call(r, n) && e.indexOf(n) < 0 && (t[n] = r[n]); if (r != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, n = Object.getOwnPropertySymbols(r); i < n.length; i++)e.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(r, n[i]) && (t[n[i]] = r[n[i]]); return t }; const VS = f.forwardRef((r, e) => { const { svg: t, spin: n = !1, rotate: i, style: s, className: a, prefixCls: o = fz, type: l, size: u = "default" } = r, d = gz(r, ["svg", "spin", "rotate", "style", "className", "prefixCls", "type", "size"]), h = F(`${o}-icon`, { [`${o}-icon-extra-small`]: u === "extra-small", [`${o}-icon-small`]: u === "small", [`${o}-icon-default`]: u === "default", [`${o}-icon-large`]: u === "large", [`${o}-icon-extra-large`]: u === "extra-large", [`${o}-icon-spinning`]: n === !0, [`${o}-icon-${l}`]: !!l }, a), g = {}; return Number.isSafeInteger(i) && (g.transform = `rotate(${i}deg)`), Object.assign(g, s), f.createElement("span", Object.assign({ role: "img", ref: e, "aria-label": l, className: h, style: g }, d), t) }); VS.elementType = "Icon"; const he = (r, e) => { const t = f.forwardRef((n, i) => f.createElement(VS, Object.assign({ svg: f.createElement(r), type: e, ref: i }, n))); return t.elementType = "Icon", t }; function mz(r) { return R.createElement("svg", Object.assign({ viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", focusable: !1, "aria-hidden": !0 }, r), R.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M23 12a11 11 0 1 1-22 0 11 11 0 0 1 22 0Zm-9.5 5.5a1.5 1.5 0 1 0-3 0 1.5 1.5 0 0 0 3 0ZM12 5a1.9 1.9 0 0 0-1.89 2l.3 5.5a1.59 1.59 0 0 0 3.17 0l.3-5.5c.07-1.09-.8-2-1.88-2Z", fill: "currentColor" })) } const Co = he(mz, "alert_circle"); function yz(r) { return R.createElement("svg", Object.assign({ viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", focusable: !1, "aria-hidden": !0 }, r), R.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "m10.23 2.4-8.7 16.67A2 2 0 0 0 3.3 22h17.4a2 2 0 0 0 1.77-2.93L13.77 2.4a2 2 0 0 0-3.54 0ZM13.14 14a1.15 1.15 0 0 1-2.28 0l-.58-4.03a1.73 1.73 0 1 1 3.44 0l-.58 4.03Zm.36 4.49a1.5 1.5 0 1 1-3 0 1.5 1.5 0 0 1 3 0Z", fill: "currentColor" })) } const yc = he(yz, "alert_triangle"); function bz(r) { return R.createElement("svg", Object.assign({ viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", focusable: !1, "aria-hidden": !0 }, r), R.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M23 12c0 .83-.67 1.5-1.5 1.5H6.12l6.44 6.44a1.5 1.5 0 0 1-2.12 2.12l-9-9a1.5 1.5 0 0 1 0-2.12l9-9a1.5 1.5 0 0 1 2.12 2.12L6.12 10.5H21.5c.83 0 1.5.67 1.5 1.5Z", fill: "currentColor" })) } const vz = he(bz, "arrow_left"); function xz(r) { return R.createElement("svg", Object.assign({ viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", focusable: !1, "aria-hidden": !0 }, r), R.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M1 12c0-.83.67-1.5 1.5-1.5h15.38l-6.44-6.44a1.5 1.5 0 0 1 2.12-2.12l9 9a1.5 1.5 0 0 1 0 2.12l-9 9a1.5 1.5 0 0 1-2.12-2.12l6.44-6.44H2.5A1.5 1.5 0 0 1 1 12Z", fill: "currentColor" })) } const BS = he(xz, "arrow_right"); function wz(r) { return R.createElement("svg", Object.assign({ viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", focusable: !1, "aria-hidden": !0 }, r), R.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M12 23a1.5 1.5 0 0 1-1.5-1.5V6.12l-6.44 6.44a1.5 1.5 0 0 1-2.12-2.12l9-9a1.5 1.5 0 0 1 2.12 0l9 9a1.5 1.5 0 0 1-2.12 2.12L13.5 6.12V21.5c0 .83-.67 1.5-1.5 1.5Z", fill: "currentColor" })) } const Cz = he(wz, "arrow_up"); function Sz(r) { return R.createElement("svg", Object.assign({ viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", focusable: !1, "aria-hidden": !0 }, r), R.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M5 1a2 2 0 0 0-2 2v18c0 1.1.9 2 2 2h14a2 2 0 0 0 2-2V8.41A2 2 0 0 0 20.41 7L15 1.59A2 2 0 0 0 13.59 1H5Zm8 2H5v18h14V9h-5a1 1 0 0 1-1-1V3Zm4.59 4L15 4.41V7h2.59Zm-6.09 5a.5.5 0 0 0-.5.5v1c0 .28.22.5.5.5h5a.5.5 0 0 0 .5-.5v-1a.5.5 0 0 0-.5-.5h-5Zm-4.5.5c0-.28.22-.5.5-.5h1c.28 0 .5.22.5.5v1a.5.5 0 0 1-.5.5h-1a.5.5 0 0 1-.5-.5v-1Zm4.5 3.5a.5.5 0 0 0-.5.5v1c0 .28.22.5.5.5h5a.5.5 0 0 0 .5-.5v-1a.5.5 0 0 0-.5-.5h-5Zm-4.5.5c0-.28.22-.5.5-.5h1c.28 0 .5.22.5.5v1a.5.5 0 0 1-.5.5h-1a.5.5 0 0 1-.5-.5v-1Z", fill: "currentColor" })) } const Ez = he(Sz, "brief_stroked"); function _z(r) { return R.createElement("svg", Object.assign({ viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", focusable: !1, "aria-hidden": !0 }, r), R.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M4 20V8h16v12H4ZM2 4c0-1.1.9-2 2-2h16a2 2 0 0 1 2 2v16a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V4Zm4 6.5c0-.28.22-.5.5-.5h2c.28 0 .5.22.5.5v2a.5.5 0 0 1-.5.5h-2a.5.5 0 0 1-.5-.5v-2Zm.5 4.5a.5.5 0 0 0-.5.5v2c0 .28.22.5.5.5h2a.5.5 0 0 0 .5-.5v-2a.5.5 0 0 0-.5-.5h-2Zm4-4.5c0-.28.22-.5.5-.5h2c.28 0 .5.22.5.5v2a.5.5 0 0 1-.5.5h-2a.5.5 0 0 1-.5-.5v-2ZM11 15a.5.5 0 0 0-.5.5v2c0 .28.22.5.5.5h2a.5.5 0 0 0 .5-.5v-2a.5.5 0 0 0-.5-.5h-2Zm4-4.5c0-.28.22-.5.5-.5h2c.28 0 .5.22.5.5v2a.5.5 0 0 1-.5.5h-2a.5.5 0 0 1-.5-.5v-2Zm.5 4.5a.5.5 0 0 0-.5.5v2c0 .28.22.5.5.5h2a.5.5 0 0 0 .5-.5v-2a.5.5 0 0 0-.5-.5h-2Z", fill: "currentColor" })) } const zS = he(_z, "calendar"); function Oz(r) { return R.createElement("svg", Object.assign({ viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", focusable: !1, "aria-hidden": !0 }, r), R.createElement("path", { d: "M2 5v14a3 3 0 0 0 3 3h7.1a7.02 7.02 0 0 1-1.43-2H6a2 2 0 0 1-2-2V8a1 1 0 0 1 1-1h14a1 1 0 0 1 1 1v2.67c.75.36 1.43.85 2 1.43V5a3 3 0 0 0-3-3H5a3 3 0 0 0-3 3Z", fill: "currentColor" }), R.createElement("path", { d: "M16 10h1c-.54 0-1.06.06-1.57.18A1 1 0 0 1 16 10Z", fill: "currentColor" }), R.createElement("path", { d: "M13.5 10.94a1 1 0 0 0-1-.94h-1a1 1 0 0 0-1 1v1a1 1 0 0 0 .77.97 7.03 7.03 0 0 1 2.23-2.03Z", fill: "currentColor" }), R.createElement("path", { d: "M7 10a1 1 0 0 0-1 1v1a1 1 0 0 0 1 1h1a1 1 0 0 0 1-1v-1a1 1 0 0 0-1-1H7Z", fill: "currentColor" }), R.createElement("path", { d: "M6 16a1 1 0 0 1 1-1h1a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H7a1 1 0 0 1-1-1v-1Z", fill: "currentColor" }), R.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M22 17a5 5 0 1 1-10 0 5 5 0 0 1 10 0Zm-4-2a1 1 0 1 0-2 0v2c0 .27.1.52.3.7l1.5 1.5a1 1 0 0 0 1.4-1.4L18 16.58V15Z", fill: "currentColor" })) } const Tz = he(Oz, "calendar_clock"); function Iz(r) { return R.createElement("svg", Object.assign({ viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", focusable: !1, "aria-hidden": !0 }, r), R.createElement("path", { d: "m17.55 15.66-4.8 5.48a1 1 0 0 1-1.5 0l-4.8-5.48A1 1 0 0 1 7.2 14h9.6a1 1 0 0 1 .75 1.66Z", fill: "currentColor" })) } const Pz = he(Iz, "caretdown"); function kz(r) { return R.createElement("svg", Object.assign({ viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", focusable: !1, "aria-hidden": !0 }, r), R.createElement("path", { d: "m6.45 8.34 4.8-5.48a1 1 0 0 1 1.5 0l4.8 5.48A1 1 0 0 1 16.8 10H7.2a1 1 0 0 1-.75-1.66Z", fill: "currentColor" })) } const Rz = he(kz, "caretup"); function Dz(r) { return R.createElement("svg", Object.assign({ viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", focusable: !1, "aria-hidden": !0 }, r), R.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M18.36 5.64a3 3 0 0 0-4.24 0L12 7.76a1 1 0 1 1-1.41-1.42l2.12-2.12a5 5 0 0 1 7.07 7.07l-2.12 2.12A1 1 0 0 1 16.24 12l2.12-2.12a3 3 0 0 0 0-4.24ZM5.64 18.36a3 3 0 0 0 4.24 0L12 16.24a1 1 0 0 1 1.41 1.42l-2.12 2.12a5 5 0 0 1-7.07-7.07l2.12-2.12A1 1 0 0 1 7.76 12l-2.12 2.12a3 3 0 0 0 0 4.24Zm9.9-8.48a1 1 0 0 0-1.42-1.42l-5.66 5.66a1 1 0 1 0 1.42 1.42l5.66-5.66Z", fill: "currentColor" })) } const Az = he(Dz, "chain_stroked"); function Nz(r) { return R.createElement("svg", Object.assign({ viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", focusable: !1, "aria-hidden": !0 }, r), R.createElement("path", { d: "M5 12.5c0-.83.67-1.5 1.5-1.5h11a1.5 1.5 0 0 1 0 3h-11A1.5 1.5 0 0 1 5 12.5Z", fill: "currentColor" })) } const Fz = he(Nz, "checkbox_indeterminate"); function $z(r) { return R.createElement("svg", Object.assign({ viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", focusable: !1, "aria-hidden": !0 }, r), R.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M17.41 7.3c.66.51.78 1.45.28 2.11l-6.5 8.5a1.5 1.5 0 0 1-2.37.01l-3.5-4.5a1.5 1.5 0 1 1 2.36-1.84L10 14.54l5.32-6.95a1.5 1.5 0 0 1 2.1-.28Z", fill: "currentColor" })) } const Lz = he($z, "checkbox_tick"); function Mz(r) { return R.createElement("svg", Object.assign({ viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", focusable: !1, "aria-hidden": !0 }, r), R.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M7.7 2.8a1 1 0 0 1 0 1.4l-3 3a1 1 0 0 1-1.4 0L1.8 5.7a1 1 0 0 1 1.4-1.4l.8.79 2.3-2.3a1 1 0 0 1 1.4 0Z", fill: "currentColor" }), R.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M7.7 9.8a1 1 0 0 1 0 1.4l-3 3a1 1 0 0 1-1.4 0l-1.5-1.5a1 1 0 1 1 1.4-1.4l.8.79 2.3-2.3a1 1 0 0 1 1.4 0Z", fill: "currentColor" }), R.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M7.7 16.8a1 1 0 0 1 0 1.4l-3 3a1 1 0 0 1-1.4 0l-1.5-1.5a1 1 0 1 1 1.4-1.4l.8.79 2.3-2.3a1 1 0 0 1 1.4 0Z", fill: "currentColor" }), R.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M9.5 12a1 1 0 0 1 1-1h11a1 1 0 1 1 0 2h-11a1 1 0 0 1-1-1Z", fill: "currentColor" }), R.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M9.5 19a1 1 0 0 1 1-1h11a1 1 0 1 1 0 2h-11a1 1 0 0 1-1-1Z", fill: "currentColor" }), R.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M9.5 5a1 1 0 0 1 1-1h11a1 1 0 1 1 0 2h-11a1 1 0 0 1-1-1Z", fill: "currentColor" })) } const pge = he(Mz, "checklist_stroked"); function jz(r) { return R.createElement("svg", Object.assign({ viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", focusable: !1, "aria-hidden": !0 }, r), R.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M4.08 7.6a1.5 1.5 0 0 1 2.12 0l5.66 5.65 5.66-5.65a1.5 1.5 0 1 1 2.12 2.12l-6.72 6.72a1.5 1.5 0 0 1-2.12 0L4.08 9.72a1.5 1.5 0 0 1 0-2.12Z", fill: "currentColor" })) } const os = he(jz, "chevron_down"); function Vz(r) { return R.createElement("svg", Object.assign({ viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", focusable: !1, "aria-hidden": !0 }, r), R.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M16.28 4.24a1.5 1.5 0 0 1 0 2.12l-5.66 5.66 5.66 5.65a1.5 1.5 0 1 1-2.12 2.13l-6.72-6.72a1.5 1.5 0 0 1 0-2.12l6.72-6.72a1.5 1.5 0 0 1 2.12 0Z", fill: "currentColor" })) } const bc = he(Vz, "chevron_left"); function Bz(r) { return R.createElement("svg", Object.assign({ viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", focusable: !1, "aria-hidden": !0 }, r), R.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M7.44 19.8a1.5 1.5 0 0 1 0-2.13l5.66-5.65-5.66-5.66a1.5 1.5 0 1 1 2.12-2.12l6.72 6.72a1.5 1.5 0 0 1 0 2.12L9.56 19.8a1.5 1.5 0 0 1-2.12 0Z", fill: "currentColor" })) } const Ms = he(Bz, "chevron_right"); function zz(r) { return R.createElement("svg", Object.assign({ viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", focusable: !1, "aria-hidden": !0 }, r), R.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M19.64 16.44a1.5 1.5 0 0 1-2.12 0l-5.66-5.66-5.66 5.66a1.5 1.5 0 1 1-2.12-2.12L10.8 7.6a1.5 1.5 0 0 1 2.12 0l6.72 6.72a1.5 1.5 0 0 1 0 2.12Z", fill: "currentColor" })) } const Hz = he(zz, "chevron_up"); function Kz(r) { return R.createElement("svg", Object.assign({ viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", focusable: !1, "aria-hidden": !0 }, r), R.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M12 23a11 11 0 1 0 0-22 11 11 0 0 0 0 22Zm5.04-6.14a1.5 1.5 0 0 1-2.13.04l-2.87-2.78L9.26 17A1.5 1.5 0 0 1 7.1 14.9l2.78-2.87L7 9.26A1.5 1.5 0 1 1 9.1 7.1l2.87 2.78L14.74 7A1.5 1.5 0 0 1 16.9 9.1l-2.78 2.87L17 14.74c.6.58.61 1.53.04 2.12Z", fill: "currentColor" })) } const us = he(Kz, "clear"); function Uz(r) { return R.createElement("svg", Object.assign({ viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", focusable: !1, "aria-hidden": !0 }, r), R.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M12 23a11 11 0 1 0 0-22 11 11 0 0 0 0 22Zm1.5-16.5v4.88l3.56 3.56a1.5 1.5 0 0 1-2.12 2.12l-4-4A1.5 1.5 0 0 1 10.5 12V6.5a1.5 1.5 0 0 1 3 0Z", fill: "currentColor" })) } const HS = he(Uz, "clock"); function Wz(r) { return R.createElement("svg", Object.assign({ viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", focusable: !1, "aria-hidden": !0 }, r), R.createElement("path", { d: "M17.66 19.78a1.5 1.5 0 0 0 2.12-2.12L14.12 12l5.66-5.66a1.5 1.5 0 0 0-2.12-2.12L12 9.88 6.34 4.22a1.5 1.5 0 1 0-2.12 2.12L9.88 12l-5.66 5.66a1.5 1.5 0 0 0 2.12 2.12L12 14.12l5.66 5.66Z", fill: "currentColor" })) } const ds = he(Wz, "close"); function Gz(r) { return R.createElement("svg", Object.assign({ viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", focusable: !1, "aria-hidden": !0 }, r), R.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M23 11.5a10.5 10.5 0 1 0-19.59 5.26L2.1 20.74a1 1 0 0 0 1.2 1.28l4.42-1.18A10.5 10.5 0 0 0 23 11.5ZM7.5 13a1.5 1.5 0 1 1 0-3 1.5 1.5 0 0 1 0 3Zm6.5-1.5a1.5 1.5 0 1 1-3 0 1.5 1.5 0 0 1 3 0Zm3.5 1.5a1.5 1.5 0 1 1 0-3 1.5 1.5 0 0 1 0 3Z", fill: "currentColor" })) } const fge = he(Gz, "comment"); function Yz(r) { return R.createElement("svg", Object.assign({ viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", focusable: !1, "aria-hidden": !0 }, r), R.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "m4 17.9.94-.74a2.97 2.97 0 0 1 1.85-.63H20V5H4v12.9ZM21 3H3a1 1 0 0 0-1 1v15.95a1 1 0 0 0 1.62.79l2.55-2a1 1 0 0 1 .62-.21H21a1 1 0 0 0 1-1V4a1 1 0 0 0-1-1ZM8 8a1 1 0 0 0 0 2h8a1 1 0 1 0 0-2H8Zm-1 5a1 1 0 0 1 1-1h5a1 1 0 1 1 0 2H8a1 1 0 0 1-1-1Z", fill: "currentColor" })) } const gge = he(Yz, "comment_stroked"); function Xz(r) { return R.createElement("svg", Object.assign({ viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", focusable: !1, "aria-hidden": !0 }, r), R.createElement("path", { d: "M7 4c0-1.1.9-2 2-2h11a2 2 0 0 1 2 2v11a2 2 0 0 1-2 2h-1V8c0-2-1-3-3-3H7V4Z", fill: "currentColor" }), R.createElement("path", { d: "M5 7a2 2 0 0 0-2 2v10c0 1.1.9 2 2 2h10a2 2 0 0 0 2-2V9a2 2 0 0 0-2-2H5Z", fill: "currentColor" })) } const qz = he(Xz, "copy"); function Zz(r) { return R.createElement("svg", Object.assign({ viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", focusable: !1, "aria-hidden": !0 }, r), R.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M22 16a2 2 0 0 1-2 2V4H6c0-1.1.9-2 2-2h12a2 2 0 0 1 2 2v12ZM2 8c0-1.1.9-2 2-2h12a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V8Zm2 0h12v12H4V8Zm2 6a1 1 0 0 1 1-1h2v-2a1 1 0 1 1 2 0v2h2a1 1 0 1 1 0 2h-2v2a1 1 0 1 1-2 0v-2H7a1 1 0 0 1-1-1Z", fill: "currentColor" })) } const KS = he(Zz, "copy_stroked"); function Jz(r) { return R.createElement("svg", Object.assign({ viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", focusable: !1, "aria-hidden": !0 }, r), R.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M4 4a3 3 0 0 0-3 3v2h22V7a3 3 0 0 0-3-3H4Zm19 7H1v7a3 3 0 0 0 3 3h16a3 3 0 0 0 3-3v-7ZM4 15a1 1 0 0 1 1-1h2a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H5a1 1 0 0 1-1-1v-1Z", fill: "currentColor" })) } const mge = he(Jz, "credit_card"); function Qz(r) { return R.createElement("svg", Object.assign({ viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", focusable: !1, "aria-hidden": !0 }, r), R.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M9.38 2a1 1 0 0 0-.9.55L7.02 5.5H3a1 1 0 0 0-1 1v1a1 1 0 0 0 1 1h18a1 1 0 0 0 1-1v-1a1 1 0 0 0-1-1h-4L15.5 2.55a1 1 0 0 0-.9-.55H9.39Zm5.48 3.5-.72-1.25a.5.5 0 0 0-.43-.25h-3.42a.5.5 0 0 0-.43.25L9.14 5.5h5.72Zm3.86 4.5H5.28a1 1 0 0 0-.97 1.24l2.12 8.49A3 3 0 0 0 9.34 22h5.32a3 3 0 0 0 2.9-2.27l2.13-8.49a1 1 0 0 0-.97-1.24Z", fill: "currentColor" })) } const yge = he(Qz, "delete"); function eH(r) { return R.createElement("svg", Object.assign({ viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", focusable: !1, "aria-hidden": !0 }, r), R.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M10 5V4h4v1h-4ZM8 5V3a1 1 0 0 1 1-1h6a1 1 0 0 1 1 1v2h4a1 1 0 1 1 0 2h-1v14a1 1 0 0 1-1 1H6a1 1 0 0 1-1-1V7H4a1 1 0 0 1 0-2h4Zm7 2H7v13h10V7h-2ZM9 9.5c0-.28.22-.5.5-.5h1c.28 0 .5.22.5.5v7a.5.5 0 0 1-.5.5h-1a.5.5 0 0 1-.5-.5v-7Zm4 0c0-.28.22-.5.5-.5h1c.28 0 .5.22.5.5v7a.5.5 0 0 1-.5.5h-1a.5.5 0 0 1-.5-.5v-7Z", fill: "currentColor" })) } const US = he(eH, "delete_stroked"); function tH(r) { return R.createElement("svg", Object.assign({ viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", focusable: !1, "aria-hidden": !0 }, r), R.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M23 12a11 11 0 1 1-22 0 11 11 0 0 1 22 0Zm-6 0a5 5 0 1 1-10 0 5 5 0 0 1 10 0Zm-5 3a3 3 0 1 0 0-6 3 3 0 0 0 0 6Z", fill: "currentColor" })) } const nH = he(tH, "disc"); function rH(r) { return R.createElement("svg", Object.assign({ viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", focusable: !1, "aria-hidden": !0 }, r), R.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M12.62 4.4c.5.53.5 1.38 0 1.91L7.14 12l5.48 5.69c.5.53.5 1.38 0 1.91-.51.53-1.33.53-1.84 0l-6.4-6.64a1.4 1.4 0 0 1 0-1.92l6.4-6.64c.5-.53 1.33-.53 1.84 0Z", fill: "currentColor" }), R.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M19.62 4.4c.5.53.5 1.38 0 1.91L14.14 12l5.48 5.69c.5.53.5 1.38 0 1.91-.51.53-1.34.53-1.84 0l-6.4-6.64a1.4 1.4 0 0 1 0-1.92l6.4-6.64c.5-.53 1.33-.53 1.84 0Z", fill: "currentColor" })) } const iH = he(rH, "double_chevron_left"); function sH(r) { return R.createElement("svg", Object.assign({ viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", focusable: !1, "aria-hidden": !0 }, r), R.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M4.38 4.4c.51-.53 1.34-.53 1.84 0l6.4 6.64c.5.53.5 1.39 0 1.92l-6.4 6.64c-.5.53-1.33.53-1.84 0a1.4 1.4 0 0 1 0-1.91L9.86 12 4.38 6.31a1.4 1.4 0 0 1 0-1.91Z", fill: "currentColor" }), R.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M11.38 4.4c.51-.53 1.33-.53 1.84 0l6.4 6.64c.5.53.5 1.39 0 1.92l-6.4 6.64c-.5.53-1.33.53-1.84 0a1.4 1.4 0 0 1 0-1.91L16.86 12l-5.48-5.69a1.4 1.4 0 0 1 0-1.91Z", fill: "currentColor" })) } const aH = he(sH, "double_chevron_right"); function oH(r) { return R.createElement("svg", Object.assign({ viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", focusable: !1, "aria-hidden": !0 }, r), R.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M17.84 8.06A6.5 6.5 0 1 0 5.18 11 4.5 4.5 0 0 0 5.5 20H17a6 6 0 0 0 .84-11.94Zm-6.16 9.67a.5.5 0 0 0 .64 0l5.15-4.29a.25.25 0 0 0-.16-.44H14V9.5a.5.5 0 0 0-.5-.5h-3a.5.5 0 0 0-.5.5V13H6.7c-.24 0-.35.3-.17.44l5.15 4.3Z", fill: "currentColor" })) } const lH = he(oH, "download"); function cH(r) { return R.createElement("svg", Object.assign({ viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", focusable: !1, "aria-hidden": !0 }, r), R.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M21.7 3.7a1 1 0 0 0-1.4-1.4L17.3 5.26A11.59 11.59 0 0 0 12 4C5 4 1 10 1 12c0 1.18 1.38 3.73 3.94 5.64L2.3 20.3a1 1 0 1 0 1.42 1.42l18-18ZM7.84 14.77l1.46-1.47a3 3 0 0 1 4-4l1.47-1.46a5 5 0 0 0-6.93 6.93Z", fill: "currentColor" }), R.createElement("path", { d: "M12 20c-1.22 0-2.35-.18-3.38-.5l2.57-2.57a5 5 0 0 0 5.75-5.75l3.56-3.56C22.13 9.27 23 11.07 23 12c0 2-4 8-11 8Z", fill: "currentColor" })) } const uH = he(cH, "eye_closed_solid"); function dH(r) { return R.createElement("svg", Object.assign({ viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", focusable: !1, "aria-hidden": !0 }, r), R.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M12 4C5 4 1 10 1 12s4 8 11 8 11-6 11-8-4-8-11-8Zm5 8a5 5 0 1 1-10 0 5 5 0 0 1 10 0Zm-5 3a3 3 0 1 0 0-6 3 3 0 0 0 0 6Z", fill: "currentColor" })) } const WS = he(dH, "eye_opened"); function hH(r) { return R.createElement("svg", Object.assign({ viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", focusable: !1, "aria-hidden": !0 }, r), R.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M12 2a1 1 0 0 0-1-1H6a2 2 0 0 0-2 2v18c0 1.1.9 2 2 2h12a2 2 0 0 0 2-2V10a1 1 0 0 0-1-1h-5a2 2 0 0 1-2-2V2ZM7 8a1 1 0 0 1 1-1h1a1 1 0 0 1 0 2H8a1 1 0 0 1-1-1Zm0 5a1 1 0 0 1 1-1h8a1 1 0 1 1 0 2H8a1 1 0 0 1-1-1Zm1 4a1 1 0 1 0 0 2h8a1 1 0 1 0 0-2H8Zm11.07-9.5H14.5a1 1 0 0 1-1-1V1.93a.8.8 0 0 1 1.37-.56l4.76 4.76a.8.8 0 0 1-.56 1.37Z", fill: "currentColor" })) } const Sf = he(hH, "file"); function pH(r) { return R.createElement("svg", Object.assign({ viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", focusable: !1, "aria-hidden": !0 }, r), R.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M1.1 2.58A1 1 0 0 1 2 2h20a1 1 0 0 1 .76 1.65l-8.2 9.18V21a1 1 0 0 1-1.44.9l-3.07-2a1 1 0 0 1-.55-.9v-6.17L1.24 3.65a1 1 0 0 1-.15-1.07Z", fill: "currentColor" })) } const fH = he(pH, "filter"); function gH(r) { return R.createElement("svg", Object.assign({ viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", focusable: !1, "aria-hidden": !0 }, r), R.createElement("path", { d: "M5 2a3 3 0 0 0-3 3v3h20c0-2-1-4-3-4h-6.45a3 3 0 0 1-1.87-.66l-1.13-.9A2 2 0 0 0 8.3 2H5Z", fill: "currentColor" }), R.createElement("path", { d: "M22 10H2v9a3 3 0 0 0 3 3h14a3 3 0 0 0 3-3v-9Z", fill: "currentColor" })) } const mH = he(gH, "folder"); function yH(r) { return R.createElement("svg", Object.assign({ viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", focusable: !1, "aria-hidden": !0 }, r), R.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M2 5a3 3 0 0 1 3-3h3.3a2 2 0 0 1 1.25.44l1.13.9a3 3 0 0 0 1.87.66H18c2 0 3 2 3 4H7.53A2 2 0 0 0 5.6 9.48L2.57 20.76C2.21 20.26 2 19.66 2 19V5Zm20.17 5H9.5a2 2 0 0 0-1.92 1.44l-2.7 9.28A1 1 0 0 0 5.82 22H18.5a2 2 0 0 0 1.92-1.44l2.7-9.28a1 1 0 0 0-.95-1.28Z", fill: "currentColor" })) } const bH = he(yH, "folder_open"); function vH(r) { return R.createElement("svg", Object.assign({ viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", focusable: !1, "aria-hidden": !0 }, r), R.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M4 4.5C4 2.6 5.42 1 7.5 1c.96 0 1.78.48 2.41 1.03a9.26 9.26 0 0 1 1.62 1.93c.17.26.33.52.47.78.14-.26.3-.52.47-.78.44-.67.98-1.38 1.62-1.93A3.73 3.73 0 0 1 16.5 1C18.58 1 20 2.6 20 4.5c0 .98-.4 1.86-1.05 2.5H21a1 1 0 0 1 1 1v2a1 1 0 0 1-1 1h-8V6h-2v5H3a1 1 0 0 1-1-1V8a1 1 0 0 1 1-1h2.05A3.49 3.49 0 0 1 4 4.5Zm7 7.5H4v8c0 1.1.9 2 2 2h5V12Zm2 10h5a2 2 0 0 0 2-2v-8h-7v10ZM10.41 6c-.16-.3-.35-.63-.56-.96a7.3 7.3 0 0 0-1.25-1.5C8.15 3.14 7.8 3 7.5 3 6.58 3 6 3.64 6 4.5 6 5.33 6.67 6 7.5 6h2.91Zm3.74-.96c-.21.33-.4.66-.56.96h2.91c.83 0 1.5-.67 1.5-1.5 0-.86-.58-1.5-1.5-1.5-.29 0-.65.15-1.1.54a7.3 7.3 0 0 0-1.25 1.5Z", fill: "currentColor" })) } const bge = he(vH, "gift"); function xH(r) { return R.createElement("svg", Object.assign({ viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", focusable: !1, "aria-hidden": !0 }, r), R.createElement("path", { d: "M12.01 1a11 11 0 0 0-3.48 21.45c.55.11.75-.23.75-.52l-.02-2.05c-3.06.66-3.7-1.3-3.7-1.3-.5-1.28-1.22-1.61-1.22-1.61-1-.68.07-.68.07-.68 1.11.08 1.7 1.13 1.7 1.13.98 1.68 2.56 1.2 3.2.92.1-.72.39-1.2.7-1.48-2.45-.26-5.02-1.2-5.02-5.43 0-1.2.44-2.2 1.13-2.96-.1-.27-.49-1.4.11-2.91 0 0 .93-.3 3.03 1.13a10.66 10.66 0 0 1 5.5 0c2.1-1.42 3.03-1.13 3.03-1.13.6 1.51.22 2.64.1 2.91a4.21 4.21 0 0 1 1.14 2.96c0 4.23-2.57 5.16-5.03 5.43.4.35.74 1 .74 2.04l-.01 3.03c0 .29.2.63.74.52A11 11 0 0 0 12.01 1Z", fill: "currentColor" }), R.createElement("path", { d: "M5.17 16.8c-.01.06-.1.08-.18.04-.07-.04-.13-.1-.09-.16.02-.06.11-.08.18-.04.08.04.11.11.1.16Zm.44.5c-.05.05-.16.01-.22-.06-.07-.07-.09-.18-.03-.24.05-.05.14-.01.22.06.07.1.09.2.03.24Zm.44.63c-.07.06-.18 0-.24-.09-.07-.09-.07-.22 0-.25.08-.06.18 0 .24.09.07.09.07.2 0 .25Zm.6.62c-.05.08-.18.06-.3-.03-.08-.1-.12-.22-.05-.28.06-.07.19-.05.3.04.09.07.1.2.05.27Zm.82.35c-.02.1-.14.13-.27.1-.13-.04-.2-.15-.18-.23.01-.09.14-.12.27-.09.13.04.2.13.18.22Zm.9.07c0 .1-.12.17-.24.17-.13 0-.24-.08-.24-.17 0-.09.11-.16.24-.16.12 0 .23.07.23.16Zm.83-.14c.02.09-.07.18-.2.2-.13.02-.23-.04-.25-.13-.02-.1.07-.18.2-.2.13-.02.23.04.25.13Z", fill: "currentColor" })) } const vge = he(xH, "github_logo"); function wH(r) { return R.createElement("svg", Object.assign({ viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", focusable: !1, "aria-hidden": !0 }, r), R.createElement("path", { d: "M9 7a2 2 0 1 0 0-4 2 2 0 0 0 0 4Z", fill: "currentColor" }), R.createElement("path", { d: "M9 14a2 2 0 1 0 0-4 2 2 0 0 0 0 4Z", fill: "currentColor" }), R.createElement("path", { d: "M11 19a2 2 0 1 1-4 0 2 2 0 0 1 4 0Z", fill: "currentColor" }), R.createElement("path", { d: "M15 7a2 2 0 1 0 0-4 2 2 0 0 0 0 4Z", fill: "currentColor" }), R.createElement("path", { d: "M17 12a2 2 0 1 1-4 0 2 2 0 0 1 4 0Z", fill: "currentColor" }), R.createElement("path", { d: "M15 21a2 2 0 1 0 0-4 2 2 0 0 0 0 4Z", fill: "currentColor" })) } const CH = he(wH, "handle"); function SH(r) { return R.createElement("svg", Object.assign({ viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", focusable: !1, "aria-hidden": !0 }, r), R.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M12 23a11 11 0 1 0 0-22 11 11 0 0 0 0 22Zm-.17-8.4c-.86 0-1.3-.53-1.3-1.23 0-1.05.53-1.72 1.74-2.64l.06-.05c.83-.62 1.4-1.06 1.4-1.85 0-.9-.83-1.4-1.76-1.4-.76 0-1.34.28-1.8.87-.33.34-.6.53-1.05.53C8.38 8.83 8 8.3 8 7.7c0-.6.34-1.22.88-1.68A5.15 5.15 0 0 1 12.28 5c2.71 0 4.62 1.34 4.62 3.64 0 1.68-1 2.5-2.2 3.31-.8.59-1.17.93-1.48 1.62-.33.6-.58 1.04-1.4 1.04Zm-.02 4.17c-.94 0-1.71-.6-1.71-1.54 0-.94.77-1.55 1.7-1.55.95 0 1.7.6 1.7 1.55 0 .93-.75 1.54-1.7 1.54Z", fill: "currentColor" })) } const EH = he(SH, "help_circle"); function _H(r) { return R.createElement("svg", Object.assign({ viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", focusable: !1, "aria-hidden": !0 }, r), R.createElement("path", { d: "M17 2a1 1 0 0 0-1 1v16h-2v-9a1 1 0 0 0-1-1h-2a1 1 0 0 0-1 1v9H8V8a1 1 0 0 0-1-1H5a1 1 0 0 0-1 1v11H3a1 1 0 0 0-1 1v1a1 1 0 0 0 1 1h18a1 1 0 0 0 1-1v-1a1 1 0 0 0-1-1h-1V3a1 1 0 0 0-1-1h-2Z", fill: "currentColor" })) } const xge = he(_H, "histogram"); function OH(r) { return R.createElement("svg", Object.assign({ viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", focusable: !1, "aria-hidden": !0 }, r), R.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M5 2a3 3 0 0 0-3 3v14a3 3 0 0 0 3 3h14a3 3 0 0 0 3-3V5a3 3 0 0 0-3-3H5Zm5 5.5a2.5 2.5 0 1 1-5 0 2.5 2.5 0 0 1 5 0Zm6.7 4.2a1 1 0 0 0-1.4 0L11 16l-1.3-1.3a1 1 0 0 0-1.4 0L5 18v1h14v-5l-2.3-2.3Z", fill: "currentColor" })) } const wge = he(OH, "image"); function TH(r) { return R.createElement("svg", Object.assign({ viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", focusable: !1, "aria-hidden": !0 }, r), R.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M9 4.5c0-.83.67-1.5 1.5-1.5h11a1.5 1.5 0 0 1 0 3h-11A1.5 1.5 0 0 1 9 4.5Zm0 5c0-.83.67-1.5 1.5-1.5h11a1.5 1.5 0 0 1 0 3h-11A1.5 1.5 0 0 1 9 9.5Zm1.5 3.5a1.5 1.5 0 0 0 0 3h11a1.5 1.5 0 0 0 0-3h-11ZM9 19.5c0-.83.67-1.5 1.5-1.5h11a1.5 1.5 0 0 1 0 3h-11A1.5 1.5 0 0 1 9 19.5ZM7.06 9.56a1.5 1.5 0 1 0-2.12-2.12l-3.5 3.5a1.5 1.5 0 0 0 0 2.12l3.5 3.5a1.5 1.5 0 0 0 2.12-2.12L4.62 12l2.44-2.44Z", fill: "currentColor" })) } const Cge = he(TH, "indent_left"); function IH(r) { return R.createElement("svg", Object.assign({ viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", focusable: !1, "aria-hidden": !0 }, r), R.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M12 23a11 11 0 1 0 0-22 11 11 0 0 0 0 22Zm2-16a2 2 0 1 1-4 0 2 2 0 0 1 4 0Zm-5 3.75c0-.41.34-.75.75-.75h2.75a1 1 0 0 1 1 1v5.5h.75a.75.75 0 0 1 0 1.5h-4.5a.75.75 0 0 1 0-1.5h.75v-5h-.75a.75.75 0 0 1-.75-.75Z", fill: "currentColor" })) } const Hm = he(IH, "info_circle"); function PH(r) { return R.createElement("svg", Object.assign({ viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", focusable: !1, "aria-hidden": !0 }, r), R.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M23 8.5a7.5 7.5 0 0 1-11.4 6.4l-.6.6V19H7v4H2v-4l6.91-6.91A7.5 7.5 0 1 1 23 8.5Zm-4-1a2.5 2.5 0 1 0-5 0 2.5 2.5 0 0 0 5 0Z", fill: "currentColor" })) } const Sge = he(PH, "key"); function kH(r) { return R.createElement("svg", Object.assign({ viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", focusable: !1, "aria-hidden": !0 }, r), R.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "m6.62 3.25.44.75H2.6C1.72 4 1 4.67 1 5.5S1.72 7 2.6 7h1.9c0 2.45 1.1 4.71 2.5 6.5-1.1.64-2.63 1-4 1a1.5 1.5 0 1 0 0 3c2.23 0 4.3-.7 6-1.88 1.4.98 3.06 1.62 4.85 1.82l-1.7 3.39a1.5 1.5 0 0 0 2.7 1.34l.58-1.17h4.14l.59 1.17a1.5 1.5 0 0 0 2.68-1.34l-4-8a1.5 1.5 0 0 0-2.68 0l-.85 1.7a1.5 1.5 0 0 0-.31-.03c-1.37 0-2.9-.36-4-1A10.7 10.7 0 0 0 13.5 7h1.9c.88 0 1.6-.67 1.6-1.5S16.28 4 15.4 4h-4.88l-1.3-2.25a1.5 1.5 0 0 0-2.6 1.5ZM7.5 7h3c0 1.69-.56 3.25-1.5 4.5A7.47 7.47 0 0 1 7.5 7Zm10 9.85L18.57 19h-2.14l1.07-2.15Z", fill: "currentColor" })) } const Ege = he(kH, "language"); function RH(r) { return R.createElement("svg", Object.assign({ viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", focusable: !1, "aria-hidden": !0 }, r), R.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "m21.21 15.05.26.14c.51.28.68.9.38 1.39-.1.15-.23.27-.38.36l-8.92 4.92c-.34.19-.76.19-1.1 0l-8.92-4.92a.98.98 0 0 1-.38-1.39c.1-.15.23-.27.38-.36l.26-.14 8.66 4.78c.32.17.72.18 1.05.02l.05-.02 8.66-4.78Zm0-4.07.26.14c.51.29.68.91.38 1.4-.1.14-.23.27-.38.36l-8.92 4.92c-.34.18-.76.18-1.1 0l-8.92-4.92a.98.98 0 0 1-.38-1.4c.1-.14.23-.27.38-.36l.26-.14 8.66 4.78c.32.18.72.19 1.05.03l.05-.03 8.66-4.78Zm-8.66-8.84 8.92 4.92c.51.28.68.9.38 1.39-.1.15-.23.27-.38.36l-8.92 4.92c-.34.19-.76.19-1.1 0L2.53 8.81a.98.98 0 0 1-.38-1.39c.1-.15.23-.27.38-.36l8.92-4.92c.34-.19.76-.19 1.1 0Z", fill: "currentColor" })) } const _ge = he(RH, "layers"); function DH(r) { return R.createElement("svg", Object.assign({ viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", focusable: !1, "aria-hidden": !0 }, r), R.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "m8.06 9.39 3.71-6.96c.13-.24.42-.33.64-.18.58.41 1.42 1.2 1.42 2.13 0 .5-.13 1.4-.27 2.33a23.55 23.55 0 0 0-.31 2.79h7.58c.45 0 1.17.45 1.17 1.5 0 .9-1 5.09-1.7 8.04l-.3 1.3c0 .22-.27.66-1.33.66H8.5a.5.5 0 0 1-.5-.5V9.63a.5.5 0 0 1 .06-.24ZM3.5 9.5a.5.5 0 0 0-.5.5v10.5c0 .28.22.5.5.5h2a.5.5 0 0 0 .5-.5V10a.5.5 0 0 0-.5-.5h-2Z", fill: "currentColor" })) } const yx = he(DH, "like_thumb"); function AH(r) { return R.createElement("svg", Object.assign({ viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", focusable: !1, "aria-hidden": !0 }, r), R.createElement("g", { opacity: .99 }, R.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M4 6.5a2 2 0 1 0 0-4 2 2 0 0 0 0 4ZM9.5 3a1.5 1.5 0 1 0 0 3h11a1.5 1.5 0 0 0 0-3h-11ZM8 11.5c0-.83.67-1.5 1.5-1.5h11a1.5 1.5 0 0 1 0 3h-11A1.5 1.5 0 0 1 8 11.5Zm0 7c0-.83.67-1.5 1.5-1.5h11a1.5 1.5 0 0 1 0 3h-11A1.5 1.5 0 0 1 8 18.5Zm-2-7a2 2 0 1 1-4 0 2 2 0 0 1 4 0Zm-2 9a2 2 0 1 0 0-4 2 2 0 0 0 0 4Z", fill: "currentColor" }))) } const Oge = he(AH, "list"); function NH(r) { return R.createElement("svg", Object.assign({ viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", focusable: !1, "aria-hidden": !0 }, r), R.createElement("g", { opacity: .99 }, R.createElement("path", { d: "M2 19.5c0-.83.67-1.5 1.5-1.5h17a1.5 1.5 0 0 1 0 3h-17A1.5 1.5 0 0 1 2 19.5Z", fill: "currentColor" }), R.createElement("path", { d: "M2 12c0-.83.67-1.5 1.5-1.5h17a1.5 1.5 0 0 1 0 3h-17A1.5 1.5 0 0 1 2 12Z", fill: "currentColor" }), R.createElement("path", { d: "M2 4.5C2 3.67 2.67 3 3.5 3h17a1.5 1.5 0 0 1 0 3h-17A1.5 1.5 0 0 1 2 4.5Z", fill: "currentColor" }))) } const Tge = he(NH, "menu"); function FH(r) { return R.createElement("svg", Object.assign({ viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", focusable: !1, "aria-hidden": !0 }, r), R.createElement("path", { d: "M2 12c0-.83.67-1.5 1.5-1.5h17a1.5 1.5 0 0 1 0 3h-17A1.5 1.5 0 0 1 2 12Z", fill: "currentColor" })) } const $H = he(FH, "minus"); function LH(r) { return R.createElement("svg", Object.assign({ viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", focusable: !1, "aria-hidden": !0 }, r), R.createElement("path", { d: "M20.5 13.5a1.5 1.5 0 0 0 0-3h-7v-7a1.5 1.5 0 0 0-3 0v7h-7a1.5 1.5 0 0 0 0 3h7v7a1.5 1.5 0 0 0 3 0v-7h7Z", fill: "currentColor" })) } const MH = he(LH, "plus"); function jH(r) { return R.createElement("svg", Object.assign({ viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", focusable: !1, "aria-hidden": !0 }, r), R.createElement("circle", { cx: 12, cy: 12, r: 5, fill: "currentColor" })) } const VH = he(jH, "radio"); function BH(r) { return R.createElement("svg", Object.assign({ viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", focusable: !1, "aria-hidden": !0 }, r), R.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M1 6c0-1.1.9-2 2-2h18a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V6Zm20 0H3v12h18V6ZM5 9a1 1 0 0 1 1-1h1.5a1 1 0 0 1 1 1v6a1 1 0 1 1-2 0v-5H6a1 1 0 0 1-1-1Zm11-1a1 1 0 1 0 0 2h.5v5a1 1 0 1 0 2 0V9a1 1 0 0 0-1-1H16Zm-3 2a1 1 0 1 1-2 0 1 1 0 0 1 2 0Zm-1 5a1 1 0 1 0 0-2 1 1 0 0 0 0 2Z", fill: "currentColor" })) } const zH = he(BH, "real_size_stroked"); function HH(r) { return R.createElement("svg", Object.assign({ viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", focusable: !1, "aria-hidden": !0 }, r), R.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M3.5 12a8 8 0 0 1 13.66-5.66c.28.28.68.71 1.09 1.16H16a1 1 0 1 0 0 2h4.5a1 1 0 0 0 1-1V4a1 1 0 1 0-2 0v1.9a37.8 37.8 0 0 0-.93-.97 10 10 0 1 0 0 14.14 1 1 0 1 0-1.41-1.41A8 8 0 0 1 3.5 12Z", fill: "currentColor" })) } const KH = he(HH, "redo_stroked"); function UH(r) { return R.createElement("svg", Object.assign({ viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", focusable: !1, "aria-hidden": !0 }, r), R.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M4.5 12a7.5 7.5 0 0 1 13.8-4.07l-2-.4a1.5 1.5 0 0 0-.6 2.94l5 1c.76.15 1.51-.3 1.74-1.04l1.5-5a1.5 1.5 0 1 0-2.88-.86l-.43 1.45A10.49 10.49 0 0 0 1.5 12a10.5 10.5 0 0 0 20.4 3.5 1.5 1.5 0 1 0-2.83-1A7.5 7.5 0 0 1 4.5 12Z", fill: "currentColor" })) } const WH = he(UH, "refresh"); function GH(r) { return R.createElement("svg", Object.assign({ viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", focusable: !1, "aria-hidden": !0 }, r), R.createElement("path", { d: "M14.2 2.2A1 1 0 0 0 12.8.8l-2.5 2.5a1 1 0 0 0 0 1.4l2.5 2.5a1 1 0 1 0 1.4-1.4l-.79-.8H16a5 5 0 0 1 5 5v2a1 1 0 1 0 2 0v-2a7 7 0 0 0-7-7h-2.59l.8-.8Z", fill: "currentColor" }), R.createElement("path", { d: "M3 10c0-1.1.9-2 2-2h12a2 2 0 0 1 2 2v10a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V10Z", fill: "currentColor" })) } const YH = he(GH, "rotate"); function XH(r) { return R.createElement("svg", Object.assign({ viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", focusable: !1, "aria-hidden": !0 }, r), R.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M2 4v16c0 1.1.9 2 2 2h16a2 2 0 0 0 2-2V8.41a1 1 0 0 0-.3-.7l-5.4-5.42a1 1 0 0 0-.71-.29H4a2 2 0 0 0-2 2Zm8 0v3h2V4h2a1 1 0 0 1 1 1v3a1 1 0 0 1-1 1H7a1 1 0 0 1-1-1V5a1 1 0 0 1 1-1h3ZM7 19a1 1 0 0 1-1-1v-4a1 1 0 0 1 1-1h10a1 1 0 0 1 1 1v4a1 1 0 0 1-1 1H7Z", fill: "currentColor" })) } const Ige = he(XH, "save"); function qH(r) { return R.createElement("svg", Object.assign({ viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", focusable: !1, "aria-hidden": !0 }, r), R.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M10.5 2a8.5 8.5 0 1 0 4.86 15.48l4.08 4.08a1.5 1.5 0 1 0 2.12-2.12l-4.08-4.08A8.5 8.5 0 0 0 10.5 2ZM5 10.5a5.5 5.5 0 1 1 11 0 5.5 5.5 0 0 1-11 0Z", fill: "currentColor" })) } const GS = he(qH, "search"); function ZH(r) { return R.createElement("svg", Object.assign({ viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", focusable: !1, "aria-hidden": !0 }, r), R.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M8 5.07c-.8.47-1.8.46-2.6 0l-.24-.15a1.4 1.4 0 0 0-1.82.29c-.64.82-1.16 1.73-1.55 2.7a1.4 1.4 0 0 0 .66 1.71l.24.14a2.57 2.57 0 0 1 0 4.48l-.24.14a1.4 1.4 0 0 0-.66 1.72 11.1 11.1 0 0 0 1.55 2.69 1.4 1.4 0 0 0 1.82.3l.25-.15a2.57 2.57 0 0 1 3.88 2.24v.28c-.01.7.46 1.33 1.16 1.43a11 11 0 0 0 3.1 0 1.4 1.4 0 0 0 1.17-1.43v-.28a2.57 2.57 0 0 1 3.87-2.24l.25.14c.6.36 1.38.26 1.82-.29.64-.82 1.16-1.73 1.55-2.7a1.4 1.4 0 0 0-.66-1.71l-.24-.14a2.57 2.57 0 0 1 0-4.48l.24-.14a1.4 1.4 0 0 0 .66-1.72 11.08 11.08 0 0 0-1.55-2.69 1.4 1.4 0 0 0-1.82-.3l-.25.15a2.57 2.57 0 0 1-3.88-2.24v-.28c.01-.7-.46-1.33-1.16-1.43a10.99 10.99 0 0 0-3.1 0c-.7.1-1.17.72-1.17 1.43v.28C9.3 3.75 8.8 4.61 8 5.07Zm6 10.4a4 4 0 1 0-4-6.93 4 4 0 0 0 4 6.92Z", fill: "currentColor" })) } const Pge = he(ZH, "setting"); function JH(r) { return R.createElement("svg", Object.assign({ viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", focusable: !1, "aria-hidden": !0 }, r), R.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M5 2h14a3 3 0 0 1 3 3v14a3 3 0 0 1-3 3H5a3 3 0 0 1-3-3V5a3 3 0 0 1 3-3Zm1 2a1 1 0 0 0-1 1v14a1 1 0 0 0 1 1h3a1 1 0 0 0 1-1V5a1 1 0 0 0-1-1H6Z", fill: "currentColor" })) } const QH = he(JH, "sidebar"); function eK(r) { return R.createElement("svg", Object.assign({ viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", focusable: !1, "aria-hidden": !0 }, r), R.createElement("path", { d: "M10.75 1.9c.4-1.2 2.1-1.2 2.5 0l1.99 6.12h6.45a1.3 1.3 0 0 1 .77 2.37l-5.22 3.78 2 6.11c.39 1.2-1 2.2-2.02 1.46L12 17.96l-5.22 3.78c-1.02.75-2.4-.25-2.01-1.46l1.99-6.11-5.22-3.78a1.3 1.3 0 0 1 .77-2.37h6.45l2-6.12Z", fill: "currentColor" })) } const tK = he(eK, "star"); function nK(r) { return R.createElement("svg", Object.assign({ viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", focusable: !1, "aria-hidden": !0 }, r), R.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "m11.42 2.1-.83-.4L6.42 9H3.2C2.54 9 2 9.54 2 10.2v10.6c0 .66.54 1.2 1.2 1.2H17.67c.65 0 1.19-.12 1.6-.4.38-.23.66-.61.72-1.06a251.76 251.76 0 0 0 1.77-7.79c.13-.68.24-1.32.24-1.68 0-.77-.3-1.38-.76-1.79a2.18 2.18 0 0 0-1.4-.53h-6.5l.19-1.16.03-.17c.13-.76.27-1.6.27-2.17 0-.97-.58-1.72-1.05-2.18a5.37 5.37 0 0 0-1.36-.98ZM6 20v-9H4v9h2Zm2 0h9.67c.19 0 .32-.02.4-.04a250.3 250.3 0 0 0 1.73-7.58c.14-.74.2-1.18.2-1.31 0-.13-.02-.2-.04-.22a.14.14 0 0 0-.03-.06.18.18 0 0 0-.06-.03l-.04-.01h-8.58v-1c0-.7.17-1.68.3-2.5v-.02c.16-.89.28-1.6.28-1.98 0-.16-.1-.42-.45-.76a2.85 2.85 0 0 0-.05-.05L8 10.27V20Z", fill: "currentColor" })) } const bx = he(nK, "thumb_up_stroked"); function rK(r) { return R.createElement("svg", Object.assign({ viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", focusable: !1, "aria-hidden": !0 }, r), R.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M21.35 4.27c.68.47.86 1.4.38 2.08l-10 14.5a1.5 1.5 0 0 1-2.33.17l-6.5-7a1.5 1.5 0 0 1 2.2-2.04l5.23 5.63 8.94-12.96a1.5 1.5 0 0 1 2.08-.38Z", fill: "currentColor" })) } const ga = he(rK, "tick"); function iK(r) { return R.createElement("svg", Object.assign({ viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", focusable: !1, "aria-hidden": !0 }, r), R.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M12 23a11 11 0 1 0 0-22 11 11 0 0 0 0 22Zm5.88-13.18-6.2 7.6a1.5 1.5 0 0 1-2.37 0l-3.5-4a1.5 1.5 0 1 1 2.37-1.84l2.3 2.46L15.5 8a1.5 1.5 0 1 1 2.38 1.82Z", fill: "currentColor" })) } const Km = he(iK, "tick_circle"); function sK(r) { return R.createElement("svg", Object.assign({ viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", focusable: !1, "aria-hidden": !0 }, r), R.createElement("path", { d: "m20.56 9.66-7.8 8.97a1 1 0 0 1-1.51 0L3.44 9.66A1 1 0 0 1 4.19 8h15.62a1 1 0 0 1 .75 1.66Z", fill: "currentColor" })) } const YS = he(sK, "tree_triangle_down"); function aK(r) { return R.createElement("svg", Object.assign({ viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", focusable: !1, "aria-hidden": !0 }, r), R.createElement("path", { d: "m9.66 3.44 8.97 7.8a1 1 0 0 1 0 1.51l-8.97 7.81A1 1 0 0 1 8 19.81V4.19a1 1 0 0 1 1.66-.75Z", fill: "currentColor" })) } const oK = he(aK, "tree_triangle_right"); function lK(r) { return R.createElement("svg", Object.assign({ viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", focusable: !1, "aria-hidden": !0 }, r), R.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M17.84 8.06A6.5 6.5 0 1 0 5.18 11 4.5 4.5 0 0 0 5.5 20H17a6 6 0 0 0 .84-11.94Zm-5.52.2a.5.5 0 0 0-.64 0l-5.15 4.3a.25.25 0 0 0 .16.44H10v4.5c0 .28.22.5.5.5h3a.5.5 0 0 0 .5-.5V13h3.31c.23 0 .34-.3.16-.44l-5.15-4.3Z", fill: "currentColor" })) } const cK = he(lK, "upload"); function uK(r) { return R.createElement("svg", Object.assign({ viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", focusable: !1, "aria-hidden": !0 }, r), R.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M23 12a11 11 0 1 1-22 0 11 11 0 0 1 22 0Zm-9.5 5.5a1.5 1.5 0 1 0-3 0 1.5 1.5 0 0 0 3 0ZM12 5a1.9 1.9 0 0 0-1.89 2l.3 5.5a1.59 1.59 0 0 0 3.17 0l.3-5.5c.07-1.09-.8-2-1.88-2Z", fill: "currentColor" })) } const XS = he(uK, "upload_error"); function dK(r) { return R.createElement("svg", Object.assign({ viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", focusable: !1, "aria-hidden": !0 }, r), R.createElement("path", { d: "M12 16c1.98 0 3.75-1.66 4.71-4.14.6-.25 1.18-1 1.44-1.97.34-1.27.27-2.4-.65-2.76C17.4 2.71 15.66 1 12 1S6.6 2.71 6.5 7.13c-.93.35-1 1.49-.65 2.76.26.98.83 1.72 1.44 1.97C8.26 14.34 10.02 16 12 16Z", fill: "currentColor" }), R.createElement("path", { d: "M19.6 22c1.24 0 2.12-1.15 1.27-2.05C19.2 18.2 15.85 17 12 17c-3.85 0-7.2 1.2-8.87 2.95-.85.9.03 2.05 1.27 2.05h15.2Z", fill: "currentColor" })) } const kge = he(dK, "user"); function hK(r) { return R.createElement("svg", Object.assign({ viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", focusable: !1, "aria-hidden": !0 }, r), R.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M1.41 10.59 3.5 8.5v-3c0-1.1.9-2 2-2h3l2.09-2.09a2 2 0 0 1 2.82 0L15.5 3.5h3a2 2 0 0 1 2 2v3l2.09 2.09a2 2 0 0 1 0 2.82L20.5 15.5v3a2 2 0 0 1-2 2h-3l-2.09 2.09a2 2 0 0 1-2.82 0L8.5 20.5h-3a2 2 0 0 1-2-2v-3l-2.09-2.09a2 2 0 0 1 0-2.82ZM7 13l3.24 3.24a1 1 0 0 0 1.46-.04l5.44-6.22a1.4 1.4 0 1 0-2.12-1.8L11 13l-2-2a1.41 1.41 0 1 0-2 2Z", fill: "currentColor" })) } const Rge = he(hK, "verify"); function pK(r) { return R.createElement("svg", Object.assign({ viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", focusable: !1, "aria-hidden": !0 }, r), R.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M14 3a1 1 0 0 1 1-1h6a1 1 0 0 1 1 1v6a1 1 0 1 1-2 0V4h-5a1 1 0 0 1-1-1Zm-4 18a1 1 0 0 1-1 1H3a1 1 0 0 1-1-1v-6a1 1 0 1 1 2 0v5h5a1 1 0 0 1 1 1ZM2 9a1 1 0 0 0 2 0V4h5a1 1 0 1 0 0-2H3a1 1 0 0 0-1 1v6Zm19 5a1 1 0 0 1 1 1v6a1 1 0 0 1-1 1h-6a1 1 0 1 1 0-2h5v-5a1 1 0 0 1 1-1ZM8.5 7.5a1 1 0 0 0-1 1v7a1 1 0 0 0 1 1h7a1 1 0 0 0 1-1v-7a1 1 0 0 0-1-1h-7Zm1 7v-5h5v5h-5Z", fill: "currentColor" })) } const fK = he(pK, "window_adaption_stroked"), Tn = { MAC_ENTER: 3, BACKSPACE: 8, TAB: 9, NUM_CENTER: 12, ENTER: 13, SHIFT: 16, CTRL: 17, ALT: 18, PAUSE: 19, CAPS_LOCK: 20, ESC: 27, SPACE: 32, PAGE_UP: 33, PAGE_DOWN: 34, END: 35, HOME: 36, LEFT: 37, UP: 38, RIGHT: 39, DOWN: 40, PRINT_SCREEN: 44, INSERT: 45, DELETE: 46, ZERO: 48, ONE: 49, TWO: 50, THREE: 51, FOUR: 52, FIVE: 53, SIX: 54, SEVEN: 55, EIGHT: 56, NINE: 57, QUESTION_MARK: 63, A: 65, B: 66, C: 67, D: 68, E: 69, F: 70, G: 71, H: 72, I: 73, J: 74, K: 75, L: 76, M: 77, N: 78, O: 79, P: 80, Q: 81, R: 82, S: 83, T: 84, U: 85, V: 86, W: 87, X: 88, Y: 89, Z: 90, META: 91, WIN_KEY_RIGHT: 92, CONTEXT_MENU: 93, NUM_ZERO: 96, NUM_ONE: 97, NUM_TWO: 98, NUM_THREE: 99, NUM_FOUR: 100, NUM_FIVE: 101, NUM_SIX: 102, NUM_SEVEN: 103, NUM_EIGHT: 104, NUM_NINE: 105, NUM_MULTIPLY: 106, NUM_PLUS: 107, NUM_MINUS: 109, NUM_PERIOD: 110, NUM_DIVISION: 111, F1: 112, F2: 113, F3: 114, F4: 115, F5: 116, F6: 117, F7: 118, F8: 119, F9: 120, F10: 121, F11: 122, F12: 123, NUMLOCK: 144, SEMICOLON: 186, DASH: 189, EQUALS: 187, COMMA: 188, PERIOD: 190, SLASH: 191, APOSTROPHE: 192, SINGLE_QUOTE: 222, OPEN_SQUARE_BRACKET: 219, BACKSLASH: 220, CLOSE_SQUARE_BRACKET: 221, WIN_KEY: 224, MAC_FF_META: 224, WIN_IME: 229 }, Um = "Enter", qS = "Escape"; function Jn(r) { return H(r, "key") === Um } const Jh = Ld.PREFIX; class Wm extends f.PureComponent { constructor(e) { super(e), this.copy = t => { const { content: n, duration: i, onCopy: s } = this.props, a = qu(n); s && s(t, n, a), this.setCopied(n, i) }, this.setCopied = (t, n) => { this.setState({ copied: !0, item: t }), this._timeId = setTimeout(() => { this.resetCopied() }, n * 1e3) }, this.resetCopied = () => { this._timeId && (clearTimeout(this._timeId), this._timeId = null, this.setState({ copied: !1, item: "" })) }, this.renderSuccessTip = () => { const { successTip: t } = this.props; return typeof t < "u" ? t : f.createElement(Ke, { componentName: "Typography" }, n => f.createElement("span", null, f.createElement(ga, null), n.copied)) }, this.renderCopyIcon = () => { const { icon: t } = this.props, n = { role: "button", tabIndex: 0, onClick: this.copy, onKeyPress: s => Jn(s) && this.copy(s) }, i = f.createElement("a", { className: `${Jh}-action-copy-icon` }, f.createElement(qz, Object.assign({ onClick: this.copy }, n))); return f.isValidElement(t) ? f.cloneElement(t, n) : i }, this.state = { copied: !1, item: "" } } componentWillUnmount() { this._timeId && (clearTimeout(this._timeId), this._timeId = null) } render() { const { style: e, className: t, forwardRef: n, copyTip: i, render: s } = this.props, { copied: a } = this.state, o = F(t, { [`${Jh}-action-copy`]: !a, [`${Jh}-action-copied`]: a }); return s ? s(a, this.copy, this.props) : f.createElement(Ke, { componentName: "Typography" }, l => f.createElement("span", { style: Object.assign({ marginLeft: "4px" }, e), className: o, ref: n }, a ? this.renderSuccessTip() : f.createElement(ln, { content: typeof i < "u" ? i : l.copy }, this.renderCopyIcon()))) } } Wm.propTypes = { content: c.string, onCopy: c.func, successTip: c.node, copyTip: c.node, duration: c.number, style: c.object, className: c.string, icon: c.node }; Wm.defaultProps = { content: "", onCopy: Ct, duration: 3, style: {}, className: "" }; const ZS = { PREFIX: `${G}-popover`, ARROW: `${G}-popover-icon-arrow` }, ha = { POSITION_SET: ["top", "topLeft", "topRight", "left", "leftTop", "leftBottom", "right", "rightTop", "rightBottom", "bottom", "bottomLeft", "bottomRight", "leftTopOver", "rightTopOver"], TRIGGER_SET: ["hover", "focus", "click", "custom", "contextMenu"], DEFAULT_ARROW_STYLE: { borderOpacity: "1", backgroundColor: "var(--semi-color-bg-3)", borderColor: "var(--semi-color-border)" } }, Cr = { ARROW_BOUNDING: Object.assign(Object.assign({}, Es.ARROW_BOUNDING), { offsetY: 6, offsetX: 0, height: 8 }), SPACING: 4, SPACING_WITH_ARROW: 10, DEFAULT_Z_INDEX: 1030 }; var gK = function (r, e) { var t = {}; for (var n in r) Object.prototype.hasOwnProperty.call(r, n) && e.indexOf(n) < 0 && (t[n] = r[n]); if (r != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, n = Object.getOwnPropertySymbols(r); i < n.length; i++)e.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(r, n[i]) && (t[n[i]] = r[n[i]]); return t }; const JS = function () { let r = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}; const { position: e = "", className: t, arrowStyle: n, popStyle: i } = r, s = gK(r, ["position", "className", "arrowStyle", "popStyle"]), a = e.indexOf("top") === 0 || e.indexOf("bottom") === 0, o = F(t, ZS.ARROW), l = H(n, "borderOpacity", ha.DEFAULT_ARROW_STYLE.borderOpacity), u = H(n, "backgroundColor", H(i, "backgroundColor", ha.DEFAULT_ARROW_STYLE.backgroundColor)), d = H(n, "borderColor", H(i, "borderColor", ha.DEFAULT_ARROW_STYLE.borderColor)), h = Object.assign(Object.assign({}, s), { width: Cr.ARROW_BOUNDING.width, height: Cr.ARROW_BOUNDING.height, xmlns: "http://www.w3.org/2000/svg", className: o }); return a ? f.createElement("svg", Object.assign({}, h), f.createElement("path", { d: "M0 0.5L0 1.5C4 1.5, 5.5 3, 7.5 5S10,8 12,8S14.5 7, 16.5 5S20,1.5 24,1.5L24 0.5L0 0.5z", fill: d, opacity: l }), f.createElement("path", { d: "M0 0L0 1C4 1, 5.5 2, 7.5 4S10,7 12,7S14.5  6, 16.5 4S20,1 24,1L24 0L0 0z", fill: u })) : f.createElement("svg", Object.assign({}, h), f.createElement("path", { d: "M0.5 0L1.5 0C1.5 4, 3 5.5, 5 7.5S8,10 8,12S7 14.5, 5 16.5S1.5,20 1.5,24L0.5 24L0.5 0z", fill: d, opacity: l }), f.createElement("path", { d: "M0 0L1 0C1 4, 2 5.5, 4 7.5S7,10 7,12S6 14.5, 4 16.5S1,20 1,24L0 24L0 0z", fill: u })) }; JS.propTypes = { position: c.string, className: c.string, arrowStyle: c.object, popStyle: c.object }; var mK = function (r, e) { var t = {}; for (var n in r) Object.prototype.hasOwnProperty.call(r, n) && e.indexOf(n) < 0 && (t[n] = r[n]); if (r != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, n = Object.getOwnPropertySymbols(r); i < n.length; i++)e.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(r, n[i]) && (t[n[i]] = r[n[i]]); return t }; const yK = ha.POSITION_SET, bK = ha.TRIGGER_SET; class kn extends f.PureComponent { constructor(e) { super(e), this.focusTrigger = () => { var t; (t = this.tooltipRef.current) === null || t === void 0 || t.focusTrigger() }, this.renderPopCard = t => { let { initialFocusRef: n } = t; const { content: i, contentClassName: s, prefixCls: a } = this.props, { direction: o } = this.context, l = F(a, s, { [`${a}-rtl`]: o === "rtl" }), u = this.renderContentNode({ initialFocusRef: n, content: i }); return f.createElement("div", { className: l }, f.createElement("div", { className: `${a}-content` }, u)) }, this.renderContentNode = t => { const { initialFocusRef: n, content: i } = t, s = { initialFocusRef: n }; return we(i) ? i(s) : i }, this.tooltipRef = f.createRef() } render() { const e = this.props, { children: t, prefixCls: n, showArrow: i, arrowStyle: s = {}, arrowBounding: a, position: o, style: l, trigger: u } = e, d = mK(e, ["children", "prefixCls", "showArrow", "arrowStyle", "arrowBounding", "position", "style", "trigger"]); let { spacing: h } = this.props; const g = { position: o, className: "", popStyle: l, arrowStyle: s }, m = i ? f.createElement(JS, Object.assign({}, g)) : !1; ze(h) && (h = i ? Cr.SPACING_WITH_ARROW : Cr.SPACING); const b = u === "click" || u === "custom" ? "dialog" : "tooltip"; return f.createElement(ln, Object.assign({ guardFocus: !0, ref: this.tooltipRef }, d, { trigger: u, position: o, style: l, content: this.renderPopCard, prefixCls: n, spacing: h, showArrow: m, arrowBounding: a, role: b }), t) } } kn.contextType = An; kn.propTypes = { children: c.node, content: c.oneOfType([c.node, c.func]), visible: c.bool, autoAdjustOverflow: c.bool, motion: c.bool, position: c.oneOf(yK), margin: c.oneOfType([c.number, c.object]), mouseEnterDelay: c.number, mouseLeaveDelay: c.number, trigger: c.oneOf(bK).isRequired, contentClassName: c.oneOfType([c.string, c.array]), onVisibleChange: c.func, onClickOutSide: c.func, style: c.object, spacing: c.oneOfType([c.number, c.object]), zIndex: c.number, showArrow: c.bool, arrowStyle: c.shape({ borderColor: c.string, backgroundColor: c.string, borderOpacity: c.oneOfType([c.string, c.number]) }), arrowPointAtCenter: c.bool, arrowBounding: c.object, prefixCls: c.string, guardFocus: c.bool, disableArrowKeyDown: c.bool }; kn.__SemiComponentName__ = "Popover"; kn.defaultProps = xn(kn.__SemiComponentName__, { arrowBounding: Cr.ARROW_BOUNDING, showArrow: !1, autoAdjustOverflow: !0, zIndex: Cr.DEFAULT_Z_INDEX, motion: !0, trigger: "hover", cancelText: "No", okText: "Yes", position: "bottom", prefixCls: ZS.PREFIX, onClickOutSide: z, onEscKeyDown: z, closeOnEsc: !0, returnFocusOnClose: !0, guardFocus: !0, disableFocusListener: !0 }); let Xt; function Qh(r) { if (!r) return 0; const e = r.match(/^\d*(\.\d*)?/); return e ? Number(e[0]) : 0 } function vK(r) { return Array.prototype.slice.apply(r).map(t => `${t}: ${r.getPropertyValue(t)};`).join("") } const xK = function (r, e) { let t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "", n = arguments.length > 3 ? arguments[3] : void 0, i = arguments.length > 4 ? arguments[4] : void 0, s = arguments.length > 5 ? arguments[5] : void 0, a = arguments.length > 6 ? arguments[6] : void 0, o = arguments.length > 7 ? arguments[7] : void 0; if (t.length === 0) return ""; Xt || (Xt = document.createElement("div"), Xt.setAttribute("aria-hidden", "true"), document.body.appendChild(Xt)); const l = window.getComputedStyle(r), u = vK(l), d = Qh(l.lineHeight), h = Math.round(d * (e + 1) + Qh(l.paddingTop) + Qh(l.paddingBottom)); Xt.setAttribute("style", u), Xt.style.position = "fixed", Xt.style.left = "0", l.getPropertyValue("width") === "auto" && r.offsetWidth && (Xt.style.width = `${r.offsetWidth}px`), Xt.style.height = "auto", Xt.style.top = "-999999px", Xt.style.zIndex = "-1000", o && (Xt.style.fontWeight = "600"), Xt.style.textOverflow = "clip", Xt.style.webkitLineClamp = "none", lr.render(f.createElement(f.Fragment, null), Xt); function g() { const C = Xt.scrollWidth <= Xt.offsetWidth, O = Xt.scrollHeight < h; return e === 1 ? C && O : O } const m = document.createElement("span"), b = document.createTextNode(t); if (m.appendChild(b), s.length > 0) { const C = document.createTextNode(s); m.appendChild(C) } Xt.appendChild(m), Object.values(Ht(n, "expand")).map(C => C && Xt.appendChild(C.cloneNode(!0))); function y() { Xt.innerHTML = "", Xt.appendChild(m), Object.values(n).map(C => C && Xt.appendChild(C.cloneNode(!0))) } function w(C, O) { const E = C.length; return O ? a === "end" ? C.slice(0, O) + i : C.slice(0, O) + i + C.slice(E - O, E) : i } function x(C, O) { let E = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0, v = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : O.length, T = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 0; const I = Math.floor((E + v) / 2), k = w(O, I); if (C.textContent = k, E >= v - 1 && v > 0) for (let P = v; P >= E; P -= 1) { const N = w(O, P); if (C.textContent = N, g()) return N } else if (v === 0) return i; return g() ? x(C, O, I, v, I) : x(C, O, E, I, T) } let S = t; return g() || (y(), S = x(b, t, 0, a === "middle" ? Math.floor(t.length / 2) : t.length)), Xt.innerHTML = "", S }, QS = f.createContext("normal"); var rd; (function (r) { r.Width = "width", r.Height = "height", r.All = "all" })(rd || (rd = {})); class As extends de { constructor(e) { var t; super(e), t = this, this.formerPropertyValue = new Map, this.getElement = () => { try { return di.findDOMNode(this.childNode || this) } catch { return null } }, this.handleResizeEventTriggered = n => { var i, s, a, o; if (this.props.observerProperty === rd.All) (s = (i = this.props).onResize) === null || s === void 0 || s.call(i, n); else { const l = []; for (const u of n) this.formerPropertyValue.has(u.target) ? u.contentRect[this.props.observerProperty] !== this.formerPropertyValue.get(u.target) && (this.formerPropertyValue.set(u.target, u.contentRect[this.props.observerProperty]), l.push(u)) : (this.formerPropertyValue.set(u.target, u.contentRect[this.props.observerProperty]), l.push(u)); l.length > 0 && ((o = (a = this.props).onResize) === null || o === void 0 || o.call(a, l)) } }, this.observeElement = function () { let n = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !1; const i = t.getElement(); if (t.observer || (t.observer = new ResizeObserver(t.handleResizeEventTriggered)), !(i && i instanceof Element)) { t.observer.disconnect(); return } i === t.element && !n || (t.observer.disconnect(), t.element = i, t.observer.observe(i), t.props.observeParent && i.parentNode && i.parentNode.ownerDocument && i.parentNode.ownerDocument.defaultView && i.parentNode instanceof i.parentNode.ownerDocument.defaultView.HTMLElement && (t._parentNode = i.parentNode, t.observer.observe(t._parentNode))) }, this.mergeRef = (n, i) => { this.childNode = i, typeof n == "function" ? n(i) : typeof n == "object" && n && "current" in n && (n.current = i) }, globalThis.ResizeObserver && (this.observer = new ResizeObserver(this.handleResizeEventTriggered)) } componentDidMount() { var e; (e = this.observeElement) === null || e === void 0 || e.call(this) } componentDidUpdate(e) { var t; (t = this.observeElement) === null || t === void 0 || t.call(this, this.props.observeParent !== e.observeParent) } componentWillUnmount() { this.observer && (this.observer.disconnect(), this.observer = null, this.element = null) } render() { const e = f.Children.only(this.props.children), { ref: t } = e; return f.cloneElement(e, { ref: n => this.mergeRef(t, n) }) } } As.propTypes = { onResize: c.func, observeParent: c.bool, observerProperty: c.string, delayTick: c.number }; As.defaultProps = { onResize: () => { }, observeParent: !1, observerProperty: "all", delayTick: 0 }; var ep = function (r, e, t, n) { function i(s) { return s instanceof t ? s : new t(function (a) { a(s) }) } return new (t || (t = Promise))(function (s, a) { function o(d) { try { u(n.next(d)) } catch (h) { a(h) } } function l(d) { try { u(n.throw(d)) } catch (h) { a(h) } } function u(d) { d.done ? s(d.value) : i(d.value).then(o, l) } u((n = n.apply(r, e || [])).next()) }) }, wK = function (r, e) { var t = {}; for (var n in r) Object.prototype.hasOwnProperty.call(r, n) && e.indexOf(n) < 0 && (t[n] = r[n]); if (r != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, n = Object.getOwnPropertySymbols(r); i < n.length; i++)e.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(r, n[i]) && (t[n[i]] = r[n[i]]); return t }; const $n = Ld.PREFIX, CK = "...", SK = (r, e) => { const { mark: t, code: n, underline: i, strong: s, link: a, disabled: o } = r; let l = e; const u = (d, h) => { let g = {}; d && (typeof d == "object" && (g = Object.assign({}, d)), l = f.createElement(h, g, l)) }; return u(t, "mark"), u(n, "code"), u(i && !a, "u"), u(s, "strong"), u(r.delete, "del"), u(a, o ? "span" : "a"), l }; class Ta extends R.Component { constructor(e) { super(e), this.observerTakingEffect = !1, this.onResize = t => ep(this, void 0, void 0, function* () { return this.rafId && window.cancelAnimationFrame(this.rafId), new Promise(n => { this.rafId = window.requestAnimationFrame(() => ep(this, void 0, void 0, function* () { yield this.getEllipsisState(), n() })) }) }), this.canUseCSSEllipsis = () => { const { copyable: t } = this.props, { expandable: n, expandText: i, pos: s, suffix: a } = this.getEllipsisOpt(); return !n && st(i) && !t && s === "end" && !a.length }, this.shouldTruncated = t => !t || t < 1 ? !1 : t <= 1 ? this.compareSingleRow() : this.wrapperRef.current.scrollHeight > this.wrapperRef.current.offsetHeight, this.compareSingleRow = () => { if (!(document && document.createRange)) return !1; const t = this.wrapperRef.current, n = t.getBoundingClientRect().width, i = Array.from(t.childNodes), s = document.createRange(), a = i.reduce((o, l) => { var u; return s.selectNodeContents(l), o + ((u = s.getBoundingClientRect().width) !== null && u !== void 0 ? u : 0) }, 0); return s.detach(), a > n }, this.showTooltip = () => { var t, n; const { isOverflowed: i, isTruncated: s, expanded: a } = this.state, { showTooltip: o, expandable: l, expandText: u } = this.getEllipsisOpt(), d = this.canUseCSSEllipsis(), h = !a && (d ? i : s), m = !l && st(u) && h && o; if (!m) return m; const b = { type: "tooltip" }; return typeof o == "object" ? o.type && o.type.toLowerCase() === "popover" ? gc({ opts: { showArrow: !0 } }, o, { opts: { className: F({ [`${$n}-ellipsis-popover`]: !0, [(t = o == null ? void 0 : o.opts) === null || t === void 0 ? void 0 : t.className]: !!(!((n = o == null ? void 0 : o.opts) === null || n === void 0) && n.className) }) } }) : Object.assign(Object.assign({}, b), o) : b }, this.onHover = () => { if (this.canUseCSSEllipsis()) { const { rows: n, suffix: i, pos: s } = this.getEllipsisOpt(), a = this.shouldTruncated(n); this.setState({ isOverflowed: a, isTruncated: !1 }); return } }, this.getEllipsisState = () => ep(this, void 0, void 0, function* () { const { rows: t, suffix: n, pos: i } = this.getEllipsisOpt(), { children: s, strong: a } = this.props; if (!this.wrapperRef || !this.wrapperRef.current) { yield this.onResize(); return } const { expanded: o } = this.state; if (this.canUseCSSEllipsis()) return; if (ss(s)) return new Promise(g => { this.setState({ isTruncated: !1, isOverflowed: !1 }, g) }); if (Nt("children" in this.props && typeof s != "string", "[Semi Typography] Only children with pure text could be used with ellipsis at this moment."), !t || t < 0 || o) return; const u = { expand: this.expandRef.current, copy: this.copyRef && this.copyRef.current }, d = Array.isArray(s) ? s.join("") : String(s), h = xK(this.wrapperRef.current, t, d, u, CK, n, i, a); return new Promise(g => { this.setState({ isOverflowed: !1, ellipsisContent: h, isTruncated: d !== h }, g) }) }), this.toggleOverflow = t => { const { onExpand: n, expandable: i, collapsible: s } = this.getEllipsisOpt(), { expanded: a } = this.state; n && n(!a, t), (i && !a || s && a) && this.setState({ expanded: !a }) }, this.getEllipsisOpt = () => { const { ellipsis: t } = this.props; return t ? Object.assign({ rows: 1, expandable: !1, pos: "end", suffix: "", showTooltip: !1, collapsible: !1, expandText: t.expandable ? this.expandStr : void 0, collapseText: t.collapsible ? this.collapseStr : void 0 }, typeof t == "object" ? t : null) : {} }, this.renderExpandable = () => { const { expanded: t, isTruncated: n } = this.state; if (!n) return null; const { expandText: i, expandable: s, collapseText: a, collapsible: o } = this.getEllipsisOpt(), l = !s && st(i), u = !o && st(a); let d; return !t && !l ? d = i : t && !u && (d = a), !l || !u ? f.createElement("a", { role: "button", tabIndex: 0, className: `${$n}-ellipsis-expand`, key: "expand", ref: this.expandRef, "aria-label": d, onClick: this.toggleOverflow, onKeyPress: h => Jn(h) && this.toggleOverflow(h) }, d) : null }, this.getEllipsisStyle = () => { const { ellipsis: t, component: n } = this.props; if (!t) return { ellipsisCls: "", ellipsisStyle: {} }; const { rows: i } = this.getEllipsisOpt(), { expanded: s } = this.state, a = !s && this.canUseCSSEllipsis(), o = F({ [`${$n}-ellipsis`]: !0, [`${$n}-ellipsis-single-line`]: i === 1, [`${$n}-ellipsis-multiple-line`]: i > 1, [`${$n}-ellipsis-multiple-line-text`]: i > 1 && n === "span", [`${$n}-ellipsis-overflow-ellipsis`]: i === 1 && a, [`${$n}-ellipsis-overflow-ellipsis-text`]: i === 1 && a && n === "span" }), l = a && i > 1 ? { WebkitLineClamp: i } : {}; return { ellipsisCls: o, ellipsisStyle: l } }, this.renderEllipsisText = t => { const { suffix: n } = t, { children: i } = this.props, { isTruncated: s, expanded: a, ellipsisContent: o } = this.state; return a || !s ? f.createElement("span", { onMouseEnter: this.onHover }, i, n && n.length ? n : null) : f.createElement("span", { onMouseEnter: this.onHover }, o, n) }, this.state = { editable: !1, copied: !1, isOverflowed: !1, ellipsisContent: e.children, expanded: !1, isTruncated: !1, prevChildren: null }, this.wrapperRef = f.createRef(), this.expandRef = f.createRef(), this.copyRef = f.createRef() } componentDidMount() { this.props.ellipsis && this.onResize().then(() => Am(() => this.observerTakingEffect = !0, 1)) } static getDerivedStateFromProps(e, t) { const { prevChildren: n } = t, i = {}; return i.prevChildren = e.children, e.ellipsis && n !== e.children && (i.isOverflowed = !1, i.ellipsisContent = e.children, i.expanded = !1, i.isTruncated = !0), i } componentDidUpdate(e) { this.props.children !== e.children && (this.forceUpdate(), this.props.ellipsis && this.onResize()) } componentWillUnmount() { this.rafId && window.cancelAnimationFrame(this.rafId) } renderOperations() { return f.createElement(f.Fragment, null, this.renderExpandable(), this.renderCopy()) } renderCopy() { var e; const { copyable: t, children: n } = this.props; if (!t) return null; const i = (e = t == null ? void 0 : t.content) !== null && e !== void 0 ? e : n; let s, a = !1; Array.isArray(i) ? (s = "", i.forEach(l => { typeof l == "object" && (a = !0), s += String(l) })) : (typeof i != "object" || (a = !0), s = String(i)), Nt(a, "Content to be copied in Typography is a object, it will case a [object Object] mistake when copy to clipboard."); const o = Object.assign({ content: s, duration: 3 }, typeof t == "object" ? t : null); return f.createElement(Wm, Object.assign({}, o, { forwardRef: this.copyRef })) } renderIcon() { const { icon: e, size: t } = this.props, n = t === "inherit" ? this.context : t; if (!e) return null; const i = n === "small" ? "small" : "default"; return f.createElement("span", { className: `${$n}-icon`, "x-semi-prop": "icon" }, Bn(e) ? f.cloneElement(e, { size: i }) : e) } renderContent() { const e = this.props, { component: t, children: n, className: i, type: s, spacing: a, disabled: o, style: l, ellipsis: u, icon: d, size: h, link: g, heading: m, weight: b } = e, y = wK(e, ["component", "children", "className", "type", "spacing", "disabled", "style", "ellipsis", "icon", "size", "link", "heading", "weight"]), w = Ht(y, ["strong", "editable", "mark", "copyable", "underline", "code", "delete"]), x = h === "inherit" ? this.context : h, S = this.renderIcon(), C = this.getEllipsisOpt(), { ellipsisCls: O, ellipsisStyle: E } = this.getEllipsisStyle(); let v = u ? this.renderEllipsisText(C) : n; const T = F({ [`${$n}-link-text`]: g, [`${$n}-link-underline`]: this.props.underline && g }); v = SK(this.props, f.createElement(f.Fragment, null, S, this.props.link ? f.createElement("span", { className: T }, v) : v)); const I = /^h[1-6]$/, k = Fe(m) && I.test(m), P = F(i, O, { [`${$n}-${s}`]: s && !g, [`${$n}-${x}`]: x, [`${$n}-link`]: g, [`${$n}-disabled`]: o, [`${$n}-${a}`]: a, [`${$n}-${m}`]: k, [`${$n}-${m}-weight-${b}`]: k && b && isNaN(Number(b)) }), N = Object.assign(Object.assign({}, isNaN(Number(b)) ? {} : { fontWeight: b }), l); return f.createElement(Md, Object.assign({ className: P, style: Object.assign(Object.assign({}, N), E), component: t, forwardRef: this.wrapperRef }, w), v, this.renderOperations()) } renderTipWrapper() { const { children: e } = this.props, t = this.showTooltip(), n = this.renderContent(); if (t) { const { type: i, opts: s, renderTooltip: a } = t; return we(a) ? a(e, n) : i.toLowerCase() === "popover" ? f.createElement(kn, Object.assign({ content: e, position: "top" }, s), n) : f.createElement(ln, Object.assign({ content: e, position: "top" }, s), n) } else return n } render() { var e = this; const { size: t } = this.props, n = t === "inherit" ? this.context : t, i = f.createElement(QS.Provider, { value: n }, f.createElement(Ke, { componentName: "Typography" }, s => (this.expandStr = s.expand, this.collapseStr = s.collapse, this.renderTipWrapper()))); return this.props.ellipsis ? f.createElement(As, { onResize: function () { e.observerTakingEffect && e.onResize(...arguments) }, observeParent: !0, observerProperty: rd.Width }, i) : i } } Ta.propTypes = { children: c.node, copyable: c.oneOfType([c.shape({ text: c.string, onCopy: c.func, successTip: c.node, copyTip: c.node }), c.bool]), delete: c.bool, disabled: c.bool, ellipsis: c.oneOfType([c.shape({ rows: c.number, expandable: c.bool, expandText: c.string, onExpand: c.func, suffix: c.string, showTooltip: c.oneOfType([c.shape({ type: c.string, opts: c.object }), c.bool]), collapsible: c.bool, collapseText: c.string, pos: c.oneOf(["end", "middle"]) }), c.bool]), mark: c.bool, underline: c.bool, link: c.oneOfType([c.object, c.bool]), spacing: c.oneOf(qn.SPACING), strong: c.bool, size: c.oneOf(qn.SIZE), type: c.oneOf(qn.TYPE), style: c.object, className: c.string, icon: c.oneOfType([c.node, c.string]), heading: c.string, component: c.string }; Ta.defaultProps = { children: null, copyable: !1, delete: !1, disabled: !1, ellipsis: !1, icon: "", mark: !1, underline: !1, strong: !1, link: !1, type: "primary", spacing: "normal", size: "normal", style: {}, className: "" }; Ta.contextType = QS; let Gd = class extends R.PureComponent { render() { return f.createElement(Ta, Object.assign({ component: "span" }, this.props)) } }; Gd.propTypes = { copyable: c.oneOfType([c.object, c.bool]), delete: c.bool, disabled: c.bool, icon: c.oneOfType([c.node, c.string]), ellipsis: c.oneOfType([c.object, c.bool]), mark: c.bool, underline: c.bool, link: c.oneOfType([c.object, c.bool]), strong: c.bool, type: c.oneOf(qn.TYPE), size: c.oneOf(qn.SIZE), style: c.object, className: c.string, code: c.bool, component: c.string, weight: c.number }; Gd.defaultProps = { copyable: !1, delete: !1, disabled: !1, icon: "", ellipsis: !1, mark: !1, underline: !1, strong: !1, link: !1, type: "primary", style: {}, size: "normal", className: "" }; var EK = function (r, e) { var t = {}; for (var n in r) Object.prototype.hasOwnProperty.call(r, n) && e.indexOf(n) < 0 && (t[n] = r[n]); if (r != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, n = Object.getOwnPropertySymbols(r); i < n.length; i++)e.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(r, n[i]) && (t[n[i]] = r[n[i]]); return t }; let Gm = class extends R.PureComponent { render() { const e = this.props, { heading: t } = e, n = EK(e, ["heading"]), i = qn.HEADING.indexOf(t) !== -1 ? `h${t}` : "h1"; return f.createElement(Ta, Object.assign({ component: i, heading: i }, n)) } }; Gm.propTypes = { copyable: c.oneOfType([c.object, c.bool]), delete: c.bool, disabled: c.bool, ellipsis: c.oneOfType([c.object, c.bool]), mark: c.bool, link: c.oneOfType([c.object, c.bool]), underline: c.bool, strong: c.bool, type: c.oneOf(qn.TYPE), heading: c.oneOf(qn.HEADING), style: c.object, className: c.string, component: c.string, weight: c.oneOfType([c.oneOf(qn.WEIGHT), c.number]) }; Gm.defaultProps = { copyable: !1, delete: !1, disabled: !1, ellipsis: !1, mark: !1, underline: !1, strong: !1, link: !1, type: "primary", heading: 1, style: {}, className: "" }; const _K = Ld.PREFIX; let Yd = class extends R.PureComponent { render() { const { className: e } = this.props, t = F(e, `${_K}-paragraph`); return f.createElement(Ta, Object.assign({ component: "p" }, this.props, { className: t })) } }; Yd.propTypes = { copyable: c.oneOfType([c.object, c.bool]), delete: c.bool, disabled: c.bool, ellipsis: c.oneOfType([c.object, c.bool]), mark: c.bool, link: c.oneOfType([c.object, c.bool]), underline: c.bool, strong: c.bool, type: c.oneOf(qn.TYPE), size: c.oneOf(qn.SIZE), spacing: c.oneOf(qn.SPACING), style: c.object, className: c.string, component: c.string }; Yd.defaultProps = { copyable: !1, delete: !1, disabled: !1, ellipsis: !1, mark: !1, underline: !1, strong: !1, link: !1, type: "primary", size: "normal", spacing: "normal", style: {}, className: "" }; class OK { constructor(e, t, n, i, s) { this.ruleMethods = { "bytes-decimal": a => { const o = ["B", "KB", "MB", "GB", "TB", "PB", "EB", "ZB", "YB"]; let l = 0; for (; a >= 1e3;)a /= 1e3, l++; return `${this.truncatePrecision(a)} ${o[l]}` }, "bytes-binary": a => { const o = ["B", "KiB", "MiB", "GiB", "TiB", "PiB", "EiB", "ZiB", "YiB"]; let l = 0; for (; a >= 1024;)a /= 1024, l++; return `${this.truncatePrecision(a)} ${o[l]}` }, percentages: a => `${this.truncatePrecision(a * 100)}%`, exponential: a => { const l = a.toExponential(this.precision + 2).split("e"); return `${this.truncatePrecision(Number(l[0]))}e${l[1]}` } }, this.truncateMethods = { ceil: Math.ceil, floor: Math.floor, round: Math.round }, this.isDiyParser = typeof s < "u", this.content = e, this.rule = t, this.precision = n, this.truncate = i, this.parser = s } format() { return this.isDiyParser ? this.parser(this.content) : this.rule === "text" ? tp(this.content).map(e => np(e) ? this.truncatePrecision(e) : e).join("") : this.rule === "numbers" ? tp(this.content).filter(e => np(e)).map(e => this.truncatePrecision(e)).join(",") : tp(this.content).map(e => np(e) ? this.ruleMethods[this.rule](Number(e)) : e).join("") } truncatePrecision(e) { const t = this.truncateMethods[this.truncate](Number(e) * Math.pow(10, this.precision)) / Math.pow(10, this.precision), n = t.toString().split("."); if (n.length === 1) return t.toFixed(this.precision); const i = n[1].length; return i < this.precision ? `${n[0]}.${n[1]}${"0".repeat(this.precision - i)}` : t.toString() } } function tp(r) { const e = /(-?[0-9]*\.?[0-9]+([eE]-?[0-9]+)?)|([^-\d\.]+)/g; return r.match(e) || [] } function np(r) { return !(isNaN(Number(r)) || r.replace(/\s+/g, "") === "") } class Ym extends R.PureComponent { formatNodeDFS(e) { return Array.isArray(e) || (e = [e]), e = e.map(t => typeof t == "string" || typeof t == "number" ? new OK(String(t), this.props.rule, this.props.precision, this.props.truncate, this.props.parser).format() : typeof t == "function" ? this.formatNodeDFS(t()) : typeof t == "object" && "children" in t.props ? Object.assign(Object.assign({}, t), { props: Object.assign(Object.assign({}, t.props), { children: this.formatNodeDFS(t.props.children) }) }) : t), e.length === 1 ? e[0] : e } render() { const e = Object.assign({}, this.props); return delete e.rule, delete e.parser, e.children = this.formatNodeDFS(this.props.children), f.createElement(Ta, Object.assign({ component: "span" }, e)) } } Ym.propTypes = { rule: c.oneOf(qn.RULE), precision: c.number, truncate: c.oneOf(qn.TRUNCATE), parser: c.func, copyable: c.oneOfType([c.object, c.bool]), delete: c.bool, disabled: c.bool, icon: c.oneOfType([c.node, c.string]), mark: c.bool, underline: c.bool, link: c.oneOfType([c.object, c.bool]), strong: c.bool, type: c.oneOf(qn.TYPE), size: c.oneOf(qn.SIZE), style: c.object, className: c.string, code: c.bool, component: c.string }; Ym.defaultProps = { rule: "text", precision: 0, truncate: "round", parser: void 0, copyable: !1, delete: !1, icon: "", mark: !1, underline: !1, strong: !1, link: !1, type: "primary", style: {}, size: "normal", className: "" }; const zn = Md; zn.Text = Gd; zn.Title = Gm; zn.Paragraph = Yd; zn.Numeral = Ym; const eE = { PREFIX: `${G}-autocomplete`, PREFIX_OPTION: `${G}-autocomplete-option`, PREFIX_GROUP: `${G}-autocomplete-group` }, Xm = { SIZE: ["small", "large", "default"], POSITION: Ds.POSITION_SET, OPTIONS: ["children", "value"], STATUS: Vo }; var TK = Si, IK = Sr, PK = "[object Number]"; function kK(r) { return typeof r == "number" || IK(r) && TK(r) == PK } var tE = kK; const Zt = _e(tE); class RK extends ve { constructor(e) { super(Object.assign({}, e)), this.isPanelOpen = !1 } init() { this._setDropdownWidth(); const { defaultOpen: e, data: t, defaultValue: n, value: i } = this.getProps(); if (t && t.length) { const a = this._generateList(t); this._adapter.updateOptionList(a) } e && this.openDropdown(); let s; typeof n < "u" && (s = n), typeof i < "u" && (s = i), typeof s < "u" && this.handleValueChange(s) } destroy() { this._adapter.unregisterClickOutsideHandler() } _setDropdownWidth() { const { style: e, dropdownMatchSelectWidth: t } = this.getProps(); let n; t && (e && Zt(e.width) || e && Fe(e.width) && !e.width.includes("%") ? n = e.width : n = this._adapter.getTriggerWidth(), this._adapter.setOptionWrapperWidth(n)) } handleInputClick(e) { this.getStates(); const { disabled: t } = this.getProps(); t || (this.isPanelOpen ? this.closeDropdown() : this.openDropdown()) } openDropdown() { this.isPanelOpen = !0, this._adapter.toggleListVisible(!0), this._setDropdownWidth(), this._adapter.registerClickOutsideHandler(e => this.closeDropdown(e)), this._adapter.notifyDropdownVisibleChange(!0), this._modifyFocusIndexOnPanelOpen() } closeDropdown(e) { this.isPanelOpen = !1, this._adapter.toggleListVisible(!1), this._adapter.unregisterClickOutsideHandler(), this._adapter.notifyDropdownVisibleChange(!1) } _generateList(e) { const { renderItem: t } = this.getProps(), n = []; return e && e.length && e.forEach((i, s) => { const a = String(new Date().getTime()) + s; let o = {}; Fe(i) || Zt(i) ? o = { value: i, key: a, label: i, show: !0 } : an(i) && !st(i.value) && (o = Object.assign({ show: !0 }, i)), t && typeof t == "function" && (o.label = t(i)), n.push(o) }), n } handleSearch(e) { this._adapter.updateInputValue(e), this._adapter.notifySearch(e), this._adapter.notifyChange(e), this._modifyFocusIndex(e), this.isPanelOpen || this.openDropdown() } handleSelect(e, t) { const { renderSelectedItem: n } = this.getProps(); let i = ""; n && typeof n == "function" ? (i = n(e), Nt(typeof i != "string", "Warning: [Semi AutoComplete] renderSelectedItem must return string, please check your function return")) : i = e.value, this._isControlledComponent() ? (this.closeDropdown(), this.notifySelect(e)) : (this._adapter.updateInputValue(i), this.updateSelection(e), this.notifySelect(e), this.closeDropdown()), this._adapter.notifyChange(i), this._adapter.updateFocusIndex(t) } updateSelection(e) { const t = new Map; e && t.set(e.label, e), this._adapter.updateSelection(t) } notifySelect(e) { this._backwardLabelInValue() ? this._adapter.notifySelect(e) : this._adapter.notifySelect(e.value) } _backwardLabelInValue() { const e = this.getProps(); let { onSelectWithObject: t } = e; return t } handleDataChange(e) { const t = this._generateList(e); this._adapter.updateOptionList(t), this._adapter.rePositionDropdown() } handleValueChange(e) { let { data: t, defaultActiveFirstOption: n } = this.getProps(), i = ""; this._backwardLabelInValue() && Object.prototype.toString.call(e) === "[object Object]" ? i = e.value : i = e; let s = this._getRenderSelectedItem(); const a = this._generateList(t); let o = a.length ? a.filter(h => s(h) === i) : []; const l = o.length, u = a.findIndex(h => s(h) === i); let d = ""; if (l) o = o[0], d = s(o); else { const h = this._backwardLabelInValue() ? e : { label: i, value: i }; d = s(h) } this._adapter.updateInputValue(d), this.updateSelection(l ? o : null), u === -1 && n ? this._adapter.updateFocusIndex(0) : this._adapter.updateFocusIndex(u) } _modifyFocusIndex(e) { let { focusIndex: t } = this.getStates(), { data: n, defaultActiveFirstOption: i } = this.getProps(), s = -1; if (e) { let a = this._getRenderSelectedItem(); s = this._generateList(n).findIndex(l => a(l) === e) } s === -1 && i ? t !== 0 && this._adapter.updateFocusIndex(0) : s !== t && this._adapter.updateFocusIndex(s) } _modifyFocusIndexOnPanelOpen() { let { inputValue: e } = this.getStates(); this._modifyFocusIndex(e) } _getRenderSelectedItem() { let { renderSelectedItem: e } = this.getProps(); return typeof e > "u" && (e = t => t == null ? void 0 : t.value), e } handleClear() { this._adapter.notifyClear() } bindKeyBoardEvent() { this._keydownHandler = e => { this._handleKeyDown(e) }, this._adapter.registerKeyDown(this._keydownHandler) } _handleKeyDown(e) { const t = e.keyCode; switch (this.getStates(), t) { case Tn.UP: e.preventDefault(), this._handleArrowKeyDown(-1); break; case Tn.DOWN: e.preventDefault(), this._handleArrowKeyDown(1); break; case Tn.ENTER: e.preventDefault(), this._handleEnterKeyDown(); break; case Tn.ESC: this.closeDropdown(); break; case Tn.TAB: this.closeDropdown(); break }this._adapter.notifyKeyDown(e) } _getEnableFocusIndex(e) { const { focusIndex: t, options: n } = this.getStates(), i = n.filter(o => o.show), s = i.length; let a = t + e; if (a < 0 && (a = s - 1), a >= s && (a = 0), e > 0) { let o = -1; for (let l = 0; l < i.length && (!i[l].disabled && (o = l), !(o >= a)); l++); a = o } else { let o = i.length; for (let l = s - 1; l >= 0 && (!i[l].disabled && (o = l), !(o <= a)); l--); a = o } this._adapter.updateFocusIndex(a), this._adapter.updateScrollTop(a) } _handleArrowKeyDown(e) { const { visible: t } = this.getStates(); t ? this._getEnableFocusIndex(e) : this.openDropdown() } _handleEnterKeyDown() { const { visible: e, options: t, focusIndex: n } = this.getStates(); if (!e) this.openDropdown(); else if (n !== void 0 && n !== -1 && t.length !== 0) { const s = t.filter(a => a.show)[n]; this.handleSelect(s, n) } else this.closeDropdown() } handleOptionMouseEnter(e) { this._adapter.updateFocusIndex(e) } handleFocus(e) { this.bindKeyBoardEvent(), this._adapter.notifyFocus(e) } handleBlur(e) { this._persistEvent(e), this._adapter.notifyBlur(e) } } const DK = `${G}-spin`, AK = { PREFIX: DK }, NK = { SIZE: ["small", "middle", "large"] }; class qm extends ve { static get spinDefaultAdapter() { return { getProp: () => { }, setLoading: e => { } } } constructor(e) { super(Object.assign(Object.assign({}, qm.spinDefaultAdapter), e)) } updateLoadingIfNeedDelay() { const { spinning: e, delay: t } = this._adapter.getProps(), { delay: n } = this._adapter.getStates(); if (n) { const i = this; this._timer = setTimeout(() => { i._adapter.setState({ loading: e, delay: 0 }) }, t) } } destroy() { this._timer && (clearTimeout(this._timer), this._timer = null) } } var FK = function (r, e) { var t = {}; for (var n in r) Object.prototype.hasOwnProperty.call(r, n) && e.indexOf(n) < 0 && (t[n] = r[n]); if (r != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, n = Object.getOwnPropertySymbols(r); i < n.length; i++)e.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(r, n[i]) && (t[n[i]] = r[n[i]]); return t }; let vx = -1; function nE() { let r = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}; const { id: e, className: t } = r, n = FK(r, ["id", "className"]); let i = e; ze(i) && (vx++, i = vx); const s = `linearGradient-${i}`; return f.createElement("svg", Object.assign({}, n, { className: t, width: "48", height: "48", viewBox: "0 0 36 36", version: "1.1", xmlns: "http://www.w3.org/2000/svg", "aria-hidden": !0, "data-icon": "spin" }), f.createElement("defs", null, f.createElement("linearGradient", { x1: "0%", y1: "100%", x2: "100%", y2: "100%", id: s }, f.createElement("stop", { stopColor: "currentColor", stopOpacity: "0", offset: "0%" }), f.createElement("stop", { stopColor: "currentColor", stopOpacity: "0.50", offset: "39.9430698%" }), f.createElement("stop", { stopColor: "currentColor", offset: "100%" }))), f.createElement("g", { stroke: "none", strokeWidth: "1", fill: "none", fillRule: "evenodd" }, f.createElement("rect", { fillOpacity: "0.01", fill: "none", x: "0", y: "0", width: "36", height: "36" }), f.createElement("path", { d: "M34,18 C34,9.163444 26.836556,2 18,2 C11.6597233,2 6.18078805,5.68784135 3.59122325,11.0354951", stroke: `url(#${s})`, strokeWidth: "4", strokeLinecap: "round" }))) } var $K = function (r, e) { var t = {}; for (var n in r) Object.prototype.hasOwnProperty.call(r, n) && e.indexOf(n) < 0 && (t[n] = r[n]); if (r != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, n = Object.getOwnPropertySymbols(r); i < n.length; i++)e.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(r, n[i]) && (t[n[i]] = r[n[i]]); return t }; const Ws = AK.PREFIX; class yi extends de { constructor(e) { super(e), this.foundation = new qm(this.adapter), this.state = { delay: e.delay, loading: !0 } } static getDerivedStateFromProps(e) { return e.delay ? e.spinning === !1 ? { delay: 0, loading: !1 } : { delay: e.delay } : { loading: e.spinning } } get adapter() { return Object.assign(Object.assign({}, super.adapter), { setLoading: e => { this.setState({ loading: e }) } }) } componentWillUnmount() { this.foundation.destroy() } renderSpin() { const { indicator: e, tip: t } = this.props, { loading: n } = this.state; return n ? f.createElement("div", { className: `${Ws}-wrapper` }, e ? f.createElement("div", { className: `${Ws}-animate`, "x-semi-prop": "indicator" }, e) : f.createElement(nE, null), t ? f.createElement("div", { "x-semi-prop": "tip" }, t) : null) : null } render() { this.foundation.updateLoadingIfNeedDelay(); const e = this.props, { children: t, style: n, wrapperClassName: i, childStyle: s, size: a } = e, o = $K(e, ["children", "style", "wrapperClassName", "childStyle", "size"]), { loading: l } = this.state, u = F(Ws, i, { [`${Ws}-${a}`]: a, [`${Ws}-block`]: t, [`${Ws}-hidden`]: !l }); return f.createElement("div", Object.assign({ className: u, style: n }, this.getDataAttr(o)), this.renderSpin(), f.createElement("div", { className: `${Ws}-children`, style: s, "x-semi-prop": "children" }, t)) } } yi.propTypes = { size: c.oneOf(NK.SIZE), spinning: c.bool, children: c.node, indicator: c.node, delay: c.number, tip: c.node, wrapperClassName: c.string, childStyle: c.object, style: c.object }; yi.defaultProps = { size: "middle", spinning: !0, children: null, indicator: null, delay: 0 }; const Xd = { PREFIX: `${G}-input` }, Hs = { SIZE: ["small", "large", "default"], DEFAULT_SIZE: "default", STATUS: ["default", "error", "warning", "success"], CLEARBTN_CLICKED_EVENT_FLAG: "__fromClearBtn", MODE: ["password"] }, LK = {}; function rE(r) { const { value: e, maxLength: t, getValueLength: n } = r; if (we(n)) { let i = 0, s = e.length; for (; i < s;) { const a = i + Math.floor((s - i) / 2), o = e.slice(0, a + 1); n(o) > t ? s = a : i = a + 1 } return e.slice(0, i) } else return e.slice(0, t) } let MK = class iE extends ve { static get inputDefaultAdapter() { return { notifyChange: z, setValue: z } } constructor(e) { super(Object.assign(Object.assign({}, iE.inputDefaultAdapter), e)) } destroy() { this._timer && (clearTimeout(this._timer), this._timer = null) } setDisable() { } setValue(e) { this._adapter.setValue(e) } handleChange(e, t) { const { maxLength: n, minLength: i, getValueLength: s } = this._adapter.getProps(); let a = e; n && we(s) && (a = this.handleVisibleMaxLength(e)), i && we(s) && this.handleVisibleMinLength(a), this._isControlledComponent() ? this._adapter.notifyChange(a, t) : (this._adapter.setValue(a), this._adapter.notifyChange(a, t)) } handleVisibleMinLength(e) { const { minLength: t, getValueLength: n } = this._adapter.getProps(), { minLength: i } = this._adapter.getStates(); if (Zt(t) && t >= 0 && we(n) && Fe(e)) { const s = n(e); if (s < t) { const a = e.length + (t - s); a !== i && this._adapter.setMinLength(a) } else i !== t && this._adapter.setMinLength(t) } } handleVisibleMaxLength(e) { const { maxLength: t, getValueLength: n } = this._adapter.getProps(); return Zt(t) && t >= 0 && we(n) && Fe(e) && n(e) > t ? (console.warn("[Semi Input] The input character is truncated because the input length exceeds the maximum length limit"), this.handleTruncateValue(e, t)) : e } handleTruncateValue(e, t) { const { getValueLength: n } = this._adapter.getProps(); return rE({ value: e, maxLength: t, getValueLength: n }) } handleClear(e) { let t = e; const n = ""; this._isControlledComponent("value") ? this._adapter.setState({ isFocus: !1 }) : this._adapter.setState({ value: "", isFocus: !1 }), (!t || typeof t != "object") && (t = {}), yr(t, Hs.CLEARBTN_CLICKED_EVENT_FLAG, !0), this._adapter.notifyChange(n, t), this._adapter.notifyClear(t), t && this.stopPropagation(t) } handleClick(e) { const { disabled: t } = this._adapter.getProps(), { isFocus: n } = this._adapter.getStates(); t || n || this._adapter.isEventTarget(e) && (this._adapter.focusInput(), this._adapter.toggleFocusing(!0)) } handleModeChange(e) { e === "password" ? this._adapter.setEyeClosed(!0) : this._adapter.setEyeClosed(!1) } handleClickEye(e) { const t = this._adapter.getState("eyeClosed"); this._adapter.focusInput(), this._adapter.toggleFocusing(!0), this._adapter.setEyeClosed(!t) } handleInputType(e) { const t = this._adapter.getProp("mode"), n = this._adapter.getState("eyeClosed"); return t === "password" ? n ? "password" : "text" : e } handleMouseDown(e) { e.preventDefault() } handleMouseUp(e) { e.preventDefault() } handleBlur(e) { const { value: t } = this.getStates(); this._adapter.toggleFocusing(!1), this._adapter.notifyBlur(t, e) } handleFocus(e) { const { value: t } = this.getStates(); this._adapter.toggleFocusing(!0), this._adapter.notifyFocus(t, e) } handleInput(e) { this._adapter.notifyInput(e) } handleKeyDown(e) { this._adapter.notifyKeyDown(e) } handleKeyUp(e) { this._adapter.notifyKeyUp(e) } handleKeyPress(e) { this._adapter.notifyKeyPress(e), e.key === Um && this._adapter.notifyEnterPress(e) } isAllowClear() { const { value: e, isFocus: t, isHovering: n } = this._adapter.getStates(), { showClear: i, disabled: s, showClearIgnoreDisabled: a } = this._adapter.getProps(); return e && i && (!s || a) && (t || n) } handleClickPrefixOrSuffix(e) { const { disabled: t } = this._adapter.getProps(), { isFocus: n } = this._adapter.getStates(); !t && !n && (this._adapter.focusInput(), this._adapter.toggleFocusing(!0)) } handlePreventMouseDown(e) { e && we(e.preventDefault) && e.preventDefault() } handleModeEnterPress(e) { ["Enter", " "].includes(e == null ? void 0 : e.key) && (this.handlePreventMouseDown(e), this.handleClickEye(e)) } }; var jK = function (r, e) { var t = {}; for (var n in r) Object.prototype.hasOwnProperty.call(r, n) && e.indexOf(n) < 0 && (t[n] = r[n]); if (r != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, n = Object.getOwnPropertySymbols(r); i < n.length; i++)e.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(r, n[i]) && (t[n[i]] = r[n[i]]); return t }; const pt = Xd.PREFIX, VK = Hs.SIZE, BK = Hs.STATUS, zK = Hs.MODE; class Zm extends de { constructor(e) { super(e), this.handleClear = n => { this.foundation.handleClear(n) }, this.handleClick = n => { this.foundation.handleClick(n) }, this.handleMouseOver = n => { this.setState({ isHovering: !0 }) }, this.handleMouseLeave = n => { this.setState({ isHovering: !1 }) }, this.handleModeChange = n => { this.foundation.handleModeChange(n) }, this.handleClickEye = n => { this.foundation.handleClickEye(n) }, this.handleMouseDown = n => { this.foundation.handleMouseDown(n) }, this.handleMouseUp = n => { this.foundation.handleMouseUp(n) }, this.handleModeEnterPress = n => { this.foundation.handleModeEnterPress(n) }, this.handleClickPrefixOrSuffix = n => { this.foundation.handleClickPrefixOrSuffix(n) }, this.handlePreventMouseDown = n => { this.foundation.handlePreventMouseDown(n) }; const t = "value" in e ? e.value : e.defaultValue; this.state = { value: t, cachedValue: e.value, disabled: !1, props: {}, isFocus: !1, isHovering: !1, eyeClosed: e.mode === "password", minLength: e.minLength }, this.inputRef = f.createRef(), this.prefixRef = f.createRef(), this.suffixRef = f.createRef(), this.foundation = new MK(this.adapter) } get adapter() { return Object.assign(Object.assign({}, super.adapter), { setValue: e => this.setState({ value: e }), setEyeClosed: e => this.setState({ eyeClosed: e }), toggleFocusing: e => { this.setState({ isFocus: e }) }, focusInput: () => { const { preventScroll: e } = this.props, t = this.inputRef && this.inputRef.current; t && t.focus({ preventScroll: e }) }, toggleHovering: e => this.setState({ isHovering: e }), getIfFocusing: () => this.state.isFocus, notifyChange: (e, t) => this.props.onChange(e, t), notifyBlur: (e, t) => this.props.onBlur(t), notifyFocus: (e, t) => this.props.onFocus(t), notifyInput: e => this.props.onInput(e), notifyKeyPress: e => this.props.onKeyPress(e), notifyKeyDown: e => this.props.onKeyDown(e), notifyKeyUp: e => this.props.onKeyUp(e), notifyEnterPress: e => this.props.onEnterPress(e), notifyClear: e => this.props.onClear(e), setMinLength: e => this.setState({ minLength: e }), isEventTarget: e => e && e.target === e.currentTarget }) } static getDerivedStateFromProps(e, t) { const n = {}; return e.value !== t.cachedValue && (n.value = e.value, n.cachedValue = e.value), n } componentDidUpdate(e) { const { mode: t } = this.props; e.mode !== t && this.handleModeChange(t) } componentDidMount() { const { disabled: e, autoFocus: t, preventScroll: n } = this.props; !e && (t || this.props.autofocus) && this.inputRef.current.focus({ preventScroll: n }) } renderPrepend() { const { addonBefore: e } = this.props; if (e) { const t = F({ [`${pt}-prepend`]: !0, [`${pt}-prepend-text`]: e && Fe(e), [`${pt}-prepend-icon`]: Bn(e) }); return f.createElement("div", { className: t, "x-semi-prop": "addonBefore" }, e) } return null } renderAppend() { const { addonAfter: e } = this.props; if (e) { const t = F({ [`${pt}-append`]: !0, [`${pt}-append-text`]: e && Fe(e), [`${pt}-append-icon`]: Bn(e) }); return f.createElement("div", { className: t, "x-semi-prop": "addonAfter" }, e) } return null } renderClearBtn() { const e = F(`${pt}-clearbtn`), { clearIcon: t } = this.props; return this.foundation.isAllowClear() ? f.createElement("div", { className: e, onMouseDown: this.handleClear }, t || f.createElement(us, null)) : null } renderModeBtn() { const { eyeClosed: e } = this.state, { mode: t, disabled: n } = this.props, i = F(`${pt}-modebtn`), s = e ? f.createElement(uH, null) : f.createElement(WS, null), a = t === "password" && !n, o = e ? "Show password" : "Hidden password"; return a ? f.createElement("div", { role: "button", tabIndex: 0, "aria-label": o, className: i, onClick: this.handleClickEye, onMouseDown: this.handleMouseDown, onMouseUp: this.handleMouseUp, onKeyPress: this.handleModeEnterPress }, s) : null } renderPrefix() { const { prefix: e, insetLabel: t, insetLabelId: n } = this.props, i = e || t; if (!i) return null; const s = F({ [`${pt}-prefix`]: !0, [`${pt}-inset-label`]: t, [`${pt}-prefix-text`]: i && Fe(i), [`${pt}-prefix-icon`]: Bn(i) }); return f.createElement("div", { className: s, onMouseDown: this.handlePreventMouseDown, onClick: this.handleClickPrefixOrSuffix, id: n, "x-semi-prop": "prefix,insetLabel" }, i) } renderSuffix(e) { const { suffix: t, hideSuffix: n } = this.props; if (!t) return null; const i = F({ [`${pt}-suffix`]: !0, [`${pt}-suffix-text`]: t && Fe(t), [`${pt}-suffix-icon`]: Bn(t), [`${pt}-suffix-hidden`]: e && !!n }); return f.createElement("div", { className: i, onMouseDown: this.handlePreventMouseDown, onClick: this.handleClickPrefixOrSuffix, "x-semi-prop": "suffix" }, t) } getInputRef() { const { forwardRef: e } = this.props; if (!st(e)) { if (typeof e == "function") return t => { e(t), this.inputRef = { current: t } }; if (Object.prototype.toString.call(e) === "[object Object]") return this.inputRef = e, e } return this.inputRef } render() { const e = this.props, { addonAfter: t, addonBefore: n, autoFocus: i, clearIcon: s, className: a, disabled: o, defaultValue: l, placeholder: u, prefix: d, mode: h, insetLabel: g, insetLabelId: m, validateStatus: b, type: y, readonly: w, size: x, suffix: S, style: C, showClear: O, onEnterPress: E, onClear: v, hideSuffix: T, inputStyle: I, forwardRef: k, maxLength: P, getValueLength: N, preventScroll: M, borderless: B, showClearIgnoreDisabled: K, onlyBorder: U } = e, W = jK(e, ["addonAfter", "addonBefore", "autoFocus", "clearIcon", "className", "disabled", "defaultValue", "placeholder", "prefix", "mode", "insetLabel", "insetLabelId", "validateStatus", "type", "readonly", "size", "suffix", "style", "showClear", "onEnterPress", "onClear", "hideSuffix", "inputStyle", "forwardRef", "maxLength", "getValueLength", "preventScroll", "borderless", "showClearIgnoreDisabled", "onlyBorder"]), { value: Z, isFocus: J, minLength: ee } = this.state, $ = this.foundation.isAllowClear(), pe = Bn(S), re = this.getInputRef(), j = `${pt}-wrapper`, ae = F(j, a, { [`${pt}-wrapper__with-prefix`]: d || g, [`${pt}-wrapper__with-suffix`]: S, [`${pt}-wrapper__with-suffix-hidden`]: $ && !!T, [`${pt}-wrapper__with-suffix-icon`]: pe, [`${pt}-wrapper__with-append`]: n, [`${pt}-wrapper__with-prepend`]: t, [`${pt}-wrapper__with-append-only`]: n && !t, [`${pt}-wrapper__with-prepend-only`]: !n && t, [`${j}-readonly`]: w, [`${j}-disabled`]: o, [`${j}-warning`]: b === "warning", [`${j}-error`]: b === "error", [`${j}-focus`]: J, [`${j}-clearable`]: O, [`${j}-modebtn`]: h === "password", [`${j}-hidden`]: y === "hidden", [`${j}-${x}`]: x, [`${pt}-borderless`]: B, [`${pt}-only_border`]: U != null }), be = F(pt, { [`${pt}-${x}`]: x, [`${pt}-disabled`]: o, [`${pt}-sibling-clearbtn`]: this.foundation.isAllowClear(), [`${pt}-sibling-modebtn`]: h === "password" }), fe = Z ?? "", Ce = Object.assign(Object.assign({}, W), { style: I, className: be, disabled: o, readOnly: w, type: this.foundation.handleInputType(y), placeholder: u, onInput: te => this.foundation.handleInput(te), onChange: te => this.foundation.handleChange(te.target.value, te), onFocus: te => this.foundation.handleFocus(te), onBlur: te => this.foundation.handleBlur(te), onKeyUp: te => this.foundation.handleKeyUp(te), onKeyDown: te => this.foundation.handleKeyDown(te), onKeyPress: te => this.foundation.handleKeyPress(te), value: fe }); we(N) || (Ce.maxLength = P), ee && (Ce.minLength = ee), b === "error" && (Ce["aria-invalid"] = "true"); let ue = Object.assign({}, C); return U !== void 0 && (ue = Object.assign({ borderWidth: U }, C)), f.createElement("div", { className: ae, style: ue, onMouseEnter: te => this.handleMouseOver(te), onMouseLeave: te => this.handleMouseLeave(te), onClick: te => this.handleClick(te) }, this.renderPrepend(), this.renderPrefix(), f.createElement("input", Object.assign({}, Ce, { ref: re })), this.renderClearBtn(), this.renderSuffix($), this.renderModeBtn(), this.renderAppend()) } } Zm.propTypes = { "aria-label": c.string, "aria-labelledby": c.string, "aria-invalid": c.bool, "aria-errormessage": c.string, "aria-describedby": c.string, "aria-required": c.bool, addonBefore: c.node, addonAfter: c.node, clearIcon: c.node, prefix: c.node, suffix: c.node, mode: c.oneOf(zK), value: c.any, defaultValue: c.any, disabled: c.bool, readonly: c.bool, autoFocus: c.bool, type: c.string, showClear: c.bool, hideSuffix: c.bool, placeholder: c.any, size: c.oneOf(VK), className: c.string, style: c.object, validateStatus: c.oneOf(BK), onClear: c.func, onChange: c.func, onBlur: c.func, onFocus: c.func, onInput: c.func, onKeyDown: c.func, onKeyUp: c.func, onKeyPress: c.func, onEnterPress: c.func, insetLabel: c.node, insetLabelId: c.string, inputStyle: c.object, getValueLength: c.func, preventScroll: c.bool, borderless: c.bool }; Zm.defaultProps = { addonBefore: "", addonAfter: "", prefix: "", suffix: "", readonly: !1, type: "text", showClear: !1, hideSuffix: !1, placeholder: "", size: "default", className: "", onClear: z, onChange: z, onBlur: z, onFocus: z, onInput: z, onKeyDown: z, onKeyUp: z, onKeyPress: z, onEnterPress: z, validateStatus: "default", borderless: !1 }; const xr = f.forwardRef((r, e) => f.createElement(Zm, Object.assign({}, r, { forwardRef: e }))); var HK = function (r, e) { var t = {}; for (var n in r) Object.prototype.hasOwnProperty.call(r, n) && e.indexOf(n) < 0 && (t[n] = r[n]); if (r != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, n = Object.getOwnPropertySymbols(r); i < n.length; i++)e.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(r, n[i]) && (t[n[i]] = r[n[i]]); return t }; class Ia extends f.PureComponent { render() { const e = this.props, { triggerRender: t, componentName: n } = e, i = HK(e, ["triggerRender", "componentName"]); return t(Object.assign({}, i)) } } Ia.propTypes = { triggerRender: c.func.isRequired, componentName: c.string, componentProps: c.object, value: c.any, inputValue: c.string, placeholder: c.oneOfType([c.string, c.array]), className: c.string, style: c.object }; const KK = { PREFIX: `${G}-highlight` }, UK = r => r.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&"); class WK extends ve { constructor(e) { super(Object.assign({}, e)), this.findAll = t => { let { autoEscape: n = !0, caseSensitive: i = !1, searchWords: s, sourceString: a } = t; Fe(s) && (s = [s]); const o = this.findChunks({ autoEscape: n, caseSensitive: i, searchWords: s, sourceString: a }), l = this.combineChunks({ chunks: o }); return this.fillInChunks({ chunksToHighlight: l, totalLength: a ? a.length : 0 }) }, this.findChunks = t => { let { autoEscape: n, caseSensitive: i, searchWords: s, sourceString: a } = t; return s.map(o => typeof o == "string" ? { text: o } : o).filter(o => o.text).reduce((o, l) => { let u = l.text; n && (u = UK(u)); const d = new RegExp(u, i ? "g" : "gi"); let h; for (; h = d.exec(a);) { const g = h.index, m = d.lastIndex; m > g && o.push({ highlight: !0, start: g, end: m, className: l.className, style: l.style }), h.index === d.lastIndex && d.lastIndex++ } return o }, []) }, this.combineChunks = t => { let { chunks: n } = t; return n.sort((i, s) => i.start - s.start).reduce((i, s) => { if (i.length === 0) return [s]; { const a = i.pop(); if (s.start <= a.end) { const o = Math.max(a.end, s.end); i.push({ highlight: !0, start: a.start, end: o, className: a.className || s.className, style: Object.assign(Object.assign({}, a.style), s.style) }) } else i.push(a, s); return i } }, []) }, this.fillInChunks = t => { let { chunksToHighlight: n, totalLength: i } = t; const s = [], a = (o, l, u, d, h) => { l - o > 0 && s.push({ start: o, end: l, highlight: u, className: d, style: h }) }; if (n.length === 0) a(0, i, !1); else { let o = 0; n.forEach(l => { a(o, l.start, !1), a(l.start, l.end, !0, l.className, l.style), o = l.end }), a(o, i, !1) } return s } } } const GK = KK.PREFIX; class vc extends R.PureComponent { constructor() { super(...arguments), this.getHighLightTextHTML = e => { let { sourceString: t = "", searchWords: n = [], option: i = { autoEscape: !0, caseSensitive: !1 } } = e; const s = new WK().findAll(Object.assign({ sourceString: t, searchWords: n }, i)), a = i.highlightTag || "mark", o = i.highlightClassName || "", l = i.highlightStyle || {}; return s.map((u, d) => { const { end: h, start: g, highlight: m, style: b, className: y } = u, w = t.substr(g, h - g); return m ? f.createElement(a, { style: Object.assign(Object.assign({}, l), b), className: `${o} ${y || ""}`.trim(), key: w + d }, w) : w }) } } render() { const { searchWords: e, sourceString: t, component: n, highlightClassName: i, highlightStyle: s, caseSensitive: a, autoEscape: o } = this.props, l = F({ [`${GK}-tag`]: !0 }, i), u = { highlightTag: n, highlightClassName: l, highlightStyle: s, caseSensitive: a, autoEscape: o }; return this.getHighLightTextHTML({ sourceString: t, searchWords: e, option: u }) } } vc.propTypes = { style: c.object, className: c.string, autoEscape: c.bool, caseSensitive: c.bool, sourceString: c.string, searchWords: c.arrayOf(c.string), highlightStyle: c.object, highlightClassName: c.string, component: c.string }; vc.defaultProps = { component: "mark", autoEscape: !0, caseSensitive: !1, sourceString: "" }; var xx = function (r, e) { var t = {}; for (var n in r) Object.prototype.hasOwnProperty.call(r, n) && e.indexOf(n) < 0 && (t[n] = r[n]); if (r != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, n = Object.getOwnPropertySymbols(r); i < n.length; i++)e.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(r, n[i]) && (t[n[i]] = r[n[i]]); return t }; let xc = class extends R.PureComponent { onClick(e, t) { var { value: n, label: i, children: s } = e, a = xx(e, ["value", "label", "children"]); const { props: o } = this; o.disabled || o.onSelect(Object.assign(Object.assign({}, a), { value: n, label: i || s }), t) } renderOptionContent(e) { let { children: t, inputValue: n, prefixCls: i } = e; return Fe(t) && n ? f.createElement(vc, { searchWords: [n], sourceString: t, highlightClassName: `${i}-keyword` }) : t } render() { const e = this.props, { children: t, disabled: n, value: i, selected: s, label: a, empty: o, emptyContent: l, onSelect: u, focused: d, showTick: h, className: g, style: m, onMouseEnter: b, prefixCls: y, renderOptionItem: w, inputValue: x } = e, S = xx(e, ["children", "disabled", "value", "selected", "label", "empty", "emptyContent", "onSelect", "focused", "showTick", "className", "style", "onMouseEnter", "prefixCls", "renderOptionItem", "inputValue"]), C = F(y, { [`${y}-disabled`]: n, [`${y}-selected`]: s, [`${y}-focused`]: d, [`${y}-empty`]: o, [g]: g }), O = F([`${y}-icon`]); return o ? l === null ? null : f.createElement(Ke, { componentName: "Select" }, E => f.createElement("div", { className: C, "x-semi-prop": "emptyContent" }, l || E.emptyText)) : typeof w == "function" ? w(Object.assign({ disabled: n, focused: d, selected: s, style: m, label: a, value: i, inputValue: x, onMouseEnter: E => b(E), onClick: E => this.onClick(Object.assign({ value: i, label: a, children: t }, S), E) }, S)) : f.createElement("div", { className: C, onClick: E => { this.onClick(Object.assign({ value: i, label: a, children: t }, S), E) }, onMouseEnter: E => b && b(E), role: "option", "aria-selected": s ? "true" : "false", "aria-disabled": n ? "true" : "false", style: m }, h ? f.createElement("div", { className: O }, f.createElement(ga, null)) : null, Fe(t) ? f.createElement("div", { className: `${y}-text` }, this.renderOptionContent({ children: t, inputValue: x, prefixCls: y })) : t) } }; xc.isSelectOption = !0; xc.propTypes = { children: c.node, disabled: c.bool, value: c.oneOfType([c.string, c.number]), selected: c.bool, label: c.node, empty: c.bool, emptyContent: c.node, onSelect: c.func, focused: c.bool, showTick: c.bool, className: c.string, style: c.object, onMouseEnter: c.func, prefixCls: c.string, renderOptionItem: c.func, inputValue: c.string }; xc.defaultProps = { prefixCls: eE.PREFIX_OPTION }; const ms = eE.PREFIX, YK = Xm.SIZE, XK = Xm.POSITION, qK = Xm.STATUS; class So extends de {
  constructor(e) {
    super(e), this.onSelect = (n, i, s) => { this.foundation.handleSelect(n, i) }, this.onSearch = n => { this.foundation.handleSearch(n) }, this.onBlur = n => this.foundation.handleBlur(n), this.onFocus = n => this.foundation.handleFocus(n), this.onInputClear = () => this.foundation.handleClear(), this.handleInputClick = n => this.foundation.handleInputClick(n), this.foundation = new RK(this.adapter); const t = 1; this.state = { dropdownMinWidth: null, inputValue: "", options: [], visible: !1, focusIndex: e.defaultActiveFirstOption ? 0 : -1, selection: new Map, rePosKey: t }, this.triggerRef = f.createRef(), this.optionsRef = f.createRef(), this.clickOutsideHandler = null, this.optionListId = "", Nt("triggerRender" in this.props && typeof this.props.triggerRender == "function", `[Semi AutoComplete]
            - If you are using the following props: 'suffix', 'prefix', 'showClear', 'validateStatus', and 'size',
            please notice that they will be removed in the next major version.
            Please use 'componentProps' to retrieve these props instead.
            - If you are using 'onBlur', 'onFocus', please try to avoid using them and look for changes in the future.`)
  } get adapter() { const e = { registerKeyDown: t => { const n = { onKeyDown: t }; this.setState({ keyboardEventSet: n }) }, unregisterKeyDown: t => { this.setState({ keyboardEventSet: {} }) }, updateFocusIndex: t => { this.setState({ focusIndex: t }) }, updateScrollTop: t => { let n; n = `.${ms}-option-selected`, t !== void 0 && (n = `.${ms}-option:nth-child(${t + 1})`); let i = document.querySelector(`#${ms}-${this.optionListId} ${n}`); if (Array.isArray(i) && (i = i[0]), i) { const s = i.parentNode; s.scrollTop = i.offsetTop - s.offsetTop - s.clientHeight / 2 + i.clientHeight / 2 } } }; return Object.assign(Object.assign(Object.assign({}, super.adapter), e), { getTriggerWidth: () => { const t = this.triggerRef.current; return t && t.getBoundingClientRect().width }, setOptionWrapperWidth: t => { this.setState({ dropdownMinWidth: t }) }, updateInputValue: t => { this.setState({ inputValue: t }) }, toggleListVisible: t => { this.setState({ visible: t }) }, updateOptionList: t => { this.setState({ options: t }) }, updateSelection: t => { this.setState({ selection: t }) }, notifySearch: t => { this.props.onSearch(t) }, notifyChange: t => { this.props.onChange(t) }, notifySelect: t => { this.props.onSelect(t) }, notifyDropdownVisibleChange: t => { this.props.onDropdownVisibleChange(t) }, notifyClear: () => { this.props.onClear() }, notifyFocus: t => { this.props.onFocus(t) }, notifyBlur: t => { this.props.onBlur(t) }, notifyKeyDown: t => { this.props.onKeyDown(t) }, rePositionDropdown: () => { let { rePosKey: t } = this.state; t = t + 1, this.setState({ rePosKey: t }) }, registerClickOutsideHandler: t => { const n = i => { const s = this.optionsRef && this.optionsRef.current, a = this.triggerRef && this.triggerRef.current, o = lr.findDOMNode(s), l = i.target, u = i.composedPath && i.composedPath() || [l]; o && (!o.contains(l) || !o.contains(l.parentNode)) && a && !a.contains(l) && !(u.includes(a) || u.includes(o)) && t(i) }; this.clickOutsideHandler = n, document.addEventListener("mousedown", n, !1) }, unregisterClickOutsideHandler: () => { this.clickOutsideHandler && document.removeEventListener("mousedown", this.clickOutsideHandler, !1) } }) } componentDidMount() { this.foundation.init(), this.optionListId = zi() } componentWillUnmount() { this.foundation.destroy() } componentDidUpdate(e, t) { ke(this.props.data, e.data) || this.foundation.handleDataChange(this.props.data), this.props.value !== e.value && this.foundation.handleValueChange(this.props.value) } renderInput() { const { size: e, prefix: t, insetLabel: n, insetLabelId: i, suffix: s, placeholder: a, style: o, className: l, showClear: u, disabled: d, triggerRender: h, validateStatus: g, autoFocus: m, value: b, id: y, clearIcon: w } = this.props, { inputValue: x, keyboardEventSet: S, selection: C } = this.state, E = Object.assign(Object.assign(Object.assign({ style: o, className: typeof h == "function" ? F(l) : F({ [ms]: !0, [`${ms}-disabled`]: d }, l), onClick: this.handleInputClick, ref: this.triggerRef, id: y }, S), { tabIndex: -1 }), this.getDataAttr(this.props)), v = { disabled: d, placeholder: a, autoFocus: m, onChange: this.onSearch, onClear: this.onInputClear, "aria-label": this.props["aria-label"], "aria-labelledby": this.props["aria-labelledby"], "aria-invalid": this.props["aria-invalid"], "aria-errormessage": this.props["aria-errormessage"], "aria-describedby": this.props["aria-describedby"], "aria-required": this.props["aria-required"], suffix: s, prefix: t || n, insetLabelId: i, showClear: u, validateStatus: g, size: e, onBlur: this.onBlur, onFocus: this.onFocus, clearIcon: w }; return f.createElement("div", Object.assign({}, E), typeof h == "function" ? f.createElement(Ia, Object.assign({}, v, { inputValue: typeof b < "u" ? b : x, value: Array.from(C.values()), triggerRender: h, componentName: "AutoComplete", componentProps: Object.assign({}, this.props) })) : f.createElement(xr, Object.assign({}, v, { value: typeof b < "u" ? b : x }))) } renderLoading() { const e = `${ms}-loading-wrapper`; return f.createElement("div", { className: e }, f.createElement(yi, null)) } renderOption(e, t) { const { focusIndex: n } = this.state, i = t === n; return f.createElement(xc, Object.assign({ showTick: !1, onSelect: (s, a) => this.onSelect(s, t, a), focused: i, onMouseEnter: () => this.foundation.handleOptionMouseEnter(t), key: e.key || e.label + e.value + t }, e), e.label) } renderOptionList() { const { maxHeight: e, dropdownStyle: t, dropdownClassName: n, loading: i, emptyContent: s } = this.props, { options: a, dropdownMinWidth: o } = this.state, l = F({ [`${ms}-option-list`]: !0 }, n); let u; a.length === 0 ? u = s : u = a.filter(h => h.show).map((h, g) => this.renderOption(h, g)); const d = Object.assign({ maxHeight: e, minWidth: o }, t); return f.createElement("div", { className: l, role: "listbox", style: d, id: `${ms}-${this.optionListId}` }, i ? this.renderLoading() : u) } render() { const { position: e, motion: t, zIndex: n, mouseEnterDelay: i, mouseLeaveDelay: s, autoAdjustOverflow: a, stopPropagation: o, getPopupContainer: l } = this.props, { visible: u, rePosKey: d } = this.state, h = this.renderInput(), g = this.renderOptionList(); return f.createElement(kn, { mouseEnterDelay: i, mouseLeaveDelay: s, autoAdjustOverflow: a, trigger: "custom", motion: t, visible: u, content: g, position: e, ref: this.optionsRef, zIndex: n, stopPropagation: o, getPopupContainer: l, rePosKey: d }, h) }
} So.propTypes = { "aria-label": c.string, "aria-labelledby": c.string, "aria-invalid": c.bool, "aria-errormessage": c.string, "aria-describedby": c.string, "aria-required": c.bool, autoFocus: c.bool, autoAdjustOverflow: c.bool, className: c.string, clearIcon: c.node, children: c.node, data: c.array, defaultOpen: c.bool, defaultValue: c.oneOfType([c.string, c.number]), defaultActiveFirstOption: c.bool, disabled: c.bool, dropdownMatchSelectWidth: c.bool, dropdownClassName: c.string, dropdownStyle: c.object, emptyContent: c.node, id: c.string, insetLabel: c.node, insetLabelId: c.string, onSearch: c.func, onSelect: c.func, onClear: c.func, onBlur: c.func, onFocus: c.func, onChange: c.func, onKeyDown: c.func, position: c.oneOf(XK), placeholder: c.string, prefix: c.node, onChangeWithObject: c.bool, onSelectWithObject: c.bool, renderItem: c.func, renderSelectedItem: c.func, suffix: c.node, showClear: c.bool, size: c.oneOf(YK), style: c.object, stopPropagation: c.oneOfType([c.bool, c.string]), maxHeight: c.oneOfType([c.string, c.number]), mouseEnterDelay: c.number, mouseLeaveDelay: c.number, motion: c.oneOfType([c.bool, c.func, c.object]), getPopupContainer: c.func, triggerRender: c.func, value: c.oneOfType([c.string, c.number]), validateStatus: c.oneOf(qK), zIndex: c.number }; So.Option = xc; So.__SemiComponentName__ = "AutoComplete"; So.defaultProps = xn(So.__SemiComponentName__, { stopPropagation: !0, motion: !0, zIndex: Cr.DEFAULT_Z_INDEX, position: "bottomLeft", data: [], showClear: !1, size: "default", onFocus: z, onSearch: z, onClear: z, onBlur: z, onSelect: z, onChange: z, onSelectWithObject: !1, onDropdownVisibleChange: z, defaultActiveFirstOption: !1, dropdownMatchSelectWidth: !0, loading: !1, maxHeight: 300, validateStatus: "default", autoFocus: !1, emptyContent: null, onKeyDown: z }); const ZK = { PREFIX: `${G}-avatar` }, Uo = { SHAPE: ["circle", "square"], SIZE: ["extra-extra-small", "extra-small", "small", "default", "medium", "large", "extra-large"], COLOR: ["grey", "red", "pink", "purple", "violet", "indigo", "blue", "light-blue", "cyan", "teal", "green", "light-green", "lime", "yellow", "amber", "orange", "white"], OVERLAP_FROM: ["start", "end"] }; class JK extends ve { constructor(e) { super(Object.assign({}, e)), this.handleFocusVisible = t => { const { target: n } = t; try { n.matches(":focus-visible") && this._adapter.setFocusVisible(!0) } catch { Nt(!0, "Warning: [Semi Avatar] The current browser does not support the focus-visible") } }, this.handleBlur = () => { this._adapter.setFocusVisible(!1) }, this.changeScale = () => { const { gap: t } = this.getProps(), n = this._adapter.getAvatarNode(), i = n == null ? void 0 : n.firstChild, [s, a] = [(n == null ? void 0 : n.offsetWidth) || 0, (i == null ? void 0 : i.offsetWidth) || 0]; if (s !== 0 && a !== 0 && t * 2 < s) { const o = s - t * 2 > a ? 1 : (s - t * 2) / a; this._adapter.setScale(o) } } } init() { const { children: e } = this.getProps(); typeof e == "string" && this.changeScale() } destroy() { } handleImgLoadError() { const { onError: e } = this.getProps(); (e ? e() : void 0) !== !1 && this._adapter.notifyImgState(!1) } handleEnter(e) { this._adapter.notifyEnter(e) } handleLeave(e) { this._adapter.notifyLeave(e) } } const QK = r => { let { gradientStart: e, gradientEnd: t } = r; const n = zi(); return f.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "51", height: "52", viewBox: "0 0 51 52", fill: "none" }, f.createElement("g", { filter: "url(#filter0_d_6_2)" }, f.createElement("path", { d: "M40.4918 46.5592C44.6795 43.176 46.261 34.1333 47.5301 25.6141C49.5854 11.8168 39.6662 1 25.8097 1C11.2857 1 3 11.4279 3 25.3518C3 33.7866 6.29361 43.8947 10.4602 46.5592C12.5868 47.9192 12.5868 47.9051 25.8097 47.9192C38.3651 47.9282 38.5352 48.14 40.4918 46.5592Z", fill: `url(#${n})` })), f.createElement("defs", null, f.createElement("filter", { id: "filter0_d_6_2", x: "0.789215", y: "0.447304", width: "49.2216", height: "51.3549", filterUnits: "userSpaceOnUse", colorInterpolationFilters: "sRGB" }, f.createElement("feFlood", { floodOpacity: "0", result: "BackgroundImageFix" }), f.createElement("feColorMatrix", { in: "SourceAlpha", type: "matrix", values: "0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0", result: "hardAlpha" }), f.createElement("feOffset", { dy: "1.65809" }), f.createElement("feGaussianBlur", { stdDeviation: "1.10539" }), f.createElement("feColorMatrix", { type: "matrix", values: "0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0.3 0" }), f.createElement("feBlend", { mode: "normal", in2: "BackgroundImageFix", result: "effect1_dropShadow_6_2" }), f.createElement("feBlend", { mode: "normal", in: "SourceGraphic", in2: "effect1_dropShadow_6_2", result: "shape" })), f.createElement("linearGradient", { id: n, x1: "17.671", y1: "31.7392", x2: "17.671", y2: "47.9333", gradientUnits: "userSpaceOnUse" }, f.createElement("stop", { stopColor: e }), f.createElement("stop", { offset: "1", stopColor: t })))) }; var eU = function (r, e) { var t = {}; for (var n in r) Object.prototype.hasOwnProperty.call(r, n) && e.indexOf(n) < 0 && (t[n] = r[n]); if (r != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, n = Object.getOwnPropertySymbols(r); i < n.length; i++)e.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(r, n[i]) && (t[n[i]] = r[n[i]]); return t }; const tU = Uo.SIZE, nU = Uo.SHAPE, rU = Uo.COLOR, ft = ZK.PREFIX; let ma = class extends de { constructor(e) { super(e), this.handleFocusVisible = t => { this.foundation.handleFocusVisible(t) }, this.handleBlur = t => { this.foundation.handleBlur() }, this.getContent = () => { const { children: t, onClick: n, imgAttr: i, src: s, srcSet: a, alt: o } = this.props, { isImgExist: l } = this.state; let u = t; const d = n !== Ct, h = s && l, g = { tabIndex: 0, onKeyDown: this.handleKeyDown, onFocus: this.handleFocusVisible, onBlur: this.handleBlur }; if (h) { const m = d ? `clickable Avatar: ${o}` : o, b = Object.assign(Object.assign({ src: s, srcSet: a, onError: this.handleError }, i), { className: F({ [`${ft}-no-focus-visible`]: d }) }), y = d ? Object.assign(Object.assign({}, b), g) : b; u = f.createElement("img", Object.assign({ alt: m }, y)) } else if (typeof t == "string") { const m = o ?? t, y = { role: "img", "aria-label": d ? `clickable Avatar: ${m}` : m, className: F(`${ft}-label`, { [`${ft}-no-focus-visible`]: d }) }, w = d ? Object.assign(Object.assign({}, y), g) : y, x = { transform: `scale(${this.state.scale})` }; u = f.createElement("span", { className: `${ft}-content`, style: x }, f.createElement("span", Object.assign({}, w, { "x-semi-prop": "children" }), t)) } return u }, this.renderBottomSlot = () => { var t, n; if (!this.props.bottomSlot) return null; if (this.props.bottomSlot.render) return this.props.bottomSlot.render(); const i = (t = this.props.bottomSlot.render) !== null && t !== void 0 ? t : () => { var s; const a = {}; return this.props.bottomSlot.bgColor && (a.backgroundColor = this.props.bottomSlot.bgColor), this.props.bottomSlot.textColor && (a.color = this.props.bottomSlot.textColor), f.createElement("span", { style: a, className: F(`${ft}-bottom_slot-shape_${this.props.bottomSlot.shape}`, `${ft}-bottom_slot-shape_${this.props.bottomSlot.shape}-${this.props.size}`, (s = this.props.bottomSlot.className) !== null && s !== void 0 ? s : "") }, this.props.bottomSlot.text) }; return f.createElement("div", { className: F([`${ft}-bottom_slot`]), style: (n = this.props.bottomSlot.style) !== null && n !== void 0 ? n : {} }, i()) }, this.renderTopSlot = () => { var t, n, i, s; if (!this.props.topSlot) return null; if (this.props.topSlot.render) return this.props.topSlot.render(); const a = {}; return this.props.topSlot.textColor && (a.color = this.props.topSlot.textColor), f.createElement("div", { style: (t = this.props.topSlot.style) !== null && t !== void 0 ? t : {}, className: F([`${ft}-top_slot-wrapper`, (n = this.props.topSlot.className) !== null && n !== void 0 ? n : "", { [`${ft}-animated`]: this.props.contentMotion }]) }, f.createElement("div", { className: F([`${ft}-top_slot-bg`, `${ft}-top_slot-bg-${this.props.size}`]) }, f.createElement("div", { className: F([`${ft}-top_slot-bg-svg`, `${ft}-top_slot-bg-svg-${this.props.size}`]) }, f.createElement(QK, { gradientStart: (i = this.props.topSlot.gradientStart) !== null && i !== void 0 ? i : "var(--semi-color-primary)", gradientEnd: (s = this.props.topSlot.gradientEnd) !== null && s !== void 0 ? s : "var(--semi-color-primary)" }))), f.createElement("div", { className: F([`${ft}-top_slot`]) }, f.createElement("div", { style: a, className: F([`${ft}-top_slot-content`, `${ft}-top_slot-content-${this.props.size}`]) }, this.props.topSlot.text))) }, this.state = { isImgExist: !0, hoverContent: "", focusVisible: !1, scale: 1 }, this.onEnter = this.onEnter.bind(this), this.onLeave = this.onLeave.bind(this), this.handleError = this.handleError.bind(this), this.handleKeyDown = this.handleKeyDown.bind(this), this.getContent = this.getContent.bind(this), this.avatarRef = f.createRef() } get adapter() { return Object.assign(Object.assign({}, super.adapter), { notifyImgState: e => { this.setState({ isImgExist: e }) }, notifyEnter: e => { const { hoverMask: t } = this.props, n = t; this.setState({ hoverContent: n }, () => { const { onMouseEnter: i } = this.props; i && i(e) }) }, notifyLeave: e => { this.setState({ hoverContent: "" }, () => { const { onMouseLeave: t } = this.props; t && t(e) }) }, setFocusVisible: e => { this.setState({ focusVisible: e }) }, setScale: e => { this.setState({ scale: e }) }, getAvatarNode: () => { var e; return (e = this.avatarRef) === null || e === void 0 ? void 0 : e.current } }) } componentDidMount() { this.foundation = new JK(this.adapter), this.foundation.init() } componentDidUpdate(e) { if (this.props.src && this.props.src !== e.src) { const t = new Image(0, 0); t.src = this.props.src, t.onload = () => { this.setState({ isImgExist: !0 }) }, t.onerror = () => { this.setState({ isImgExist: !1 }) }, t.onabort = () => { this.setState({ isImgExist: !1 }) } } typeof this.props.children == "string" && this.props.children !== e.children && this.foundation.changeScale() } componentWillUnmount() { this.foundation.destroy() } onEnter(e) { this.foundation.handleEnter(e) } onLeave(e) { this.foundation.handleLeave(e) } handleError() { this.foundation.handleImgLoadError() } handleKeyDown(e) { const { onClick: t } = this.props; switch (e.key) { case "Enter": t(e), yn(e); break; case "Escape": e.target.blur(); break } } render() { var e; const t = this.props, { shape: n, children: i, size: s, color: a, className: o, hoverMask: l, onClick: u, imgAttr: d, src: h, srcSet: g, style: m, alt: b, gap: y, bottomSlot: w, topSlot: x, border: S, contentMotion: C } = t, O = eU(t, ["shape", "children", "size", "color", "className", "hoverMask", "onClick", "imgAttr", "src", "srcSet", "style", "alt", "gap", "bottomSlot", "topSlot", "border", "contentMotion"]), { isImgExist: E, hoverContent: v, focusVisible: T } = this.state; let I = {}; Uo.SIZE.includes(s) || (I = { width: s, height: s }), I = Object.assign(Object.assign({}, I), m); const k = w || x || S, P = { onClick: u, onMouseEnter: this.onEnter, onMouseLeave: this.onLeave }, N = h && E, M = F(ft, { [`${ft}-${n}`]: n, [`${ft}-${s}`]: s, [`${ft}-${a}`]: a && !N, [`${ft}-img`]: N, [`${ft}-focus`]: T, [`${ft}-animated`]: C }, o), B = v ? f.createElement("div", { className: `${ft}-hover`, "x-semi-prop": "hoverContent" }, v) : null; let K = f.createElement("span", Object.assign({}, O, { style: k ? {} : I, className: M }, k ? {} : P, { role: "listitem", ref: this.avatarRef }), this.getContent(), B); if (S) { const U = {}; typeof S == "object" && (S != null && S.color) && (U.borderColor = S == null ? void 0 : S.color), K = f.createElement("div", { style: Object.assign({ position: "relative" }, I) }, K, f.createElement("span", { style: U, className: F([`${ft}-additionalBorder`, `${ft}-additionalBorder-${s}`, { [`${ft}-${n}`]: n }]) }), typeof this.props.border == "object" && this.props.border.motion && f.createElement("span", { style: U, className: F([`${ft}-additionalBorder`, `${ft}-additionalBorder-${s}`, { [`${ft}-${n}`]: n, [`${ft}-additionalBorder-animated`]: typeof this.props.border == "object" && ((e = this.props.border) === null || e === void 0 ? void 0 : e.motion) }]) })) } return k ? f.createElement("span", Object.assign({ className: F([`${ft}-wrapper`]), style: I }, P), K, x && ["extra-small", "small", "default", "medium", "large", "extra-large"].includes(s) && n === "circle" && this.renderTopSlot(), w && ["extra-small", "small", "default", "medium", "large", "extra-large"].includes(s) && this.renderBottomSlot()) : K } }; ma.__SemiComponentName__ = "Avatar"; ma.defaultProps = xn(ma.__SemiComponentName__, { size: "medium", color: "grey", shape: "circle", gap: 3, onClick: Ct, onMouseEnter: Ct, onMouseLeave: Ct }); ma.propTypes = { children: c.node, color: c.oneOf(rU), shape: c.oneOf(nU), size: c.oneOf(tU), hoverMask: c.node, className: c.string, style: c.object, gap: c.number, imgAttr: c.object, src: c.string, srcSet: c.string, alt: c.string, onError: c.func, onClick: c.func, onMouseEnter: c.func, onMouseLeave: c.func, bottomSlot: c.shape({ render: c.func, shape: c.oneOf(["circle", "square"]), text: c.node, bgColor: c.string, textColor: c.string, className: c.string, style: c.object }), topSlot: c.shape({ render: c.func, gradientStart: c.string, gradientEnd: c.string, text: c.node, textColor: c.string, className: c.string, style: c.object }), border: c.oneOfType([c.shape({ color: c.string, motion: c.bool }), c.bool]), contentMotion: c.bool }; ma.elementType = "Avatar"; var iU = 4, sU = .001, aU = 1e-7, oU = 10, Ol = 11, nu = 1 / (Ol - 1), lU = typeof Float32Array == "function"; function sE(r, e) { return 1 - 3 * e + 3 * r } function aE(r, e) { return 3 * e - 6 * r } function oE(r) { return 3 * r } function id(r, e, t) { return ((sE(e, t) * r + aE(e, t)) * r + oE(e)) * r } function lE(r, e, t) { return 3 * sE(e, t) * r * r + 2 * aE(e, t) * r + oE(e) } function cU(r, e, t, n, i) { var s, a, o = 0; do a = e + (t - e) / 2, s = id(a, n, i) - r, s > 0 ? t = a : e = a; while (Math.abs(s) > aU && ++o < oU); return a } function uU(r, e, t, n) { for (var i = 0; i < iU; ++i) { var s = lE(e, t, n); if (s === 0) return e; var a = id(e, t, n) - r; e -= a / s } return e } function dU(r) { return r } var hU = function (e, t, n, i) { if (!(0 <= e && e <= 1 && 0 <= n && n <= 1)) throw new Error("bezier x values must be in [0, 1] range"); if (e === t && n === i) return dU; for (var s = lU ? new Float32Array(Ol) : new Array(Ol), a = 0; a < Ol; ++a)s[a] = id(a * nu, e, n); function o(l) { for (var u = 0, d = 1, h = Ol - 1; d !== h && s[d] <= l; ++d)u += nu; --d; var g = (l - s[d]) / (s[d + 1] - s[d]), m = u + g * nu, b = lE(m, e, n); return b >= sU ? uU(l, m, e, n) : b === 0 ? m : cU(l, u, u + nu, e, n) } return function (u) { return u === 0 ? 0 : u === 1 ? 1 : id(o(u), t, i) } }; const rp = _e(hU); function wx(r, e, t) { return Math.min(Math.max(r, e), t) } function pU(r) { const e = /\(([^)]+)\)/.exec(r); return e ? e[1].split(",").map(t => parseFloat(t)) : [] } function ru() { let r = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 1, e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : .5; const t = wx(r, 1, 10), n = wx(e, .1, 2); return i => i === 0 || i === 1 ? i : -t * Math.pow(2, 10 * (i - 1)) * Math.sin((i - 1 - n / (Math.PI * 2) * Math.asin(1 / t)) * (Math.PI * 2) / n) } const ip = (() => { const r = ["Quad", "Cubic", "Quart", "Quint", "Sine", "Expo", "Circ", "Back", "Elastic"], e = { In: [[.55, .085, .68, .53], [.55, .055, .675, .19], [.895, .03, .685, .22], [.755, .05, .855, .06], [.47, 0, .745, .715], [.95, .05, .795, .035], [.6, .04, .98, .335], [.6, -.28, .735, .045], ru], Out: [[.25, .46, .45, .94], [.215, .61, .355, 1], [.165, .84, .44, 1], [.23, 1, .32, 1], [.39, .575, .565, 1], [.19, 1, .22, 1], [.075, .82, .165, 1], [.175, .885, .32, 1.275], (n, i) => s => 1 - ru(n, i)(1 - s)], InOut: [[.455, .03, .515, .955], [.645, .045, .355, 1], [.77, 0, .175, 1], [.86, 0, .07, 1], [.445, .05, .55, .95], [1, 0, 0, 1], [.785, .135, .15, .86], [.68, -.55, .265, 1.55], (n, i) => s => s < .5 ? ru(n, i)(s * 2) / 2 : 1 - ru(n, i)(s * -2 + 2) / 2] }, t = { linear: [.25, .25, .75, .75] }; for (const n of Object.keys(e)) e[n].forEach((i, s) => { t["ease" + n + r[s]] = i }); return t })(); function Cx(r) { if (typeof r == "function") return r; !r || typeof r != "string" ? r = "linear" : r = r.trim(); let e = r.split("(")[0]; const t = pU(r); let n; return e === "cubic-bezier" || e === "cubicBezier" ? rp(...t.length ? t : ip.linear) : ((!e || typeof e != "string" || typeof e == "string" && ip[e] == null) && (e = "linear"), n = ip[e], typeof n == "function" ? n(...t) : t.length ? rp(...t) : rp(...n)) } class fU { constructor() { this._eventMap = new Map } on(e, t) { return e && typeof t == "function" && (this._eventMap.has(e) || this._eventMap.set(e, []), this._eventMap.get(e).push(t)), this } once(e, t) { var n = this; if (e && typeof t == "function") { const i = function () { t(...arguments), n.off(e, i) }; this.on(e, i) } } off(e, t) { if (e) if (typeof t == "function") { const n = this._eventMap.get(e); if (Array.isArray(n) && n.length) { let i = -1; for (; (i = n.findIndex(s => s === t)) > -1;)n.splice(i, 1) } } else t == null && this._eventMap.delete(e); return this } emit(e) { for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), i = 1; i < t; i++)n[i - 1] = arguments[i]; return this._eventMap.has(e) ? (this._eventMap.get(e).forEach(s => s(...n)), !0) : !1 } } function Bl(r) { return !!(r && typeof r == "object" && (r.duration > 0 || typeof r.easing == "string" || typeof r.easing == "function")) } function gU(r, e, t, n, i) { for (const s of Object.keys(e)) { const a = e[s], o = typeof a == "number" ? a : a.val; if (!(typeof a == "object" && a.done)) { if (Bl(a) && n && i && a.duration) { if (a.duration + n <= i || o !== r[s]) return !1 } else if (typeof t[s] == "number" && t[s] !== 0) return !1; if (r[s] !== o) return !1 } } return !0 } function iu(r) { const e = {}; for (const t in r) Object.prototype.hasOwnProperty.call(r, t) && (e[t] = typeof r[t] == "number" ? r[t] : r[t].val); return e } const Ha = [0, 0]; function Sx(r, e, t, n, i, s, a) { const o = -i * (e - n), l = -s * t, u = o + l, d = t + u * r, h = e + d * r; return Math.abs(d) < a && Math.abs(h - n) < a ? (Ha[0] = n, Ha[1] = 0, Ha) : (Ha[0] = h, Ha[1] = d, Ha) } function mU(r) { const e = {}, t = Object.keys(r) || []; for (const n of t) e[n] = 0; return e } const yU = { default: { tension: 170, friction: 26 }, gentle: { tension: 120, friction: 14 }, wobbly: { tension: 180, friction: 12 }, stiff: { tension: 210, friction: 20 }, slow: { tension: 280, friction: 60 }, molasses: { tension: 280, friction: 120 } }, bU = Object.assign(Object.assign({}, yU.default), { precision: .01 }); function vU(r) { let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}; if (Bl(e)) { const n = Cx(e.easing), i = typeof e.duration == "number" && e.duration > 0 ? e.duration : 1e3; e = Object.assign(Object.assign({}, e), { easing: n, duration: i }) } let t = Object.assign(Object.assign(Object.assign({}, bU), e), { done: !1 }); if (r && typeof r == "object" && "val" in r) { if (Bl(r)) { const n = Cx(r.easing), i = typeof r.duration == "number" && r.duration > 0 ? r.duration : parseInt(e.duration) || 1e3; r = Object.assign(Object.assign({}, r), { easing: n, duration: i }) } t = Object.assign(Object.assign({}, t), r) } else t = Object.assign(Object.assign({}, t), { val: r }); return t } const hl = () => Date.now(), ys = 1e3 / 60; class Jm extends fU { constructor() { let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}; super(), this._props = Object.assign({}, e), this._config = Object.assign({}, t), this.initStates() } _wrapConfig(e, t) { t = t && typeof t == "object" ? t : this._config; const n = {}; for (const i of Object.keys(e)) n[i] = vU(e[i], t); return n } initStates(e, t) { e = e && typeof e == "object" ? e : this._props, t = t && typeof t == "object" ? t : this._config; const { from: n, to: i } = e; if (this._from = {}, n) for (const o of Object.keys(n)) this._from[o] = typeof n[o] == "object" && n[o].val ? n[o].val : n[o]; this._to = this._wrapConfig(i, t), this._delay = parseInt(t.delay) || 0; const s = this._from && iu(this._from) || iu(this._to), a = mU(s); this._currentStyle = Object.assign({}, s), this._currentVelocity = Object.assign({}, a), this._lastIdealStyle = Object.assign({}, s), this._lastIdealVelocity = Object.assign({}, a), this.resetPlayStates(), this._frameCount = 0, this._prevTime = 0 } animate() { this._timer == null && (this._timer = requestAnimationFrame(e => { const t = hl(); if (gU(this._currentStyle, this._to, this._currentVelocity, this._startedTime || t, t) || this._ended || this._stopped) { this._wasAnimating && !this._ended && !this._stopped && (this._timer = setTimeout(() => { clearTimeout(this._timer), this._timer = null, this._ended = !0, this.emit("rest", this.getCurrentStates()) }, ys)), this.resetPlayStates(); return } this._started || (this._started = !0, this.emit("start", this.getCurrentStates())), this._stopped = !1, this._paused = !1, this._wasAnimating = !0, this._startedTime === 0 && (this._startedTime = t); const n = t, i = n - this._prevTime; this._prevTime = n, n - this._startedTime < this._delay && (this._timer = null, this.animate()); const s = {}, a = {}, o = {}, l = {}, u = this._to && Object.keys(this._to) || []; for (const d of u) { const h = this._to[d]; this._accumulatedTime[d] = typeof this._accumulatedTime[d] != "number" ? i : this._accumulatedTime[d] + i; const g = this._from[d] != null && typeof this._from[d] == "object" ? this._from[d].val : this._from[d], m = h.val; if (typeof h == "number") o[d] = h, l[d] = 0, s[d] = h, a[d] = 0; else { let b = this._lastIdealStyle[d], y = this._lastIdealVelocity[d]; if (Bl(this._config) || Bl(h)) { const { easing: w, duration: x } = h; b = g + w((n - this._startedTime) / x) * (m - g), n >= this._startedTime + x && (b = m, h.done = !0), s[d] = b, o[d] = b } else if (m != null && m === this._currentStyle[d]) o[d] = m, l[d] = 0, s[d] = m, a[d] = 0; else { const w = (this._accumulatedTime[d] - Math.floor(this._accumulatedTime[d] / ys) * ys) / ys, x = Math.floor(this._accumulatedTime[d] / ys); for (let O = 0; O < x; O++) [b, y] = Sx(ys / 1e3, b, y, h.val, h.tension, h.friction, h.precision); const [S, C] = Sx(ys / 1e3, b, y, h.val, h.tension, h.friction, h.precision); o[d] = b + (S - b) * w, l[d] = y + (C - y) * w, s[d] = b, a[d] = y, this._accumulatedTime[d] -= x * ys } } } this._timer = null, this._currentStyle = Object.assign({}, o), this._currentVelocity = Object.assign({}, l), this._lastIdealStyle = Object.assign({}, s), this._lastIdealVelocity = Object.assign({}, a), this._destroyed || (this.emit("frame", this.getCurrentStates()), this.animate()) })) } start() { this._prevTime = hl(), this._startedTime = hl(), this.animate() } end() { this._ended || (this._ended = !0, this._currentStyle = this.getFinalStates(), this.emit("frame", this.getFinalStates()), this.emit("rest", this.getFinalStates())), this.destroy() } pause() { this._paused || (this._pausedTime = hl(), this._paused = !0, this.emit("pause", this.getCurrentStates()), this.destroy(), this._destroyed = !1) } resume() { if (this._started && this._paused) { const t = hl() - this._pausedTime; this._paused = !1, this._startedTime += t, this._prevTime += t, this._pausedTime = 0, this.emit("resume", this.getCurrentStates()), this.animate() } } stop() { this.destroy(), this._stopped || (this._stopped = !0, this.emit("stop", this.getInitialStates()), this.initStates()) } destroy() { cancelAnimationFrame(this._timer), clearTimeout(this._timer), this._timer = null, this._destroyed = !0 } resetPlayStates() { this._started = !1, this._stopped = !1, this._ended = !1, this._paused = !1, this._destroyed = !1, this._timer = null, this._wasAnimating = !1, this._accumulatedTime = {}, this._startedTime = 0, this._pausedTime = 0 } reset() { this.destroy(), this.initStates() } reverse() { this.destroy(); const e = Object.assign({}, this._props), [t, n] = [e.to, e.from]; e.from = t, e.to = n, this._props = Object.assign({}, e), this.initStates() } getCurrentStates() { return Object.assign({}, this._currentStyle) } getInitialStates() { return Object.assign({}, iu(this._props.from)) } getFinalStates() { return Object.assign({}, iu(this._props.to)) } } const Qm = { PREFIX: `${G}-button` }, wc = { sizes: ["default", "small", "large"], iconPositions: ["left", "right"], htmlTypes: ["button", "reset", "submit"], btnTypes: ["primary", "secondary", "tertiary", "warning", "danger"], themes: ["solid", "borderless", "light", "outline"], DEFAULT_ICON_SIZE: "default", DEFAULT_ICON_POSITION: "left" }, xU = { SIZE: ["extra-small", "small", "default", "large", "extra-large", "custom"], ICON_PREFIX: "semi-icon-" }; var wU = function (r, e) { var t = {}; for (var n in r) Object.prototype.hasOwnProperty.call(r, n) && e.indexOf(n) < 0 && (t[n] = r[n]); if (r != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, n = Object.getOwnPropertySymbols(r); i < n.length; i++)e.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(r, n[i]) && (t[n[i]] = r[n[i]]); return t }; const CU = wc.sizes, { htmlTypes: SU, btnTypes: EU } = wc; let Cc = class extends R.PureComponent { render() { const e = this.props, { children: t, block: n, htmlType: i, loading: s, circle: a, className: o, style: l, disabled: u, size: d, theme: h, type: g, prefixCls: m, iconPosition: b } = e, y = wU(e, ["children", "block", "htmlType", "loading", "circle", "className", "style", "disabled", "size", "theme", "type", "prefixCls", "iconPosition"]), w = Object.assign(Object.assign({ disabled: u }, Ht(y, ["x-semi-children-alias"])), { className: F(m, { [`${m}-${g}`]: !u && g, [`${m}-disabled`]: u, [`${m}-size-large`]: d === "large", [`${m}-size-small`]: d === "small", [`${m}-light`]: h === "light", [`${m}-block`]: n, [`${m}-circle`]: a, [`${m}-borderless`]: h === "borderless", [`${m}-outline`]: h === "outline", [`${m}-${g}-disabled`]: u && g }, o), type: i, "aria-disabled": u }), x = {}; return o && o.includes("-with-icon") || (x["x-semi-prop"] = this.props["x-semi-children-alias"] || "children"), f.createElement("button", Object.assign({}, w, { onClick: this.props.onClick, onMouseDown: this.props.onMouseDown, style: l }), f.createElement("span", Object.assign({ className: F(`${m}-content`, this.props.contentClassName), onClick: S => u && S.stopPropagation() }, x), t)) } }; Cc.defaultProps = { disabled: !1, size: "default", type: "primary", theme: "light", block: !1, htmlType: "button", onMouseDown: Ct, onClick: Ct, onMouseEnter: Ct, onMouseLeave: Ct, prefixCls: Qm.PREFIX }; Cc.propTypes = { children: c.node, disabled: c.bool, prefixCls: c.string, style: c.object, size: c.oneOf(CU), type: c.oneOf(EU), block: c.bool, onClick: c.func, onMouseDown: c.func, circle: c.bool, loading: c.bool, htmlType: c.oneOf(SU), theme: c.oneOf(wc.themes), className: c.string, onMouseEnter: c.func, onMouseLeave: c.func, "aria-label": c.string, contentClassName: c.string }; var _U = function (r, e) { var t = {}; for (var n in r) Object.prototype.hasOwnProperty.call(r, n) && e.indexOf(n) < 0 && (t[n] = r[n]); if (r != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, n = Object.getOwnPropertySymbols(r); i < n.length; i++)e.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(r, n[i]) && (t[n[i]] = r[n[i]]); return t }; const OU = xU.SIZE; class br extends R.PureComponent { render() { const e = this.props, { children: t, iconPosition: n, iconSize: i, iconStyle: s, style: a, icon: o, noHorizontalPadding: l, theme: u, className: d, prefixCls: h, loading: g } = e, m = _U(e, ["children", "iconPosition", "iconSize", "iconStyle", "style", "icon", "noHorizontalPadding", "theme", "className", "prefixCls", "loading"]), b = Object.assign({}, a); Array.isArray(l) ? (l.includes("left") && (b.paddingLeft = 0), l.includes("right") && (b.paddingRight = 0)) : l === !0 ? (b.paddingLeft = 0, b.paddingRight = 0) : typeof l == "string" && (l === "left" && (b.paddingLeft = 0), l === "right" && (b.paddingRight = 0)); let y = null, w = null; g && !m.disabled ? w = f.createElement(nE, null) : f.isValidElement(o) && (w = o); const x = F({ [`${h}-content-left`]: n === "right", [`${h}-content-right`]: n === "left" }), S = this.props["x-semi-children-alias"] || "children", C = t != null ? f.createElement("span", { className: x, "x-semi-prop": S }, t) : null; n === "left" ? y = f.createElement(f.Fragment, null, w, C) : y = f.createElement(f.Fragment, null, C, w); const O = F(d, `${h}-with-icon`, { [`${h}-with-icon-only`]: C == null || C === "", [`${h}-loading`]: g }); return f.createElement(Cc, Object.assign({}, m, { className: O, theme: u, style: b }), y) } } br.defaultProps = { iconPosition: wc.DEFAULT_ICON_POSITION, prefixCls: Qm.PREFIX, loading: !1, noHorizontalPadding: !1, onMouseEnter: z, onMouseLeave: z }; br.elementType = "IconButton"; br.propTypes = { iconStyle: c.object, style: c.object, loading: c.bool, prefixCls: c.string, icon: c.oneOfType([c.object, c.string, c.node]), iconSize: c.oneOf(OU), noHorizontalPadding: c.oneOfType([c.bool, c.string, c.array]), children: c.node, theme: c.string, iconPosition: c.oneOf(wc.iconPositions), className: c.string, onMouseEnter: c.func, onMouseLeave: c.func }; const TU = { PREFIX: `${G}-banner` }, IU = { TYPE: ["info", "success", "danger", "warning"] }; class ey extends ve { constructor(e) { super(Object.assign(Object.assign({}, ey.defaultAdapter), e)) } removeBanner(e) { this._adapter.notifyClose(e), this._adapter.setVisible() } } const _r = TU.PREFIX, PU = IU.TYPE; class cE extends de { constructor(e) { super(e), this.remove = t => { t && t.stopPropagation(), this.foundation.removeBanner(t) }, this.state = { visible: !0 }, Nt("target" in this.props, "[Semi Banner] 'target' has been deprecated, please write JSX directly instead.") } get adapter() { return Object.assign(Object.assign({}, super.adapter), { setVisible: () => { this.setState({ visible: !1 }) }, notifyClose: e => { const { onClose: t } = this.props; t(e) } }) } componentDidMount() { this.foundation = new ey(this.adapter), this.foundation.init() } componentWillUnmount() { this.foundation.destroy() } renderCloser() { const { closeIcon: e } = this.props; return e === null ? e : f.createElement(br, { className: `${_r}-close`, onClick: this.remove, icon: e || f.createElement(ds, { "x-semi-prop": "closeIcon", "aria-hidden": !0 }), theme: "borderless", size: "small", type: "tertiary", "aria-label": "Close" }) } renderIcon() { const { type: e, icon: t } = this.props; let i = { warning: f.createElement(yc, { size: "large", "aria-label": "warning" }), success: f.createElement(Km, { size: "large", "aria-label": "success" }), info: f.createElement(Hm, { size: "large", "aria-label": "info" }), danger: f.createElement(Co, { size: "large", "aria-label": "danger" }) }[e]; const s = F({ [`${_r}-icon`]: !0 }); return typeof t < "u" && (i = t), i ? f.createElement("div", { className: s, "x-semi-prop": "icon" }, i) : null } render() { const { children: e, type: t, className: n, style: i, bordered: s, title: a, description: o, fullMode: l } = this.props, { visible: u } = this.state, d = F(_r, n, { [`${_r}-${t}`]: t, [`${_r}-full`]: l, [`${_r}-in-container`]: !l, [`${_r}-bordered`]: !l && s }); return u ? f.createElement("div", Object.assign({ className: d, style: i, role: "alert" }, this.getDataAttr(this.props)), f.createElement("div", { className: `${_r}-content-wrapper` }, f.createElement("div", { className: `${_r}-content` }, this.renderIcon(), f.createElement("div", { className: `${_r}-content-body` }, a ? f.createElement(zn.Title, { heading: 5, className: `${_r}-title`, component: "div", "x-semi-prop": "title" }, a) : null, o ? f.createElement(zn.Paragraph, { className: `${_r}-description`, component: "div", "x-semi-prop": "description" }, o) : null)), this.renderCloser()), e ? f.createElement("div", { className: `${_r}-extra`, "x-semi-prop": "children" }, e) : null) : null } } cE.propTypes = { fullMode: c.bool, type: c.oneOf(PU), title: c.node, description: c.node, icon: c.node, closeIcon: c.node, children: c.node, style: c.object, className: c.string, onClose: c.func, bordered: c.bool }; cE.defaultProps = { onClose: () => { }, type: "info", fullMode: !0 }; let St = class extends f.PureComponent { constructor() { let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}; super(e) } render() { const e = Object.assign({}, this.props), t = !!e.icon, n = !!e.loading, i = !!e.disabled; return t || n && !i ? f.createElement(br, Object.assign({}, e)) : f.createElement(Cc, Object.assign({}, e)) } }; St.__SemiComponentName__ = "Button"; St.propTypes = Object.assign(Object.assign({}, Cc.propTypes), br.propTypes); St.defaultProps = xn(St.__SemiComponentName__); St.elementType = "Button"; const uE = { PREFIX: `${G}-card` }, kU = { SHADOWS: ["hover", "always"], TYPE: ["grid"] }; var RU = function (r, e) { var t = {}; for (var n in r) Object.prototype.hasOwnProperty.call(r, n) && e.indexOf(n) < 0 && (t[n] = r[n]); if (r != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, n = Object.getOwnPropertySymbols(r); i < n.length; i++)e.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(r, n[i]) && (t[n[i]] = r[n[i]]); return t }; const pl = uE.PREFIX; class dE extends R.PureComponent { render() { const e = this.props, { avatar: t, className: n, description: i, style: s, title: a } = e, o = RU(e, ["avatar", "className", "description", "style", "title"]), l = F(`${pl}-meta`, n), u = t && f.createElement("div", { className: `${pl}-meta-avatar` }, t), d = a && f.createElement("div", { className: `${pl}-meta-wrapper-title` }, a), h = i && f.createElement("div", { className: `${pl}-meta-wrapper-description` }, i), g = a || i ? f.createElement("div", { className: `${pl}-meta-wrapper` }, d, h) : null; return f.createElement("div", Object.assign({}, o, { className: l, style: s }), u, g) } } dE.propTypes = { avatar: c.node, className: c.string, description: c.node, style: c.object, title: c.node }; const ty = { PREFIX: `${G}-skeleton` }; var DU = function (r, e) { var t = {}; for (var n in r) Object.prototype.hasOwnProperty.call(r, n) && e.indexOf(n) < 0 && (t[n] = r[n]); if (r != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, n = Object.getOwnPropertySymbols(r); i < n.length; i++)e.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(r, n[i]) && (t[n[i]] = r[n[i]]); return t }; const AU = Uo.SIZE, NU = Uo.SHAPE, qd = r => e => t => f.createElement(e, Object.assign({ type: r }, t)); class Wo extends R.PureComponent { render() { const e = this.props, { prefixCls: t, className: n, type: i, size: s, shape: a } = e, o = DU(e, ["prefixCls", "className", "type", "size", "shape"]), l = F(n, `${t}-${i}`, { [`${t}-${i}-${s}`]: i.toUpperCase() === "AVATAR" }, { [`${t}-${i}-${a}`]: i.toUpperCase() === "AVATAR" }); return f.createElement("div", Object.assign({ className: l }, o)) } } Wo.propTypes = { type: c.string, prefixCls: c.string, style: c.object, className: c.string, size: c.oneOf(AU), shape: c.oneOf(NU) }; Wo.defaultProps = { prefixCls: ty.PREFIX, size: "medium", shape: "circle" }; const FU = qd("avatar")(Wo), $U = qd("image")(Wo), LU = qd("title")(Wo), MU = qd("button")(Wo); class ny extends R.PureComponent { render() { const { prefixCls: e, className: t, style: n, rows: i } = this.props, s = F(t, `${e}-paragraph`); return f.createElement("ul", { className: s, style: n }, [...Array(i)].map((a, o) => f.createElement("li", { key: o }))) } } ny.propTypes = { rows: c.number, prefixCls: c.string, style: c.object, className: c.string }; ny.defaultProps = { prefixCls: ty.PREFIX, rows: 4 }; var jU = function (r, e) { var t = {}; for (var n in r) Object.prototype.hasOwnProperty.call(r, n) && e.indexOf(n) < 0 && (t[n] = r[n]); if (r != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, n = Object.getOwnPropertySymbols(r); i < n.length; i++)e.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(r, n[i]) && (t[n[i]] = r[n[i]]); return t }; const Ex = ty.PREFIX; class gi extends R.PureComponent { render() { const e = this.props, { placeholder: t, active: n, children: i, className: s, loading: a, style: o } = e, l = jU(e, ["placeholder", "active", "children", "className", "loading", "style"]), u = F(Ex, { [`${Ex}-active`]: !!n }, s); let d; return a ? d = f.createElement("div", Object.assign({ className: u, style: o }, l, { "x-semi-prop": "placeholder" }), t) : d = i, d } } gi.Avatar = FU; gi.Title = LU; gi.Button = MU; gi.Paragraph = ny; gi.Image = $U; gi.defaultProps = { loading: !0 }; gi.propTypes = { active: c.bool, placeholder: c.node, style: c.object, className: c.string, loading: c.bool, children: c.node }; const VU = { PREFIX: `${G}-space` }, na = { ALIGN_SET: ["start", "end", "center", "baseline"], SPACING_LOOSE: "loose", SPACING_MEDIUM: "medium", SPACING_TIGHT: "tight" }, BU = "Symbol(react.fragment)", Ef = r => { let e = []; return f.Children.forEach(r, t => { t != null && (Array.isArray(t) ? e = e.concat(Ef(t)) : R.isValidElement(t) && t.type && t.type.toString() === BU && t.props ? e = e.concat(Ef(t.props.children)) : e.push(t)) }), e }, ti = VU.PREFIX; class Zd extends R.PureComponent { render() { const { children: e = null, style: t, className: n, spacing: i, wrap: s, align: a, vertical: o } = this.props, l = s && o ? !1 : s, u = Object.assign({}, t); let d = "", h = ""; Fe(i) ? (d = i, h = i) : Zt(i) ? (u.rowGap = i, u.columnGap = i) : dm(i) && (Fe(i[0]) ? d = i[0] : Zt(i[0]) && (u.columnGap = `${i[0]}px`), Fe(i[1]) ? h = i[1] : Zt(i[1]) && (u.rowGap = `${i[1]}px`)); const g = F(ti, n, { [`${ti}-align-${a}`]: a, [`${ti}-vertical`]: o, [`${ti}-horizontal`]: !o, [`${ti}-wrap`]: l, [`${ti}-tight-horizontal`]: d === na.SPACING_TIGHT, [`${ti}-tight-vertical`]: h === na.SPACING_TIGHT, [`${ti}-medium-horizontal`]: d === na.SPACING_MEDIUM, [`${ti}-medium-vertical`]: h === na.SPACING_MEDIUM, [`${ti}-loose-horizontal`]: d === na.SPACING_LOOSE, [`${ti}-loose-vertical`]: h === na.SPACING_LOOSE }), m = Ef(e), b = Xr(this.props); return f.createElement("div", Object.assign({}, b, { className: g, style: u, "x-semi-prop": "children" }), m) } } Zd.propTypes = { wrap: c.bool, align: c.oneOf(na.ALIGN_SET), vertical: c.bool, spacing: c.oneOfType([c.string, c.number, c.array]), children: c.node, style: c.object, className: c.string }; Zd.defaultProps = { vertical: !1, wrap: !1, spacing: "tight", align: "center" }; var zU = function (r, e) { var t = {}; for (var n in r) Object.prototype.hasOwnProperty.call(r, n) && e.indexOf(n) < 0 && (t[n] = r[n]); if (r != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, n = Object.getOwnPropertySymbols(r); i < n.length; i++)e.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(r, n[i]) && (t[n[i]] = r[n[i]]); return t }; const Un = uE.PREFIX; class ry extends R.PureComponent { constructor() { super(...arguments), this.renderHeader = () => { const { title: e, headerExtraContent: t, header: n, headerLine: i, headerStyle: s } = this.props, a = F(`${Un}-header`, { [`${Un}-header-bordered`]: !!i }), o = F(`${Un}-header-wrapper`), l = F(`${Un}-header-wrapper-title`, { [`${Un}-header-wrapper-spacing`]: !!t }); return n || t || e ? f.createElement("div", { style: s, className: a }, n || f.createElement("div", { className: o }, t && f.createElement("div", { className: `${Un}-header-wrapper-extra`, "x-semi-prop": "headerExtraContent" }, t), e && f.createElement("div", { className: l }, Fe(e) ? f.createElement(zn.Title, { heading: 6, ellipsis: { showTooltip: !0, rows: 1 }, "x-semi-prop": "title" }, e) : e))) : null }, this.renderCover = () => { const { cover: e } = this.props, t = F(`${Un}-cover`); return e && f.createElement("div", { className: t, "x-semi-prop": "cover" }, e) }, this.renderBody = () => { const { bodyStyle: e, children: t, actions: n, loading: i } = this.props, s = F(`${Un}-body`), a = F(`${Un}-body-actions`), o = F(`${Un}-body-actions-item`), l = f.createElement("div", null, f.createElement(gi.Title, null), f.createElement("br", null), f.createElement(gi.Paragraph, { rows: 3 })); return f.createElement("div", { style: e, className: s }, t && f.createElement(gi, { placeholder: l, loading: i, active: !0 }, t), Array.isArray(n) && f.createElement("div", { className: a }, f.createElement(Zd, { spacing: 12 }, n.map((u, d) => f.createElement("div", { key: d, className: o, "x-semi-prop": `actions.${d}` }, u))))) }, this.renderFooter = () => { const { footer: e, footerLine: t, footerStyle: n } = this.props, i = F(`${Un}-footer`, { [`${Un}-footer-bordered`]: t }); return e && f.createElement("div", { style: n, className: i, "x-semi-prop": "footer" }, e) } } render() { const e = this.props, { bordered: t, shadows: n, style: i, className: s } = e, a = zU(e, ["bordered", "shadows", "style", "className"]), o = Ht(a, ["actions", "bodyStyle", "cover", "headerExtraContent", "footer", "footerLine", "footerStyle", "header", "headerLine", "headerStyle", "loading", "title"]), l = F(Un, s, { [`${Un}-bordered`]: t, [`${Un}-shadows`]: n, [`${Un}-shadows-${n}`]: n }); return f.createElement("div", Object.assign({}, o, { "aria-busy": this.props.loading, className: l, style: i }), this.renderHeader(), this.renderCover(), this.renderBody(), this.renderFooter()) } } ry.Meta = dE; ry.propTypes = { actions: c.array, bodyStyle: c.object, bordered: c.bool, children: c.node, className: c.string, cover: c.node, footer: c.node, footerLine: c.bool, footerStyle: c.object, header: c.node, headerExtraContent: c.node, headerLine: c.bool, headerStyle: c.object, loading: c.bool, shadows: c.oneOf(kU.SHADOWS), style: c.object, title: c.node, "aria-label": c.string }; ry.defaultProps = { bordered: !0, footerLine: !1, headerLine: !0, loading: !1 }; function HU(r, e, t, n) { for (var i = r.length, s = t + (n ? 1 : -1); n ? s-- : ++s < i;)if (e(r[s], s, r)) return s; return -1 } var iy = HU; function KU(r) { return r !== r } var UU = KU; function WU(r, e, t) { for (var n = t - 1, i = r.length; ++n < i;)if (r[n] === e) return n; return -1 } var GU = WU, YU = iy, XU = UU, qU = GU; function ZU(r, e, t) { return e === e ? qU(r, e, t) : YU(r, XU, t) } var sy = ZU, JU = mm, QU = 1 / 0, e6 = 17976931348623157e292; function t6(r) { if (!r) return r === 0 ? r : 0; if (r = JU(r), r === QU || r === -1 / 0) { var e = r < 0 ? -1 : 1; return e * e6 } return r === r ? r : 0 } var n6 = t6, r6 = n6; function i6(r) { var e = r6(r), t = e % 1; return e === e ? t ? e - t : e : 0 } var Go = i6, s6 = Ca; function a6(r, e) { return s6(e, function (t) { return r[t] }) } var o6 = a6, l6 = o6, c6 = zs; function u6(r) { return r == null ? [] : l6(r, c6(r)) } var hE = u6; const pE = _e(hE); var d6 = sy, h6 = Ei, p6 = ym, f6 = Go, g6 = hE, m6 = Math.max; function y6(r, e, t, n) { r = h6(r) ? r : g6(r), t = t && !n ? f6(t) : 0; var i = r.length; return t < 0 && (t = m6(i + t, 0)), p6(r) ? t <= i && r.indexOf(e, t) > -1 : !!i && d6(r, e, t) > -1 } var b6 = y6; const $i = _e(b6); var v6 = zd, x6 = _a, w6 = H1, C6 = Ei, S6 = lc, E6 = zs, _6 = Object.prototype, O6 = _6.hasOwnProperty, T6 = w6(function (r, e) { if (S6(e) || C6(e)) { x6(e, E6(e), r); return } for (var t in e) O6.call(e, t) && v6(r, t, e[t]) }), I6 = T6; const P6 = _e(I6); var k6 = sy; function R6(r, e) { var t = r == null ? 0 : r.length; return !!t && k6(r, e, 0) > -1 } var fE = R6; function D6(r, e, t) { for (var n = -1, i = r == null ? 0 : r.length; ++n < i;)if (t(e, r[n])) return !0; return !1 } var gE = D6, A6 = km, N6 = fE, F6 = gE, $6 = Ca, L6 = Ea, M6 = Rm, j6 = 200; function V6(r, e, t, n) { var i = -1, s = N6, a = !0, o = r.length, l = [], u = e.length; if (!o) return l; t && (e = $6(e, L6(t))), n ? (s = F6, a = !1) : e.length >= j6 && (s = M6, a = !1, e = new A6(e)); e: for (; ++i < o;) { var d = r[i], h = t == null ? d : t(d); if (d = n || d !== 0 ? d : 0, a && h === h) { for (var g = u; g--;)if (e[g] === h) continue e; l.push(d) } else s(e, h, n) || l.push(d) } return l } var mE = V6, B6 = mE, z6 = Pm, H6 = Hd, _x = Cm, K6 = H6(function (r, e) { return _x(r) ? B6(r, z6(e, 1, _x, !0)) : [] }), U6 = K6; const Eo = _e(U6); var W6 = Fd, G6 = pS, Y6 = jo; function X6(r, e, t) { for (var n = -1, i = e.length, s = {}; ++n < i;) { var a = e[n], o = W6(r, a); t(o, a) && G6(s, Y6(a, r), o) } return s } var q6 = X6; function Z6(r, e) { return r != null && e in Object(r) } var J6 = Z6, Q6 = jo, eW = cc, tW = Dn, nW = hc, rW = wm, iW = Sa; function sW(r, e, t) { e = Q6(e, r); for (var n = -1, i = e.length, s = !1; ++n < i;) { var a = iW(e[n]); if (!(s = r != null && t(r, a))) break; r = r[a] } return s || ++n != i ? s : (i = r == null ? 0 : r.length, !!i && rW(i) && nW(a, i) && (tW(r) || eW(r))) } var aW = sW, oW = J6, lW = aW; function cW(r, e) { return r != null && lW(r, e, oW) } var yE = cW, uW = q6, dW = yE; function hW(r, e) { return uW(r, e, function (t, n) { return dW(r, n) }) } var pW = hW, fW = pW, gW = aS, mW = gW(function (r, e) { return r == null ? {} : fW(r, e) }), yW = mW; const cr = _e(yW); var bW = Fo; function vW(r, e, t) { for (var n = -1, i = r.length; ++n < i;) { var s = r[n], a = e(s); if (a != null && (o === void 0 ? a === a && !bW(a) : t(a, o))) var o = a, l = s } return l } var xW = vW; function wW(r, e) { return r > e } var CW = wW, SW = xW, EW = CW, _W = fc; function OW(r) { return r && r.length ? SW(r, _W, EW) : void 0 } var TW = OW; const IW = _e(TW); var sp = Z1, PW = u1, kW = Dm, RW = 1 / 0, DW = sp && 1 / kW(new sp([, -0]))[1] == RW ? function (r) { return new sp(r) } : PW, AW = DW, NW = km, FW = fE, $W = gE, LW = Rm, MW = AW, jW = Dm, VW = 200; function BW(r, e, t) { var n = -1, i = FW, s = r.length, a = !0, o = [], l = o; if (t) a = !1, i = $W; else if (s >= VW) { var u = e ? null : MW(r); if (u) return jW(u); a = !1, i = LW, l = new NW } else l = e ? [] : o; e: for (; ++n < s;) { var d = r[n], h = e ? e(d) : d; if (d = t || d !== 0 ? d : 0, a && h === h) { for (var g = l.length; g--;)if (l[g] === h) continue e; e && l.push(h), o.push(d) } else i(l, h, t) || (l !== o && l.push(h), o.push(d)) } return o } var zW = BW, HW = zW; function KW(r) { return r && r.length ? HW(r) : [] } var UW = KW; const WW = _e(UW), bE = { PREFIX: `${G}-tree`, PREFIX_OPTION: `${G}-tree-option` }; function vE(r, e) { return `${r}-${e}` } function Jd(r) { return !ss(r) && !st(r) } function Ts(r, e, t) { let n = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : !1; const i = [], s = !!n, a = H(t, "key", "key"), o = H(t, "children", "children"); function l(u) { let d = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null; return u.map((h, g) => { const m = vE(d ? d.pos : "0", g), b = h[a], y = {}; t && Object.entries(Ht(t, "children")).forEach(S => { let [C, O] = S; const E = h[O]; !st(E) && (y[C] = E) }); const w = Object.assign(Object.assign(Object.assign({}, cr(h, ["key", "label", "value", "icon", "disabled", "isLeaf"])), y), { parent: d, pos: m, children: null, data: h, _innerDataTag: !0, isEnd: [...d ? d.isEnd : [], g === u.length - 1] }), x = typeof n == "boolean"; return (!s || !x && n.has(b)) && i.push(w), e.has(b) && (!s || !x && n.has(b)) ? w.children = l(h[o] || [], w) : w.children = [], w }) } return l(r), i } function GW(r, e, t) { const n = H(t, "key", "key"), i = H(t, "children", "children"), s = (a, o, l) => { const u = a ? a[i] : r, d = a ? vE(l.pos, o) : "0"; if (a) { const h = H(a, n, null), g = { data: Object.assign({}, a), ind: o, pos: d, key: h !== null ? h : d, parentPos: l.node ? l.pos : null, level: Number(l.level) + 1 }; e(g) } u && u.forEach((h, g) => { s(h, g, { node: a, pos: d, level: l ? Number(l.level) + 1 : -1 }) }) }; s(null) } function YW(r, e) { const t = {}, n = {}, i = {}, s = { posEntities: t, keyEntities: n, valueEntities: i }, a = H(e, "value", "value"); return GW(r, o => { const { pos: l, key: u, parentPos: d } = o, h = Object.assign({}, o), g = H(h, `data.${a}`, null); g !== null && (i[g] = u), t[l] = h, n[u] = h, h.parent = t[d], h.parent && (h.parent.children = h.parent.children || [], h.parent.children.push(h)) }, e), s } function ra(r, e) { let t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1; if (!Jd(r)) return []; if (!t && Array.isArray(r) ? r = r.length ? [r[0]] : [] : Array.isArray(r) || (r = [r]), kt(e)) return r; const n = []; return r.forEach(i => { i in e ? n.push(e[i]) : i && n.push(i) }), n } function Mi(r, e) { let t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !0; const n = [], i = s => { if (!s) return; const { children: a } = s; Jd(a) && a.forEach(l => { n.push(l.key), i(e[l.key]) }) }; return r.forEach(s => { t && n.push(s), i(e[s]) }), n } function XW(r, e) { let t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : []; const n = []; return r && r.forEach(i => { const s = e[i]; s && s.children && s.children.forEach(a => { (!t.length || !t.includes(a.key)) && n.push(a.key) }) }), n } function ay(r, e) { let t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !0; const n = []; return r.forEach(s => { e[s] && e[s].parent && n.push(e[s].parent.key) }), XW(WW(n), e, t ? [] : r) } function ji(r, e) { let t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !0; const n = [], i = s => { s.parent && (n.push(s.parent.key), i(s.parent)) }; return r.forEach(s => { e[s] && i(e[s]), t && n.push(s) }), n } function qW(r, e) { const t = {}; return r.forEach(n => { if (!e[n]) return; const { level: i } = e[n]; t[i] ? t[i].push(n) : t[i] = [n] }), t } function Sc(r, e) { const t = Array.isArray(r) ? r : [r], n = Mi(t, e, !0), i = new Set([...n]); let s = new Set([]), a = []; const o = qW(t, e), l = u => { const { key: d, parent: h, level: g } = u; if (!h || a.includes(d)) return; const m = ay([d], e); if (a = [...a, ...m], m.every(y => i.has(y))) i.add(h.key), g - 1 in o && g ? o[g - 1].push(h.key) : o[g - 1] = [h.key]; else { const y = ji([d], e, !1); s = new Set([...s, ...y]) } }; for (; !kt(o);) { const u = IW(Object.keys(o).map(d => Number(d))); o[u].forEach(d => l(e[d])), delete o[u] } return { checkedKeys: i, halfCheckedKeys: s } } function ap() { let r = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [], e = arguments.length > 1 ? arguments[1] : void 0, t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !0; if (Array.isArray(r) || (r = [r]), t) { const n = ji(r, e, !0); return new Set(n) } return new Set(r) } function Ox(r, e, t, n) { const i = ra(r, n, t); return new Set(ji(i, e, !1)) } function Tx(r, e, t) { let n = "show"; const i = [...r], s = [...e]; if (Math.abs(i.length - s.length) !== 1) return { motionType: n, motionKeys: [] }; let a = []; return i.length > s.length ? (n = "hide", a = Eo(i, s)) : a = Eo(s, i), { motionType: a.length === 1 ? n : "show", motionKeys: a.length === 1 ? Mi(a, t, !1) : [] } } function xE(r, e, t, n) { if (!t) return !0; let i = t, s = e; return typeof t == "boolean" && (i = (a, o) => { const l = a.toLowerCase(); return o.toString().toLowerCase().includes(l) }), n && (s = e[n]), i(r, s, e) } function hi(r, e) { let t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1, n = arguments.length > 3 ? arguments[3] : void 0; const i = [], s = new Set(r); return t ? r.forEach(a => { e[a] && !Jd(e[a].children) && i.push(a), !e[a] && n && i.push(a) }) : r.forEach(a => { if (!e[a]) { n && i.push(a); return } const { parent: o } = e[a]; o && s.has(o.key) || i.push(a) }), i } function Ix(r, e, t) { const n = [], i = s => { t[s].children && t[s].children.forEach(a => { const { key: o } = a; n.push(o), e.has(o) && i(o) }) }; return i(r), n } function wE(r, e, t, n) { const i = Mi([r], e, !0), s = e[r]; t = new Set([...t, r]); const a = o => { if (!o.parent) return; const { key: l } = o; if (ay([l], e).every(h => t.has(h))) { const h = o.parent; t.add(h.key), a(h) } else { const h = ji([l], e, !1); n = new Set([...n, ...h]) } }; return a(s), { checkedKeys: new Set([...t, ...i]), halfCheckedKeys: n } } function CE(r, e, t, n) { const i = Mi([r], e, !0), s = e[r]; i.forEach(o => { t.has(o) && t.delete(o), n.has(o) && n.delete(o) }); const a = o => { const l = o.parent; if (!l || !t.has(l.key) && !n.has(l.key)) return; const { key: u } = o, h = ay([u], e).some(m => t.has(m) || n.has(m)), g = ji([u], e, !1); h ? g.forEach(m => { t.has(m) && (t.delete(m), n.add(m)) }) : (t.has(l.key) && t.delete(l.key), n.has(l.key) && n.delete(l.key), a(l)) }; return s && a(s), { checkedKeys: t, halfCheckedKeys: n } } function ZW(r) { const { showFilteredOnly: e, keyEntities: t, inputValue: n, treeData: i, filterTreeNode: s, filterProps: a, prevExpandedKeys: o, keyMaps: l } = r; let u = []; u = Object.values(t).filter(b => xE(n, b.data, s, a)).map(b => b.key); let d = ji(u, t, !1); if (o.length) { const b = o.filter(y => !!t[y]); d = d.concat(b) } const h = Mi(u, t, !0), g = new Set([...h, ...d]); return { flattenNodes: Ts(i, new Set(d), l, e && g), filteredKeys: new Set(u), filteredExpandedKeys: new Set(d), filteredShownKeys: g } } function sd(r, e) { const t = H(e, "value", "value"), n = H(e, "key", "key"); return Array.isArray(r) ? r.map(i => H(i, t, i[n])) : H(r, t, r[n]) } function bs(r, e, t) { return e && Jd(r) ? sd(r, t) : r } function Px(r, e) { return [...r].filter(n => n in e) } function SE(r, e) { const t = H(e, "disabled", "disabled"), n = Object.keys(r).filter(s => r[s].data[t]), { checkedKeys: i } = Sc(n, r); return i } const EE = { PREFIX: `${G}-cascader`, PREFIX_OPTION: `${G}-cascader-option` }, qt = { SIZE_SET: ["small", "large", "default"], VALIDATE_STATUS: ["success", "default", "error", "warning"], IS_KEY: "isKey", IS_VALUE: "isValue", SHOW_NEXT_BY_CLICK: "click", SHOW_NEXT_BY_HOVER: "hover", LEAF_ONLY_MERGE_TYPE: "leafOnly", AUTO_MERGE_VALUE_MERGE_TYPE: "autoMergeValue", NONE_MERGE_TYPE: "none", SEARCH_POSITION_TRIGGER: "trigger", SEARCH_POSITION_CUSTOM: "custom", RELATED: "related", UN_RELATED: "unRelated" }, _E = "_SEMI_CASCADER_SPLIT_"; function JW(r, e) { return `${r}-${e}` } function QW(r) { return !ss(r) && !st(r) } function e9(r) { return Array.isArray(r) ? r : [r] } function t9(r, e, t, n) { if (!t) return !0; let i = t, s; return typeof t == "boolean" ? (i = (a, o) => { const l = a.toLowerCase(); return o.toLowerCase().includes(l) }, s = n.join("")) : s = n.join(), i(r, s, e) } function n9(r, e) { const t = (n, i, s) => { const a = n ? n.children : r; let o = null; if (n) { const l = s ? `${s.key}${_E}${n.value}` : `${n.value}`, u = s ? JW(s.pos, i) : `${i}`; o = { data: Object.assign({}, n), ind: i, key: l, pos: u, level: s ? s.level + 1 : 0, parentKey: s ? s.key : null, path: s ? [...s.path, l] : [l], valuePath: s ? [...s.valuePath, n.value] : [n.value] }, e(o) } a && a.forEach((l, u) => { t(l, u, o) }) }; t(null) } function r9(r) { return r != null && r.length ? Array.isArray(r[0]) ? r.map(e => ad(e)) : [ad(r)] : [] } function ad(r) { return r.join(_E) } function i9(r, e) { const t = r.split("-").map(s => Number(s)); let n = e, i = []; return t.forEach((s, a) => { var o; n = a === 0 ? n[s] : (o = n == null ? void 0 : n.children) === null || o === void 0 ? void 0 : o[s], i.push(n == null ? void 0 : n.value) }), ad(i) } function OE(r) { const e = {}; return n9(r, t => { const { key: n, parentKey: i } = t, s = Object.assign({}, t); e[n] = s, s.parent = e[i], s.parent && (s.parent.children = s.parent.children || [], s.parent.children.push(s)) }), e } function _f(r, e) { let t; return e ? t = qt.LEAF_ONLY_MERGE_TYPE : r ? t = qt.AUTO_MERGE_VALUE_MERGE_TYPE : t = qt.NONE_MERGE_TYPE, t } class s9 extends ve { constructor(e) { super(Object.assign({}, e)), this.handleKeyDown = t => { t.key === qS && this.getState("isOpen") && this.close(t) }, this.updateSearching = t => { this._adapter.updateStates({ isSearching: !1 }) }, this.handleTagRemoveByKey = t => { var n, i; const { keyEntities: s } = this.getStates(), { disabled: a } = this.getProps(); if (a) return; const o = (n = s[t]) !== null && n !== void 0 ? n : {}; !(!((i = o == null ? void 0 : o.data) === null || i === void 0) && i.disable) && this._handleMultipleSelect(o), this._adapter.rePositionDropdown() }, this.handleTagRemoveInTrigger = t => { const { treeData: n } = this.getStates(), i = i9(t, n); this.handleTagRemoveByKey(i) } } init() { const e = this.getProp("open") || this.getProp("defaultOpen"); this.collectOptions(!0), this._adapter.updateLoadingKeyRefValue(new Set), this._adapter.updateLoadedKeyRefValue(new Set), e && !this._isDisabled() && this.open() } destroy() { this._adapter.unregisterClickOutsideHandler() } _isDisabled() { return this.getProp("disabled") } _isFilterable() { return !!this.getProp("filterTreeNode") } _notifyChange(e) { const { onChangeWithObject: t, multiple: n } = this.getProps(), i = t ? [] : "value"; if (n) { const s = []; e.forEach(a => { const o = this.getItemPropPath(a, i); s.push(o) }), this._adapter.notifyChange(s) } else { const s = st(e) || !("key" in e) ? [] : this.getItemPropPath(e.key, i); this._adapter.notifyChange(s) } } _isLeaf(e) { return this.getProp("loadData") ? !!e.isLeaf : !e.children || !e.children.length } _clearInput() { this._adapter.updateInputValue("") } _notifyBlur(e) { this._adapter.notifyBlur(e) } _notifyFocus(e) { this._adapter.notifyFocus(e) } _isOptionDisabled(e, t) { return ji([e], t, !0).some(i => t[i].data.disabled) } getItemPropPath(e, t, n) { const i = n || this.getState("keyEntities"), s = i[e]; let a = []; if (s) if (s._notExist) a = s.path; else { const o = s.path; a = Array.isArray(t) ? o.map(l => i[l].data) : o.map(l => i[l].data[t]) } return a } _getCacheValue(e) { const { selectedKeys: t } = this.getStates(), n = Array.from(t)[0]; let i; if (kt(e[n])) if ($i(n, "not-exist-")) { const s = n.match(/not-exist-(\S*)/)[1]; kt(e[s]) ? i = s : i = e[s].valuePath } else i = n; else i = e[n].valuePath; return i } collectOptions() { let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !1; const { treeData: t, value: n, defaultValue: i } = this.getProps(), s = OE(t); this._adapter.rePositionDropdown(); let a; e ? a = i : kt(s) || (a = this._getCacheValue(s)); const o = this._isControlledComponent() ? st(n) ? [] : n : a; QW(o) ? this.updateSelectedKey(o, s) : this._adapter.updateStates({ keyEntities: s }) } handleValueChange(e) { const { keyEntities: t } = this.getStates(); this.updateSelectedKey(e, t) } _getClearSelectedKey(e) { const t = {}, { searchPlaceholder: n, placeholder: i, multiple: s } = this.getProps(); return t.selectedKeys = new Set([]), t.activeKeys = new Set([]), t.filteredKeys = new Set([]), e && !s && (t.inputPlaceHolder = n || i || "", t.inputValue = ""), t } updateSelectedKey(e, t) { const { changeOnSelect: n, onChangeWithObject: i, multiple: s } = this.getProps(), { activeKeys: a, loading: o, keyEntities: l, selectedKeys: u } = this.getStates(), d = this._adapter.getLoadingKeyRefValue(), h = this._isFilterable(), g = [...a].filter(C => d.has(C)), m = e9(e), b = i && an(m[0]) ? m.map(C => C.value) : m, y = r9(b); let w = {}; const x = y.length > 0 ? y[0] : void 0, S = x ? t[x] : void 0; if (S) if (n || this._isLeaf(S.data)) { if (w.selectedKeys = new Set([x]), g.length || (w.activeKeys = new Set(S.path)), h && !s) { const C = this.renderDisplayText(x, t); w.inputPlaceHolder = C } } else ke(y, Array.from(u)) && (w = this._getClearSelectedKey(h)); else if (e && e.length) { const C = b[b.length - 1], O = `not-exist-${C}`, E = { data: { label: C, value: C }, key: O, path: b, _notExist: !0 }; if (w.selectedKeys = new Set([O]), h && !s) { const v = this._defaultRenderText(b); w.inputPlaceHolder = v } t[O] = E } else if (o) { w.keyEntities = P6(l, t), this._adapter.updateStates(w); return } else w = this._getClearSelectedKey(h); w.keyEntities = t, this._adapter.updateStates(w) } open() { const e = this._isFilterable(), { multiple: t } = this.getProps(); this._adapter.openMenu(), e && (this._clearInput(), !t && this.toggle2SearchInput(!0)), this._isControlledComponent() && this.reCalcActiveKeys(), this._adapter.notifyDropdownVisibleChange(!0), this._adapter.registerClickOutsideHandler(n => this.close(n)) } reCalcActiveKeys() { const { selectedKeys: e, activeKeys: t, keyEntities: n } = this.getStates(), i = [...e][0], s = n[i]; if (!s) return; const a = new Set(s.path); ke(a, t) || this._adapter.updateStates({ activeKeys: a }) } close(e, t) { const { multiple: n } = this.getProps(); if (this._adapter.closeMenu(), this._adapter.notifyDropdownVisibleChange(!1), this._adapter.unregisterClickOutsideHandler(), this._isFilterable()) { const { selectedKeys: i, isSearching: s } = this.getStates(); let a = ""; t && !n ? a = this.renderDisplayText(t) : i.size && !n && (a = this.renderDisplayText([...i][0])), this._adapter.updateStates({ inputValue: a }), !n && this.toggle2SearchInput(!1), !n && this._adapter.updateFocusState(!1) } this._notifyBlur(e) } focus() { const { filterTreeNode: e } = this.getProps(); e && this._adapter.focusInput(), this._adapter.updateFocusState(!0) } blur() { const { filterTreeNode: e } = this.getProps(); e && this._adapter.blurInput(), this._adapter.updateFocusState(!1) } toggle2SearchInput(e) { e ? this._adapter.toggleInputShow(e, () => this.focus()) : this._adapter.toggleInputShow(e, () => { }) } handleItemClick(e, t) { this._isDisabled() || (this.handleSingleSelect(e, t), this._adapter.rePositionDropdown()) } handleItemHover(e, t) { this._isDisabled() || this.handleShowNextByHover(t) } handleShowNextByHover(e) { const { keyEntities: t } = this.getStates(), { data: n, key: i } = e, s = this._isLeaf(n), a = t[i].path; this._adapter.updateStates({ activeKeys: new Set(a) }), s || this.notifyIfLoadData(e) } onItemCheckboxClick(e) { this._isDisabled() || (this._handleMultipleSelect(e), this._adapter.rePositionDropdown()) } handleClick(e) { const t = this._isDisabled(), n = this._isFilterable(), { isOpen: i } = this.getStates(); t || (i ? i && !n && this.close(e) : (this.open(), this._notifyFocus(e))) } handleSelectionEnterPress(e) { Jn(e) && this.handleClick(e) } toggleHoverState(e) { this._adapter.toggleHovering(e) } _defaultRenderText(e, t) { const n = this.getProp("separator"); return t && typeof t == "function" ? t(e) : e.join(n) } renderDisplayText(e, t) { const n = this.getProp("displayRender"), i = this.getProp("displayProp"), s = this.getItemPropPath(e, i, t); return this._defaultRenderText(s, n) } handleNodeLoad(e) { const { data: t, key: n } = e, i = new Set(this._adapter.getLoadingKeyRefValue()), a = new Set(this._adapter.getLoadedKeyRefValue()).add(n), o = new Set([...i]); o.delete(n), this._adapter.notifyOnLoad(a, t), this._adapter.updateLoadingKeyRefValue(o), this._adapter.updateLoadedKeyRefValue(a), this._adapter.updateStates({ loadingKeys: o, loadedKeys: a }) } notifyIfLoadData(e) { const { data: t, key: n } = e; if (this._adapter.updateStates({ loading: !1 }), !t.isLeaf && !t.children && this.getProp("loadData")) { const i = this._adapter.getLoadedKeyRefValue(), s = new Set(this._adapter.getLoadingKeyRefValue()); if (i.has(n) || s.has(n)) return; this._adapter.updateStates({ loading: !0 }); const { keyEntities: a } = this.getStates(), o = this.getItemPropPath(n, [], a), l = s.add(n); this._adapter.updateLoadingKeyRefValue(l), this._adapter.updateStates({ loadingKeys: l }), this._adapter.notifyLoadData(o, this.handleNodeLoad.bind(this, e)) } } handleSingleSelect(e, t) { const { changeOnSelect: n, filterLeafOnly: i, multiple: s, enableLeafClick: a } = this.getProps(), { keyEntities: o, selectedKeys: l, isSearching: u } = this.getStates(), d = this._isFilterable(), { data: h, key: g } = t, m = this._isLeaf(h), b = o[g].path, y = [g], w = g !== [...l][0]; if (!m && !n && !u) { this._adapter.updateStates({ activeKeys: new Set(b) }), this.notifyIfLoadData(t); return } if (s) this._adapter.updateStates({ activeKeys: new Set(b) }), m && a && this.onItemCheckboxClick(t); else if (this._adapter.notifySelect(h.value), w) { if (this._notifyChange(t), this.notifyIfLoadData(t), this._isControlledComponent()) { this._adapter.updateStates({ activeKeys: new Set(b) }), m && this.close(e); return } this._adapter.updateStates({ activeKeys: new Set(b), selectedKeys: new Set(y) }); const x = this.renderDisplayText(g); d && this._adapter.updateInputPlaceHolder(x), m ? this.close(e, g) : !i && u && this.close(e, g) } else this.close(e) } _handleMultipleSelect(e) { const { checkRelation: t } = this.getProps(); t === qt.RELATED ? this._handleRelatedMultipleSelect(e) : t === "unRelated" && this._handleUnRelatedMultipleSelect(e), this._adapter.updateStates({ inputValue: "" }) } _handleRelatedMultipleSelect(e) { const { key: t } = e, { checkedKeys: n, keyEntities: i, resolvedCheckedKeys: s } = this.getStates(), { autoMergeValue: a, max: o, disableStrictly: l, leafOnly: u } = this.getProps(), d = n.has(t), h = l ? this.calcCheckedStatus(!d, t) : !d, { checkedKeys: g, halfCheckedKeys: m } = l ? this.calcNonDisabledCheckedKeys(t, h) : this.calcCheckedKeys(t, h), b = _f(a, u), y = b === qt.LEAF_ONLY_MERGE_TYPE, w = b === qt.NONE_MERGE_TYPE, x = new Set(hi(g, i, y)), S = w ? g : x; if (Zt(o)) { if (w) { if (n.size < g.size && g.size > o) { const C = []; g.forEach(O => { C.push(i[O]) }), this._adapter.notifyOnExceed(C); return } } else if (s.size < x.size && x.size > o) { const C = []; x.forEach(O => { C.push(i[O]) }), this._adapter.notifyOnExceed(C); return } } this._isControlledComponent() || this._adapter.updateStates({ checkedKeys: g, halfCheckedKeys: m, resolvedCheckedKeys: x }), this._notifyChange(S), h && this._notifySelect(S) } _handleUnRelatedMultipleSelect(e) { const { key: t } = e, { checkedKeys: n, keyEntities: i } = this.getStates(), { max: s } = this.getProps(), a = new Set(n); let o; if (n.has(t)) a.delete(t), o = !1; else { if (Zt(s) && n.size >= s) { const u = []; n.forEach(d => { u.push(i[d]) }), this._adapter.notifyOnExceed(u); return } a.add(t), o = !0 } this._isControlledComponent() || this._adapter.updateStates({ checkedKeys: a }), this._notifyChange(a), o && this._notifySelect(a) } calcNonDisabledCheckedKeys(e, t) { const { keyEntities: n, disabledKeys: i } = this.getStates(), s = new Set(this.getState("checkedKeys")), a = hi(Mi([e], n, !1), n, !0); if (!a.some(d => i.has(d))) return this.calcCheckedKeys(e, t); const l = a.filter(d => !i.has(d)), u = t ? [...l, ...s] : Eo(hi([...s], n, !0), l); return Sc(u, n) } calcCheckedStatus(e, t) { if (!e) return e; const { checkedKeys: n, keyEntities: i, disabledKeys: s } = this.getStates(), a = hi(Mi([t], i, !1), i, !0); return a.some(d => s.has(d)) ? !a.filter(d => !s.has(d)).every(d => n.has(d)) : e } _notifySelect(e) { const { keyEntities: t } = this.getStates(), n = []; e.forEach(s => { var a, o; const l = (o = (a = t[s]) === null || a === void 0 ? void 0 : a.data) === null || o === void 0 ? void 0 : o.value; l !== void 0 && n.push(l) }); const i = n.length === 1 ? n[0] : n; this._adapter.notifySelect(i) } calcCheckedKeys(e, t) { const { keyEntities: n } = this.getStates(), i = new Set(this.getState("checkedKeys")), s = new Set(this.getState("halfCheckedKeys")); return t ? wE(e, n, i, s) : CE(e, n, i, s) } handleInputChange(e) { this._adapter.updateInputValue(e); const { keyEntities: t } = this.getStates(), { treeNodeFilterProp: n, filterTreeNode: i, filterLeafOnly: s } = this.getProps(); let a = []; e && (a = Object.values(t).filter(o => { const { key: l, _notExist: u, data: d } = o; if (u) return !1; const h = this.getItemPropPath(l, n); return t9(e, d, i, h) }).filter(o => i && !s || this._isLeaf(o)).map(o => o.key)), this._adapter.updateStates({ isSearching: !!e, filteredKeys: new Set(a) }), this._adapter.notifyOnSearch(e), this._adapter.rePositionDropdown() } handleClear() { const { isSearching: e } = this.getStates(), { searchPlaceholder: t, placeholder: n, multiple: i } = this.getProps(), s = this._isFilterable(), a = this._isControlledComponent(), o = {}; i ? (o.isSearching = !1, this._adapter.updateInputValue(""), this._adapter.notifyOnSearch(""), o.checkedKeys = new Set([]), o.halfCheckedKeys = new Set([]), o.selectedKeys = new Set([]), o.activeKeys = new Set([]), o.resolvedCheckedKeys = new Set([]), this._adapter.notifyChange([])) : s && e ? (o.isSearching = !1, this._adapter.updateInputValue(""), this._adapter.notifyOnSearch("")) : (s && (o.inputValue = "", o.inputPlaceHolder = t || n || "", this._adapter.updateInputValue(""), this._adapter.notifyOnSearch("")), a || (o.selectedKeys = new Set([])), o.activeKeys = new Set([]), o.filteredKeys = new Set([]), this._adapter.notifyChange([])), this._adapter.updateStates(o), this._adapter.notifyClear(), this._adapter.rePositionDropdown() } handleClearEnterPress(e) { Jn(e) && this.handleClear() } getRenderData() { const { keyEntities: e, isSearching: t } = this.getStates(), n = this._isFilterable(); return t && n ? this.getFilteredData() : Object.values(e).filter(i => i.parentKey === null && !i._notExist).sort((i, s) => parseInt(i.ind, 10) - parseInt(s.ind, 10)) } getFilteredData() { const { treeNodeFilterProp: e, filterSorter: t } = this.getProps(), { filteredKeys: n, keyEntities: i, inputValue: s } = this.getStates(), a = []; return [...n].forEach(l => { const u = i[l]; if (!u) return; const d = this.getItemPropPath(l, []), h = d.map(m => m[e]), g = this._isOptionDisabled(l, i); a.push({ data: u.data, pathData: d, key: l, disabled: g, searchText: h }) }), we(t) && a.sort((l, u) => t(l.pathData, u.pathData, s)), a } handleListScroll(e, t) { const { activeKeys: n, keyEntities: i } = this.getStates(), s = [...n][n.size - 1], a = s ? H(i, [s, "data"], null) : null; this._adapter.notifyListScroll(e, { panelIndex: t, activeNode: a }) } } var a9 = Si, o9 = Sr, l9 = "[object Boolean]"; function c9(r) { return r === !0 || r === !1 || o9(r) && a9(r) == l9 } var u9 = c9; const oy = _e(u9), Iu = { PREFIX: `${G}-checkbox`, INNER: `${G}-checkbox-inner`, TEXT: `${G}-checkbox-text`, INPUT: `${G}-checkbox-input`, CHECKED: `${G}-checkbox-checked`, DISABLED: `${G}-checkbox-disabled`, BUTTON: `${G}-checkbox-button`, WRAPPER: "" }, d9 = { PREFIX: `${G}-checkboxGroup`, INNER: `${G}-checkboxGroup-inner`, TEXT: `${G}-checkboxGroup-text`, INPUT: `${G}-checkboxGroup-input`, CHECKED: `${G}-checkboxGroup-checked`, DISABLED: `${G}-checkboxGroup-disabled` }, Li = { DIRECTION_SET: ["horizontal", "vertical"], TYPE_DEFAULT: "default", TYPE_CARD: "card", TYPE_PURECARD: "pureCard", DEFAULT_DIRECTION: "vertical" }; class h9 extends ve { constructor(e) { super(Object.assign({}, e)), this.clickState = !1, this.handleFocusVisible = t => { const { target: n } = t; try { if (this.clickState) { this.clickState = !1; return } n.matches(":focus-visible") && this._adapter.setFocusVisible(!0) } catch { Nt(!0, "Warning: [Semi Checkbox] The current browser does not support the focus-visible") } }, this.handleBlur = () => { this.clickState = !1, this._adapter.setFocusVisible(!1) } } init() { const { children: e, extra: t, extraId: n, addonId: i } = this.getProps(); e && !i && this._adapter.setAddonId(), t && !n && this._adapter.setExtraId() } notifyChange(e, t) { const n = this._adapter.generateEvent(e, t); this._adapter.notifyChange(n) } handleChange(e) { if (this.getProp("disabled")) return; if ((e == null ? void 0 : e.type) === "click" && (this.clickState = !0), this._adapter.focusCheckboxEntity(), this._adapter.getIsInGroup()) { this._adapter.getGroupDisabled() || this.handleChangeInGroup(e); return } const s = !this.getState("checked"); this._isControlledComponent("checked") ? this.notifyChange(s, e) : (this.setChecked(s), this.notifyChange(s, e)) } handleChangeInGroup(e) { const { value: t } = this.getProps(), s = !this._adapter.getGroupValue().includes(t), a = this._adapter.generateEvent(s, e); this._adapter.notifyChange(a), this._adapter.notifyGroupChange(a) } handleEnterPress(e) { Jn(e) && this.handleChange(e) } setChecked(e) { this._adapter.setNativeControlChecked(e) } destroy() { } } const ly = f.createContext({}); class Qd extends R.PureComponent { blur() { this.inputEntity.blur() } focus() { const { preventScroll: e } = this.props; this.inputEntity.focus({ preventScroll: e }) } render() { const { indeterminate: e, checked: t, disabled: n, prefixCls: i, name: s, isPureCardType: a, addonId: o, extraId: l, focusInner: u, onInputFocus: d, onInputBlur: h } = this.props, g = i || Iu.PREFIX, m = F({ [`${g}-inner`]: !0, [`${g}-inner-checked`]: !!t, [`${g}-inner-pureCardType`]: a }, Iu.WRAPPER), b = F({ [`${g}-inner-display`]: !0, [`${g}-focus`]: u, [`${g}-focus-border`]: u && !t }), y = t ? f.createElement(Lz, null) : e ? f.createElement(Fz, null) : null, w = { type: "checkbox", "aria-label": this.props["aria-label"], "aria-disabled": n, "aria-checked": t, "aria-labelledby": o, "aria-describedby": l || this.props["aria-describedby"], "aria-invalid": this.props["aria-invalid"], "aria-errormessage": this.props["aria-errormessage"], "aria-required": this.props["aria-required"], className: Iu.INPUT, onChange: z, checked: t, disabled: n, onFocus: d, onBlur: h }; return s && (w.name = s), f.createElement("span", { className: m }, f.createElement("input", Object.assign({}, w, { ref: x => { this.inputEntity = x } })), f.createElement("span", { className: b }, y)) } } Qd.contextType = ly; Qd.propTypes = { "aria-describedby": c.string, "aria-errormessage": c.string, "aria-invalid": c.bool, "aria-labelledby": c.string, "aria-required": c.bool, checked: c.bool, disabled: c.bool, onChange: c.func, children: c.node, grouped: c.bool, value: c.any, isPureCardType: c.bool, addonId: c.string, extraId: c.string, focusInner: c.bool, onInputFocus: c.func, onInputBlur: c.func, preventScroll: c.bool }; Qd.defaultProps = { onChange: z }; class bi extends de { get adapter() { return Object.assign(Object.assign({}, super.adapter), { setNativeControlChecked: e => { this.setState({ checked: e }) }, notifyChange: e => { const { onChange: t } = this.props; t && t(e) }, generateEvent: (e, t) => { const { props: n } = this; return { target: Object.assign(Object.assign({}, n), { checked: e }), stopPropagation: () => { t.stopPropagation() }, preventDefault: () => { t.preventDefault() }, nativeEvent: { stopImmediatePropagation: () => { t.nativeEvent && typeof t.nativeEvent.stopImmediatePropagation == "function" && t.nativeEvent.stopImmediatePropagation() } } } }, getIsInGroup: () => this.isInGroup(), getGroupValue: () => this.context && this.context.checkboxGroup.value || [], notifyGroupChange: e => { this.context.checkboxGroup.onChange(e) }, getGroupDisabled: () => this.context && this.context.checkboxGroup.disabled, setAddonId: () => { this.setState({ addonId: zi({ prefix: "addon" }) }) }, setExtraId: () => { this.setState({ extraId: zi({ prefix: "extra" }) }) }, setFocusVisible: e => { this.setState({ focusVisible: e }) }, focusCheckboxEntity: () => { this.focus() } }) } constructor(e) { super(e), this.handleChange = n => this.foundation.handleChange(n), this.handleEnterPress = n => this.foundation.handleEnterPress(n), this.handleFocusVisible = n => { this.foundation.handleFocusVisible(n) }, this.handleBlur = n => { this.foundation.handleBlur() }; const t = !1; this.state = { checked: e.checked || e.defaultChecked || t, addonId: e.addonId, extraId: e.extraId, focusVisible: !1 }, this.checkboxEntity = null, this.foundation = new h9(this.adapter) } componentDidUpdate(e) { this.props.checked !== e.checked && (st(this.props.checked) ? this.foundation.setChecked(!1) : oy(this.props.checked) && this.foundation.setChecked(this.props.checked)) } isInGroup() { return !!(this.context && this.context.checkboxGroup && "value" in this.props) } focus() { this.checkboxEntity && this.checkboxEntity.focus() } blur() { this.checkboxEntity && this.checkboxEntity.blur() } render() { const { disabled: e, style: t, prefixCls: n, className: i, indeterminate: s, children: a, onMouseEnter: o, onMouseLeave: l, extra: u, value: d, role: h, tabIndex: g, id: m, type: b } = this.props, { checked: y, addonId: w, extraId: x, focusVisible: S } = this.state, C = { checked: y, disabled: e }, O = this.isInGroup(); if (O) { if (this.context.checkboxGroup.value) { const B = (this.context.checkboxGroup.value || []).includes(d); C.checked = B } this.context.checkboxGroup.disabled && (C.disabled = this.context.checkboxGroup.disabled || this.props.disabled); const { isCardType: N, isPureCardType: M } = this.context.checkboxGroup; C.isCardType = N, C.isPureCardType = M, C.name = this.context.checkboxGroup.name } else C.isPureCardType = b === Li.TYPE_PURECARD, C.isCardType = b === Li.TYPE_CARD || C.isPureCardType; const E = n || Iu.PREFIX, v = C.isCardType || C.isPureCardType, T = F(E, { [`${E}-disabled`]: C.disabled, [`${E}-indeterminate`]: s, [`${E}-checked`]: C.checked, [`${E}-unChecked`]: !C.checked, [`${E}-cardType`]: C.isCardType, [`${E}-cardType_disabled`]: C.disabled && C.isCardType, [`${E}-cardType_enable`]: !(C.disabled && C.isCardType), [`${E}-cardType_checked`]: C.isCardType && C.checked && !C.disabled, [`${E}-cardType_checked_disabled`]: C.isCardType && C.checked && C.disabled, [i]: !!i, [`${E}-focus`]: S && v }), I = F(`${E}-extra`, { [`${E}-cardType_extra_noChildren`]: C.isCardType && !a }); O && this.context.checkboxGroup.name; const k = this.props["x-semi-children-alias"] || "children", P = () => !a && !u ? null : f.createElement("div", { className: `${E}-content` }, a ? f.createElement("span", { id: w, className: `${E}-addon`, "x-semi-prop": k }, a) : null, u ? f.createElement("div", { id: x, className: I, "x-semi-prop": "extra" }, u) : null); return f.createElement("span", Object.assign({ role: h, tabIndex: g, style: t, className: T, id: m, onMouseEnter: o, onMouseLeave: l, onClick: this.handleChange, onKeyPress: this.handleEnterPress, "aria-labelledby": this.props["aria-labelledby"] }, this.getDataAttr(this.props)), f.createElement(Qd, Object.assign({}, this.props, C, { addonId: a && w, extraId: u && x, isPureCardType: C.isPureCardType, ref: N => { this.checkboxEntity = N }, focusInner: S && !v, onInputFocus: this.handleFocusVisible, onInputBlur: this.handleBlur })), P()) } } bi.contextType = ly; bi.propTypes = { "aria-describedby": c.string, "aria-errormessage": c.string, "aria-invalid": c.bool, "aria-labelledby": c.string, "aria-required": c.bool, checked: c.bool, defaultChecked: c.bool, disabled: c.bool, indeterminate: c.bool, onChange: c.func, value: c.any, style: c.object, className: c.string, prefixCls: c.string, onMouseEnter: c.func, onMouseLeave: c.func, extra: c.node, index: c.number, "aria-label": c.string, tabIndex: c.number, preventScroll: c.bool, type: c.string }; bi.defaultProps = { defaultChecked: !1, indeterminate: !1, onChange: z, onMouseEnter: z, onMouseLeave: z, type: "default" }; bi.elementType = "Checkbox"; class cy extends ve { static get checkboxGroupDefaultAdapter() { return {} } constructor(e) { super(Object.assign(Object.assign({}, cy.checkboxGroupDefaultAdapter), e)) } init() { const { defaultValue: e, value: t } = this.getProps(); typeof e < "u" && !Array.isArray(e) && Nt(!0, "Warning: [Semi CheckboxGroup] defaultValue should be an Array"), typeof t < "u" && !Array.isArray(t) && Nt(!0, "Warning: [Semi CheckboxGroup] value should be an Array") } notifyChange(e) { this._adapter.notifyChange(e) } handleChange(e) { const t = this.getState("value"); let n = []; Array.isArray(t) || (n = [t]), e.target.checked ? n = [...t, e.target.value] : n = t.filter((s, a) => s !== e.target.value), "value" in this.getProps() ? this.notifyChange(n) : (this._adapter.updateGroupValue(n), this.notifyChange(n)) } getFormatName() { return this.getProp("name") || "default" } handlePropValueChange(e) { Array.isArray(e) ? this._adapter.updateGroupValue(e) : (typeof e > "u" && this._adapter.updateGroupValue([]), Nt(!0, "Warning: [Semi CheckboxGroup] value should be an Array")) } destroy() { } } class Ec extends de { get adapter() { return Object.assign(Object.assign({}, super.adapter), { updateGroupValue: e => { this.setState({ value: e }) }, notifyChange: e => { this.props.onChange && this.props.onChange(e) } }) } constructor(e) { super(e), this.state = { value: e.value || e.defaultValue }, this.foundation = new cy(this.adapter), this.onChange = this.onChange.bind(this) } componentDidMount() { this.foundation.init() } componentDidUpdate(e) { ke(e.value, this.props.value) || this.foundation.handlePropValueChange(this.props.value) } componentWillUnmount() { this.foundation.destroy() } onChange(e) { this.foundation.handleChange(e) } render() { const { children: e, options: t, prefixCls: n, direction: i, className: s, id: a, style: o, type: l, disabled: u } = this.props, d = l === Li.TYPE_PURECARD, h = l === Li.TYPE_CARD || d, g = n || d9.PREFIX, m = F({ [g]: !0, [`${g}-wrapper`]: !0, [`${g}-${i}`]: i, [`${g}-${i}-cardType`]: i && h, [`${g}-${i}-pureCardType`]: i && d }, s), b = this.state.value.slice(); let y; return t ? y = (t || []).map((w, x) => typeof w == "string" ? f.createElement(bi, { role: "listitem", key: x, disabled: this.props.disabled, value: w, prefixCls: n }, w) : f.createElement(bi, { role: "listitem", key: x, disabled: w.disabled || this.props.disabled, value: w.value, prefixCls: n, extra: w.extra, className: w.className, style: w.style, onChange: w.onChange }, w.label)) : e && (y = f.Children.toArray(e).map((w, x) => f.cloneElement(w, { key: x, role: "listitem" }))), f.createElement("div", Object.assign({ id: a, role: "list", "aria-label": this.props["aria-label"], className: m, style: o, "aria-labelledby": this.props["aria-labelledby"], "aria-describedby": this.props["aria-describedby"] }, this.getDataAttr(this.props)), f.createElement(ly.Provider, { value: { checkboxGroup: { onChange: this.onChange, value: b, disabled: this.props.disabled, name: this.foundation.getFormatName(), isCardType: h, isPureCardType: d } } }, y)) } } Ec.propTypes = { "aria-describedby": c.string, "aria-errormessage": c.string, "aria-invalid": c.bool, "aria-labelledby": c.string, "aria-required": c.bool, defaultValue: c.array, disabled: c.bool, name: c.string, options: c.array, value: c.array, onChange: c.func, children: c.node, prefixCls: c.string, direction: c.oneOf(Li.DIRECTION_SET), className: c.string, type: c.oneOf([Li.TYPE_DEFAULT, Li.TYPE_CARD, Li.TYPE_PURECARD]), style: c.object }; Ec.defaultProps = { disabled: !1, onChange: () => { }, type: Li.TYPE_DEFAULT, defaultValue: [], direction: Li.DEFAULT_DIRECTION }; class Of extends bi { } Of.Group = Ec; function Tf() { return Tf = Object.assign ? Object.assign.bind() : function (r) { for (var e = 1; e < arguments.length; e++) { var t = arguments[e]; for (var n in t) ({}).hasOwnProperty.call(t, n) && (r[n] = t[n]) } return r }, Tf.apply(null, arguments) } function p9(r, e) { r.prototype = Object.create(e.prototype), r.prototype.constructor = r, ed(r, e) } var kx = Number.isNaN || function (e) { return typeof e == "number" && e !== e }; function f9(r, e) { return !!(r === e || kx(r) && kx(e)) } function g9(r, e) { if (r.length !== e.length) return !1; for (var t = 0; t < r.length; t++)if (!f9(r[t], e[t])) return !1; return !0 } function oa(r, e) { e === void 0 && (e = g9); var t, n = [], i, s = !1; function a() { for (var o = [], l = 0; l < arguments.length; l++)o[l] = arguments[l]; return s && t === this && e(o, n) || (i = r.apply(this, o), s = !0, t = this, n = o), i } return a } function jge(r, e) { if (r == null) return {}; var t = {}; for (var n in r) if ({}.hasOwnProperty.call(r, n)) { if (e.indexOf(n) !== -1) continue; t[n] = r[n] } return t } var m9 = typeof performance == "object" && typeof performance.now == "function", Rx = m9 ? function () { return performance.now() } : function () { return Date.now() }; function Dx(r) { cancelAnimationFrame(r.id) } function y9(r, e) { var t = Rx(); function n() { Rx() - t >= e ? r.call(null) : i.id = requestAnimationFrame(n) } var i = { id: requestAnimationFrame(n) }; return i } var op = -1; function Ax(r) { if (r === void 0 && (r = !1), op === -1 || r) { var e = document.createElement("div"), t = e.style; t.width = "50px", t.height = "50px", t.overflow = "scroll", document.body.appendChild(e), op = e.offsetWidth - e.clientWidth, document.body.removeChild(e) } return op } var Ka = null; function Nx(r) { if (r === void 0 && (r = !1), Ka === null || r) { var e = document.createElement("div"), t = e.style; t.width = "50px", t.height = "50px", t.overflow = "scroll", t.direction = "rtl"; var n = document.createElement("div"), i = n.style; return i.width = "100px", i.height = "100px", e.appendChild(n), document.body.appendChild(e), e.scrollLeft > 0 ? Ka = "positive-descending" : (e.scrollLeft = 1, e.scrollLeft === 0 ? Ka = "negative" : Ka = "positive-ascending"), document.body.removeChild(e), Ka } return Ka } var b9 = 150, v9 = function (e, t) { return e }; function TE(r) { var e, t = r.getItemOffset, n = r.getEstimatedTotalSize, i = r.getItemSize, s = r.getOffsetForIndexAndAlignment, a = r.getStartIndexForOffset, o = r.getStopIndexForStartIndex, l = r.initInstanceProps, u = r.shouldResetStyleCacheOnItemSizeChange, d = r.validateProps; return e = function (h) { p9(g, h); function g(b) { var y; return y = h.call(this, b) || this, y._instanceProps = l(y.props, ye(y)), y._outerRef = void 0, y._resetIsScrollingTimeoutId = null, y.state = { instance: ye(y), isScrolling: !1, scrollDirection: "forward", scrollOffset: typeof y.props.initialScrollOffset == "number" ? y.props.initialScrollOffset : 0, scrollUpdateWasRequested: !1 }, y._callOnItemsRendered = void 0, y._callOnItemsRendered = oa(function (w, x, S, C) { return y.props.onItemsRendered({ overscanStartIndex: w, overscanStopIndex: x, visibleStartIndex: S, visibleStopIndex: C }) }), y._callOnScroll = void 0, y._callOnScroll = oa(function (w, x, S) { return y.props.onScroll({ scrollDirection: w, scrollOffset: x, scrollUpdateWasRequested: S }) }), y._getItemStyle = void 0, y._getItemStyle = function (w) { var x = y.props, S = x.direction, C = x.itemSize, O = x.layout, E = y._getItemStyleCache(u && C, u && O, u && S), v; if (E.hasOwnProperty(w)) v = E[w]; else { var T = t(y.props, w, y._instanceProps), I = i(y.props, w, y._instanceProps), k = S === "horizontal" || O === "horizontal", P = S === "rtl", N = k ? T : 0; E[w] = v = { position: "absolute", left: P ? void 0 : N, right: P ? N : void 0, top: k ? 0 : T, height: k ? "100%" : I, width: k ? I : "100%" } } return v }, y._getItemStyleCache = void 0, y._getItemStyleCache = oa(function (w, x, S) { return {} }), y._onScrollHorizontal = function (w) { var x = w.currentTarget, S = x.clientWidth, C = x.scrollLeft, O = x.scrollWidth; y.setState(function (E) { if (E.scrollOffset === C) return null; var v = y.props.direction, T = C; if (v === "rtl") switch (Nx()) { case "negative": T = -C; break; case "positive-descending": T = O - S - C; break }return T = Math.max(0, Math.min(T, O - S)), { isScrolling: !0, scrollDirection: E.scrollOffset < T ? "forward" : "backward", scrollOffset: T, scrollUpdateWasRequested: !1 } }, y._resetIsScrollingDebounced) }, y._onScrollVertical = function (w) { var x = w.currentTarget, S = x.clientHeight, C = x.scrollHeight, O = x.scrollTop; y.setState(function (E) { if (E.scrollOffset === O) return null; var v = Math.max(0, Math.min(O, C - S)); return { isScrolling: !0, scrollDirection: E.scrollOffset < v ? "forward" : "backward", scrollOffset: v, scrollUpdateWasRequested: !1 } }, y._resetIsScrollingDebounced) }, y._outerRefSetter = function (w) { var x = y.props.outerRef; y._outerRef = w, typeof x == "function" ? x(w) : x != null && typeof x == "object" && x.hasOwnProperty("current") && (x.current = w) }, y._resetIsScrollingDebounced = function () { y._resetIsScrollingTimeoutId !== null && Dx(y._resetIsScrollingTimeoutId), y._resetIsScrollingTimeoutId = y9(y._resetIsScrolling, b9) }, y._resetIsScrolling = function () { y._resetIsScrollingTimeoutId = null, y.setState({ isScrolling: !1 }, function () { y._getItemStyleCache(-1, null) }) }, y } g.getDerivedStateFromProps = function (y, w) { return x9(y, w), d(y), null }; var m = g.prototype; return m.scrollTo = function (y) { y = Math.max(0, y), this.setState(function (w) { return w.scrollOffset === y ? null : { scrollDirection: w.scrollOffset < y ? "forward" : "backward", scrollOffset: y, scrollUpdateWasRequested: !0 } }, this._resetIsScrollingDebounced) }, m.scrollToItem = function (y, w) { w === void 0 && (w = "auto"); var x = this.props, S = x.itemCount, C = x.layout, O = this.state.scrollOffset; y = Math.max(0, Math.min(y, S - 1)); var E = 0; if (this._outerRef) { var v = this._outerRef; C === "vertical" ? E = v.scrollWidth > v.clientWidth ? Ax() : 0 : E = v.scrollHeight > v.clientHeight ? Ax() : 0 } this.scrollTo(s(this.props, y, w, O, this._instanceProps, E)) }, m.componentDidMount = function () { var y = this.props, w = y.direction, x = y.initialScrollOffset, S = y.layout; if (typeof x == "number" && this._outerRef != null) { var C = this._outerRef; w === "horizontal" || S === "horizontal" ? C.scrollLeft = x : C.scrollTop = x } this._callPropsCallbacks() }, m.componentDidUpdate = function () { var y = this.props, w = y.direction, x = y.layout, S = this.state, C = S.scrollOffset, O = S.scrollUpdateWasRequested; if (O && this._outerRef != null) { var E = this._outerRef; if (w === "horizontal" || x === "horizontal") if (w === "rtl") switch (Nx()) { case "negative": E.scrollLeft = -C; break; case "positive-ascending": E.scrollLeft = C; break; default: var v = E.clientWidth, T = E.scrollWidth; E.scrollLeft = T - v - C; break } else E.scrollLeft = C; else E.scrollTop = C } this._callPropsCallbacks() }, m.componentWillUnmount = function () { this._resetIsScrollingTimeoutId !== null && Dx(this._resetIsScrollingTimeoutId) }, m.render = function () { var y = this.props, w = y.children, x = y.className, S = y.direction, C = y.height, O = y.innerRef, E = y.innerElementType, v = y.innerTagName, T = y.itemCount, I = y.itemData, k = y.itemKey, P = k === void 0 ? v9 : k, N = y.layout, M = y.outerElementType, B = y.outerTagName, K = y.style, U = y.useIsScrolling, W = y.width, Z = this.state.isScrolling, J = S === "horizontal" || N === "horizontal", ee = J ? this._onScrollHorizontal : this._onScrollVertical, $ = this._getRangeToRender(), pe = $[0], re = $[1], j = []; if (T > 0) for (var ae = pe; ae <= re; ae++)j.push(R.createElement(w, { data: I, key: P(ae, I), index: ae, isScrolling: U ? Z : void 0, style: this._getItemStyle(ae) })); var be = n(this.props, this._instanceProps); return R.createElement(M || B || "div", { className: x, onScroll: ee, ref: this._outerRefSetter, style: Tf({ position: "relative", height: C, width: W, overflow: "auto", WebkitOverflowScrolling: "touch", willChange: "transform", direction: S }, K) }, R.createElement(E || v || "div", { children: j, ref: O, style: { height: J ? "100%" : be, pointerEvents: Z ? "none" : void 0, width: J ? be : "100%" } })) }, m._callPropsCallbacks = function () { if (typeof this.props.onItemsRendered == "function") { var y = this.props.itemCount; if (y > 0) { var w = this._getRangeToRender(), x = w[0], S = w[1], C = w[2], O = w[3]; this._callOnItemsRendered(x, S, C, O) } } if (typeof this.props.onScroll == "function") { var E = this.state, v = E.scrollDirection, T = E.scrollOffset, I = E.scrollUpdateWasRequested; this._callOnScroll(v, T, I) } }, m._getRangeToRender = function () { var y = this.props, w = y.itemCount, x = y.overscanCount, S = this.state, C = S.isScrolling, O = S.scrollDirection, E = S.scrollOffset; if (w === 0) return [0, 0, 0, 0]; var v = a(this.props, E, this._instanceProps), T = o(this.props, v, E, this._instanceProps), I = !C || O === "backward" ? Math.max(1, x) : 1, k = !C || O === "forward" ? Math.max(1, x) : 1; return [Math.max(0, v - I), Math.max(0, Math.min(w - 1, T + k)), v, T] }, g }(R.PureComponent), e.defaultProps = { direction: "ltr", itemData: void 0, layout: "vertical", overscanCount: 2, useIsScrolling: !1 }, e } var x9 = function (e, t) { e.children, e.direction, e.height, e.layout, e.innerTagName, e.outerTagName, e.width, t.instance }, w9 = 50, ro = function (e, t, n) { var i = e, s = i.itemSize, a = n.itemMetadataMap, o = n.lastMeasuredIndex; if (t > o) { var l = 0; if (o >= 0) { var u = a[o]; l = u.offset + u.size } for (var d = o + 1; d <= t; d++) { var h = s(d); a[d] = { offset: l, size: h }, l += h } n.lastMeasuredIndex = t } return a[t] }, C9 = function (e, t, n) { var i = t.itemMetadataMap, s = t.lastMeasuredIndex, a = s > 0 ? i[s].offset : 0; return a >= n ? IE(e, t, s, 0, n) : S9(e, t, Math.max(0, s), n) }, IE = function (e, t, n, i, s) { for (; i <= n;) { var a = i + Math.floor((n - i) / 2), o = ro(e, a, t).offset; if (o === s) return a; o < s ? i = a + 1 : o > s && (n = a - 1) } return i > 0 ? i - 1 : 0 }, S9 = function (e, t, n, i) { for (var s = e.itemCount, a = 1; n < s && ro(e, n, t).offset < i;)n += a, a *= 2; return IE(e, t, Math.min(n, s - 1), Math.floor(n / 2), i) }, Fx = function (e, t) { var n = e.itemCount, i = t.itemMetadataMap, s = t.estimatedItemSize, a = t.lastMeasuredIndex, o = 0; if (a >= n && (a = n - 1), a >= 0) { var l = i[a]; o = l.offset + l.size } var u = n - a - 1, d = u * s; return o + d }, E9 = TE({ getItemOffset: function (e, t, n) { return ro(e, t, n).offset }, getItemSize: function (e, t, n) { return n.itemMetadataMap[t].size }, getEstimatedTotalSize: Fx, getOffsetForIndexAndAlignment: function (e, t, n, i, s, a) { var o = e.direction, l = e.height, u = e.layout, d = e.width, h = o === "horizontal" || u === "horizontal", g = h ? d : l, m = ro(e, t, s), b = Fx(e, s), y = Math.max(0, Math.min(b - g, m.offset)), w = Math.max(0, m.offset - g + m.size + a); switch (n === "smart" && (i >= w - g && i <= y + g ? n = "auto" : n = "center"), n) { case "start": return y; case "end": return w; case "center": return Math.round(w + (y - w) / 2); case "auto": default: return i >= w && i <= y ? i : i < w ? w : y } }, getStartIndexForOffset: function (e, t, n) { return C9(e, n, t) }, getStopIndexForStartIndex: function (e, t, n, i) { for (var s = e.direction, a = e.height, o = e.itemCount, l = e.layout, u = e.width, d = s === "horizontal" || l === "horizontal", h = d ? u : a, g = ro(e, t, i), m = n + h, b = g.offset + g.size, y = t; y < o - 1 && b < m;)y++, b += ro(e, y, i).size; return y }, initInstanceProps: function (e, t) { var n = e, i = n.estimatedItemSize, s = { itemMetadataMap: {}, estimatedItemSize: i || w9, lastMeasuredIndex: -1 }; return t.resetAfterIndex = function (a, o) { o === void 0 && (o = !0), s.lastMeasuredIndex = Math.min(s.lastMeasuredIndex, a - 1), t._getItemStyleCache(-1), o && t.forceUpdate() }, s }, shouldResetStyleCacheOnItemSizeChange: !1, validateProps: function (e) { e.itemSize } }), eh = TE({ getItemOffset: function (e, t) { var n = e.itemSize; return t * n }, getItemSize: function (e, t) { var n = e.itemSize; return n }, getEstimatedTotalSize: function (e) { var t = e.itemCount, n = e.itemSize; return n * t }, getOffsetForIndexAndAlignment: function (e, t, n, i, s, a) { var o = e.direction, l = e.height, u = e.itemCount, d = e.itemSize, h = e.layout, g = e.width, m = o === "horizontal" || h === "horizontal", b = m ? g : l, y = Math.max(0, u * d - b), w = Math.min(y, t * d), x = Math.max(0, t * d - b + d + a); switch (n === "smart" && (i >= x - b && i <= w + b ? n = "auto" : n = "center"), n) { case "start": return w; case "end": return x; case "center": { var S = Math.round(x + (w - x) / 2); return S < Math.ceil(b / 2) ? 0 : S > y + Math.floor(b / 2) ? y : S } case "auto": default: return i >= x && i <= w ? i : i < x ? x : w } }, getStartIndexForOffset: function (e, t) { var n = e.itemCount, i = e.itemSize; return Math.max(0, Math.min(n - 1, Math.floor(t / i))) }, getStopIndexForStartIndex: function (e, t, n) { var i = e.direction, s = e.height, a = e.itemCount, o = e.itemSize, l = e.layout, u = e.width, d = i === "horizontal" || l === "horizontal", h = t * o, g = d ? u : s, m = Math.ceil((g + n - h) / o); return Math.max(0, Math.min(a - 1, t + m - 1)) }, initInstanceProps: function (e) { }, shouldResetStyleCacheOnItemSizeChange: !0, validateProps: function (e) { e.itemSize } }); const _9 = r => { let { index: e, data: t, style: n } = r; const { visibleOptions: i, renderOption: s } = t, a = i[e]; return s(a, e, n) }, Tt = EE.PREFIX_OPTION; let th = class extends R.PureComponent { constructor() { var e; super(...arguments), e = this, this.onClick = (t, n) => { const { onItemClick: i } = this.props; n.data.disabled || "disabled" in n && n.disabled || i(t, n) }, this.handleItemEnterPress = (t, n) => { Jn(t) && this.onClick(t, n) }, this.onHover = (t, n) => { const { showNext: i, onItemHover: s } = this.props; n.data.disabled || i === qt.SHOW_NEXT_BY_HOVER && s(t, n) }, this.onCheckboxChange = (t, n) => { const { onItemCheckboxClick: i } = this.props; t.stopPropagation(), t.nativeEvent && typeof t.nativeEvent.stopImmediatePropagation == "function" && t.nativeEvent.stopImmediatePropagation(), i(n) }, this.getItemStatus = t => { const { activeKeys: n, selectedKeys: i, loadedKeys: s, loadingKeys: a } = this.props, o = { active: !1, selected: !1, loading: !1 }; return n.has(t) && (o.active = !0), i.has(t) && (o.selected = !0), a.has(t) && !s.has(t) && (o.loading = !0), o }, this.renderIcon = function (t) { let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1; const i = s => s + (n ? ` ${Tt}-icon-left` : ""); switch (t) { case "child": const { expandIcon: s } = e.props; return s || f.createElement(Ms, { className: i(`${Tt}-icon ${Tt}-icon-expand`) }); case "tick": return f.createElement(ga, { className: i(`${Tt}-icon ${Tt}-icon-active`) }); case "loading": return f.createElement(yi, { wrapperClassName: i(`${Tt}-spin-icon`) }); case "empty": return f.createElement("span", { "aria-hidden": !0, className: i(`${Tt}-icon ${Tt}-icon-empty`) }); default: return null } }, this.highlight = t => { const n = [], { keyword: i, separator: s } = this.props; return t.forEach((a, o) => { typeof a == "string" && $i(a, i) ? a.split(i).forEach((l, u) => { u > 0 && n.push(f.createElement("span", { className: `${Tt}-label-highlight`, key: `${u}-${o}` }, i)), n.push(l) }) : n.push(a), o !== t.length - 1 && n.push(s) }), n }, this.renderFlattenOptionItem = (t, n, i) => { var s; const { multiple: a, selectedKeys: o, checkedKeys: l, halfCheckedKeys: u, keyword: d, filterRender: h, virtualize: g } = this.props, { searchText: m, key: b, disabled: y, pathData: w } = t, x = o.has(b), S = F(Tt, { [`${Tt}-flatten`]: !h, [`${Tt}-disabled`]: y, [`${Tt}-select`]: x && !a }), C = v => { this.onClick(v, t) }, O = v => this.handleItemEnterPress(v, t), E = v => this.onCheckboxChange(v, t); if (h) { const v = { className: S, inputValue: d, disabled: y, data: w, checkStatus: { checked: l.has(t.key), halfChecked: u.has(t.key) }, selected: x, onClick: C, onCheck: E }, T = h(v), I = g ? { key: b, style: Object.assign(Object.assign({}, (s = T.props.style) !== null && s !== void 0 ? s : {}), i) } : { key: b }; return f.cloneElement(T, I) } return f.createElement("li", { role: "menuitem", className: S, style: i, key: b, onClick: C, onKeyPress: O }, f.createElement("span", { className: `${Tt}-label` }, !a && this.renderIcon("empty"), a && f.createElement(Of, { onChange: E, disabled: y, indeterminate: u.has(t.key), checked: l.has(t.key), className: `${Tt}-label-checkbox` }), this.highlight(m))) }, this.renderFlattenOption = t => { const { virtualize: n } = this.props; return f.createElement("ul", { className: `${Tt}-list`, key: "flatten-list" }, n ? this.renderVirtualizeList(t) : t.map(s => this.renderFlattenOptionItem(s))) }, this.renderVirtualizeList = t => { var n; const { direction: i } = this.context, { virtualize: s } = this.props; return f.createElement(eh, { height: s.height, itemCount: t.length, itemSize: s.itemSize, itemData: { visibleOptions: t, renderOption: this.renderFlattenOptionItem }, width: (n = s.width) !== null && n !== void 0 ? n : "100%", style: { direction: i } }, _9) } } renderItem(e) { let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : []; const { multiple: n, checkedKeys: i, halfCheckedKeys: s } = this.props; let a; const o = t.length; return t.push(f.createElement("ul", { role: "menu", className: `${Tt}-list`, key: e[0].key, onScroll: l => this.props.onListScroll(l, o) }, e.map(l => { const { data: u, key: d, parentKey: h } = l, { children: g, label: m, disabled: b, isLeaf: y } = u, { active: w, selected: x, loading: S } = this.getItemStatus(d), C = !!g && g.length, O = C || this.props.loadData && !y; w && C && (a = l); const E = F(Tt, { [`${Tt}-active`]: w && !x, [`${Tt}-select`]: x && !n, [`${Tt}-disabled`]: b }), v = h ? { "aria-owns": `cascaderItem-${h}` } : {}; return f.createElement("li", Object.assign({ role: "menuitem", id: `cascaderItem-${d}`, "aria-expanded": w, "aria-haspopup": !!O, "aria-disabled": b }, v, { className: E, key: d, onClick: T => { this.onClick(T, l) }, onKeyPress: T => this.handleItemEnterPress(T, l), onMouseEnter: T => { this.onHover(T, l) } }), f.createElement("span", { className: `${Tt}-label` }, x && !n && this.renderIcon("tick"), !x && !n && this.renderIcon("empty"), n && f.createElement(Of, { onChange: T => this.onCheckboxChange(T, l), disabled: b, indeterminate: s.has(l.key), checked: i.has(l.key), className: `${Tt}-label-checkbox` }), f.createElement("span", null, m)), O ? this.renderIcon(S ? "loading" : "child", !0) : null) }))), a && t.concat(this.renderItem(a.children, t)), t } renderEmpty() { const { emptyContent: e } = this.props; return e === null ? null : f.createElement(Ke, { componentName: "Cascader" }, t => f.createElement("ul", { className: `${Tt} ${Tt}-empty`, key: "empty-list" }, f.createElement("span", { className: `${Tt}-label`, "x-semi-prop": "emptyContent" }, e || t.emptyText))) } render() { const { data: e, searchable: t } = this.props, { direction: n } = this.context, i = !e || !e.length; let s; const a = F({ [`${Tt}-lists`]: !0, [`${Tt}-lists-rtl`]: n === "rtl", [`${Tt}-lists-empty`]: i }); return i ? s = this.renderEmpty() : s = t ? this.renderFlattenOption(e) : this.renderItem(e), f.createElement("div", { className: a }, s) } }; th.contextType = An; th.propTypes = { data: c.array, emptyContent: c.node, searchable: c.bool, onItemClick: c.func, onItemHover: c.func, multiple: c.bool, showNext: c.oneOf([qt.SHOW_NEXT_BY_CLICK, qt.SHOW_NEXT_BY_HOVER]), checkedKeys: c.object, halfCheckedKeys: c.object, onItemCheckboxClick: c.func, separator: c.string, keyword: c.string, virtualize: c.object, expandIcon: c.node }; th.defaultProps = { empty: !1 }; const PE = { PREFIX: `${G}-tag` }, Yo = { TAG_SIZE: ["default", "small", "large"], TAG_COLOR: ["grey", "red", "pink", "purple", "violet", "indigo", "blue", "light-blue", "cyan", "teal", "green", "light-green", "lime", "yellow", "amber", "orange", "white"], TAG_TYPE: ["light", "solid", "ghost"], AVATAR_SHAPE: ["square", "circle"] }; var O9 = function (r, e) { var t = {}; for (var n in r) Object.prototype.hasOwnProperty.call(r, n) && e.indexOf(n) < 0 && (t[n] = r[n]); if (r != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, n = Object.getOwnPropertySymbols(r); i < n.length; i++)e.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(r, n[i]) && (t[n[i]] = r[n[i]]); return t }; const Wn = PE.PREFIX, kE = Yo.TAG_COLOR, RE = Yo.TAG_SIZE, DE = Yo.TAG_TYPE, T9 = Yo.AVATAR_SHAPE; class wr extends R.Component { constructor(e) { super(e), this.state = { visible: !0 }, this.close = this.close.bind(this), this.handleKeyDown = this.handleKeyDown.bind(this) } static getDerivedStateFromProps(e) { return "visible" in e ? { visible: e.visible } : null } setVisible(e) { "visible" in this.props || this.setState({ visible: e }) } close(e, t, n) { const { onClose: i } = this.props; e.stopPropagation(), e.nativeEvent.stopImmediatePropagation(), i && i(t, e, n), !e.defaultPrevented && this.setVisible(!1) } handleKeyDown(e) { const { closable: t, onClick: n, onKeyDown: i } = this.props; switch (e.key) { case "Backspace": case "Delete": t && this.close(e, this.props.children, this.props.tagKey), yn(e); break; case "Enter": n(e), yn(e); break; case "Escape": e.target.blur(); break }i && i(e) } renderAvatar() { const { avatarShape: e, avatarSrc: t } = this.props; return f.createElement(ma, { src: t, shape: e }) } render() { const e = this.props, { tagKey: t, children: n, size: i, color: s, closable: a, visible: o, onClose: l, onClick: u, className: d, type: h, shape: g, avatarSrc: m, avatarShape: b, tabIndex: y, prefixIcon: w, suffixIcon: x } = e, S = O9(e, ["tagKey", "children", "size", "color", "closable", "visible", "onClose", "onClick", "className", "type", "shape", "avatarSrc", "avatarShape", "tabIndex", "prefixIcon", "suffixIcon"]), { visible: C } = this.state, O = u !== wr.defaultProps.onClick || a, E = { role: "button", tabIndex: y || 0, onKeyDown: this.handleKeyDown }, v = Object.assign(Object.assign({}, S), { onClick: u, tabIndex: y, className: F(Wn, { [`${Wn}-default`]: i === "default", [`${Wn}-small`]: i === "small", [`${Wn}-large`]: i === "large", [`${Wn}-square`]: g === "square", [`${Wn}-circle`]: g === "circle", [`${Wn}-${h}`]: h, [`${Wn}-${s}-${h}`]: s && h, [`${Wn}-closable`]: a, [`${Wn}-invisible`]: !C, [`${Wn}-avatar-${b}`]: m }, d) }), T = O ? Object.assign(Object.assign({}, v), E) : v, I = a ? f.createElement("div", { className: `${Wn}-close`, onClick: N => this.close(N, n, t) }, f.createElement(ds, { size: "small" })) : null, k = Fe(n), P = F(`${Wn}-content`, `${Wn}-content-${k ? "ellipsis" : "center"}`); return f.createElement("div", Object.assign({ "aria-label": this.props["aria-label"] || k ? `${a ? "Closable " : ""}Tag: ${n}` : "" }, T), w ? f.createElement("div", { className: `${Wn}-prefix-icon` }, w) : null, m ? this.renderAvatar() : null, f.createElement("div", { className: P }, n), x ? f.createElement("div", { className: `${Wn}-suffix-icon` }, x) : null, I) } } wr.defaultProps = { size: RE[0], color: kE[0], closable: !1, type: DE[0], onClose: () => { }, onClick: () => { }, onMouseEnter: () => { }, style: {}, className: "", shape: "square", avatarShape: "square", prefixIcon: null, suffixIcon: null }; wr.propTypes = { children: c.node, tagKey: c.oneOfType([c.string, c.number]), size: c.oneOf(RE), color: c.oneOf(kE), type: c.oneOf(DE), closable: c.bool, visible: c.bool, onClose: c.func, onClick: c.func, prefixIcon: c.node, suffixIcon: c.node, style: c.object, className: c.string, avatarSrc: c.string, avatarShape: c.oneOf(T9), "aria-label": c.string }; const I9 = { PREFIX: `${G}-tagInput` }, $x = { SIZE_SET: ["large", "default", "small"], STATUS: ["success", "default", "error", "warning"] }, su = (r, e) => { let t = []; if (Fe(e) || Zt(e)) t = r.split(e); else if (dm(e)) { const n = e[0]; t = r; for (let i = 1; i < e.length; i++)t = t.split(e[i]).join(n); t = t.split(n) } else t.push(r); return t }; function P9(r, e, t) { const n = r.slice(); return n.splice(t < 0 ? n.length + t : t, 0, n.splice(e, 1)[0]), n } class k9 extends ve { constructor(e) { super(Object.assign({}, e)), this.handleInputChange = t => { const { value: n } = t.target, { entering: i } = this.getStates(); i ? this._onInputChange(n, t) : this._checkInputChangeValid(n) && this._onInputChange(n, t) }, this.handleInputCompositionStart = t => { const { maxLength: n } = this.getProps(); Zt(n) && this._adapter.setEntering(!0) }, this.handleInputCompositionEnd = t => { const { value: n } = t.target, { maxLength: i, onInputExceed: s, separator: a } = this.getProps(); if (!Zt(i)) return; this._adapter.setEntering(!1); let o = !0; const l = su(n, a); let u = 0; for (; u < l.length; u++)if (l[u].length > i) { o = !1, we(s) && s(n); break } if (o) this._adapter.setInputValue(n); else { const d = l.slice(0, u); u < l.length && d.push(l[u].slice(0, i)), this._adapter.setInputValue(d.join(a)) } }, this._checkInputChangeValid = t => { const { maxLength: n, onInputExceed: i, separator: s } = this._adapter.getProps(), { inputValue: a } = this._adapter.getStates(); let o = !0; if (Zt(n)) { const l = su(t, s), u = su(a, s), d = Math.max(l.length, u.length); for (let h = 0; h < d; h++)if (!st(l[h]) && (st(u[h]) || l[h].length > u[h].length) && l[h].length > n) { o = !1, we(i) && i(t); break } } return o }, this.handleKeyDown = t => { const { inputValue: n, tagsArray: i } = this._adapter.getStates(), s = t.keyCode; s === Tn.ENTER && (t.preventDefault(), n !== "" && this._handleAddTags(t)); const { length: a } = i; if (s === Tn.BACKSPACE && n === "" && a > 0) { const o = i.slice(0, a - 1), l = i[a - 1]; this._onRemove(o, l, a - 1) } this._adapter.notifyKeyDown(t) } } _handleAddTags(e) { const { separator: t, max: n, onExceed: i, allowDuplicates: s } = this._adapter.getProps(), { inputValue: a, tagsArray: o } = this._adapter.getStates(); let l = su(a, t); l = l.filter((d, h) => !s && (o.includes(d) || l.indexOf(d) !== h) ? !1 : Fe(d) && d.trim() !== ""); let u = o.concat(l); Zt(n) && u.length > n && (we(i) && i(u), u = u.slice(0, n), l = l.slice(0, n - o.length)), l.length > 0 && this._onAdd(u, l), this._onInputChange("", e) } handleInputBlur(e) { const { addOnBlur: t } = this._adapter.getProps(); t === !0 && this._handleAddTags(e), this._adapter.setFocusing(!1), this._adapter.notifyBlur(e) } handleInputFocus(e) { this._adapter.setFocusing(!0), this._adapter.notifyFocus(e) } handleClearEnterPress(e) { Jn(e) && this.handleClearBtn(e) } handleClearBtn(e) { const { inputValue: t, tagsArray: n } = this._adapter.getStates(); n.length > 0 && (this._adapter.setTagsArray([]), this._adapter.notifyTagChange([])), t.length > 0 && this._onInputChange("", e), e.stopPropagation() } handleTagClose(e) { const { tagsArray: t } = this._adapter.getStates(), n = [...t]; n.splice(e, 1); const i = t[e]; this._onRemove(n, i, e) } handleInputMouseEnter() { this._adapter.setHovering(!0) } handleInputMouseLeave() { this._adapter.setHovering(!1) } handleClick(e) { const { disabled: t } = this.getProps(); if (t) return; this._adapter.getClickOutsideHandler() || (this._adapter.setActive(!0), this._adapter.registerClickOutsideHandler(i => this.clickOutsideCallBack())) } clickOutsideCallBack() { this._adapter.unregisterClickOutsideHandler(), this._adapter.setActive(!1) } handleClickPrefixOrSuffix(e) { const { disabled: t } = this._adapter.getProps(), { isFocus: n } = this._adapter.getStates(); !t && !n && this._adapter.toggleFocusing(!0) } handlePreventMouseDown(e) { e && we(e.preventDefault) && e.preventDefault() } _onRemove(e, t, n) { this._isControlledComponent() || this._adapter.setTagsArray(e), this._adapter.notifyTagChange(e), this._adapter.notifyTagRemove(t, n) } _onAdd(e, t) { this._isControlledComponent() || this._adapter.setTagsArray(e), this._adapter.notifyTagChange(e), this._adapter.notifyTagAdd(t) } _onInputChange(e, t) { this._adapter.setInputValue(e), this._adapter.notifyInputChange(e, t) } handleSortEnd(e) { const { oldIndex: t, newIndex: n } = e, { tagsArray: i } = this.getStates(), s = P9(i, t, n); this._isControlledComponent() || this._adapter.setTagsArray(s), this._adapter.notifyTagChange(s) } } function R9() { for (var r = arguments.length, e = new Array(r), t = 0; t < r; t++)e[t] = arguments[t]; return R.useMemo(() => n => { e.forEach(i => i(n)) }, e) } const nh = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u"; function Xo(r) { const e = Object.prototype.toString.call(r); return e === "[object Window]" || e === "[object global]" } function uy(r) { return "nodeType" in r } function ur(r) { var e, t; return r ? Xo(r) ? r : uy(r) && (e = (t = r.ownerDocument) == null ? void 0 : t.defaultView) != null ? e : window : window } function dy(r) { const { Document: e } = ur(r); return r instanceof e } function _c(r) { return Xo(r) ? !1 : r instanceof ur(r).HTMLElement } function AE(r) { return r instanceof ur(r).SVGElement } function qo(r) { return r ? Xo(r) ? r.document : uy(r) ? dy(r) ? r : _c(r) || AE(r) ? r.ownerDocument : document : document : document } const vi = nh ? R.useLayoutEffect : R.useEffect; function rh(r) { const e = R.useRef(r); return vi(() => { e.current = r }), R.useCallback(function () { for (var t = arguments.length, n = new Array(t), i = 0; i < t; i++)n[i] = arguments[i]; return e.current == null ? void 0 : e.current(...n) }, []) } function D9() { const r = R.useRef(null), e = R.useCallback((n, i) => { r.current = setInterval(n, i) }, []), t = R.useCallback(() => { r.current !== null && (clearInterval(r.current), r.current = null) }, []); return [e, t] } function zl(r, e) { e === void 0 && (e = [r]); const t = R.useRef(r); return vi(() => { t.current !== r && (t.current = r) }, e), t } function Oc(r, e) { const t = R.useRef(); return R.useMemo(() => { const n = r(t.current); return t.current = n, n }, [...e]) } function od(r) { const e = rh(r), t = R.useRef(null), n = R.useCallback(i => { i !== t.current && (e == null || e(i, t.current)), t.current = i }, []); return [t, n] } function ld(r) { const e = R.useRef(); return R.useEffect(() => { e.current = r }, [r]), e.current } let lp = {}; function Tc(r, e) { return R.useMemo(() => { if (e) return e; const t = lp[r] == null ? 0 : lp[r] + 1; return lp[r] = t, r + "-" + t }, [r, e]) } function NE(r) { return function (e) { for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), i = 1; i < t; i++)n[i - 1] = arguments[i]; return n.reduce((s, a) => { const o = Object.entries(a); for (const [l, u] of o) { const d = s[l]; d != null && (s[l] = d + r * u) } return s }, { ...e }) } } const po = NE(1), Hl = NE(-1); function A9(r) { return "clientX" in r && "clientY" in r } function ih(r) { if (!r) return !1; const { KeyboardEvent: e } = ur(r.target); return e && r instanceof e } function N9(r) { if (!r) return !1; const { TouchEvent: e } = ur(r.target); return e && r instanceof e } function cd(r) { if (N9(r)) { if (r.touches && r.touches.length) { const { clientX: e, clientY: t } = r.touches[0]; return { x: e, y: t } } else if (r.changedTouches && r.changedTouches.length) { const { clientX: e, clientY: t } = r.changedTouches[0]; return { x: e, y: t } } } return A9(r) ? { x: r.clientX, y: r.clientY } : null } const js = Object.freeze({ Translate: { toString(r) { if (!r) return; const { x: e, y: t } = r; return "translate3d(" + (e ? Math.round(e) : 0) + "px, " + (t ? Math.round(t) : 0) + "px, 0)" } }, Scale: { toString(r) { if (!r) return; const { scaleX: e, scaleY: t } = r; return "scaleX(" + e + ") scaleY(" + t + ")" } }, Transform: { toString(r) { if (r) return [js.Translate.toString(r), js.Scale.toString(r)].join(" ") } }, Transition: { toString(r) { let { property: e, duration: t, easing: n } = r; return e + " " + t + "ms " + n } } }), Lx = "a,frame,iframe,input:not([type=hidden]):not(:disabled),select:not(:disabled),textarea:not(:disabled),button:not(:disabled),*[tabindex]"; function F9(r) { return r.matches(Lx) ? r : r.querySelector(Lx) } const $9 = { display: "none" }; function L9(r) { let { id: e, value: t } = r; return f.createElement("div", { id: e, style: $9 }, t) } function M9(r) { let { id: e, announcement: t, ariaLiveType: n = "assertive" } = r; const i = { position: "fixed", top: 0, left: 0, width: 1, height: 1, margin: -1, border: 0, padding: 0, overflow: "hidden", clip: "rect(0 0 0 0)", clipPath: "inset(100%)", whiteSpace: "nowrap" }; return f.createElement("div", { id: e, style: i, role: "status", "aria-live": n, "aria-atomic": !0 }, t) } function j9() { const [r, e] = R.useState(""); return { announce: R.useCallback(n => { n != null && e(n) }, []), announcement: r } } const FE = R.createContext(null); function V9(r) { const e = R.useContext(FE); R.useEffect(() => { if (!e) throw new Error("useDndMonitor must be used within a children of <DndContext>"); return e(r) }, [r, e]) } function B9() { const [r] = R.useState(() => new Set), e = R.useCallback(n => (r.add(n), () => r.delete(n)), [r]); return [R.useCallback(n => { let { type: i, event: s } = n; r.forEach(a => { var o; return (o = a[i]) == null ? void 0 : o.call(a, s) }) }, [r]), e] } const z9 = {
  draggable: `
    To pick up a draggable item, press the space bar.
    While dragging, use the arrow keys to move the item.
    Press space again to drop the item in its new position, or press escape to cancel.
  `}, H9 = { onDragStart(r) { let { active: e } = r; return "Picked up draggable item " + e.id + "." }, onDragOver(r) { let { active: e, over: t } = r; return t ? "Draggable item " + e.id + " was moved over droppable area " + t.id + "." : "Draggable item " + e.id + " is no longer over a droppable area." }, onDragEnd(r) { let { active: e, over: t } = r; return t ? "Draggable item " + e.id + " was dropped over droppable area " + t.id : "Draggable item " + e.id + " was dropped." }, onDragCancel(r) { let { active: e } = r; return "Dragging was cancelled. Draggable item " + e.id + " was dropped." } }; function K9(r) { let { announcements: e = H9, container: t, hiddenTextDescribedById: n, screenReaderInstructions: i = z9 } = r; const { announce: s, announcement: a } = j9(), o = Tc("DndLiveRegion"), [l, u] = R.useState(!1); if (R.useEffect(() => { u(!0) }, []), V9(R.useMemo(() => ({ onDragStart(h) { let { active: g } = h; s(e.onDragStart({ active: g })) }, onDragMove(h) { let { active: g, over: m } = h; e.onDragMove && s(e.onDragMove({ active: g, over: m })) }, onDragOver(h) { let { active: g, over: m } = h; s(e.onDragOver({ active: g, over: m })) }, onDragEnd(h) { let { active: g, over: m } = h; s(e.onDragEnd({ active: g, over: m })) }, onDragCancel(h) { let { active: g, over: m } = h; s(e.onDragCancel({ active: g, over: m })) } }), [s, e])), !l) return null; const d = f.createElement(f.Fragment, null, f.createElement(L9, { id: n, value: i.draggable }), f.createElement(M9, { id: o, announcement: a })); return t ? di.createPortal(d, t) : d } var Pn; (function (r) { r.DragStart = "dragStart", r.DragMove = "dragMove", r.DragEnd = "dragEnd", r.DragCancel = "dragCancel", r.DragOver = "dragOver", r.RegisterDroppable = "registerDroppable", r.SetDroppableDisabled = "setDroppableDisabled", r.UnregisterDroppable = "unregisterDroppable" })(Pn || (Pn = {})); function ud() { } function cp(r, e) { return R.useMemo(() => ({ sensor: r, options: e ?? {} }), [r, e]) } function U9() { for (var r = arguments.length, e = new Array(r), t = 0; t < r; t++)e[t] = arguments[t]; return R.useMemo(() => [...e].filter(n => n != null), [...e]) } const xi = Object.freeze({ x: 0, y: 0 }); function $E(r, e) { return Math.sqrt(Math.pow(r.x - e.x, 2) + Math.pow(r.y - e.y, 2)) } function W9(r, e) { const t = cd(r); if (!t) return "0 0"; const n = { x: (t.x - e.left) / e.width * 100, y: (t.y - e.top) / e.height * 100 }; return n.x + "% " + n.y + "%" } function LE(r, e) { let { data: { value: t } } = r, { data: { value: n } } = e; return t - n } function G9(r, e) { let { data: { value: t } } = r, { data: { value: n } } = e; return n - t } function Mx(r) { let { left: e, top: t, height: n, width: i } = r; return [{ x: e, y: t }, { x: e + i, y: t }, { x: e, y: t + n }, { x: e + i, y: t + n }] } function ME(r, e) { if (!r || r.length === 0) return null; const [t] = r; return t[e] } function jx(r, e, t) { return e === void 0 && (e = r.left), t === void 0 && (t = r.top), { x: e + r.width * .5, y: t + r.height * .5 } } const Y9 = r => { let { collisionRect: e, droppableRects: t, droppableContainers: n } = r; const i = jx(e, e.left, e.top), s = []; for (const a of n) { const { id: o } = a, l = t.get(o); if (l) { const u = $E(jx(l), i); s.push({ id: o, data: { droppableContainer: a, value: u } }) } } return s.sort(LE) }, X9 = r => { let { collisionRect: e, droppableRects: t, droppableContainers: n } = r; const i = Mx(e), s = []; for (const a of n) { const { id: o } = a, l = t.get(o); if (l) { const u = Mx(l), d = i.reduce((g, m, b) => g + $E(u[b], m), 0), h = Number((d / 4).toFixed(4)); s.push({ id: o, data: { droppableContainer: a, value: h } }) } } return s.sort(LE) }; function q9(r, e) { const t = Math.max(e.top, r.top), n = Math.max(e.left, r.left), i = Math.min(e.left + e.width, r.left + r.width), s = Math.min(e.top + e.height, r.top + r.height), a = i - n, o = s - t; if (n < i && t < s) { const l = e.width * e.height, u = r.width * r.height, d = a * o, h = d / (l + u - d); return Number(h.toFixed(4)) } return 0 } const Z9 = r => { let { collisionRect: e, droppableRects: t, droppableContainers: n } = r; const i = []; for (const s of n) { const { id: a } = s, o = t.get(a); if (o) { const l = q9(o, e); l > 0 && i.push({ id: a, data: { droppableContainer: s, value: l } }) } } return i.sort(G9) }; function J9(r, e, t) { return { ...r, scaleX: e && t ? e.width / t.width : 1, scaleY: e && t ? e.height / t.height : 1 } } function jE(r, e) { return r && e ? { x: r.left - e.left, y: r.top - e.top } : xi } function Q9(r) { return function (t) { for (var n = arguments.length, i = new Array(n > 1 ? n - 1 : 0), s = 1; s < n; s++)i[s - 1] = arguments[s]; return i.reduce((a, o) => ({ ...a, top: a.top + r * o.y, bottom: a.bottom + r * o.y, left: a.left + r * o.x, right: a.right + r * o.x }), { ...t }) } } const e7 = Q9(1); function VE(r) { if (r.startsWith("matrix3d(")) { const e = r.slice(9, -1).split(/, /); return { x: +e[12], y: +e[13], scaleX: +e[0], scaleY: +e[5] } } else if (r.startsWith("matrix(")) { const e = r.slice(7, -1).split(/, /); return { x: +e[4], y: +e[5], scaleX: +e[0], scaleY: +e[3] } } return null } function t7(r, e, t) { const n = VE(e); if (!n) return r; const { scaleX: i, scaleY: s, x: a, y: o } = n, l = r.left - a - (1 - i) * parseFloat(t), u = r.top - o - (1 - s) * parseFloat(t.slice(t.indexOf(" ") + 1)), d = i ? r.width / i : r.width, h = s ? r.height / s : r.height; return { width: d, height: h, top: u, right: l + d, bottom: u + h, left: l } } const n7 = { ignoreTransform: !1 }; function Zo(r, e) { e === void 0 && (e = n7); let t = r.getBoundingClientRect(); if (e.ignoreTransform) { const { transform: u, transformOrigin: d } = ur(r).getComputedStyle(r); u && (t = t7(t, u, d)) } const { top: n, left: i, width: s, height: a, bottom: o, right: l } = t; return { top: n, left: i, width: s, height: a, bottom: o, right: l } } function Vx(r) { return Zo(r, { ignoreTransform: !0 }) } function r7(r) { const e = r.innerWidth, t = r.innerHeight; return { top: 0, left: 0, right: e, bottom: t, width: e, height: t } } function i7(r, e) { return e === void 0 && (e = ur(r).getComputedStyle(r)), e.position === "fixed" } function s7(r, e) { e === void 0 && (e = ur(r).getComputedStyle(r)); const t = /(auto|scroll|overlay)/; return ["overflow", "overflowX", "overflowY"].some(i => { const s = e[i]; return typeof s == "string" ? t.test(s) : !1 }) } function sh(r, e) { const t = []; function n(i) { if (e != null && t.length >= e || !i) return t; if (dy(i) && i.scrollingElement != null && !t.includes(i.scrollingElement)) return t.push(i.scrollingElement), t; if (!_c(i) || AE(i) || t.includes(i)) return t; const s = ur(r).getComputedStyle(i); return i !== r && s7(i, s) && t.push(i), i7(i, s) ? t : n(i.parentNode) } return r ? n(r) : t } function BE(r) { const [e] = sh(r, 1); return e ?? null } function up(r) { return !nh || !r ? null : Xo(r) ? r : uy(r) ? dy(r) || r === qo(r).scrollingElement ? window : _c(r) ? r : null : null } function zE(r) { return Xo(r) ? r.scrollX : r.scrollLeft } function HE(r) { return Xo(r) ? r.scrollY : r.scrollTop } function If(r) { return { x: zE(r), y: HE(r) } } var Ln; (function (r) { r[r.Forward = 1] = "Forward", r[r.Backward = -1] = "Backward" })(Ln || (Ln = {})); function KE(r) { return !nh || !r ? !1 : r === document.scrollingElement } function UE(r) { const e = { x: 0, y: 0 }, t = KE(r) ? { height: window.innerHeight, width: window.innerWidth } : { height: r.clientHeight, width: r.clientWidth }, n = { x: r.scrollWidth - t.width, y: r.scrollHeight - t.height }, i = r.scrollTop <= e.y, s = r.scrollLeft <= e.x, a = r.scrollTop >= n.y, o = r.scrollLeft >= n.x; return { isTop: i, isLeft: s, isBottom: a, isRight: o, maxScroll: n, minScroll: e } } const a7 = { x: .2, y: .2 }; function o7(r, e, t, n, i) { let { top: s, left: a, right: o, bottom: l } = t; n === void 0 && (n = 10), i === void 0 && (i = a7); const { isTop: u, isBottom: d, isLeft: h, isRight: g } = UE(r), m = { x: 0, y: 0 }, b = { x: 0, y: 0 }, y = { height: e.height * i.y, width: e.width * i.x }; return !u && s <= e.top + y.height ? (m.y = Ln.Backward, b.y = n * Math.abs((e.top + y.height - s) / y.height)) : !d && l >= e.bottom - y.height && (m.y = Ln.Forward, b.y = n * Math.abs((e.bottom - y.height - l) / y.height)), !g && o >= e.right - y.width ? (m.x = Ln.Forward, b.x = n * Math.abs((e.right - y.width - o) / y.width)) : !h && a <= e.left + y.width && (m.x = Ln.Backward, b.x = n * Math.abs((e.left + y.width - a) / y.width)), { direction: m, speed: b } } function l7(r) { if (r === document.scrollingElement) { const { innerWidth: s, innerHeight: a } = window; return { top: 0, left: 0, right: s, bottom: a, width: s, height: a } } const { top: e, left: t, right: n, bottom: i } = r.getBoundingClientRect(); return { top: e, left: t, right: n, bottom: i, width: r.clientWidth, height: r.clientHeight } } function WE(r) { return r.reduce((e, t) => po(e, If(t)), xi) } function c7(r) { return r.reduce((e, t) => e + zE(t), 0) } function u7(r) { return r.reduce((e, t) => e + HE(t), 0) } function GE(r, e) { if (e === void 0 && (e = Zo), !r) return; const { top: t, left: n, bottom: i, right: s } = e(r); BE(r) && (i <= 0 || s <= 0 || t >= window.innerHeight || n >= window.innerWidth) && r.scrollIntoView({ block: "center", inline: "center" }) } const d7 = [["x", ["left", "right"], c7], ["y", ["top", "bottom"], u7]]; class hy { constructor(e, t) { this.rect = void 0, this.width = void 0, this.height = void 0, this.top = void 0, this.bottom = void 0, this.right = void 0, this.left = void 0; const n = sh(t), i = WE(n); this.rect = { ...e }, this.width = e.width, this.height = e.height; for (const [s, a, o] of d7) for (const l of a) Object.defineProperty(this, l, { get: () => { const u = o(n), d = i[s] - u; return this.rect[l] + d }, enumerable: !0 }); Object.defineProperty(this, "rect", { enumerable: !1 }) } } class Pl { constructor(e) { this.target = void 0, this.listeners = [], this.removeAll = () => { this.listeners.forEach(t => { var n; return (n = this.target) == null ? void 0 : n.removeEventListener(...t) }) }, this.target = e } add(e, t, n) { var i; (i = this.target) == null || i.addEventListener(e, t, n), this.listeners.push([e, t, n]) } } function h7(r) { const { EventTarget: e } = ur(r); return r instanceof e ? r : qo(r) } function dp(r, e) { const t = Math.abs(r.x), n = Math.abs(r.y); return typeof e == "number" ? Math.sqrt(t ** 2 + n ** 2) > e : "x" in e && "y" in e ? t > e.x && n > e.y : "x" in e ? t > e.x : "y" in e ? n > e.y : !1 } var Vr; (function (r) { r.Click = "click", r.DragStart = "dragstart", r.Keydown = "keydown", r.ContextMenu = "contextmenu", r.Resize = "resize", r.SelectionChange = "selectionchange", r.VisibilityChange = "visibilitychange" })(Vr || (Vr = {})); function Bx(r) { r.preventDefault() } function p7(r) { r.stopPropagation() } var tt; (function (r) { r.Space = "Space", r.Down = "ArrowDown", r.Right = "ArrowRight", r.Left = "ArrowLeft", r.Up = "ArrowUp", r.Esc = "Escape", r.Enter = "Enter", r.Tab = "Tab" })(tt || (tt = {})); const YE = { start: [tt.Space, tt.Enter], cancel: [tt.Esc], end: [tt.Space, tt.Enter, tt.Tab] }, f7 = (r, e) => { let { currentCoordinates: t } = e; switch (r.code) { case tt.Right: return { ...t, x: t.x + 25 }; case tt.Left: return { ...t, x: t.x - 25 }; case tt.Down: return { ...t, y: t.y + 25 }; case tt.Up: return { ...t, y: t.y - 25 } } }; class py { constructor(e) { this.props = void 0, this.autoScrollEnabled = !1, this.referenceCoordinates = void 0, this.listeners = void 0, this.windowListeners = void 0, this.props = e; const { event: { target: t } } = e; this.props = e, this.listeners = new Pl(qo(t)), this.windowListeners = new Pl(ur(t)), this.handleKeyDown = this.handleKeyDown.bind(this), this.handleCancel = this.handleCancel.bind(this), this.attach() } attach() { this.handleStart(), this.windowListeners.add(Vr.Resize, this.handleCancel), this.windowListeners.add(Vr.VisibilityChange, this.handleCancel), setTimeout(() => this.listeners.add(Vr.Keydown, this.handleKeyDown)) } handleStart() { const { activeNode: e, onStart: t } = this.props, n = e.node.current; n && GE(n), t(xi) } handleKeyDown(e) { if (ih(e)) { const { active: t, context: n, options: i } = this.props, { keyboardCodes: s = YE, coordinateGetter: a = f7, scrollBehavior: o = "smooth" } = i, { code: l } = e; if (s.end.includes(l)) { this.handleEnd(e); return } if (s.cancel.includes(l)) { this.handleCancel(e); return } const { collisionRect: u } = n.current, d = u ? { x: u.left, y: u.top } : xi; this.referenceCoordinates || (this.referenceCoordinates = d); const h = a(e, { active: t, context: n.current, currentCoordinates: d }); if (h) { const g = Hl(h, d), m = { x: 0, y: 0 }, { scrollableAncestors: b } = n.current; for (const y of b) { const w = e.code, { isTop: x, isRight: S, isLeft: C, isBottom: O, maxScroll: E, minScroll: v } = UE(y), T = l7(y), I = { x: Math.min(w === tt.Right ? T.right - T.width / 2 : T.right, Math.max(w === tt.Right ? T.left : T.left + T.width / 2, h.x)), y: Math.min(w === tt.Down ? T.bottom - T.height / 2 : T.bottom, Math.max(w === tt.Down ? T.top : T.top + T.height / 2, h.y)) }, k = w === tt.Right && !S || w === tt.Left && !C, P = w === tt.Down && !O || w === tt.Up && !x; if (k && I.x !== h.x) { const N = y.scrollLeft + g.x, M = w === tt.Right && N <= E.x || w === tt.Left && N >= v.x; if (M && !g.y) { y.scrollTo({ left: N, behavior: o }); return } M ? m.x = y.scrollLeft - N : m.x = w === tt.Right ? y.scrollLeft - E.x : y.scrollLeft - v.x, m.x && y.scrollBy({ left: -m.x, behavior: o }); break } else if (P && I.y !== h.y) { const N = y.scrollTop + g.y, M = w === tt.Down && N <= E.y || w === tt.Up && N >= v.y; if (M && !g.x) { y.scrollTo({ top: N, behavior: o }); return } M ? m.y = y.scrollTop - N : m.y = w === tt.Down ? y.scrollTop - E.y : y.scrollTop - v.y, m.y && y.scrollBy({ top: -m.y, behavior: o }); break } } this.handleMove(e, po(Hl(h, this.referenceCoordinates), m)) } } } handleMove(e, t) { const { onMove: n } = this.props; e.preventDefault(), n(t) } handleEnd(e) { const { onEnd: t } = this.props; e.preventDefault(), this.detach(), t() } handleCancel(e) { const { onCancel: t } = this.props; e.preventDefault(), this.detach(), t() } detach() { this.listeners.removeAll(), this.windowListeners.removeAll() } } py.activators = [{ eventName: "onKeyDown", handler: (r, e, t) => { let { keyboardCodes: n = YE, onActivation: i } = e, { active: s } = t; const { code: a } = r.nativeEvent; if (n.start.includes(a)) { const o = s.activatorNode.current; return o && r.target !== o ? !1 : (r.preventDefault(), i == null || i({ event: r.nativeEvent }), !0) } return !1 } }]; function zx(r) { return !!(r && "distance" in r) } function Hx(r) { return !!(r && "delay" in r) } class fy { constructor(e, t, n) { var i; n === void 0 && (n = h7(e.event.target)), this.props = void 0, this.events = void 0, this.autoScrollEnabled = !0, this.document = void 0, this.activated = !1, this.initialCoordinates = void 0, this.timeoutId = null, this.listeners = void 0, this.documentListeners = void 0, this.windowListeners = void 0, this.props = e, this.events = t; const { event: s } = e, { target: a } = s; this.props = e, this.events = t, this.document = qo(a), this.documentListeners = new Pl(this.document), this.listeners = new Pl(n), this.windowListeners = new Pl(ur(a)), this.initialCoordinates = (i = cd(s)) != null ? i : xi, this.handleStart = this.handleStart.bind(this), this.handleMove = this.handleMove.bind(this), this.handleEnd = this.handleEnd.bind(this), this.handleCancel = this.handleCancel.bind(this), this.handleKeydown = this.handleKeydown.bind(this), this.removeTextSelection = this.removeTextSelection.bind(this), this.attach() } attach() { const { events: e, props: { options: { activationConstraint: t, bypassActivationConstraint: n } } } = this; if (this.listeners.add(e.move.name, this.handleMove, { passive: !1 }), this.listeners.add(e.end.name, this.handleEnd), e.cancel && this.listeners.add(e.cancel.name, this.handleCancel), this.windowListeners.add(Vr.Resize, this.handleCancel), this.windowListeners.add(Vr.DragStart, Bx), this.windowListeners.add(Vr.VisibilityChange, this.handleCancel), this.windowListeners.add(Vr.ContextMenu, Bx), this.documentListeners.add(Vr.Keydown, this.handleKeydown), t) { if (n != null && n({ event: this.props.event, activeNode: this.props.activeNode, options: this.props.options })) return this.handleStart(); if (Hx(t)) { this.timeoutId = setTimeout(this.handleStart, t.delay), this.handlePending(t); return } if (zx(t)) { this.handlePending(t); return } } this.handleStart() } detach() { this.listeners.removeAll(), this.windowListeners.removeAll(), setTimeout(this.documentListeners.removeAll, 50), this.timeoutId !== null && (clearTimeout(this.timeoutId), this.timeoutId = null) } handlePending(e, t) { const { active: n, onPending: i } = this.props; i(n, e, this.initialCoordinates, t) } handleStart() { const { initialCoordinates: e } = this, { onStart: t } = this.props; e && (this.activated = !0, this.documentListeners.add(Vr.Click, p7, { capture: !0 }), this.removeTextSelection(), this.documentListeners.add(Vr.SelectionChange, this.removeTextSelection), t(e)) } handleMove(e) { var t; const { activated: n, initialCoordinates: i, props: s } = this, { onMove: a, options: { activationConstraint: o } } = s; if (!i) return; const l = (t = cd(e)) != null ? t : xi, u = Hl(i, l); if (!n && o) { if (zx(o)) { if (o.tolerance != null && dp(u, o.tolerance)) return this.handleCancel(); if (dp(u, o.distance)) return this.handleStart() } if (Hx(o) && dp(u, o.tolerance)) return this.handleCancel(); this.handlePending(o, u); return } e.cancelable && e.preventDefault(), a(l) } handleEnd() { const { onAbort: e, onEnd: t } = this.props; this.detach(), this.activated || e(this.props.active), t() } handleCancel() { const { onAbort: e, onCancel: t } = this.props; this.detach(), this.activated || e(this.props.active), t() } handleKeydown(e) { e.code === tt.Esc && this.handleCancel() } removeTextSelection() { var e; (e = this.document.getSelection()) == null || e.removeAllRanges() } } const g7 = { cancel: { name: "pointercancel" }, move: { name: "pointermove" }, end: { name: "pointerup" } }; class XE extends fy { constructor(e) { const { event: t } = e, n = qo(t.target); super(e, g7, n) } } XE.activators = [{ eventName: "onPointerDown", handler: (r, e) => { let { nativeEvent: t } = r, { onActivation: n } = e; return !t.isPrimary || t.button !== 0 ? !1 : (n == null || n({ event: t }), !0) } }]; const m7 = { move: { name: "mousemove" }, end: { name: "mouseup" } }; var Pf; (function (r) { r[r.RightClick = 2] = "RightClick" })(Pf || (Pf = {})); class qE extends fy { constructor(e) { super(e, m7, qo(e.event.target)) } } qE.activators = [{ eventName: "onMouseDown", handler: (r, e) => { let { nativeEvent: t } = r, { onActivation: n } = e; return t.button === Pf.RightClick ? !1 : (n == null || n({ event: t }), !0) } }]; const hp = { cancel: { name: "touchcancel" }, move: { name: "touchmove" }, end: { name: "touchend" } }; class ZE extends fy { constructor(e) { super(e, hp) } static setup() { return window.addEventListener(hp.move.name, e, { capture: !1, passive: !1 }), function () { window.removeEventListener(hp.move.name, e) }; function e() { } } } ZE.activators = [{ eventName: "onTouchStart", handler: (r, e) => { let { nativeEvent: t } = r, { onActivation: n } = e; const { touches: i } = t; return i.length > 1 ? !1 : (n == null || n({ event: t }), !0) } }]; var kl; (function (r) { r[r.Pointer = 0] = "Pointer", r[r.DraggableRect = 1] = "DraggableRect" })(kl || (kl = {})); var Kl; (function (r) { r[r.TreeOrder = 0] = "TreeOrder", r[r.ReversedTreeOrder = 1] = "ReversedTreeOrder" })(Kl || (Kl = {})); function y7(r) { let { acceleration: e, activator: t = kl.Pointer, canScroll: n, draggingRect: i, enabled: s, interval: a = 5, order: o = Kl.TreeOrder, pointerCoordinates: l, scrollableAncestors: u, scrollableAncestorRects: d, delta: h, threshold: g } = r; const m = v7({ delta: h, disabled: !s }), [b, y] = D9(), w = R.useRef({ x: 0, y: 0 }), x = R.useRef({ x: 0, y: 0 }), S = R.useMemo(() => { switch (t) { case kl.Pointer: return l ? { top: l.y, bottom: l.y, left: l.x, right: l.x } : null; case kl.DraggableRect: return i } }, [t, i, l]), C = R.useRef(null), O = R.useCallback(() => { const v = C.current; if (!v) return; const T = w.current.x * x.current.x, I = w.current.y * x.current.y; v.scrollBy(T, I) }, []), E = R.useMemo(() => o === Kl.TreeOrder ? [...u].reverse() : u, [o, u]); R.useEffect(() => { if (!s || !u.length || !S) { y(); return } for (const v of E) { if ((n == null ? void 0 : n(v)) === !1) continue; const T = u.indexOf(v), I = d[T]; if (!I) continue; const { direction: k, speed: P } = o7(v, I, S, e, g); for (const N of ["x", "y"]) m[N][k[N]] || (P[N] = 0, k[N] = 0); if (P.x > 0 || P.y > 0) { y(), C.current = v, b(O, a), w.current = P, x.current = k; return } } w.current = { x: 0, y: 0 }, x.current = { x: 0, y: 0 }, y() }, [e, O, n, y, s, a, JSON.stringify(S), JSON.stringify(m), b, u, E, d, JSON.stringify(g)]) } const b7 = { x: { [Ln.Backward]: !1, [Ln.Forward]: !1 }, y: { [Ln.Backward]: !1, [Ln.Forward]: !1 } }; function v7(r) { let { delta: e, disabled: t } = r; const n = ld(e); return Oc(i => { if (t || !n || !i) return b7; const s = { x: Math.sign(e.x - n.x), y: Math.sign(e.y - n.y) }; return { x: { [Ln.Backward]: i.x[Ln.Backward] || s.x === -1, [Ln.Forward]: i.x[Ln.Forward] || s.x === 1 }, y: { [Ln.Backward]: i.y[Ln.Backward] || s.y === -1, [Ln.Forward]: i.y[Ln.Forward] || s.y === 1 } } }, [t, e, n]) } function x7(r, e) { const t = e != null ? r.get(e) : void 0, n = t ? t.node.current : null; return Oc(i => { var s; return e == null ? null : (s = n ?? i) != null ? s : null }, [n, e]) } function w7(r, e) { return R.useMemo(() => r.reduce((t, n) => { const { sensor: i } = n, s = i.activators.map(a => ({ eventName: a.eventName, handler: e(a.handler, n) })); return [...t, ...s] }, []), [r, e]) } var Ul; (function (r) { r[r.Always = 0] = "Always", r[r.BeforeDragging = 1] = "BeforeDragging", r[r.WhileDragging = 2] = "WhileDragging" })(Ul || (Ul = {})); var kf; (function (r) { r.Optimized = "optimized" })(kf || (kf = {})); const Kx = new Map; function C7(r, e) { let { dragging: t, dependencies: n, config: i } = e; const [s, a] = R.useState(null), { frequency: o, measure: l, strategy: u } = i, d = R.useRef(r), h = w(), g = zl(h), m = R.useCallback(function (x) { x === void 0 && (x = []), !g.current && a(S => S === null ? x : S.concat(x.filter(C => !S.includes(C)))) }, [g]), b = R.useRef(null), y = Oc(x => { if (h && !t) return Kx; if (!x || x === Kx || d.current !== r || s != null) { const S = new Map; for (let C of r) { if (!C) continue; if (s && s.length > 0 && !s.includes(C.id) && C.rect.current) { S.set(C.id, C.rect.current); continue } const O = C.node.current, E = O ? new hy(l(O), O) : null; C.rect.current = E, E && S.set(C.id, E) } return S } return x }, [r, s, t, h, l]); return R.useEffect(() => { d.current = r }, [r]), R.useEffect(() => { h || m() }, [t, h]), R.useEffect(() => { s && s.length > 0 && a(null) }, [JSON.stringify(s)]), R.useEffect(() => { h || typeof o != "number" || b.current !== null || (b.current = setTimeout(() => { m(), b.current = null }, o)) }, [o, h, m, ...n]), { droppableRects: y, measureDroppableContainers: m, measuringScheduled: s != null }; function w() { switch (u) { case Ul.Always: return !1; case Ul.BeforeDragging: return t; default: return !t } } } function gy(r, e) { return Oc(t => r ? t || (typeof e == "function" ? e(r) : r) : null, [e, r]) } function S7(r, e) { return gy(r, e) } function E7(r) { let { callback: e, disabled: t } = r; const n = rh(e), i = R.useMemo(() => { if (t || typeof window > "u" || typeof window.MutationObserver > "u") return; const { MutationObserver: s } = window; return new s(n) }, [n, t]); return R.useEffect(() => () => i == null ? void 0 : i.disconnect(), [i]), i } function ah(r) { let { callback: e, disabled: t } = r; const n = rh(e), i = R.useMemo(() => { if (t || typeof window > "u" || typeof window.ResizeObserver > "u") return; const { ResizeObserver: s } = window; return new s(n) }, [t]); return R.useEffect(() => () => i == null ? void 0 : i.disconnect(), [i]), i } function _7(r) { return new hy(Zo(r), r) } function Ux(r, e, t) { e === void 0 && (e = _7); const [n, i] = R.useState(null); function s() { i(l => { if (!r) return null; if (r.isConnected === !1) { var u; return (u = l ?? t) != null ? u : null } const d = e(r); return JSON.stringify(l) === JSON.stringify(d) ? l : d }) } const a = E7({ callback(l) { if (r) for (const u of l) { const { type: d, target: h } = u; if (d === "childList" && h instanceof HTMLElement && h.contains(r)) { s(); break } } } }), o = ah({ callback: s }); return vi(() => { s(), r ? (o == null || o.observe(r), a == null || a.observe(document.body, { childList: !0, subtree: !0 })) : (o == null || o.disconnect(), a == null || a.disconnect()) }, [r]), n } function O7(r) { const e = gy(r); return jE(r, e) } const Wx = []; function T7(r) { const e = R.useRef(r), t = Oc(n => r ? n && n !== Wx && r && e.current && r.parentNode === e.current.parentNode ? n : sh(r) : Wx, [r]); return R.useEffect(() => { e.current = r }, [r]), t } function I7(r) { const [e, t] = R.useState(null), n = R.useRef(r), i = R.useCallback(s => { const a = up(s.target); a && t(o => o ? (o.set(a, If(a)), new Map(o)) : null) }, []); return R.useEffect(() => { const s = n.current; if (r !== s) { a(s); const o = r.map(l => { const u = up(l); return u ? (u.addEventListener("scroll", i, { passive: !0 }), [u, If(u)]) : null }).filter(l => l != null); t(o.length ? new Map(o) : null), n.current = r } return () => { a(r), a(s) }; function a(o) { o.forEach(l => { const u = up(l); u == null || u.removeEventListener("scroll", i) }) } }, [i, r]), R.useMemo(() => r.length ? e ? Array.from(e.values()).reduce((s, a) => po(s, a), xi) : WE(r) : xi, [r, e]) } function Gx(r, e) { e === void 0 && (e = []); const t = R.useRef(null); return R.useEffect(() => { t.current = null }, e), R.useEffect(() => { const n = r !== xi; n && !t.current && (t.current = r), !n && t.current && (t.current = null) }, [r]), t.current ? Hl(r, t.current) : xi } function P7(r) { R.useEffect(() => { if (!nh) return; const e = r.map(t => { let { sensor: n } = t; return n.setup == null ? void 0 : n.setup() }); return () => { for (const t of e) t == null || t() } }, r.map(e => { let { sensor: t } = e; return t })) } function k7(r, e) { return R.useMemo(() => r.reduce((t, n) => { let { eventName: i, handler: s } = n; return t[i] = a => { s(a, e) }, t }, {}), [r, e]) } function JE(r) { return R.useMemo(() => r ? r7(r) : null, [r]) } const Yx = []; function R7(r, e) { e === void 0 && (e = Zo); const [t] = r, n = JE(t ? ur(t) : null), [i, s] = R.useState(Yx); function a() { s(() => r.length ? r.map(l => KE(l) ? n : new hy(e(l), l)) : Yx) } const o = ah({ callback: a }); return vi(() => { o == null || o.disconnect(), a(), r.forEach(l => o == null ? void 0 : o.observe(l)) }, [r]), i } function QE(r) { if (!r) return null; if (r.children.length > 1) return r; const e = r.children[0]; return _c(e) ? e : r } function D7(r) { let { measure: e } = r; const [t, n] = R.useState(null), i = R.useCallback(u => { for (const { target: d } of u) if (_c(d)) { n(h => { const g = e(d); return h ? { ...h, width: g.width, height: g.height } : g }); break } }, [e]), s = ah({ callback: i }), a = R.useCallback(u => { const d = QE(u); s == null || s.disconnect(), d && (s == null || s.observe(d)), n(d ? e(d) : null) }, [e, s]), [o, l] = od(a); return R.useMemo(() => ({ nodeRef: o, rect: t, setRef: l }), [t, o, l]) } const A7 = [{ sensor: XE, options: {} }, { sensor: py, options: {} }], N7 = { current: {} }, Pu = { draggable: { measure: Vx }, droppable: { measure: Vx, strategy: Ul.WhileDragging, frequency: kf.Optimized }, dragOverlay: { measure: Zo } }; class Rl extends Map { get(e) { var t; return e != null && (t = super.get(e)) != null ? t : void 0 } toArray() { return Array.from(this.values()) } getEnabled() { return this.toArray().filter(e => { let { disabled: t } = e; return !t }) } getNodeFor(e) { var t, n; return (t = (n = this.get(e)) == null ? void 0 : n.node.current) != null ? t : void 0 } } const F7 = { activatorEvent: null, active: null, activeNode: null, activeNodeRect: null, collisions: null, containerNodeRect: null, draggableNodes: new Map, droppableRects: new Map, droppableContainers: new Rl, over: null, dragOverlay: { nodeRef: { current: null }, rect: null, setRef: ud }, scrollableAncestors: [], scrollableAncestorRects: [], measuringConfiguration: Pu, measureDroppableContainers: ud, windowRect: null, measuringScheduled: !1 }, e_ = { activatorEvent: null, activators: [], active: null, activeNodeRect: null, ariaDescribedById: { draggable: "" }, dispatch: ud, draggableNodes: new Map, over: null, measureDroppableContainers: ud }, Ic = R.createContext(e_), t_ = R.createContext(F7); function $7() { return { draggable: { active: null, initialCoordinates: { x: 0, y: 0 }, nodes: new Map, translate: { x: 0, y: 0 } }, droppable: { containers: new Rl } } } function L7(r, e) { switch (e.type) { case Pn.DragStart: return { ...r, draggable: { ...r.draggable, initialCoordinates: e.initialCoordinates, active: e.active } }; case Pn.DragMove: return r.draggable.active == null ? r : { ...r, draggable: { ...r.draggable, translate: { x: e.coordinates.x - r.draggable.initialCoordinates.x, y: e.coordinates.y - r.draggable.initialCoordinates.y } } }; case Pn.DragEnd: case Pn.DragCancel: return { ...r, draggable: { ...r.draggable, active: null, initialCoordinates: { x: 0, y: 0 }, translate: { x: 0, y: 0 } } }; case Pn.RegisterDroppable: { const { element: t } = e, { id: n } = t, i = new Rl(r.droppable.containers); return i.set(n, t), { ...r, droppable: { ...r.droppable, containers: i } } } case Pn.SetDroppableDisabled: { const { id: t, key: n, disabled: i } = e, s = r.droppable.containers.get(t); if (!s || n !== s.key) return r; const a = new Rl(r.droppable.containers); return a.set(t, { ...s, disabled: i }), { ...r, droppable: { ...r.droppable, containers: a } } } case Pn.UnregisterDroppable: { const { id: t, key: n } = e, i = r.droppable.containers.get(t); if (!i || n !== i.key) return r; const s = new Rl(r.droppable.containers); return s.delete(t), { ...r, droppable: { ...r.droppable, containers: s } } } default: return r } } function M7(r) { let { disabled: e } = r; const { active: t, activatorEvent: n, draggableNodes: i } = R.useContext(Ic), s = ld(n), a = ld(t == null ? void 0 : t.id); return R.useEffect(() => { if (!e && !n && s && a != null) { if (!ih(s) || document.activeElement === s.target) return; const o = i.get(a); if (!o) return; const { activatorNode: l, node: u } = o; if (!l.current && !u.current) return; requestAnimationFrame(() => { for (const d of [l.current, u.current]) { if (!d) continue; const h = F9(d); if (h) { h.focus(); break } } }) } }, [n, e, i, a, s]), null } function n_(r, e) { let { transform: t, ...n } = e; return r != null && r.length ? r.reduce((i, s) => s({ transform: i, ...n }), t) : t } function j7(r) { return R.useMemo(() => ({ draggable: { ...Pu.draggable, ...r == null ? void 0 : r.draggable }, droppable: { ...Pu.droppable, ...r == null ? void 0 : r.droppable }, dragOverlay: { ...Pu.dragOverlay, ...r == null ? void 0 : r.dragOverlay } }), [r == null ? void 0 : r.draggable, r == null ? void 0 : r.droppable, r == null ? void 0 : r.dragOverlay]) } function V7(r) { let { activeNode: e, measure: t, initialRect: n, config: i = !0 } = r; const s = R.useRef(!1), { x: a, y: o } = typeof i == "boolean" ? { x: i, y: i } : i; vi(() => { if (!a && !o || !e) { s.current = !1; return } if (s.current || !n) return; const u = e == null ? void 0 : e.node.current; if (!u || u.isConnected === !1) return; const d = t(u), h = jE(d, n); if (a || (h.x = 0), o || (h.y = 0), s.current = !0, Math.abs(h.x) > 0 || Math.abs(h.y) > 0) { const g = BE(u); g && g.scrollBy({ top: h.y, left: h.x }) } }, [e, a, o, n, t]) } const oh = R.createContext({ ...xi, scaleX: 1, scaleY: 1 }); var _s; (function (r) { r[r.Uninitialized = 0] = "Uninitialized", r[r.Initializing = 1] = "Initializing", r[r.Initialized = 2] = "Initialized" })(_s || (_s = {})); const B7 = R.memo(function (e) { var t, n, i, s; let { id: a, accessibility: o, autoScroll: l = !0, children: u, sensors: d = A7, collisionDetection: h = Z9, measuring: g, modifiers: m, ...b } = e; const y = R.useReducer(L7, void 0, $7), [w, x] = y, [S, C] = B9(), [O, E] = R.useState(_s.Uninitialized), v = O === _s.Initialized, { draggable: { active: T, nodes: I, translate: k }, droppable: { containers: P } } = w, N = T != null ? I.get(T) : null, M = R.useRef({ initial: null, translated: null }), B = R.useMemo(() => { var Ie; return T != null ? { id: T, data: (Ie = N == null ? void 0 : N.data) != null ? Ie : N7, rect: M } : null }, [T, N]), K = R.useRef(null), [U, W] = R.useState(null), [Z, J] = R.useState(null), ee = zl(b, Object.values(b)), $ = Tc("DndDescribedBy", a), pe = R.useMemo(() => P.getEnabled(), [P]), re = j7(g), { droppableRects: j, measureDroppableContainers: ae, measuringScheduled: be } = C7(pe, { dragging: v, dependencies: [k.x, k.y], config: re.droppable }), fe = x7(I, T), Ce = R.useMemo(() => Z ? cd(Z) : null, [Z]), ue = Sn(), te = S7(fe, re.draggable.measure); V7({ activeNode: T != null ? I.get(T) : null, config: ue.layoutShiftCompensation, initialRect: te, measure: re.draggable.measure }); const le = Ux(fe, re.draggable.measure, te), Re = Ux(fe ? fe.parentElement : null), at = R.useRef({ activatorEvent: null, active: null, activeNode: fe, collisionRect: null, collisions: null, droppableRects: j, draggableNodes: I, draggingNode: null, draggingNodeRect: null, droppableContainers: P, over: null, scrollableAncestors: [], scrollAdjustedTranslate: null }), yt = P.getNodeFor((t = at.current.over) == null ? void 0 : t.id), ht = D7({ measure: re.dragOverlay.measure }), Ft = (n = ht.nodeRef.current) != null ? n : fe, qe = v ? (i = ht.rect) != null ? i : le : null, $t = !!(ht.nodeRef.current && ht.rect), gn = O7($t ? null : le), Hn = JE(Ft ? ur(Ft) : null), ot = T7(v ? yt ?? fe : null), Ut = R7(ot), Wt = n_(m, { transform: { x: k.x - gn.x, y: k.y - gn.y, scaleX: 1, scaleY: 1 }, activatorEvent: Z, active: B, activeNodeRect: le, containerNodeRect: Re, draggingNodeRect: qe, over: at.current.over, overlayNodeRect: ht.rect, scrollableAncestors: ot, scrollableAncestorRects: Ut, windowRect: Hn }), wn = Ce ? po(Ce, k) : null, Ze = I7(ot), hr = Gx(Ze), X = Gx(Ze, [le]), Q = po(Wt, hr), L = qe ? e7(qe, Wt) : null, Oe = B && L ? h({ active: B, collisionRect: L, droppableRects: j, droppableContainers: pe, pointerCoordinates: wn }) : null, De = ME(Oe, "id"), [ie, un] = R.useState(null), Qt = $t ? Wt : po(Wt, X), jn = J9(Qt, (s = ie == null ? void 0 : ie.rect) != null ? s : null, le), Et = R.useRef(null), _t = R.useCallback((Ie, Dt) => { let { sensor: me, options: tn } = Dt; if (K.current == null) return; const Gt = I.get(K.current); if (!Gt) return; const nn = Ie.nativeEvent, En = new me({ active: K.current, activeNode: Gt, event: nn, options: tn, context: at, onAbort(dn) { if (!I.get(dn)) return; const { onDragAbort: Pe } = ee.current, Je = { id: dn }; Pe == null || Pe(Je), S({ type: "onDragAbort", event: Je }) }, onPending(dn, Kn, Pe, Je) { if (!I.get(dn)) return; const { onDragPending: lt } = ee.current, Yt = { id: dn, constraint: Kn, initialCoordinates: Pe, offset: Je }; lt == null || lt(Yt), S({ type: "onDragPending", event: Yt }) }, onStart(dn) { const Kn = K.current; if (Kn == null) return; const Pe = I.get(Kn); if (!Pe) return; const { onDragStart: Je } = ee.current, Bt = { activatorEvent: nn, active: { id: Kn, data: Pe.data, rect: M } }; di.unstable_batchedUpdates(() => { Je == null || Je(Bt), E(_s.Initializing), x({ type: Pn.DragStart, initialCoordinates: dn, active: Kn }), S({ type: "onDragStart", event: Bt }), W(Et.current), J(nn) }) }, onMove(dn) { x({ type: Pn.DragMove, coordinates: dn }) }, onEnd: Fn(Pn.DragEnd), onCancel: Fn(Pn.DragCancel) }); Et.current = En; function Fn(dn) { return async function () { const { active: Pe, collisions: Je, over: Bt, scrollAdjustedTranslate: lt } = at.current; let Yt = null; if (Pe && lt) { const { cancelDrop: Ot } = ee.current; Yt = { activatorEvent: nn, active: Pe, collisions: Je, delta: lt, over: Bt }, dn === Pn.DragEnd && typeof Ot == "function" && await Promise.resolve(Ot(Yt)) && (dn = Pn.DragCancel) } K.current = null, di.unstable_batchedUpdates(() => { x({ type: dn }), E(_s.Uninitialized), un(null), W(null), J(null), Et.current = null; const Ot = dn === Pn.DragEnd ? "onDragEnd" : "onDragCancel"; if (Yt) { const Rt = ee.current[Ot]; Rt == null || Rt(Yt), S({ type: Ot, event: Yt }) } }) } } }, [I]), Nn = R.useCallback((Ie, Dt) => (me, tn) => { const Gt = me.nativeEvent, nn = I.get(tn); if (K.current !== null || !nn || Gt.dndKit || Gt.defaultPrevented) return; const En = { active: nn }; Ie(me, Dt.options, En) === !0 && (Gt.dndKit = { capturedBy: Dt.sensor }, K.current = tn, _t(me, Dt)) }, [I, _t]), Cn = w7(d, Nn); P7(d), vi(() => { le && O === _s.Initializing && E(_s.Initialized) }, [le, O]), R.useEffect(() => { const { onDragMove: Ie } = ee.current, { active: Dt, activatorEvent: me, collisions: tn, over: Gt } = at.current; if (!Dt || !me) return; const nn = { active: Dt, activatorEvent: me, collisions: tn, delta: { x: Q.x, y: Q.y }, over: Gt }; di.unstable_batchedUpdates(() => { Ie == null || Ie(nn), S({ type: "onDragMove", event: nn }) }) }, [Q.x, Q.y]), R.useEffect(() => { const { active: Ie, activatorEvent: Dt, collisions: me, droppableContainers: tn, scrollAdjustedTranslate: Gt } = at.current; if (!Ie || K.current == null || !Dt || !Gt) return; const { onDragOver: nn } = ee.current, En = tn.get(De), Fn = En && En.rect.current ? { id: En.id, rect: En.rect.current, data: En.data, disabled: En.disabled } : null, dn = { active: Ie, activatorEvent: Dt, collisions: me, delta: { x: Gt.x, y: Gt.y }, over: Fn }; di.unstable_batchedUpdates(() => { un(Fn), nn == null || nn(dn), S({ type: "onDragOver", event: dn }) }) }, [De]), vi(() => { at.current = { activatorEvent: Z, active: B, activeNode: fe, collisionRect: L, collisions: Oe, droppableRects: j, draggableNodes: I, draggingNode: Ft, draggingNodeRect: qe, droppableContainers: P, over: ie, scrollableAncestors: ot, scrollAdjustedTranslate: Q }, M.current = { initial: qe, translated: L } }, [B, fe, Oe, L, I, Ft, qe, j, P, ie, ot, Q]), y7({ ...ue, delta: k, draggingRect: L, pointerCoordinates: wn, scrollableAncestors: ot, scrollableAncestorRects: Ut }); const Ar = R.useMemo(() => ({ active: B, activeNode: fe, activeNodeRect: le, activatorEvent: Z, collisions: Oe, containerNodeRect: Re, dragOverlay: ht, draggableNodes: I, droppableContainers: P, droppableRects: j, over: ie, measureDroppableContainers: ae, scrollableAncestors: ot, scrollableAncestorRects: Ut, measuringConfiguration: re, measuringScheduled: be, windowRect: Hn }), [B, fe, le, Z, Oe, Re, ht, I, P, j, ie, ae, ot, Ut, re, be, Hn]), en = R.useMemo(() => ({ activatorEvent: Z, activators: Cn, active: B, activeNodeRect: le, ariaDescribedById: { draggable: $ }, dispatch: x, draggableNodes: I, over: ie, measureDroppableContainers: ae }), [Z, Cn, B, le, x, $, I, ie, ae]); return f.createElement(FE.Provider, { value: C }, f.createElement(Ic.Provider, { value: en }, f.createElement(t_.Provider, { value: Ar }, f.createElement(oh.Provider, { value: jn }, u)), f.createElement(M7, { disabled: (o == null ? void 0 : o.restoreFocus) === !1 })), f.createElement(K9, { ...o, hiddenTextDescribedById: $ })); function Sn() { const Ie = (U == null ? void 0 : U.autoScrollEnabled) === !1, Dt = typeof l == "object" ? l.enabled === !1 : l === !1, me = v && !Ie && !Dt; return typeof l == "object" ? { ...l, enabled: me } : { enabled: me } } }), z7 = R.createContext(null), Xx = "button", H7 = "Draggable"; function K7(r) { let { id: e, data: t, disabled: n = !1, attributes: i } = r; const s = Tc(H7), { activators: a, activatorEvent: o, active: l, activeNodeRect: u, ariaDescribedById: d, draggableNodes: h, over: g } = R.useContext(Ic), { role: m = Xx, roleDescription: b = "draggable", tabIndex: y = 0 } = i ?? {}, w = (l == null ? void 0 : l.id) === e, x = R.useContext(w ? oh : z7), [S, C] = od(), [O, E] = od(), v = k7(a, e), T = zl(t); vi(() => (h.set(e, { id: e, key: s, node: S, activatorNode: O, data: T }), () => { const k = h.get(e); k && k.key === s && h.delete(e) }), [h, e]); const I = R.useMemo(() => ({ role: m, tabIndex: y, "aria-disabled": n, "aria-pressed": w && m === Xx ? !0 : void 0, "aria-roledescription": b, "aria-describedby": d.draggable }), [n, m, y, w, b, d.draggable]); return { active: l, activatorEvent: o, activeNodeRect: u, attributes: I, isDragging: w, listeners: n ? void 0 : v, node: S, over: g, setNodeRef: C, setActivatorNodeRef: E, transform: x } } function r_() { return R.useContext(t_) } const U7 = "Droppable", W7 = { timeout: 25 }; function G7(r) { let { data: e, disabled: t = !1, id: n, resizeObserverConfig: i } = r; const s = Tc(U7), { active: a, dispatch: o, over: l, measureDroppableContainers: u } = R.useContext(Ic), d = R.useRef({ disabled: t }), h = R.useRef(!1), g = R.useRef(null), m = R.useRef(null), { disabled: b, updateMeasurementsFor: y, timeout: w } = { ...W7, ...i }, x = zl(y ?? n), S = R.useCallback(() => { if (!h.current) { h.current = !0; return } m.current != null && clearTimeout(m.current), m.current = setTimeout(() => { u(Array.isArray(x.current) ? x.current : [x.current]), m.current = null }, w) }, [w]), C = ah({ callback: S, disabled: b || !a }), O = R.useCallback((I, k) => { C && (k && (C.unobserve(k), h.current = !1), I && C.observe(I)) }, [C]), [E, v] = od(O), T = zl(e); return R.useEffect(() => { !C || !E.current || (C.disconnect(), h.current = !1, C.observe(E.current)) }, [E, C]), R.useEffect(() => (o({ type: Pn.RegisterDroppable, element: { id: n, key: s, disabled: t, node: E, rect: g, data: T } }), () => o({ type: Pn.UnregisterDroppable, key: s, id: n })), [n]), R.useEffect(() => { t !== d.current.disabled && (o({ type: Pn.SetDroppableDisabled, id: n, key: s, disabled: t }), d.current.disabled = t) }, [n, s, t, o]), { active: a, rect: g, isOver: (l == null ? void 0 : l.id) === n, node: E, over: l, setNodeRef: v } } function Y7(r) { let { animation: e, children: t } = r; const [n, i] = R.useState(null), [s, a] = R.useState(null), o = ld(t); return !t && !n && o && i(o), vi(() => { if (!s) return; const l = n == null ? void 0 : n.key, u = n == null ? void 0 : n.props.id; if (l == null || u == null) { i(null); return } Promise.resolve(e(u, s)).then(() => { i(null) }) }, [e, n, s]), f.createElement(f.Fragment, null, t, n ? R.cloneElement(n, { ref: a }) : null) } const X7 = { x: 0, y: 0, scaleX: 1, scaleY: 1 }; function q7(r) { let { children: e } = r; return f.createElement(Ic.Provider, { value: e_ }, f.createElement(oh.Provider, { value: X7 }, e)) } const Z7 = { position: "fixed", touchAction: "none" }, J7 = r => ih(r) ? "transform 250ms ease" : void 0, Q7 = R.forwardRef((r, e) => { let { as: t, activatorEvent: n, adjustScale: i, children: s, className: a, rect: o, style: l, transform: u, transition: d = J7 } = r; if (!o) return null; const h = i ? u : { ...u, scaleX: 1, scaleY: 1 }, g = { ...Z7, width: o.width, height: o.height, top: o.top, left: o.left, transform: js.Transform.toString(h), transformOrigin: i && n ? W9(n, o) : void 0, transition: typeof d == "function" ? d(n) : d, ...l }; return f.createElement(t, { className: a, style: g, ref: e }, s) }), e8 = r => e => { let { active: t, dragOverlay: n } = e; const i = {}, { styles: s, className: a } = r; if (s != null && s.active) for (const [o, l] of Object.entries(s.active)) l !== void 0 && (i[o] = t.node.style.getPropertyValue(o), t.node.style.setProperty(o, l)); if (s != null && s.dragOverlay) for (const [o, l] of Object.entries(s.dragOverlay)) l !== void 0 && n.node.style.setProperty(o, l); return a != null && a.active && t.node.classList.add(a.active), a != null && a.dragOverlay && n.node.classList.add(a.dragOverlay), function () { for (const [l, u] of Object.entries(i)) t.node.style.setProperty(l, u); a != null && a.active && t.node.classList.remove(a.active) } }, t8 = r => { let { transform: { initial: e, final: t } } = r; return [{ transform: js.Transform.toString(e) }, { transform: js.Transform.toString(t) }] }, n8 = { duration: 250, easing: "ease", keyframes: t8, sideEffects: e8({ styles: { active: { opacity: "0" } } }) }; function r8(r) { let { config: e, draggableNodes: t, droppableContainers: n, measuringConfiguration: i } = r; return rh((s, a) => { if (e === null) return; const o = t.get(s); if (!o) return; const l = o.node.current; if (!l) return; const u = QE(a); if (!u) return; const { transform: d } = ur(a).getComputedStyle(a), h = VE(d); if (!h) return; const g = typeof e == "function" ? e : i8(e); return GE(l, i.draggable.measure), g({ active: { id: s, data: o.data, node: l, rect: i.draggable.measure(l) }, draggableNodes: t, dragOverlay: { node: a, rect: i.dragOverlay.measure(u) }, droppableContainers: n, measuringConfiguration: i, transform: h }) }) } function i8(r) { const { duration: e, easing: t, sideEffects: n, keyframes: i } = { ...n8, ...r }; return s => { let { active: a, dragOverlay: o, transform: l, ...u } = s; if (!e) return; const d = { x: o.rect.left - a.rect.left, y: o.rect.top - a.rect.top }, h = { scaleX: l.scaleX !== 1 ? a.rect.width * l.scaleX / o.rect.width : 1, scaleY: l.scaleY !== 1 ? a.rect.height * l.scaleY / o.rect.height : 1 }, g = { x: l.x - d.x, y: l.y - d.y, ...h }, m = i({ ...u, active: a, dragOverlay: o, transform: { initial: l, final: g } }), [b] = m, y = m[m.length - 1]; if (JSON.stringify(b) === JSON.stringify(y)) return; const w = n == null ? void 0 : n({ active: a, dragOverlay: o, ...u }), x = o.node.animate(m, { duration: e, easing: t, fill: "forwards" }); return new Promise(S => { x.onfinish = () => { w == null || w(), S() } }) } } let qx = 0; function s8(r) { return R.useMemo(() => { if (r != null) return qx++, qx }, [r]) } const a8 = f.memo(r => { let { adjustScale: e = !1, children: t, dropAnimation: n, style: i, transition: s, modifiers: a, wrapperElement: o = "div", className: l, zIndex: u = 999 } = r; const { activatorEvent: d, active: h, activeNodeRect: g, containerNodeRect: m, draggableNodes: b, droppableContainers: y, dragOverlay: w, over: x, measuringConfiguration: S, scrollableAncestors: C, scrollableAncestorRects: O, windowRect: E } = r_(), v = R.useContext(oh), T = s8(h == null ? void 0 : h.id), I = n_(a, { activatorEvent: d, active: h, activeNodeRect: g, containerNodeRect: m, draggingNodeRect: w.rect, over: x, overlayNodeRect: w.rect, scrollableAncestors: C, scrollableAncestorRects: O, transform: v, windowRect: E }), k = gy(g), P = r8({ config: n, draggableNodes: b, droppableContainers: y, measuringConfiguration: S }), N = k ? w.setRef : void 0; return f.createElement(q7, null, f.createElement(Y7, { animation: P }, h && T ? f.createElement(Q7, { key: T, id: h.id, ref: N, as: o, activatorEvent: d, adjustScale: e, className: l, transition: s, rect: k, style: { zIndex: u, ...i }, transform: I }, t) : null)) }); function i_(r, e, t) { const n = r.slice(); return n.splice(t < 0 ? n.length + t : t, 0, n.splice(e, 1)[0]), n } function o8(r, e) { return r.reduce((t, n, i) => { const s = e.get(n); return s && (t[i] = s), t }, Array(r.length)) } function au(r) { return r !== null && r >= 0 } function l8(r, e) { if (r === e) return !0; if (r.length !== e.length) return !1; for (let t = 0; t < r.length; t++)if (r[t] !== e[t]) return !1; return !0 } function c8(r) { return typeof r == "boolean" ? { draggable: r, droppable: r } : r } const my = r => { let { rects: e, activeIndex: t, overIndex: n, index: i } = r; const s = i_(e, n, t), a = e[i], o = s[i]; return !o || !a ? null : { x: o.left - a.left, y: o.top - a.top, scaleX: o.width / a.width, scaleY: o.height / a.height } }, s_ = "Sortable", a_ = f.createContext({ activeIndex: -1, containerId: s_, disableTransforms: !1, items: [], overIndex: -1, useDragOverlay: !1, sortedRects: [], strategy: my, disabled: { draggable: !1, droppable: !1 } }); function u8(r) { let { children: e, id: t, items: n, strategy: i = my, disabled: s = !1 } = r; const { active: a, dragOverlay: o, droppableRects: l, over: u, measureDroppableContainers: d } = r_(), h = Tc(s_, t), g = o.rect !== null, m = R.useMemo(() => n.map(v => typeof v == "object" && "id" in v ? v.id : v), [n]), b = a != null, y = a ? m.indexOf(a.id) : -1, w = u ? m.indexOf(u.id) : -1, x = R.useRef(m), S = !l8(m, x.current), C = w !== -1 && y === -1 || S, O = c8(s); vi(() => { S && b && d(m) }, [S, m, b, d]), R.useEffect(() => { x.current = m }, [m]); const E = R.useMemo(() => ({ activeIndex: y, containerId: h, disabled: O, disableTransforms: C, items: m, overIndex: w, useDragOverlay: g, sortedRects: o8(m, l), strategy: i }), [y, h, O.draggable, O.droppable, C, m, w, l, g, i]); return f.createElement(a_.Provider, { value: E }, e) } const d8 = r => { let { id: e, items: t, activeIndex: n, overIndex: i } = r; return i_(t, n, i).indexOf(e) }, h8 = r => { let { containerId: e, isSorting: t, wasDragging: n, index: i, items: s, newIndex: a, previousItems: o, previousContainerId: l, transition: u } = r; return !u || !n || o !== s && i === a ? !1 : t ? !0 : a !== i && e === l }, p8 = { duration: 200, easing: "ease" }, o_ = "transform", f8 = js.Transition.toString({ property: o_, duration: 0, easing: "linear" }), g8 = { roleDescription: "sortable" }; function m8(r) { let { disabled: e, index: t, node: n, rect: i } = r; const [s, a] = R.useState(null), o = R.useRef(t); return vi(() => { if (!e && t !== o.current && n.current) { const l = i.current; if (l) { const u = Zo(n.current, { ignoreTransform: !0 }), d = { x: l.left - u.left, y: l.top - u.top, scaleX: l.width / u.width, scaleY: l.height / u.height }; (d.x || d.y) && a(d) } } t !== o.current && (o.current = t) }, [e, t, n, i]), R.useEffect(() => { s && a(null) }, [s]), s } function y8(r) { let { animateLayoutChanges: e = h8, attributes: t, disabled: n, data: i, getNewIndex: s = d8, id: a, strategy: o, resizeObserverConfig: l, transition: u = p8 } = r; const { items: d, containerId: h, activeIndex: g, disabled: m, disableTransforms: b, sortedRects: y, overIndex: w, useDragOverlay: x, strategy: S } = R.useContext(a_), C = b8(n, m), O = d.indexOf(a), E = R.useMemo(() => ({ sortable: { containerId: h, index: O, items: d }, ...i }), [h, i, O, d]), v = R.useMemo(() => d.slice(d.indexOf(a)), [d, a]), { rect: T, node: I, isOver: k, setNodeRef: P } = G7({ id: a, data: E, disabled: C.droppable, resizeObserverConfig: { updateMeasurementsFor: v, ...l } }), { active: N, activatorEvent: M, activeNodeRect: B, attributes: K, setNodeRef: U, listeners: W, isDragging: Z, over: J, setActivatorNodeRef: ee, transform: $ } = K7({ id: a, data: E, attributes: { ...g8, ...t }, disabled: C.draggable }), pe = R9(P, U), re = !!N, j = re && !b && au(g) && au(w), ae = !x && Z, be = ae && j ? $ : null, Ce = j ? be ?? (o ?? S)({ rects: y, activeNodeRect: B, activeIndex: g, overIndex: w, index: O }) : null, ue = au(g) && au(w) ? s({ id: a, items: d, activeIndex: g, overIndex: w }) : O, te = N == null ? void 0 : N.id, le = R.useRef({ activeId: te, items: d, newIndex: ue, containerId: h }), Re = d !== le.current.items, at = e({ active: N, containerId: h, isDragging: Z, isSorting: re, id: a, index: O, items: d, newIndex: le.current.newIndex, previousItems: le.current.items, previousContainerId: le.current.containerId, transition: u, wasDragging: le.current.activeId != null }), yt = m8({ disabled: !at, index: O, node: I, rect: T }); return R.useEffect(() => { re && le.current.newIndex !== ue && (le.current.newIndex = ue), h !== le.current.containerId && (le.current.containerId = h), d !== le.current.items && (le.current.items = d) }, [re, ue, h, d]), R.useEffect(() => { if (te === le.current.activeId) return; if (te && !le.current.activeId) { le.current.activeId = te; return } const Ft = setTimeout(() => { le.current.activeId = te }, 50); return () => clearTimeout(Ft) }, [te]), { active: N, activeIndex: g, attributes: K, data: E, rect: T, index: O, newIndex: ue, items: d, isOver: k, isSorting: re, isDragging: Z, listeners: W, node: I, overIndex: w, over: J, setNodeRef: pe, setActivatorNodeRef: ee, setDroppableNodeRef: P, setDraggableNodeRef: U, transform: yt ?? Ce, transition: ht() }; function ht() { if (yt || Re && le.current.newIndex === O) return f8; if (!(ae && !ih(M) || !u) && (re || at)) return js.Transition.toString({ ...u, property: o_ }) } } function b8(r, e) { var t, n; return typeof r == "boolean" ? { draggable: r, droppable: !1 } : { draggable: (t = r == null ? void 0 : r.draggable) != null ? t : e.draggable, droppable: (n = r == null ? void 0 : r.droppable) != null ? n : e.droppable } } function dd(r) { if (!r) return !1; const e = r.data.current; return !!(e && "sortable" in e && typeof e.sortable == "object" && "containerId" in e.sortable && "items" in e.sortable && "index" in e.sortable) } const v8 = [tt.Down, tt.Right, tt.Up, tt.Left], x8 = (r, e) => { let { context: { active: t, collisionRect: n, droppableRects: i, droppableContainers: s, over: a, scrollableAncestors: o } } = e; if (v8.includes(r.code)) { if (r.preventDefault(), !t || !n) return; const l = []; s.getEnabled().forEach(h => { if (!h || h != null && h.disabled) return; const g = i.get(h.id); if (g) switch (r.code) { case tt.Down: n.top < g.top && l.push(h); break; case tt.Up: n.top > g.top && l.push(h); break; case tt.Left: n.left > g.left && l.push(h); break; case tt.Right: n.left < g.left && l.push(h); break } }); const u = X9({ active: t, collisionRect: n, droppableRects: i, droppableContainers: l, pointerCoordinates: null }); let d = ME(u, "id"); if (d === (a == null ? void 0 : a.id) && u.length > 1 && (d = u[1].id), d != null) { const h = s.get(t.id), g = s.get(d), m = g ? i.get(g.id) : null, b = g == null ? void 0 : g.node.current; if (b && m && h && g) { const w = sh(b).some((v, T) => o[T] !== v), x = l_(h, g), S = w8(h, g), C = w || !x ? { x: 0, y: 0 } : { x: S ? n.width - m.width : 0, y: S ? n.height - m.height : 0 }, O = { x: m.left, y: m.top }; return C.x && C.y ? O : Hl(O, C) } } } }; function l_(r, e) { return !dd(r) || !dd(e) ? !1 : r.data.current.sortable.containerId === e.data.current.sortable.containerId } function w8(r, e) { return !dd(r) || !dd(e) || !l_(r, e) ? !1 : r.data.current.sortable.index < e.data.current.sortable.index } const C8 = "semi-sortable"; function S8(r) { return f.createElement("div", Object.assign({ style: { overflow: "auto" } }, r)) } const E8 = { coordinateGetter: x8 }; function _8(r) { let { items: e, onSortEnd: t, adjustScale: n, renderItem: i, transition: s, collisionDetection: a = Y9, strategy: o = my, useDragOverlay: l = !0, dragOverlayCls: u, container: d = S8, prefix: h = C8 } = r; const [g, m] = R.useState(null), b = U9(cp(qE), cp(ZE), cp(py, E8)), y = R.useCallback(O => e.indexOf(O), [e]), w = R.useMemo(() => g ? y(g) : -1, [y, g]), x = R.useCallback(O => { let { active: E } = O; E && m(E.id) }, []), S = R.useCallback(O => { let { over: E } = O; if (m(null), E) { const v = y(E.id); w !== v && t({ oldIndex: w, newIndex: v }) } }, [w, y, t]), C = R.useCallback(() => { m(null) }, []); return f.createElement(B7, { sensors: b, collisionDetection: a, onDragStart: x, onDragEnd: S, onDragCancel: C, autoScroll: { order: Kl.ReversedTreeOrder } }, f.createElement(u8, { items: e, strategy: o }, f.createElement(d, null, e.map((O, E) => f.createElement(O8, { key: O, id: O, index: E, renderItem: i, useDragOverlay: l, prefix: h, transition: s })))), l ? di.createPortal(f.createElement(a8, { adjustScale: n, style: { zIndex: void 0 }, className: u }, g ? i({ id: g, sortableHandle: O => O }) : null), document.body) : null) } function O8(r) { let { animateLayoutChanges: e, id: t, renderItem: n, prefix: i, transition: s } = r; const { listeners: a, setNodeRef: o, transform: l, transition: u, active: d, isOver: h, attributes: g } = y8({ id: t, animateLayoutChanges: e, transition: s }), m = R.useCallback(w => () => f.createElement("span", Object.assign({}, a, { style: { lineHeight: 0 }, onMouseDown: x => { a.onMouseDown(x), x.preventDefault(), x.stopPropagation() } }), f.createElement(w, null)), [a]), b = F(`${i}-sortable-item`, { [`${i}-sortable-item-over`]: h, [`${i}-sortable-item-active`]: (d == null ? void 0 : d.id) === t }), y = R.useMemo(() => ss(s) ? void 0 : { transform: js.Transform.toString(Object.assign(Object.assign({}, l), { scaleX: 1, scaleY: 1 })), transition: u }, [s, l, u]); return f.createElement("div", Object.assign({ ref: o, style: y, className: b }, g), n({ id: t, sortableHandle: m })) } var T8 = function (r, e) { var t = {}; for (var n in r) Object.prototype.hasOwnProperty.call(r, n) && e.indexOf(n) < 0 && (t[n] = r[n]); if (r != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, n = Object.getOwnPropertySymbols(r); i < n.length; i++)e.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(r, n[i]) && (t[n[i]] = r[n[i]]); return t }; const Qe = I9.PREFIX; function I8(r) { return f.createElement("div", Object.assign({ className: `${Qe}-sortable-list` }, r)) } class Pc extends de { constructor(e) { super(e), this.handleInputChange = t => { this.foundation.handleInputChange(t) }, this.handleKeyDown = t => { this.foundation.handleKeyDown(t) }, this.handleInputFocus = t => { this.foundation.handleInputFocus(t) }, this.handleInputBlur = t => { this.foundation.handleInputBlur(t) }, this.handleClearBtn = t => { this.foundation.handleClearBtn(t) }, this.handleClearEnterPress = t => { this.foundation.handleClearEnterPress(t) }, this.handleTagClose = t => { this.foundation.handleTagClose(t) }, this.handleInputMouseLeave = t => { this.foundation.handleInputMouseLeave() }, this.handleClick = t => { this.foundation.handleClick(t) }, this.handleInputMouseEnter = t => { this.foundation.handleInputMouseEnter() }, this.handleClickPrefixOrSuffix = t => { this.foundation.handleClickPrefixOrSuffix(t) }, this.handlePreventMouseDown = t => { this.foundation.handlePreventMouseDown(t) }, this.getAllTags = () => { const { tagsArray: t } = this.state; return t.map((n, i) => this.renderTag(n, i)) }, this.renderTag = (t, n, i) => { const { size: s, disabled: a, renderTagItem: o, showContentTooltip: l, draggable: u } = this.props, { active: d } = this.state, h = d && u, g = F(`${Qe}-wrapper-tag`, { [`${Qe}-wrapper-tag-size-${s}`]: s, [`${Qe}-wrapper-tag-icon`]: h }), m = F(`${Qe}-wrapper-typo`, { [`${Qe}-wrapper-typo-disabled`]: a }), b = F({ [`${Qe}-drag-item`]: h, [`${Qe}-wrapper-tag-icon`]: h }), y = i && i(() => f.createElement(CH, { className: `${Qe}-drag-handler` })), w = h ? t : `${n}${t}`, x = () => { !a && this.handleTagClose(n) }; return we(o) ? f.createElement("div", { className: b, key: w }, h && i ? f.createElement(y, null) : null, o(t, n, x)) : f.createElement(wr, { className: g, color: "white", size: s === "small" ? "small" : "large", type: "light", onClose: x, closable: !a, key: w, visible: !0, "aria-label": `${a ? "" : "Closable "}Tag: ${t}` }, h && i ? f.createElement(y, null) : null, f.createElement(Yd, { className: m, ellipsis: { showTooltip: l, rows: 1 } }, t)) }, this.renderSortTag = t => { const { id: n, sortableHandle: i } = t, { tagsArray: s } = this.state, a = s.indexOf(n); return this.renderTag(n, a, i) }, this.onSortEnd = t => { this.foundation.handleSortEnd(t) }, this.handleInputCompositionStart = t => { this.foundation.handleInputCompositionStart(t) }, this.handleInputCompositionEnd = t => { this.foundation.handleInputCompositionEnd(t) }, this.foundation = new k9(this.adapter), this.state = { tagsArray: e.defaultValue || [], inputValue: "", focusing: !1, hovering: !1, active: !1, entering: !1 }, this.inputRef = f.createRef(), this.tagInputRef = f.createRef(), this.clickOutsideHandler = null } static getDerivedStateFromProps(e, t) { const { value: n, inputValue: i } = e, { tagsArray: s } = t; let a; return dm(n) ? a = n : "value" in e && !n ? a = [] : a = s, { tagsArray: a, inputValue: Fe(i) ? i : t.inputValue } } get adapter() { return Object.assign(Object.assign({}, super.adapter), { setInputValue: e => { this.setState({ inputValue: e }) }, setTagsArray: e => { this.setState({ tagsArray: e }) }, setFocusing: e => { this.setState({ focusing: e }) }, toggleFocusing: e => { const { preventScroll: t } = this.props, n = this.inputRef && this.inputRef.current; e ? n && n.focus({ preventScroll: t }) : n && n.blur(), this.setState({ focusing: e }) }, setHovering: e => { this.setState({ hovering: e }) }, setActive: e => { this.setState({ active: e }) }, setEntering: e => { this.setState({ entering: e }) }, getClickOutsideHandler: () => this.clickOutsideHandler, notifyBlur: e => { this.props.onBlur(e) }, notifyFocus: e => { this.props.onFocus(e) }, notifyInputChange: (e, t) => { this.props.onInputChange(e, t) }, notifyTagChange: e => { this.props.onChange(e) }, notifyTagAdd: e => { this.props.onAdd(e) }, notifyTagRemove: (e, t) => { this.props.onRemove(e, t) }, notifyKeyDown: e => { this.props.onKeyDown(e) }, registerClickOutsideHandler: e => { const t = n => { const i = this.tagInputRef && this.tagInputRef.current, s = n.target, a = n.composedPath && n.composedPath() || [s]; i && !i.contains(s) && !a.includes(i) && e(n) }; this.clickOutsideHandler = t, document.addEventListener("click", t, !1) }, unregisterClickOutsideHandler: () => { document.removeEventListener("click", this.clickOutsideHandler, !1), this.clickOutsideHandler = null } }) } componentDidMount() { const { disabled: e, autoFocus: t, preventScroll: n } = this.props; !e && t && (this.inputRef.current.focus({ preventScroll: n }), this.foundation.handleClick()), this.foundation.init() } renderClearBtn() { const { hovering: e, tagsArray: t, inputValue: n } = this.state, { showClear: i, disabled: s, clearIcon: a } = this.props, o = F(`${Qe}-clearBtn`, { [`${Qe}-clearBtn-invisible`]: !e || n === "" && t.length === 0 || s }); return i ? f.createElement("div", { role: "button", tabIndex: 0, "aria-label": "Clear TagInput value", className: o, onClick: l => this.handleClearBtn(l), onKeyPress: l => this.handleClearEnterPress(l) }, a || f.createElement(us, null)) : null } renderPrefix() { const { prefix: e, insetLabel: t, insetLabelId: n } = this.props, i = e || t; if (ss(i) || st(i)) return null; const s = F(`${Qe}-prefix`, { [`${Qe}-inset-label`]: t, [`${Qe}-prefix-text`]: i && Fe(i), [`${Qe}-prefix-icon`]: Bn(i) }); return f.createElement("div", { className: s, onMouseDown: this.handlePreventMouseDown, onClick: this.handleClickPrefixOrSuffix, id: n, "x-semi-prop": "prefix" }, i) } renderSuffix() { const { suffix: e } = this.props; if (ss(e) || st(e)) return null; const t = F(`${Qe}-suffix`, { [`${Qe}-suffix-text`]: e && Fe(e), [`${Qe}-suffix-icon`]: Bn(e) }); return f.createElement("div", { className: t, onMouseDown: this.handlePreventMouseDown, onClick: this.handleClickPrefixOrSuffix, "x-semi-prop": "suffix" }, e) } renderTags() { const { disabled: e, maxTagCount: t, showRestTagsPopover: n, restTagsPopoverProps: i = {}, draggable: s, expandRestTagsOnClick: a } = this.props, { tagsArray: o, active: l } = this.state, u = F(`${Qe}-wrapper-n`, { [`${Qe}-wrapper-n-disabled`]: e }), d = this.getAllTags(); let h = [], g = [...d]; (!l || !a) && t && t < d.length && (g = d.slice(0, t), h = d.slice(t)); const m = f.createElement("span", { className: u }, "+", o.length - t), b = d.map((y, w) => ({ item: y, key: o[w] })); return l && s && b.length > 0 ? f.createElement(_8, { items: o, onSortEnd: this.onSortEnd, renderItem: this.renderSortTag, container: I8, prefix: Qe, transition: null, dragOverlayCls: `${Qe}-right-item-drag-item-move` }) : f.createElement(f.Fragment, null, g, h.length > 0 && (n ? f.createElement(kn, Object.assign({ content: h, showArrow: !0, trigger: "hover", position: "top", autoAdjustOverflow: !0 }, i), m) : m)) } blur() { this.inputRef.current.blur(), this.foundation.clickOutsideCallBack() } focus() { const { preventScroll: e, disabled: t } = this.props; this.inputRef.current.focus({ preventScroll: e }), t || this.foundation.handleClick() } render() { const e = this.props, { size: t, style: n, className: i, disabled: s, placeholder: a, validateStatus: o, prefix: l, insetLabel: u, suffix: d } = e, h = T8(e, ["size", "style", "className", "disabled", "placeholder", "validateStatus", "prefix", "insetLabel", "suffix"]), { focusing: g, hovering: m, tagsArray: b, inputValue: y, active: w } = this.state, x = F(Qe, i, { [`${Qe}-focus`]: g || w, [`${Qe}-disabled`]: s, [`${Qe}-hover`]: m && !s, [`${Qe}-error`]: o === "error", [`${Qe}-warning`]: o === "warning", [`${Qe}-small`]: t === "small", [`${Qe}-large`]: t === "large", [`${Qe}-with-prefix`]: !!l || !!u, [`${Qe}-with-suffix`]: !!d }), S = F(`${Qe}-wrapper-input`, `${Qe}-wrapper-input-${t}`), C = F(`${Qe}-wrapper`); return f.createElement("div", Object.assign({ ref: this.tagInputRef, style: n, className: x, "aria-disabled": s, "aria-label": this.props["aria-label"], "aria-invalid": o === "error", onMouseEnter: O => { this.handleInputMouseEnter(O) }, onMouseLeave: O => { this.handleInputMouseLeave(O) }, onClick: O => { this.handleClick(O) } }, this.getDataAttr(h)), this.renderPrefix(), f.createElement("div", { className: C }, this.renderTags(), f.createElement(xr, { "aria-label": "input value", ref: this.inputRef, className: S, disabled: s, value: y, size: t, placeholder: b.length === 0 ? a : "", onKeyDown: O => { this.handleKeyDown(O) }, onChange: (O, E) => { this.handleInputChange(E) }, onBlur: O => { this.handleInputBlur(O) }, onFocus: O => { this.handleInputFocus(O) }, onCompositionStart: this.handleInputCompositionStart, onCompositionEnd: this.handleInputCompositionEnd })), this.renderClearBtn(), this.renderSuffix()) } } Pc.propTypes = { children: c.node, clearIcon: c.node, style: c.object, className: c.string, disabled: c.bool, allowDuplicates: c.bool, max: c.number, maxTagCount: c.number, maxLength: c.number, showRestTagsPopover: c.bool, restTagsPopoverProps: c.object, showContentTooltip: c.oneOfType([c.shape({ type: c.string, opts: c.object }), c.bool]), defaultValue: c.array, value: c.array, inputValue: c.string, placeholder: c.string, separator: c.oneOfType([c.string, c.array]), showClear: c.bool, addOnBlur: c.bool, draggable: c.bool, expandRestTagsOnClick: c.bool, autoFocus: c.bool, renderTagItem: c.func, onBlur: c.func, onFocus: c.func, onChange: c.func, onInputChange: c.func, onExceed: c.func, onInputExceed: c.func, onAdd: c.func, onRemove: c.func, onKeyDown: c.func, size: c.oneOf($x.SIZE_SET), validateStatus: c.oneOf($x.STATUS), prefix: c.oneOfType([c.string, c.node]), suffix: c.oneOfType([c.string, c.node]), "aria-label": c.string, preventScroll: c.bool }; Pc.defaultProps = { showClear: !1, addOnBlur: !1, allowDuplicates: !0, showRestTagsPopover: !0, autoFocus: !1, draggable: !1, expandRestTagsOnClick: !0, showContentTooltip: !0, separator: ",", size: "default", validateStatus: "default", onBlur: z, onFocus: z, onChange: z, onInputChange: z, onExceed: z, onInputExceed: z, onAdd: z, onRemove: z, onKeyDown: z }; const Ue = EE.PREFIX, P8 = 0; class _o extends de { constructor(e) { super(e), this.search = t => { this.handleInputChange(t) }, this.handleInputChange = t => { this.foundation.handleInputChange(t) }, this.handleTagRemoveInTrigger = t => { this.foundation.handleTagRemoveInTrigger(t) }, this.handleTagClose = (t, n, i) => { n.preventDefault(), this.foundation.handleTagRemoveByKey(i) }, this.renderTagItem = (t, n) => { const { keyEntities: i, disabledKeys: s } = this.state, { size: a, disabled: o, displayProp: l, displayRender: u, disableStrictly: d } = this.props; if (i[t]) { const h = o || i[t].data.disabled || d && s.has(t), g = F(`${Ue}-selection-tag`, { [`${Ue}-selection-tag-disabled`]: h }); return we(u) ? u(i[t], n) : f.createElement(wr, { size: a === "default" ? "large" : a, key: `tag-${t}-${n}`, color: "white", tagKey: t, className: g, closable: !0, onClose: this.handleTagClose }, i[t].data[l]) } return null }, this.onRemoveInTagInput = t => { this.foundation.handleTagRemoveByKey(t) }, this.handleItemClick = (t, n) => { this.foundation.handleItemClick(t, n) }, this.handleItemHover = (t, n) => { this.foundation.handleItemHover(t, n) }, this.onItemCheckboxClick = t => { this.foundation.onItemCheckboxClick(t) }, this.handleListScroll = (t, n) => { this.foundation.handleListScroll(t, n) }, this.renderContent = () => { const { inputValue: t, isSearching: n, activeKeys: i, selectedKeys: s, checkedKeys: a, halfCheckedKeys: o, loadedKeys: l, loadingKeys: u } = this.state, { filterTreeNode: d, dropdownClassName: h, dropdownStyle: g, loadData: m, emptyContent: b, separator: y, topSlot: w, bottomSlot: x, showNext: S, multiple: C, filterRender: O, virtualizeInSearch: E, expandIcon: v } = this.props, T = !!d && n, I = F(h, `${Ue}-popover`), k = this.foundation.getRenderData(); return f.createElement("div", { className: I, role: "listbox", style: g, onKeyDown: this.foundation.handleKeyDown }, w, f.createElement(th, { activeKeys: i, selectedKeys: s, separator: y, loadedKeys: l, loadingKeys: u, onItemClick: this.handleItemClick, onItemHover: this.handleItemHover, showNext: S, onItemCheckboxClick: this.onItemCheckboxClick, onListScroll: this.handleListScroll, searchable: T, keyword: t, emptyContent: b, loadData: m, data: k, multiple: C, checkedKeys: a, halfCheckedKeys: o, filterRender: O, virtualize: E, expandIcon: v }), x) }, this.renderPlusN = t => { const { disabled: n, showRestTagsPopover: i, restTagsPopoverProps: s } = this.props, a = F(`${Ue}-selection-n`, { [`${Ue}-selection-n-disabled`]: n }), o = f.createElement("span", { className: a }, "+", t.length); return i ? f.createElement(kn, Object.assign({ content: t, showArrow: !0, trigger: "hover", position: "top", autoAdjustOverflow: !0 }, s), o) : o }, this.renderMultipleTags = () => { const { autoMergeValue: t, maxTagCount: n, checkRelation: i } = this.props, { checkedKeys: s, resolvedCheckedKeys: a } = this.state, o = this.mergeType === qt.NONE_MERGE_TYPE || i === qt.UN_RELATED ? s : a, l = [], u = []; return [...o].forEach((d, h) => { const g = !Zt(n) || n >= h + 1, m = this.renderTagItem(d, h); g ? l.push(m) : u.push(m) }), f.createElement(f.Fragment, null, l, !kt(u) && this.renderPlusN(u)) }, this.renderDisplayText = () => { const { displayProp: t, separator: n, displayRender: i } = this.props, { selectedKeys: s } = this.state; let a = ""; if (s.size) { const o = this.foundation.getItemPropPath([...s][0], t); i && typeof i == "function" ? a = i(o) : a = o.map((l, u) => f.createElement(R.Fragment, { key: `${l}-${u}` }, u < o.length - 1 ? f.createElement(f.Fragment, null, l, n) : l)) } return a }, this.renderSelectContent = () => { const { placeholder: t, filterTreeNode: n, multiple: i, searchPosition: s } = this.props, { checkedKeys: a } = this.state; if (!(!!n && s === qt.SEARCH_POSITION_TRIGGER)) { if (i) return a.size === 0 ? f.createElement("span", { className: `${Ue}-selection-placeholder` }, t) : this.renderMultipleTags(); { const u = this.renderDisplayText(), d = F({ [`${Ue}-selection-placeholder`]: !u }); return f.createElement("span", { className: d }, u || t) } } return i ? this.renderTagInput() : this.renderInput() }, this.renderSuffix = () => { const { suffix: t } = this.props, n = F({ [`${Ue}-suffix`]: !0, [`${Ue}-suffix-text`]: t && Fe(t), [`${Ue}-suffix-icon`]: Bn(t) }); return f.createElement("div", { className: n, "x-semi-prop": "suffix" }, t) }, this.renderPrefix = () => { const { prefix: t, insetLabel: n, insetLabelId: i } = this.props, s = t || n, a = F({ [`${Ue}-prefix`]: !0, [`${Ue}-inset-label`]: n, [`${Ue}-prefix-text`]: s && Fe(s), [`${Ue}-prefix-icon`]: Bn(s) }); return f.createElement("div", { className: a, id: i, "x-semi-prop": "prefix,insetLabel" }, s) }, this.renderCustomTrigger = () => { var t; const { disabled: n, triggerRender: i, multiple: s } = this.props, { selectedKeys: a, inputValue: o, inputPlaceHolder: l, resolvedCheckedKeys: u, checkedKeys: d, keyEntities: h } = this.state; let g; return s ? this.mergeType === qt.NONE_MERGE_TYPE ? (g = new Set, d.forEach(m => { var b; g.add((b = h[m]) === null || b === void 0 ? void 0 : b.pos) })) : (g = new Set, u.forEach(m => { var b; g.add((b = h[m]) === null || b === void 0 ? void 0 : b.pos) })) : g = (t = h[[...a][0]]) === null || t === void 0 ? void 0 : t.pos, f.createElement(Ia, { value: g, inputValue: o, onChange: this.handleInputChange, onClear: this.handleClear, placeholder: l, disabled: n, triggerRender: i, componentName: "Cascader", componentProps: Object.assign({}, this.props), onSearch: this.handleInputChange, onRemove: this.handleTagRemoveInTrigger }) }, this.handleMouseOver = () => { this.foundation.toggleHoverState(!0) }, this.handleMouseLeave = () => { this.foundation.toggleHoverState(!1) }, this.handleClear = t => { t && t.stopPropagation(), this.foundation.handleClear() }, this.handleClearEnterPress = t => { t && t.stopPropagation(), this.foundation.handleClearEnterPress(t) }, this.showClearBtn = () => { const { showClear: t, disabled: n, multiple: i } = this.props, { selectedKeys: s, isOpen: a, isHovering: o, checkedKeys: l, inputValue: u } = this.state, d = s.size, h = i && l.size; return t && (u || d || h) && !n && (a || o) }, this.renderClearBtn = () => { const t = F(`${Ue}-clearbtn`), { clearIcon: n } = this.props; return this.showClearBtn() ? f.createElement("div", { className: t, onClick: this.handleClear, onKeyPress: this.handleClearEnterPress, role: "button", tabIndex: 0 }, n || f.createElement(us, null)) : null }, this.renderArrow = () => { const { arrowIcon: t } = this.props; return this.showClearBtn() ? null : t ? f.createElement("div", { className: F(`${Ue}-arrow`), "x-semi-prop": "arrowIcon" }, t) : null }, this.renderSelection = () => { const { disabled: t, multiple: n, filterTreeNode: i, style: s, size: a, className: o, validateStatus: l, prefix: u, suffix: d, insetLabel: h, triggerRender: g, showClear: m, id: b, borderless: y } = this.props, { isOpen: w, isFocus: x, isInput: S, checkedKeys: C } = this.state, O = !!i, E = typeof g == "function", v = E ? F(o) : F(Ue, o, { [`${Ue}-borderless`]: y, [`${Ue}-focus`]: x || w && !S, [`${Ue}-disabled`]: t, [`${Ue}-single`]: !0, [`${Ue}-filterable`]: O, [`${Ue}-error`]: l === "error", [`${Ue}-warning`]: l === "warning", [`${Ue}-small`]: a === "small", [`${Ue}-large`]: a === "large", [`${Ue}-with-prefix`]: u || h, [`${Ue}-with-suffix`]: d }), T = m ? { onMouseEnter: () => this.handleMouseOver(), onMouseLeave: () => this.handleMouseLeave() } : {}, I = F(`${Ue}-selection`, { [`${Ue}-selection-multiple`]: n && !kt(C) }), k = E ? this.renderCustomTrigger() : [f.createElement(R.Fragment, { key: "prefix" }, u || h ? this.renderPrefix() : null), f.createElement(R.Fragment, { key: "selection" }, f.createElement("div", { className: I }, this.renderSelectContent())), f.createElement(R.Fragment, { key: "suffix" }, d ? this.renderSuffix() : null), f.createElement(R.Fragment, { key: "clearbtn" }, this.renderClearBtn()), f.createElement(R.Fragment, { key: "arrow" }, this.renderArrow())]; return f.createElement("div", Object.assign({ className: v, style: s, ref: this.triggerRef, onClick: P => this.foundation.handleClick(P), onKeyPress: P => this.foundation.handleSelectionEnterPress(P), "aria-invalid": this.props["aria-invalid"], "aria-errormessage": this.props["aria-errormessage"], "aria-label": this.props["aria-label"], "aria-labelledby": this.props["aria-labelledby"], "aria-describedby": this.props["aria-describedby"], "aria-required": this.props["aria-required"], id: b, onKeyDown: this.foundation.handleKeyDown }, T, { role: "combobox", tabIndex: 0 }, this.getDataAttr(this.props)), k) }, this.state = { disabledKeys: new Set, isOpen: e.defaultOpen, rePosKey: P8, keyEntities: {}, selectedKeys: new Set([]), activeKeys: new Set([]), filteredKeys: new Set([]), inputValue: "", isSearching: !1, inputPlaceHolder: e.searchPlaceholder || e.placeholder, prevProps: {}, isHovering: !1, checkedKeys: new Set([]), halfCheckedKeys: new Set([]), resolvedCheckedKeys: new Set([]), loadedKeys: new Set, loadingKeys: new Set, loading: !1, showInput: !1 }, this.options = {}, this.isEmpty = !1, this.mergeType = _f(e.autoMergeValue, e.leafOnly), this.inputRef = f.createRef(), this.triggerRef = f.createRef(), this.optionsRef = f.createRef(), this.clickOutsideHandler = null, this.foundation = new s9(this.adapter), this.loadingKeysRef = f.createRef(), this.loadedKeysRef = f.createRef() } get adapter() { var e = this; const t = { updateInputValue: i => { this.setState({ inputValue: i }) }, updateInputPlaceHolder: i => { this.setState({ inputPlaceHolder: i }) }, focusInput: () => { const { preventScroll: i } = this.props; this.inputRef && this.inputRef.current && this.inputRef.current.focus({ preventScroll: i }) }, blurInput: () => { this.inputRef && this.inputRef.current && this.inputRef.current.blur() } }, n = { registerClickOutsideHandler: i => { const s = a => { const o = this.optionsRef && this.optionsRef.current, l = this.triggerRef && this.triggerRef.current, u = lr.findDOMNode(o), d = a.target, h = a.composedPath && a.composedPath() || [d]; u && (!u.contains(d) || !u.contains(d.parentNode)) && l && !l.contains(d) && !(h.includes(l) || h.includes(u)) && i(a) }; this.clickOutsideHandler = s, document.addEventListener("mousedown", s, !1) }, unregisterClickOutsideHandler: () => { document.removeEventListener("mousedown", this.clickOutsideHandler, !1) }, rePositionDropdown: () => { let { rePosKey: i } = this.state; i = i + 1, this.setState({ rePosKey: i }) } }; return Object.assign(Object.assign(Object.assign(Object.assign({}, super.adapter), t), n), { updateStates: i => { this.setState(Object.assign({}, i)) }, openMenu: () => { this.setState({ isOpen: !0 }) }, closeMenu: i => { this.setState({ isOpen: !1 }, () => { i && i() }) }, updateSelection: i => this.setState({ selectedKeys: i }), notifyChange: i => { this.props.onChange && this.props.onChange(i) }, notifySelect: i => { this.props.onSelect && this.props.onSelect(i) }, notifyOnSearch: i => { this.props.onSearch && this.props.onSearch(i) }, notifyFocus: function () { e.props.onFocus && e.props.onFocus(...arguments) }, notifyBlur: function () { e.props.onBlur && e.props.onBlur(...arguments) }, notifyDropdownVisibleChange: i => { this.props.onDropdownVisibleChange(i) }, toggleHovering: i => { this.setState({ isHovering: i }) }, notifyLoadData: (i, s) => { const { loadData: a } = this.props; a && new Promise(o => { a(i).then(() => { setTimeout(() => { s(), this.setState({ loading: !1 }), o() }) }) }) }, notifyOnLoad: (i, s) => { const { onLoad: a } = this.props; a && a(i, s) }, notifyListScroll: (i, s) => { let { panelIndex: a, activeNode: o } = s; this.props.onListScroll(i, { panelIndex: a, activeNode: o }) }, notifyOnExceed: i => this.props.onExceed(i), notifyClear: () => this.props.onClear(), toggleInputShow: (i, s) => { this.setState({ showInput: i }, () => { s() }) }, updateFocusState: i => { this.setState({ isFocus: i }) }, updateLoadingKeyRefValue: i => { this.loadingKeysRef.current = i }, getLoadingKeyRefValue: () => this.loadingKeysRef.current, updateLoadedKeyRefValue: i => { this.loadedKeysRef.current = i }, getLoadedKeyRefValue: () => this.loadedKeysRef.current }) } static getDerivedStateFromProps(e, t) { const { multiple: n, value: i, defaultValue: s, onChangeWithObject: a, leafOnly: o, autoMergeValue: l, checkRelation: u, searchPlaceholder: d, placeholder: h } = e, { prevProps: g } = t; let m = t.keyEntities || {}; const b = {}, y = d || h; y !== t.inputPlaceHolder && (b.inputPlaceHolder = y); const w = C => { const O = kt(g) && C in e, E = g && !ke(g[C], e[C]); return O || E }, x = () => { const C = !g && "treeData" in e, O = g && g.treeData !== e.treeData; return C || O }, S = (C, O) => { let E = []; Array.isArray(C) ? E = Array.isArray(C[0]) ? C : [C] : C !== void 0 && (E = [[C]]); const v = []; return E.forEach(I => { const k = a && an(I[0]) ? I.map(P => P == null ? void 0 : P.value) : I; k.length > 0 && v.push(k) }), v.reduce((I, k) => { const P = ad(k); return O[P] && I.push(P), I }, []) }; if (n) { const C = w("treeData") || x(), O = w("value") || kt(g) && s; if (C || O) { C && (b.treeData = e.treeData, m = OE(e.treeData), b.keyEntities = m); let E = t.checkedKeys; if (O) { const v = w("value") ? i : s; E = S(v, m) } else C && "value" in e && (E = S(i, m)); if (Ri(E) && (E = [...E]), u === qt.RELATED) { const v = Sc(E, m), T = new Set(v.checkedKeys), I = new Set(v.halfCheckedKeys); e.disableStrictly && (b.disabledKeys = SE(m)); const k = _f(l, o) === qt.LEAF_ONLY_MERGE_TYPE; b.checkedKeys = T, b.halfCheckedKeys = I, b.resolvedCheckedKeys = new Set(hi(T, m, k)) } else b.checkedKeys = new Set(E); b.prevProps = e } } return b } componentDidMount() { this.foundation.init() } componentWillUnmount() { this.foundation.destroy() } componentDidUpdate(e) { if (this.props.multiple) return; let t = !1; ke(e.treeData, this.props.treeData) || (t = !0, this.foundation.collectOptions()), e.value !== this.props.value && !t && this.foundation.handleValueChange(this.props.value) } renderTagInput() { const { size: e, disabled: t, placeholder: n, maxTagCount: i, showRestTagsPopover: s, restTagsPopoverProps: a, checkRelation: o } = this.props, { inputValue: l, checkedKeys: u, keyEntities: d, resolvedCheckedKeys: h, inputPlaceHolder: g } = this.state, m = F(`${Ue}-tagInput-wrapper`), b = this.mergeType === qt.NONE_MERGE_TYPE || o === qt.UN_RELATED ? u : h; return f.createElement(Pc, { className: m, ref: this.inputRef, disabled: t, size: e, value: [...b], showRestTagsPopover: s, restTagsPopoverProps: a, maxTagCount: i, renderTagItem: this.renderTagItem, inputValue: l, onInputChange: this.handleInputChange, onRemove: this.onRemoveInTagInput, placeholder: g, expandRestTagsOnClick: !1 }) } renderInput() { const { size: e, disabled: t } = this.props, n = F(`${Ue}-input`), { inputValue: i, inputPlaceHolder: s, showInput: a } = this.state, o = { disabled: t, value: i, className: n, onChange: this.handleInputChange }, l = F({ [`${Ue}-search-wrapper`]: !0, [`${Ue}-search-wrapper-${e}`]: e !== "default" }), u = this.renderDisplayText(), d = F({ [`${Ue}-selection-placeholder`]: !u, [`${Ue}-selection-text-hide`]: a && i, [`${Ue}-selection-text-inactive`]: a && !i }); return f.createElement("div", { className: l }, f.createElement("span", { className: d }, u || s), a && f.createElement(xr, Object.assign({ ref: this.inputRef, size: e }, o))) } close() { this.foundation.close() } open() { this.foundation.open() } focus() { this.foundation.focus() } blur() { this.foundation.blur() } render() { const { zIndex: e, getPopupContainer: t, autoAdjustOverflow: n, stopPropagation: i, mouseLeaveDelay: s, mouseEnterDelay: a, position: o, motion: l, dropdownMargin: u } = this.props, { isOpen: d, rePosKey: h } = this.state, { direction: g } = this.context, m = this.renderContent(), b = this.renderSelection(), y = o ?? (g === "rtl" ? "bottomRight" : "bottomLeft"); return f.createElement(kn, { getPopupContainer: t, zIndex: e, motion: l, margin: u, ref: this.optionsRef, content: m, visible: d, trigger: "custom", rePosKey: h, position: y, autoAdjustOverflow: n, stopPropagation: i, mouseLeaveDelay: s, mouseEnterDelay: a, afterClose: () => this.foundation.updateSearching(!1) }, b) } } _o.__SemiComponentName__ = "Cascader"; _o.contextType = An; _o.propTypes = { "aria-labelledby": c.string, "aria-invalid": c.bool, "aria-errormessage": c.string, "aria-describedby": c.string, "aria-required": c.bool, "aria-label": c.string, arrowIcon: c.node, borderless: c.bool, clearIcon: c.node, changeOnSelect: c.bool, defaultValue: c.oneOfType([c.string, c.array]), disabled: c.bool, dropdownClassName: c.string, dropdownStyle: c.object, dropdownMargin: c.oneOfType([c.number, c.object]), emptyContent: c.node, motion: c.bool, filterTreeNode: c.oneOfType([c.func, c.bool]), filterLeafOnly: c.bool, placeholder: c.string, searchPlaceholder: c.string, size: c.oneOf(qt.SIZE_SET), style: c.object, className: c.string, treeData: c.arrayOf(c.shape({ value: c.oneOfType([c.string, c.number]), label: c.any })), treeNodeFilterProp: c.string, suffix: c.node, prefix: c.node, insetLabel: c.node, insetLabelId: c.string, id: c.string, displayProp: c.string, displayRender: c.func, onChange: c.func, onSearch: c.func, onSelect: c.func, onBlur: c.func, onFocus: c.func, children: c.node, getPopupContainer: c.func, zIndex: c.number, value: c.oneOfType([c.string, c.number, c.array]), validateStatus: c.oneOf(qt.VALIDATE_STATUS), showNext: c.oneOf([qt.SHOW_NEXT_BY_CLICK, qt.SHOW_NEXT_BY_HOVER]), stopPropagation: c.oneOfType([c.bool, c.string]), showClear: c.bool, defaultOpen: c.bool, autoAdjustOverflow: c.bool, onDropdownVisibleChange: c.func, triggerRender: c.func, onListScroll: c.func, onChangeWithObject: c.bool, bottomSlot: c.node, topSlot: c.node, multiple: c.bool, autoMergeValue: c.bool, maxTagCount: c.number, showRestTagsPopover: c.bool, restTagsPopoverProps: c.object, max: c.number, separator: c.string, onExceed: c.func, onClear: c.func, loadData: c.func, onLoad: c.func, loadedKeys: c.array, disableStrictly: c.bool, leafOnly: c.bool, enableLeafClick: c.bool, preventScroll: c.bool, position: c.string, searchPosition: c.string }; _o.defaultProps = xn(_o.__SemiComponentName__, { borderless: !1, leafOnly: !1, arrowIcon: f.createElement(os, null), stopPropagation: !0, motion: !0, defaultOpen: !1, zIndex: Cr.DEFAULT_Z_INDEX, showClear: !1, autoClearSearchValue: !0, changeOnSelect: !1, disableStrictly: !1, autoMergeValue: !0, multiple: !1, filterTreeNode: !1, filterLeafOnly: !0, showRestTagsPopover: !1, restTagsPopoverProps: {}, separator: " / ", size: "default", treeNodeFilterProp: "label", displayProp: "label", treeData: [], showNext: qt.SHOW_NEXT_BY_CLICK, onExceed: z, onClear: z, onDropdownVisibleChange: z, onListScroll: z, enableLeafClick: !1, "aria-label": "Cascader", searchPosition: qt.SEARCH_POSITION_TRIGGER, checkRelation: qt.RELATED }); class k8 extends ve { constructor(e) { super(Object.assign({}, e)), this.updateDOMInRenderTree = t => { this._adapter.setDOMInRenderTree(t) }, this.updateDOMHeight = t => { this._adapter.setDOMHeight(t) }, this.updateVisible = t => { this._adapter.setVisible(t) }, this.updateIsTransitioning = t => { this._adapter.setIsTransitioning(t) } } } const Zx = { PREFIX: `${G}-collapsible` }; class ls extends de { constructor(e) { super(e), this.domRef = f.createRef(), this.hasBeenRendered = !1, this.handleResize = t => { const n = t[0]; if (n) { const i = ls.getEntryInfo(n); this.foundation.updateDOMHeight(i.height), this.foundation.updateDOMInRenderTree(i.isShown) } }, this.isChildrenInRenderTree = () => this.domRef.current ? this.domRef.current.offsetHeight > 0 : !1, this.state = { domInRenderTree: !1, domHeight: 0, visible: this.props.isOpen, isTransitioning: !1 }, this.foundation = new k8(this.adapter) } get adapter() { return Object.assign(Object.assign({}, super.adapter), { setDOMInRenderTree: e => { this.state.domInRenderTree !== e && this.setState({ domInRenderTree: e }) }, setDOMHeight: e => { this.state.domHeight !== e && this.setState({ domHeight: e }) }, setVisible: e => { this.state.visible !== e && this.setState({ visible: e }) }, setIsTransitioning: e => { this.state.isTransitioning !== e && this.setState({ isTransitioning: e }) } }) } componentDidMount() { super.componentDidMount(), this.resizeObserver = new ResizeObserver(this.handleResize), this.resizeObserver.observe(this.domRef.current); const e = this.isChildrenInRenderTree(); this.foundation.updateDOMInRenderTree(e), e && this.foundation.updateDOMHeight(this.domRef.current.scrollHeight) } componentDidUpdate(e, t, n) { const i = Object.keys(cr(this.props, ["reCalcKey", "isOpen"])).filter(a => !ke(this.props[a], e[a])), s = Object.keys(cr(this.state, ["domInRenderTree"])).filter(a => !ke(this.state[a], t[a])); i.includes("reCalcKey") && this.foundation.updateDOMHeight(this.domRef.current.scrollHeight), s.includes("domInRenderTree") && this.state.domInRenderTree && this.foundation.updateDOMHeight(this.domRef.current.scrollHeight), i.includes("isOpen") && (this.props.isOpen || !this.props.motion) && this.foundation.updateVisible(this.props.isOpen), this.props.motion && e.isOpen !== this.props.isOpen && this.foundation.updateIsTransitioning(!0) } componentWillUnmount() { super.componentWillUnmount(), this.resizeObserver.disconnect() } render() { const e = Object.assign({ overflow: "hidden", height: this.props.isOpen ? this.state.domHeight : this.props.collapseHeight, opacity: this.props.isOpen || !this.props.fade || this.props.collapseHeight !== 0 ? 1 : 0, transitionDuration: `${this.props.motion && this.state.isTransitioning ? this.props.duration : 0}ms` }, this.props.style), t = F(`${Zx.PREFIX}-wrapper`, { [`${Zx.PREFIX}-transition`]: this.props.motion && this.state.isTransitioning }, this.props.className), n = this.props.keepDOM && (this.props.lazyRender ? this.hasBeenRendered : !0) || this.props.collapseHeight !== 0 || this.state.visible || this.props.isOpen; return n && !this.hasBeenRendered && (this.hasBeenRendered = !0), f.createElement("div", Object.assign({ className: t, style: e, onTransitionEnd: () => { var i, s; this.props.isOpen || this.foundation.updateVisible(!1), this.foundation.updateIsTransitioning(!1), (s = (i = this.props).onMotionEnd) === null || s === void 0 || s.call(i) } }, this.getDataAttr(this.props)), f.createElement("div", { "x-semi-prop": "children", ref: this.domRef, style: { overflow: "hidden" }, id: this.props.id }, n && this.props.children)) } } ls.__SemiComponentName__ = "Collapsible"; ls.defaultProps = xn(ls.__SemiComponentName__, { isOpen: !1, duration: 250, motion: !0, keepDOM: !1, lazyRender: !1, collapseHeight: 0, fade: !1 }); ls.getEntryInfo = r => { let e; r.borderBoxSize ? e = !(r.borderBoxSize[0].blockSize === 0 && r.borderBoxSize[0].inlineSize === 0) : e = !(r.contentRect.height === 0 && r.contentRect.width === 0); let t = 0; return r.borderBoxSize ? t = Math.ceil(r.borderBoxSize[0].blockSize) : t = r.target.clientHeight, { isShown: e, height: t } }; ls.propTypes = { motion: c.bool, children: c.node, isOpen: c.bool, duration: c.number, keepDOM: c.bool, collapseHeight: c.number, style: c.object, className: c.string, reCalcKey: c.oneOfType([c.string, c.number]) }; var R8 = iS; function D8(r, e) { return r == null ? !0 : R8(r, e) } var A8 = D8; const Rf = _e(A8); var N8 = Ca, F8 = Vd, $8 = Dn, L8 = Fo, M8 = g1, j8 = Sa, V8 = Nd; function B8(r) { return $8(r) ? N8(r, j8) : L8(r) ? [r] : F8(M8(V8(r))) } var z8 = B8; const Wl = _e(z8), Jx = r => { const e = Wl(r); return Zt(r) && e.length === 1 ? !1 : Number.isInteger(+e[e.length - 1]) }; function H8(r) { if (an(r)) { const e = pE(r); return e.length ? e.every(t => typeof t > "u") : !0 } else return !1 } function yy(r, e) { if (e.length === 0) return; const t = H(r, e); (Array.isArray(t) && t.every(n => n == null) || H8(t)) && Rf(r, e), yy(r, e.slice(0, e.length - 1)) } function K8(r) { return pE(r).length === 0 } function ir(r, e) { return H(r, e) } function ku(r, e) { Rf(r, e); let t = Wl(e); t = t.slice(0, t.length - 1), yy(r, t) } function pp(r, e, t, n) { if (n || t !== void 0) return yr(r, e, t); if (Jx(e) && ir(r, e) !== void 0) { yr(r, e, void 0); let i = Wl(e); i = i.slice(0, i.length - 1), yy(r, i) } else !Jx(e) && ir(r, e) !== void 0 && ku(r, e) } function c_(r, e) { return r && (typeof r == "function" || typeof r == "object") && e && (typeof e == "function" || typeof e == "object") && Object.entries(e).forEach(t => { let [n, i] = t; r[n] = i }), r } const U8 = { DAY_TODAY: `${G}-datepicker-day-today`, DAY_IN_RANGE: `${G}-datepicker-day-inrange`, DAY_HOVER: `${G}-datepicker-day-inhover`, DAY_SELECTED: `${G}-datepicker-day-selected`, DAY_SELECTED_START: `${G}-datepicker-day-selected-start`, DAY_SELECTED_END: `${G}-datepicker-day-selected-end`, DAY_DISABLED: `${G}-datepicker-day-disabled`, DAY_HOVER_DAY: `${G}-datepicker-day-hoverday`, DAY_HOVER_DAY_OFFSET: `${G}-datepicker-day-hoverday-offset`, DAY_IN_OFFSET_RANGE: `${G}-datepicker-day-inoffsetrange`, DAY_SELECTED_RANGE_HOVER: `${G}-datepicker-day-selectedrange-hover`, DAY_OFFSET_RANGE_START: `${G}-datepicker-day-offsetrange-start`, DAY_OFFSET_RANGE_END: `${G}-datepicker-day-offsetrange-end`, DAY_SELECTED_START_AFTER_HOVER: `${G}-datepicker-day-selected-start-afterhover`, DAY_SELECTED_END_BEFORE_HOVER: `${G}-datepicker-day-selected-end-beforehover`, DAY_HOVER_DAY_BEFORE_RANGE: `${G}-datepicker-day-hoverday-beforerange`, DAY_HOVER_DAY_AFTER_RANGE: `${G}-datepicker-day-hoverday-afterrange`, DAY_HOVER_DAY_IN_RANGE: `${G}-datepicker-day-hoverday-inrange`, DAY_HOVER_DAY_AROUND_SINGLE_SELECTED: `${G}-datepicker-day-hoverday-around-singleselected` }, Ae = Object.assign({ PREFIX: `${G}-datepicker`, NAVIGATION: `${G}-datepicker-navigation`, PANEL_YAM: `${G}-datepicker-panel-yam`, MONTH: `${G}-datepicker-month`, WEEKDAY: `${G}-datepicker-weekday`, WEEKS: `${G}-datepicker-weeks`, WEEK: `${G}-datepicker-week`, DAY: `${G}-datepicker-day` }, U8), W8 = { FORMAT_FULL_DATE: "yyyy-MM-dd", FORMAT_TIME_PICKER: "HH:mm:ss", FORMAT_DATE_TIME: "yyyy-MM-dd HH:mm:ss", FORMAT_YEAR_MONTH: "yyyy-MM" }, ne = Object.assign({ DEFAULT_SEPARATOR_MULTIPLE: ",", DEFAULT_SEPARATOR_RANGE: " ~ ", SIZE_SET: ["small", "default", "large"], TYPE_SET: ["date", "dateRange", "year", "month", "monthRange", "dateTime", "dateTimeRange"], PRESET_POSITION_SET: ["left", "right", "top", "bottom"], DENSITY_SET: ["default", "compact"], PANEL_TYPE_LEFT: "left", PANEL_TYPE_RIGHT: "right", STATUS: Vo, POSITION_SET: ha.POSITION_SET, POSITION_INLINE_INPUT: "leftTopOver" }, W8), Oo = { WEEK_START_ON: 0, WEEK_HEIGHT: 36, SPACING: Cr.SPACING, SPACING_INSET_INPUT: 1 }; var G8 = Si, Y8 = Sr, X8 = "[object Date]"; function q8(r) { return Y8(r) && G8(r) == X8 } var Z8 = q8, J8 = Z8, Q8 = Ea, Qx = dc, e0 = Qx && Qx.isDate, eG = e0 ? Q8(e0) : J8, tG = eG; const t0 = _e(tG); function rs(r) { return typeof r == "string" } function n0(r, e) { const t = rs(r) ? Gr(r) : r, n = rs(e) ? Gr(e) : e; return CB(t, n) } function io(r, e) { const t = rs(r) ? Gr(r) : r, n = rs(e) ? Gr(e) : e; return kS(t, n) } function Ua(r, e) { let { start: t, end: n } = e; const i = rs(r) ? Gr(r) : r, s = rs(t) ? Gr(t) : t, a = rs(n) ? Gr(n) : n; return kS(s, a) && x4(i, { start: s, end: a }) && !Qu(i, s) && !Qu(i, a) } function vs(r, e) { const t = rs(r) ? Gr(r) : r, n = rs(e) ? Gr(e) : e; return Mm(t, n) } function Yr(r) { return r && Object.prototype.toString.call(r) === "[object Date]" && !isNaN(r) } function nG(r) { return typeof r == "number" || Object.prototype.toString.call(r) === "[object Number]" } function Df(r) { return nG(r) && Yr(new Date(r)) } const u_ = { date: ne.FORMAT_FULL_DATE, dateTime: ne.FORMAT_DATE_TIME, dateRange: ne.FORMAT_FULL_DATE, dateTimeRange: ne.FORMAT_DATE_TIME, month: ne.FORMAT_YEAR_MONTH, monthRange: ne.FORMAT_YEAR_MONTH }, rG = r => u_; function Ps(r) { return r && u_[r] } const iG = (r, e) => { const t = new Date().getFullYear(); let n = typeof r == "number" ? r : t - 100, i = typeof e == "number" ? e : t + 100; return i < n && ([n, i] = [i, n]), Array.from({ length: i - n + 1 }, (s, a) => n + a) }, ou = (r, e) => { if (!e) return ""; const t = new Date(e), n = we(r) ? r(t) : t; return mt(new Date(n), ne.FORMAT_FULL_DATE) }; function r0(r, e) { const t = new Date().getFullYear(), n = new Date().getMonth(), i = e.right || n + 2, s = r.right || (i <= 12 ? t : t + 1); return { year: { left: r.left || t, right: s }, month: { left: e.left || n + 1, right: i <= 12 ? i : 1 } } } var Af = { exports: {} }, Nf = { exports: {} }, d_ = { exports: {} }; (function (r) { function e(t) { return t && t.__esModule ? t : { default: t } } r.exports = e, r.exports.__esModule = !0, r.exports.default = r.exports })(d_); var cn = d_.exports, Ff = { exports: {} }, $f = { exports: {} }, h_ = { exports: {} }; (function (r) { function e(t) { "@babel/helpers - typeof"; return r.exports = e = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function (n) { return typeof n } : function (n) { return n && typeof Symbol == "function" && n.constructor === Symbol && n !== Symbol.prototype ? "symbol" : typeof n }, r.exports.__esModule = !0, r.exports.default = r.exports, e(t) } r.exports = e, r.exports.__esModule = !0, r.exports.default = r.exports })(h_); var p_ = h_.exports, Lf = { exports: {} }; (function (r, e) { Object.defineProperty(e, "__esModule", { value: !0 }), e.default = t; function t(n, i) { if (i.length < n) throw new TypeError(n + " argument" + (n > 1 ? "s" : "") + " required, but only " + i.length + " present") } r.exports = e.default })(Lf, Lf.exports); var dr = Lf.exports; (function (r, e) { var t = cn.default; Object.defineProperty(e, "__esModule", { value: !0 }), e.default = s; var n = t(p_), i = t(dr); function s(a) { return (0, i.default)(1, arguments), a instanceof Date || (0, n.default)(a) === "object" && Object.prototype.toString.call(a) === "[object Date]" } r.exports = e.default })($f, $f.exports); var sG = $f.exports, Mf = { exports: {} }; (function (r, e) { var t = cn.default; Object.defineProperty(e, "__esModule", { value: !0 }), e.default = s; var n = t(p_), i = t(dr); function s(a) { (0, i.default)(1, arguments); var o = Object.prototype.toString.call(a); return a instanceof Date || (0, n.default)(a) === "object" && o === "[object Date]" ? new Date(a.getTime()) : typeof a == "number" || o === "[object Number]" ? new Date(a) : ((typeof a == "string" || o === "[object String]") && typeof console < "u" && (console.warn("Starting with v2.0.0-beta.1 date-fns doesn't accept strings as date arguments. Please use `parseISO` to parse strings. See: https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#string-arguments"), console.warn(new Error().stack)), new Date(NaN)) } r.exports = e.default })(Mf, Mf.exports); var Wi = Mf.exports; (function (r, e) { var t = cn.default; Object.defineProperty(e, "__esModule", { value: !0 }), e.default = a; var n = t(sG), i = t(Wi), s = t(dr); function a(o) { if ((0, s.default)(1, arguments), !(0, n.default)(o) && typeof o != "number") return !1; var l = (0, i.default)(o); return !isNaN(Number(l)) } r.exports = e.default })(Ff, Ff.exports); var aG = Ff.exports, jf = { exports: {} }, Vf = { exports: {} }, Bf = { exports: {} }; (function (r, e) { Object.defineProperty(e, "__esModule", { value: !0 }), e.default = t; function t(n) { if (n === null || n === !0 || n === !1) return NaN; var i = Number(n); return isNaN(i) ? i : i < 0 ? Math.ceil(i) : Math.floor(i) } r.exports = e.default })(Bf, Bf.exports); var Pa = Bf.exports; (function (r, e) { var t = cn.default; Object.defineProperty(e, "__esModule", { value: !0 }), e.default = a; var n = t(Pa), i = t(Wi), s = t(dr); function a(o, l) { (0, s.default)(2, arguments); var u = (0, i.default)(o).getTime(), d = (0, n.default)(l); return new Date(u + d) } r.exports = e.default })(Vf, Vf.exports); var oG = Vf.exports; (function (r, e) { var t = cn.default; Object.defineProperty(e, "__esModule", { value: !0 }), e.default = a; var n = t(oG), i = t(dr), s = t(Pa); function a(o, l) { (0, i.default)(2, arguments); var u = (0, s.default)(l); return (0, n.default)(o, -u) } r.exports = e.default })(jf, jf.exports); var lG = jf.exports, zf = { exports: {} }, Hf = { exports: {} }; (function (r, e) { var t = cn.default; Object.defineProperty(e, "__esModule", { value: !0 }), e.default = a; var n = t(Wi), i = t(dr), s = 864e5; function a(o) { (0, i.default)(1, arguments); var l = (0, n.default)(o), u = l.getTime(); l.setUTCMonth(0, 1), l.setUTCHours(0, 0, 0, 0); var d = l.getTime(), h = u - d; return Math.floor(h / s) + 1 } r.exports = e.default })(Hf, Hf.exports); var cG = Hf.exports, Kf = { exports: {} }, Uf = { exports: {} }; (function (r, e) { var t = cn.default; Object.defineProperty(e, "__esModule", { value: !0 }), e.default = s; var n = t(Wi), i = t(dr); function s(a) { (0, i.default)(1, arguments); var o = 1, l = (0, n.default)(a), u = l.getUTCDay(), d = (u < o ? 7 : 0) + u - o; return l.setUTCDate(l.getUTCDate() - d), l.setUTCHours(0, 0, 0, 0), l } r.exports = e.default })(Uf, Uf.exports); var by = Uf.exports, Wf = { exports: {} }, Gf = { exports: {} }; (function (r, e) { var t = cn.default; Object.defineProperty(e, "__esModule", { value: !0 }), e.default = a; var n = t(Wi), i = t(dr), s = t(by); function a(o) { (0, i.default)(1, arguments); var l = (0, n.default)(o), u = l.getUTCFullYear(), d = new Date(0); d.setUTCFullYear(u + 1, 0, 4), d.setUTCHours(0, 0, 0, 0); var h = (0, s.default)(d), g = new Date(0); g.setUTCFullYear(u, 0, 4), g.setUTCHours(0, 0, 0, 0); var m = (0, s.default)(g); return l.getTime() >= h.getTime() ? u + 1 : l.getTime() >= m.getTime() ? u : u - 1 } r.exports = e.default })(Gf, Gf.exports); var f_ = Gf.exports; (function (r, e) { var t = cn.default; Object.defineProperty(e, "__esModule", { value: !0 }), e.default = a; var n = t(f_), i = t(by), s = t(dr); function a(o) { (0, s.default)(1, arguments); var l = (0, n.default)(o), u = new Date(0); u.setUTCFullYear(l, 0, 4), u.setUTCHours(0, 0, 0, 0); var d = (0, i.default)(u); return d } r.exports = e.default })(Wf, Wf.exports); var uG = Wf.exports; (function (r, e) { var t = cn.default; Object.defineProperty(e, "__esModule", { value: !0 }), e.default = l; var n = t(Wi), i = t(by), s = t(uG), a = t(dr), o = 6048e5; function l(u) { (0, a.default)(1, arguments); var d = (0, n.default)(u), h = (0, i.default)(d).getTime() - (0, s.default)(d).getTime(); return Math.round(h / o) + 1 } r.exports = e.default })(Kf, Kf.exports); var dG = Kf.exports, Yf = { exports: {} }, Xf = { exports: {} }, ka = {}; Object.defineProperty(ka, "__esModule", { value: !0 }); ka.getDefaultOptions = hG; ka.setDefaultOptions = pG; var g_ = {}; function hG() { return g_ } function pG(r) { g_ = r } (function (r, e) { var t = cn.default; Object.defineProperty(e, "__esModule", { value: !0 }), e.default = o; var n = t(Wi), i = t(dr), s = t(Pa), a = ka; function o(l, u) { var d, h, g, m, b, y, w, x; (0, i.default)(1, arguments); var S = (0, a.getDefaultOptions)(), C = (0, s.default)((d = (h = (g = (m = u == null ? void 0 : u.weekStartsOn) !== null && m !== void 0 ? m : u == null || (b = u.locale) === null || b === void 0 || (y = b.options) === null || y === void 0 ? void 0 : y.weekStartsOn) !== null && g !== void 0 ? g : S.weekStartsOn) !== null && h !== void 0 ? h : (w = S.locale) === null || w === void 0 || (x = w.options) === null || x === void 0 ? void 0 : x.weekStartsOn) !== null && d !== void 0 ? d : 0); if (!(C >= 0 && C <= 6)) throw new RangeError("weekStartsOn must be between 0 and 6 inclusively"); var O = (0, n.default)(l), E = O.getUTCDay(), v = (E < C ? 7 : 0) + E - C; return O.setUTCDate(O.getUTCDate() - v), O.setUTCHours(0, 0, 0, 0), O } r.exports = e.default })(Xf, Xf.exports); var vy = Xf.exports, qf = { exports: {} }, Zf = { exports: {} }; (function (r, e) { var t = cn.default; Object.defineProperty(e, "__esModule", { value: !0 }), e.default = l; var n = t(Wi), i = t(dr), s = t(vy), a = t(Pa), o = ka; function l(u, d) { var h, g, m, b, y, w, x, S; (0, i.default)(1, arguments); var C = (0, n.default)(u), O = C.getUTCFullYear(), E = (0, o.getDefaultOptions)(), v = (0, a.default)((h = (g = (m = (b = d == null ? void 0 : d.firstWeekContainsDate) !== null && b !== void 0 ? b : d == null || (y = d.locale) === null || y === void 0 || (w = y.options) === null || w === void 0 ? void 0 : w.firstWeekContainsDate) !== null && m !== void 0 ? m : E.firstWeekContainsDate) !== null && g !== void 0 ? g : (x = E.locale) === null || x === void 0 || (S = x.options) === null || S === void 0 ? void 0 : S.firstWeekContainsDate) !== null && h !== void 0 ? h : 1); if (!(v >= 1 && v <= 7)) throw new RangeError("firstWeekContainsDate must be between 1 and 7 inclusively"); var T = new Date(0); T.setUTCFullYear(O + 1, 0, v), T.setUTCHours(0, 0, 0, 0); var I = (0, s.default)(T, d), k = new Date(0); k.setUTCFullYear(O, 0, v), k.setUTCHours(0, 0, 0, 0); var P = (0, s.default)(k, d); return C.getTime() >= I.getTime() ? O + 1 : C.getTime() >= P.getTime() ? O : O - 1 } r.exports = e.default })(Zf, Zf.exports); var m_ = Zf.exports; (function (r, e) { var t = cn.default; Object.defineProperty(e, "__esModule", { value: !0 }), e.default = l; var n = t(m_), i = t(dr), s = t(vy), a = t(Pa), o = ka; function l(u, d) { var h, g, m, b, y, w, x, S; (0, i.default)(1, arguments); var C = (0, o.getDefaultOptions)(), O = (0, a.default)((h = (g = (m = (b = d == null ? void 0 : d.firstWeekContainsDate) !== null && b !== void 0 ? b : d == null || (y = d.locale) === null || y === void 0 || (w = y.options) === null || w === void 0 ? void 0 : w.firstWeekContainsDate) !== null && m !== void 0 ? m : C.firstWeekContainsDate) !== null && g !== void 0 ? g : (x = C.locale) === null || x === void 0 || (S = x.options) === null || S === void 0 ? void 0 : S.firstWeekContainsDate) !== null && h !== void 0 ? h : 1), E = (0, n.default)(u, d), v = new Date(0); v.setUTCFullYear(E, 0, O), v.setUTCHours(0, 0, 0, 0); var T = (0, s.default)(v, d); return T } r.exports = e.default })(qf, qf.exports); var fG = qf.exports; (function (r, e) { var t = cn.default; Object.defineProperty(e, "__esModule", { value: !0 }), e.default = l; var n = t(Wi), i = t(vy), s = t(fG), a = t(dr), o = 6048e5; function l(u, d) { (0, a.default)(1, arguments); var h = (0, n.default)(u), g = (0, i.default)(h, d).getTime() - (0, s.default)(h, d).getTime(); return Math.round(g / o) + 1 } r.exports = e.default })(Yf, Yf.exports); var gG = Yf.exports, Jf = { exports: {} }; (function (r, e) { Object.defineProperty(e, "__esModule", { value: !0 }), e.default = t; function t(n, i) { for (var s = n < 0 ? "-" : "", a = Math.abs(n).toString(); a.length < i;)a = "0" + a; return s + a } r.exports = e.default })(Jf, Jf.exports); var y_ = Jf.exports, Qf = { exports: {} }; (function (r, e) { var t = cn.default; Object.defineProperty(e, "__esModule", { value: !0 }), e.default = void 0; var n = t(y_), i = { y: function (o, l) { var u = o.getUTCFullYear(), d = u > 0 ? u : 1 - u; return (0, n.default)(l === "yy" ? d % 100 : d, l.length) }, M: function (o, l) { var u = o.getUTCMonth(); return l === "M" ? String(u + 1) : (0, n.default)(u + 1, 2) }, d: function (o, l) { return (0, n.default)(o.getUTCDate(), l.length) }, a: function (o, l) { var u = o.getUTCHours() / 12 >= 1 ? "pm" : "am"; switch (l) { case "a": case "aa": return u.toUpperCase(); case "aaa": return u; case "aaaaa": return u[0]; case "aaaa": default: return u === "am" ? "a.m." : "p.m." } }, h: function (o, l) { return (0, n.default)(o.getUTCHours() % 12 || 12, l.length) }, H: function (o, l) { return (0, n.default)(o.getUTCHours(), l.length) }, m: function (o, l) { return (0, n.default)(o.getUTCMinutes(), l.length) }, s: function (o, l) { return (0, n.default)(o.getUTCSeconds(), l.length) }, S: function (o, l) { var u = l.length, d = o.getUTCMilliseconds(), h = Math.floor(d * Math.pow(10, u - 3)); return (0, n.default)(h, l.length) } }, s = i; e.default = s, r.exports = e.default })(Qf, Qf.exports); var mG = Qf.exports; (function (r, e) { var t = cn.default; Object.defineProperty(e, "__esModule", { value: !0 }), e.default = void 0; var n = t(cG), i = t(dG), s = t(f_), a = t(gG), o = t(m_), l = t(y_), u = t(mG), d = { am: "am", pm: "pm", midnight: "midnight", noon: "noon", morning: "morning", afternoon: "afternoon", evening: "evening", night: "night" }, h = { G: function (x, S, C) { var O = x.getUTCFullYear() > 0 ? 1 : 0; switch (S) { case "G": case "GG": case "GGG": return C.era(O, { width: "abbreviated" }); case "GGGGG": return C.era(O, { width: "narrow" }); case "GGGG": default: return C.era(O, { width: "wide" }) } }, y: function (x, S, C) { if (S === "yo") { var O = x.getUTCFullYear(), E = O > 0 ? O : 1 - O; return C.ordinalNumber(E, { unit: "year" }) } return u.default.y(x, S) }, Y: function (x, S, C, O) { var E = (0, o.default)(x, O), v = E > 0 ? E : 1 - E; if (S === "YY") { var T = v % 100; return (0, l.default)(T, 2) } return S === "Yo" ? C.ordinalNumber(v, { unit: "year" }) : (0, l.default)(v, S.length) }, R: function (x, S) { var C = (0, s.default)(x); return (0, l.default)(C, S.length) }, u: function (x, S) { var C = x.getUTCFullYear(); return (0, l.default)(C, S.length) }, Q: function (x, S, C) { var O = Math.ceil((x.getUTCMonth() + 1) / 3); switch (S) { case "Q": return String(O); case "QQ": return (0, l.default)(O, 2); case "Qo": return C.ordinalNumber(O, { unit: "quarter" }); case "QQQ": return C.quarter(O, { width: "abbreviated", context: "formatting" }); case "QQQQQ": return C.quarter(O, { width: "narrow", context: "formatting" }); case "QQQQ": default: return C.quarter(O, { width: "wide", context: "formatting" }) } }, q: function (x, S, C) { var O = Math.ceil((x.getUTCMonth() + 1) / 3); switch (S) { case "q": return String(O); case "qq": return (0, l.default)(O, 2); case "qo": return C.ordinalNumber(O, { unit: "quarter" }); case "qqq": return C.quarter(O, { width: "abbreviated", context: "standalone" }); case "qqqqq": return C.quarter(O, { width: "narrow", context: "standalone" }); case "qqqq": default: return C.quarter(O, { width: "wide", context: "standalone" }) } }, M: function (x, S, C) { var O = x.getUTCMonth(); switch (S) { case "M": case "MM": return u.default.M(x, S); case "Mo": return C.ordinalNumber(O + 1, { unit: "month" }); case "MMM": return C.month(O, { width: "abbreviated", context: "formatting" }); case "MMMMM": return C.month(O, { width: "narrow", context: "formatting" }); case "MMMM": default: return C.month(O, { width: "wide", context: "formatting" }) } }, L: function (x, S, C) { var O = x.getUTCMonth(); switch (S) { case "L": return String(O + 1); case "LL": return (0, l.default)(O + 1, 2); case "Lo": return C.ordinalNumber(O + 1, { unit: "month" }); case "LLL": return C.month(O, { width: "abbreviated", context: "standalone" }); case "LLLLL": return C.month(O, { width: "narrow", context: "standalone" }); case "LLLL": default: return C.month(O, { width: "wide", context: "standalone" }) } }, w: function (x, S, C, O) { var E = (0, a.default)(x, O); return S === "wo" ? C.ordinalNumber(E, { unit: "week" }) : (0, l.default)(E, S.length) }, I: function (x, S, C) { var O = (0, i.default)(x); return S === "Io" ? C.ordinalNumber(O, { unit: "week" }) : (0, l.default)(O, S.length) }, d: function (x, S, C) { return S === "do" ? C.ordinalNumber(x.getUTCDate(), { unit: "date" }) : u.default.d(x, S) }, D: function (x, S, C) { var O = (0, n.default)(x); return S === "Do" ? C.ordinalNumber(O, { unit: "dayOfYear" }) : (0, l.default)(O, S.length) }, E: function (x, S, C) { var O = x.getUTCDay(); switch (S) { case "E": case "EE": case "EEE": return C.day(O, { width: "abbreviated", context: "formatting" }); case "EEEEE": return C.day(O, { width: "narrow", context: "formatting" }); case "EEEEEE": return C.day(O, { width: "short", context: "formatting" }); case "EEEE": default: return C.day(O, { width: "wide", context: "formatting" }) } }, e: function (x, S, C, O) { var E = x.getUTCDay(), v = (E - O.weekStartsOn + 8) % 7 || 7; switch (S) { case "e": return String(v); case "ee": return (0, l.default)(v, 2); case "eo": return C.ordinalNumber(v, { unit: "day" }); case "eee": return C.day(E, { width: "abbreviated", context: "formatting" }); case "eeeee": return C.day(E, { width: "narrow", context: "formatting" }); case "eeeeee": return C.day(E, { width: "short", context: "formatting" }); case "eeee": default: return C.day(E, { width: "wide", context: "formatting" }) } }, c: function (x, S, C, O) { var E = x.getUTCDay(), v = (E - O.weekStartsOn + 8) % 7 || 7; switch (S) { case "c": return String(v); case "cc": return (0, l.default)(v, S.length); case "co": return C.ordinalNumber(v, { unit: "day" }); case "ccc": return C.day(E, { width: "abbreviated", context: "standalone" }); case "ccccc": return C.day(E, { width: "narrow", context: "standalone" }); case "cccccc": return C.day(E, { width: "short", context: "standalone" }); case "cccc": default: return C.day(E, { width: "wide", context: "standalone" }) } }, i: function (x, S, C) { var O = x.getUTCDay(), E = O === 0 ? 7 : O; switch (S) { case "i": return String(E); case "ii": return (0, l.default)(E, S.length); case "io": return C.ordinalNumber(E, { unit: "day" }); case "iii": return C.day(O, { width: "abbreviated", context: "formatting" }); case "iiiii": return C.day(O, { width: "narrow", context: "formatting" }); case "iiiiii": return C.day(O, { width: "short", context: "formatting" }); case "iiii": default: return C.day(O, { width: "wide", context: "formatting" }) } }, a: function (x, S, C) { var O = x.getUTCHours(), E = O / 12 >= 1 ? "pm" : "am"; switch (S) { case "a": case "aa": return C.dayPeriod(E, { width: "abbreviated", context: "formatting" }); case "aaa": return C.dayPeriod(E, { width: "abbreviated", context: "formatting" }).toLowerCase(); case "aaaaa": return C.dayPeriod(E, { width: "narrow", context: "formatting" }); case "aaaa": default: return C.dayPeriod(E, { width: "wide", context: "formatting" }) } }, b: function (x, S, C) { var O = x.getUTCHours(), E; switch (O === 12 ? E = d.noon : O === 0 ? E = d.midnight : E = O / 12 >= 1 ? "pm" : "am", S) { case "b": case "bb": return C.dayPeriod(E, { width: "abbreviated", context: "formatting" }); case "bbb": return C.dayPeriod(E, { width: "abbreviated", context: "formatting" }).toLowerCase(); case "bbbbb": return C.dayPeriod(E, { width: "narrow", context: "formatting" }); case "bbbb": default: return C.dayPeriod(E, { width: "wide", context: "formatting" }) } }, B: function (x, S, C) { var O = x.getUTCHours(), E; switch (O >= 17 ? E = d.evening : O >= 12 ? E = d.afternoon : O >= 4 ? E = d.morning : E = d.night, S) { case "B": case "BB": case "BBB": return C.dayPeriod(E, { width: "abbreviated", context: "formatting" }); case "BBBBB": return C.dayPeriod(E, { width: "narrow", context: "formatting" }); case "BBBB": default: return C.dayPeriod(E, { width: "wide", context: "formatting" }) } }, h: function (x, S, C) { if (S === "ho") { var O = x.getUTCHours() % 12; return O === 0 && (O = 12), C.ordinalNumber(O, { unit: "hour" }) } return u.default.h(x, S) }, H: function (x, S, C) { return S === "Ho" ? C.ordinalNumber(x.getUTCHours(), { unit: "hour" }) : u.default.H(x, S) }, K: function (x, S, C) { var O = x.getUTCHours() % 12; return S === "Ko" ? C.ordinalNumber(O, { unit: "hour" }) : (0, l.default)(O, S.length) }, k: function (x, S, C) { var O = x.getUTCHours(); return O === 0 && (O = 24), S === "ko" ? C.ordinalNumber(O, { unit: "hour" }) : (0, l.default)(O, S.length) }, m: function (x, S, C) { return S === "mo" ? C.ordinalNumber(x.getUTCMinutes(), { unit: "minute" }) : u.default.m(x, S) }, s: function (x, S, C) { return S === "so" ? C.ordinalNumber(x.getUTCSeconds(), { unit: "second" }) : u.default.s(x, S) }, S: function (x, S) { return u.default.S(x, S) }, X: function (x, S, C, O) { var E = O._originalDate || x, v = E.getTimezoneOffset(); if (v === 0) return "Z"; switch (S) { case "X": return m(v); case "XXXX": case "XX": return b(v); case "XXXXX": case "XXX": default: return b(v, ":") } }, x: function (x, S, C, O) { var E = O._originalDate || x, v = E.getTimezoneOffset(); switch (S) { case "x": return m(v); case "xxxx": case "xx": return b(v); case "xxxxx": case "xxx": default: return b(v, ":") } }, O: function (x, S, C, O) { var E = O._originalDate || x, v = E.getTimezoneOffset(); switch (S) { case "O": case "OO": case "OOO": return "GMT" + g(v, ":"); case "OOOO": default: return "GMT" + b(v, ":") } }, z: function (x, S, C, O) { var E = O._originalDate || x, v = E.getTimezoneOffset(); switch (S) { case "z": case "zz": case "zzz": return "GMT" + g(v, ":"); case "zzzz": default: return "GMT" + b(v, ":") } }, t: function (x, S, C, O) { var E = O._originalDate || x, v = Math.floor(E.getTime() / 1e3); return (0, l.default)(v, S.length) }, T: function (x, S, C, O) { var E = O._originalDate || x, v = E.getTime(); return (0, l.default)(v, S.length) } }; function g(w, x) { var S = w > 0 ? "-" : "+", C = Math.abs(w), O = Math.floor(C / 60), E = C % 60; if (E === 0) return S + String(O); var v = x; return S + String(O) + v + (0, l.default)(E, 2) } function m(w, x) { if (w % 60 === 0) { var S = w > 0 ? "-" : "+"; return S + (0, l.default)(Math.abs(w) / 60, 2) } return b(w, x) } function b(w, x) { var S = x || "", C = w > 0 ? "-" : "+", O = Math.abs(w), E = (0, l.default)(Math.floor(O / 60), 2), v = (0, l.default)(O % 60, 2); return C + E + S + v } var y = h; e.default = y, r.exports = e.default })(zf, zf.exports); var yG = zf.exports, eg = { exports: {} }; (function (r, e) { Object.defineProperty(e, "__esModule", { value: !0 }), e.default = void 0; var t = function (l, u) { switch (l) { case "P": return u.date({ width: "short" }); case "PP": return u.date({ width: "medium" }); case "PPP": return u.date({ width: "long" }); case "PPPP": default: return u.date({ width: "full" }) } }, n = function (l, u) { switch (l) { case "p": return u.time({ width: "short" }); case "pp": return u.time({ width: "medium" }); case "ppp": return u.time({ width: "long" }); case "pppp": default: return u.time({ width: "full" }) } }, i = function (l, u) { var d = l.match(/(P+)(p+)?/) || [], h = d[1], g = d[2]; if (!g) return t(l, u); var m; switch (h) { case "P": m = u.dateTime({ width: "short" }); break; case "PP": m = u.dateTime({ width: "medium" }); break; case "PPP": m = u.dateTime({ width: "long" }); break; case "PPPP": default: m = u.dateTime({ width: "full" }); break }return m.replace("{{date}}", t(h, u)).replace("{{time}}", n(g, u)) }, s = { p: n, P: i }, a = s; e.default = a, r.exports = e.default })(eg, eg.exports); var bG = eg.exports, tg = { exports: {} }; (function (r, e) { Object.defineProperty(e, "__esModule", { value: !0 }), e.default = t; function t(n) { var i = new Date(Date.UTC(n.getFullYear(), n.getMonth(), n.getDate(), n.getHours(), n.getMinutes(), n.getSeconds(), n.getMilliseconds())); return i.setUTCFullYear(n.getFullYear()), n.getTime() - i.getTime() } r.exports = e.default })(tg, tg.exports); var b_ = tg.exports, kc = {}; Object.defineProperty(kc, "__esModule", { value: !0 }); kc.isProtectedDayOfYearToken = wG; kc.isProtectedWeekYearToken = CG; kc.throwProtectedError = SG; var vG = ["D", "DD"], xG = ["YY", "YYYY"]; function wG(r) { return vG.indexOf(r) !== -1 } function CG(r) { return xG.indexOf(r) !== -1 } function SG(r, e, t) { if (r === "YYYY") throw new RangeError("Use `yyyy` instead of `YYYY` (in `".concat(e, "`) for formatting years to the input `").concat(t, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md")); if (r === "YY") throw new RangeError("Use `yy` instead of `YY` (in `".concat(e, "`) for formatting years to the input `").concat(t, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md")); if (r === "D") throw new RangeError("Use `d` instead of `D` (in `".concat(e, "`) for formatting days of the month to the input `").concat(t, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md")); if (r === "DD") throw new RangeError("Use `dd` instead of `DD` (in `".concat(e, "`) for formatting days of the month to the input `").concat(t, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md")) } var ng = { exports: {} }, rg = { exports: {} }, ig = { exports: {} }; (function (r, e) { Object.defineProperty(e, "__esModule", { value: !0 }), e.default = void 0; var t = { lessThanXSeconds: { one: "less than a second", other: "less than {{count}} seconds" }, xSeconds: { one: "1 second", other: "{{count}} seconds" }, halfAMinute: "half a minute", lessThanXMinutes: { one: "less than a minute", other: "less than {{count}} minutes" }, xMinutes: { one: "1 minute", other: "{{count}} minutes" }, aboutXHours: { one: "about 1 hour", other: "about {{count}} hours" }, xHours: { one: "1 hour", other: "{{count}} hours" }, xDays: { one: "1 day", other: "{{count}} days" }, aboutXWeeks: { one: "about 1 week", other: "about {{count}} weeks" }, xWeeks: { one: "1 week", other: "{{count}} weeks" }, aboutXMonths: { one: "about 1 month", other: "about {{count}} months" }, xMonths: { one: "1 month", other: "{{count}} months" }, aboutXYears: { one: "about 1 year", other: "about {{count}} years" }, xYears: { one: "1 year", other: "{{count}} years" }, overXYears: { one: "over 1 year", other: "over {{count}} years" }, almostXYears: { one: "almost 1 year", other: "almost {{count}} years" } }, n = function (a, o, l) { var u, d = t[a]; return typeof d == "string" ? u = d : o === 1 ? u = d.one : u = d.other.replace("{{count}}", o.toString()), l != null && l.addSuffix ? l.comparison && l.comparison > 0 ? "in " + u : u + " ago" : u }, i = n; e.default = i, r.exports = e.default })(ig, ig.exports); var EG = ig.exports, sg = { exports: {} }, ag = { exports: {} }; (function (r, e) { Object.defineProperty(e, "__esModule", { value: !0 }), e.default = t; function t(n) { return function () { var i = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, s = i.width ? String(i.width) : n.defaultWidth, a = n.formats[s] || n.formats[n.defaultWidth]; return a } } r.exports = e.default })(ag, ag.exports); var _G = ag.exports; (function (r, e) { var t = cn.default; Object.defineProperty(e, "__esModule", { value: !0 }), e.default = void 0; var n = t(_G), i = { full: "EEEE, MMMM do, y", long: "MMMM do, y", medium: "MMM d, y", short: "MM/dd/yyyy" }, s = { full: "h:mm:ss a zzzz", long: "h:mm:ss a z", medium: "h:mm:ss a", short: "h:mm a" }, a = { full: "{{date}} 'at' {{time}}", long: "{{date}} 'at' {{time}}", medium: "{{date}}, {{time}}", short: "{{date}}, {{time}}" }, o = { date: (0, n.default)({ formats: i, defaultWidth: "full" }), time: (0, n.default)({ formats: s, defaultWidth: "full" }), dateTime: (0, n.default)({ formats: a, defaultWidth: "full" }) }, l = o; e.default = l, r.exports = e.default })(sg, sg.exports); var OG = sg.exports, og = { exports: {} }; (function (r, e) { Object.defineProperty(e, "__esModule", { value: !0 }), e.default = void 0; var t = { lastWeek: "'last' eeee 'at' p", yesterday: "'yesterday at' p", today: "'today at' p", tomorrow: "'tomorrow at' p", nextWeek: "eeee 'at' p", other: "P" }, n = function (a, o, l, u) { return t[a] }, i = n; e.default = i, r.exports = e.default })(og, og.exports); var TG = og.exports, lg = { exports: {} }, cg = { exports: {} }; (function (r, e) { Object.defineProperty(e, "__esModule", { value: !0 }), e.default = t; function t(n) { return function (i, s) { var a = s != null && s.context ? String(s.context) : "standalone", o; if (a === "formatting" && n.formattingValues) { var l = n.defaultFormattingWidth || n.defaultWidth, u = s != null && s.width ? String(s.width) : l; o = n.formattingValues[u] || n.formattingValues[l] } else { var d = n.defaultWidth, h = s != null && s.width ? String(s.width) : n.defaultWidth; o = n.values[h] || n.values[d] } var g = n.argumentCallback ? n.argumentCallback(i) : i; return o[g] } } r.exports = e.default })(cg, cg.exports); var IG = cg.exports; (function (r, e) { var t = cn.default; Object.defineProperty(e, "__esModule", { value: !0 }), e.default = void 0; var n = t(IG), i = { narrow: ["B", "A"], abbreviated: ["BC", "AD"], wide: ["Before Christ", "Anno Domini"] }, s = { narrow: ["1", "2", "3", "4"], abbreviated: ["Q1", "Q2", "Q3", "Q4"], wide: ["1st quarter", "2nd quarter", "3rd quarter", "4th quarter"] }, a = { narrow: ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"], abbreviated: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"], wide: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"] }, o = { narrow: ["S", "M", "T", "W", "T", "F", "S"], short: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"], abbreviated: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"], wide: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"] }, l = { narrow: { am: "a", pm: "p", midnight: "mi", noon: "n", morning: "morning", afternoon: "afternoon", evening: "evening", night: "night" }, abbreviated: { am: "AM", pm: "PM", midnight: "midnight", noon: "noon", morning: "morning", afternoon: "afternoon", evening: "evening", night: "night" }, wide: { am: "a.m.", pm: "p.m.", midnight: "midnight", noon: "noon", morning: "morning", afternoon: "afternoon", evening: "evening", night: "night" } }, u = { narrow: { am: "a", pm: "p", midnight: "mi", noon: "n", morning: "in the morning", afternoon: "in the afternoon", evening: "in the evening", night: "at night" }, abbreviated: { am: "AM", pm: "PM", midnight: "midnight", noon: "noon", morning: "in the morning", afternoon: "in the afternoon", evening: "in the evening", night: "at night" }, wide: { am: "a.m.", pm: "p.m.", midnight: "midnight", noon: "noon", morning: "in the morning", afternoon: "in the afternoon", evening: "in the evening", night: "at night" } }, d = function (b, y) { var w = Number(b), x = w % 100; if (x > 20 || x < 10) switch (x % 10) { case 1: return w + "st"; case 2: return w + "nd"; case 3: return w + "rd" }return w + "th" }, h = { ordinalNumber: d, era: (0, n.default)({ values: i, defaultWidth: "wide" }), quarter: (0, n.default)({ values: s, defaultWidth: "wide", argumentCallback: function (b) { return b - 1 } }), month: (0, n.default)({ values: a, defaultWidth: "wide" }), day: (0, n.default)({ values: o, defaultWidth: "wide" }), dayPeriod: (0, n.default)({ values: l, defaultWidth: "wide", formattingValues: u, defaultFormattingWidth: "wide" }) }, g = h; e.default = g, r.exports = e.default })(lg, lg.exports); var PG = lg.exports, ug = { exports: {} }, dg = { exports: {} }; (function (r, e) { Object.defineProperty(e, "__esModule", { value: !0 }), e.default = t; function t(s) { return function (a) { var o = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, l = o.width, u = l && s.matchPatterns[l] || s.matchPatterns[s.defaultMatchWidth], d = a.match(u); if (!d) return null; var h = d[0], g = l && s.parsePatterns[l] || s.parsePatterns[s.defaultParseWidth], m = Array.isArray(g) ? i(g, function (w) { return w.test(h) }) : n(g, function (w) { return w.test(h) }), b; b = s.valueCallback ? s.valueCallback(m) : m, b = o.valueCallback ? o.valueCallback(b) : b; var y = a.slice(h.length); return { value: b, rest: y } } } function n(s, a) { for (var o in s) if (s.hasOwnProperty(o) && a(s[o])) return o } function i(s, a) { for (var o = 0; o < s.length; o++)if (a(s[o])) return o } r.exports = e.default })(dg, dg.exports); var kG = dg.exports, hg = { exports: {} }; (function (r, e) { Object.defineProperty(e, "__esModule", { value: !0 }), e.default = t; function t(n) { return function (i) { var s = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, a = i.match(n.matchPattern); if (!a) return null; var o = a[0], l = i.match(n.parsePattern); if (!l) return null; var u = n.valueCallback ? n.valueCallback(l[0]) : l[0]; u = s.valueCallback ? s.valueCallback(u) : u; var d = i.slice(o.length); return { value: u, rest: d } } } r.exports = e.default })(hg, hg.exports); var RG = hg.exports; (function (r, e) { var t = cn.default; Object.defineProperty(e, "__esModule", { value: !0 }), e.default = void 0; var n = t(kG), i = t(RG), s = /^(\d+)(th|st|nd|rd)?/i, a = /\d+/i, o = { narrow: /^(b|a)/i, abbreviated: /^(b\.?\s?c\.?|b\.?\s?c\.?\s?e\.?|a\.?\s?d\.?|c\.?\s?e\.?)/i, wide: /^(before christ|before common era|anno domini|common era)/i }, l = { any: [/^b/i, /^(a|c)/i] }, u = { narrow: /^[1234]/i, abbreviated: /^q[1234]/i, wide: /^[1234](th|st|nd|rd)? quarter/i }, d = { any: [/1/i, /2/i, /3/i, /4/i] }, h = { narrow: /^[jfmasond]/i, abbreviated: /^(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)/i, wide: /^(january|february|march|april|may|june|july|august|september|october|november|december)/i }, g = { narrow: [/^j/i, /^f/i, /^m/i, /^a/i, /^m/i, /^j/i, /^j/i, /^a/i, /^s/i, /^o/i, /^n/i, /^d/i], any: [/^ja/i, /^f/i, /^mar/i, /^ap/i, /^may/i, /^jun/i, /^jul/i, /^au/i, /^s/i, /^o/i, /^n/i, /^d/i] }, m = { narrow: /^[smtwf]/i, short: /^(su|mo|tu|we|th|fr|sa)/i, abbreviated: /^(sun|mon|tue|wed|thu|fri|sat)/i, wide: /^(sunday|monday|tuesday|wednesday|thursday|friday|saturday)/i }, b = { narrow: [/^s/i, /^m/i, /^t/i, /^w/i, /^t/i, /^f/i, /^s/i], any: [/^su/i, /^m/i, /^tu/i, /^w/i, /^th/i, /^f/i, /^sa/i] }, y = { narrow: /^(a|p|mi|n|(in the|at) (morning|afternoon|evening|night))/i, any: /^([ap]\.?\s?m\.?|midnight|noon|(in the|at) (morning|afternoon|evening|night))/i }, w = { any: { am: /^a/i, pm: /^p/i, midnight: /^mi/i, noon: /^no/i, morning: /morning/i, afternoon: /afternoon/i, evening: /evening/i, night: /night/i } }, x = { ordinalNumber: (0, i.default)({ matchPattern: s, parsePattern: a, valueCallback: function (O) { return parseInt(O, 10) } }), era: (0, n.default)({ matchPatterns: o, defaultMatchWidth: "wide", parsePatterns: l, defaultParseWidth: "any" }), quarter: (0, n.default)({ matchPatterns: u, defaultMatchWidth: "wide", parsePatterns: d, defaultParseWidth: "any", valueCallback: function (O) { return O + 1 } }), month: (0, n.default)({ matchPatterns: h, defaultMatchWidth: "wide", parsePatterns: g, defaultParseWidth: "any" }), day: (0, n.default)({ matchPatterns: m, defaultMatchWidth: "wide", parsePatterns: b, defaultParseWidth: "any" }), dayPeriod: (0, n.default)({ matchPatterns: y, defaultMatchWidth: "any", parsePatterns: w, defaultParseWidth: "any" }) }, S = x; e.default = S, r.exports = e.default })(ug, ug.exports); var DG = ug.exports; (function (r, e) { var t = cn.default; Object.defineProperty(e, "__esModule", { value: !0 }), e.default = void 0; var n = t(EG), i = t(OG), s = t(TG), a = t(PG), o = t(DG), l = { code: "en-US", formatDistance: n.default, formatLong: i.default, formatRelative: s.default, localize: a.default, match: o.default, options: { weekStartsOn: 0, firstWeekContainsDate: 1 } }, u = l; e.default = u, r.exports = e.default })(rg, rg.exports); var AG = rg.exports; (function (r, e) { var t = cn.default; Object.defineProperty(e, "__esModule", { value: !0 }), e.default = void 0; var n = t(AG), i = n.default; e.default = i, r.exports = e.default })(ng, ng.exports); var NG = ng.exports; (function (r, e) { var t = cn.default; Object.defineProperty(e, "__esModule", { value: !0 }), e.default = C; var n = t(aG), i = t(lG), s = t(Wi), a = t(yG), o = t(bG), l = t(b_), u = kc, d = t(Pa), h = t(dr), g = ka, m = t(NG), b = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g, y = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g, w = /^'([^]*?)'?$/, x = /''/g, S = /[a-zA-Z]/; function C(E, v, T) { var I, k, P, N, M, B, K, U, W, Z, J, ee, $, pe, re, j, ae, be; (0, h.default)(2, arguments); var fe = String(v), Ce = (0, g.getDefaultOptions)(), ue = (I = (k = T == null ? void 0 : T.locale) !== null && k !== void 0 ? k : Ce.locale) !== null && I !== void 0 ? I : m.default, te = (0, d.default)((P = (N = (M = (B = T == null ? void 0 : T.firstWeekContainsDate) !== null && B !== void 0 ? B : T == null || (K = T.locale) === null || K === void 0 || (U = K.options) === null || U === void 0 ? void 0 : U.firstWeekContainsDate) !== null && M !== void 0 ? M : Ce.firstWeekContainsDate) !== null && N !== void 0 ? N : (W = Ce.locale) === null || W === void 0 || (Z = W.options) === null || Z === void 0 ? void 0 : Z.firstWeekContainsDate) !== null && P !== void 0 ? P : 1); if (!(te >= 1 && te <= 7)) throw new RangeError("firstWeekContainsDate must be between 1 and 7 inclusively"); var le = (0, d.default)((J = (ee = ($ = (pe = T == null ? void 0 : T.weekStartsOn) !== null && pe !== void 0 ? pe : T == null || (re = T.locale) === null || re === void 0 || (j = re.options) === null || j === void 0 ? void 0 : j.weekStartsOn) !== null && $ !== void 0 ? $ : Ce.weekStartsOn) !== null && ee !== void 0 ? ee : (ae = Ce.locale) === null || ae === void 0 || (be = ae.options) === null || be === void 0 ? void 0 : be.weekStartsOn) !== null && J !== void 0 ? J : 0); if (!(le >= 0 && le <= 6)) throw new RangeError("weekStartsOn must be between 0 and 6 inclusively"); if (!ue.localize) throw new RangeError("locale must contain localize property"); if (!ue.formatLong) throw new RangeError("locale must contain formatLong property"); var Re = (0, s.default)(E); if (!(0, n.default)(Re)) throw new RangeError("Invalid time value"); var at = (0, l.default)(Re), yt = (0, i.default)(Re, at), ht = { firstWeekContainsDate: te, weekStartsOn: le, locale: ue, _originalDate: Re }, Ft = fe.match(y).map(function (qe) { var $t = qe[0]; if ($t === "p" || $t === "P") { var gn = o.default[$t]; return gn(qe, ue.formatLong) } return qe }).join("").match(b).map(function (qe) { if (qe === "''") return "'"; var $t = qe[0]; if ($t === "'") return O(qe); var gn = a.default[$t]; if (gn) return !(T != null && T.useAdditionalWeekYearTokens) && (0, u.isProtectedWeekYearToken)(qe) && (0, u.throwProtectedError)(qe, v, String(E)), !(T != null && T.useAdditionalDayOfYearTokens) && (0, u.isProtectedDayOfYearToken)(qe) && (0, u.throwProtectedError)(qe, v, String(E)), gn(yt, qe, ue.localize, ht); if ($t.match(S)) throw new RangeError("Format string contains an unescaped latin alphabet character `" + $t + "`"); return qe }).join(""); return Ft } function O(E) { var v = E.match(w); return v ? v[1].replace(x, "'") : E } r.exports = e.default })(Nf, Nf.exports); var FG = Nf.exports, pg = { exports: {} }, fg = { exports: {} }; (function (r, e) { Object.defineProperty(e, "__esModule", { value: !0 }), e.default = t; function t(a, o, l) { var u = s(a, l.timeZone, l.locale); return u.formatToParts ? n(u, o) : i(u, o) } function n(a, o) { for (var l = a.formatToParts(o), u = l.length - 1; u >= 0; --u)if (l[u].type === "timeZoneName") return l[u].value } function i(a, o) { var l = a.format(o).replace(/\u200E/g, ""), u = / [\w-+ ]+$/.exec(l); return u ? u[0].substr(1) : "" } function s(a, o, l) { if (l && !l.code) throw new Error("date-fns-tz error: Please set a language code on the locale object imported from date-fns, e.g. `locale.code = 'en-US'`"); return new Intl.DateTimeFormat(l ? [l.code, "en-US"] : void 0, { timeZone: o, timeZoneName: a }) } r.exports = e.default })(fg, fg.exports); var $G = fg.exports, gg = { exports: {} }, mg = { exports: {} }; (function (r, e) { Object.defineProperty(e, "__esModule", { value: !0 }), e.default = t; function t(l, u) { var d = o(u); return d.formatToParts ? i(d, l) : s(d, l) } var n = { year: 0, month: 1, day: 2, hour: 3, minute: 4, second: 5 }; function i(l, u) { try { for (var d = l.formatToParts(u), h = [], g = 0; g < d.length; g++) { var m = n[d[g].type]; m >= 0 && (h[m] = parseInt(d[g].value, 10)) } return h } catch (b) { if (b instanceof RangeError) return [NaN]; throw b } } function s(l, u) { var d = l.format(u).replace(/\u200E/g, ""), h = /(\d+)\/(\d+)\/(\d+),? (\d+):(\d+):(\d+)/.exec(d); return [h[3], h[1], h[2], h[4], h[5], h[6]] } var a = {}; function o(l) { if (!a[l]) { var u = new Intl.DateTimeFormat("en-US", { hour12: !1, timeZone: "America/New_York", year: "numeric", month: "numeric", day: "2-digit", hour: "2-digit", minute: "2-digit", second: "2-digit" }).format(new Date("2014-06-25T04:00:00.123Z")), d = u === "06/25/2014, 00:00:00" || u === "‎06‎/‎25‎/‎2014‎ ‎00‎:‎00‎:‎00"; a[l] = d ? new Intl.DateTimeFormat("en-US", { hour12: !1, timeZone: l, year: "numeric", month: "numeric", day: "2-digit", hour: "2-digit", minute: "2-digit", second: "2-digit" }) : new Intl.DateTimeFormat("en-US", { hourCycle: "h23", timeZone: l, year: "numeric", month: "numeric", day: "2-digit", hour: "2-digit", minute: "2-digit", second: "2-digit" }) } return a[l] } r.exports = e.default })(mg, mg.exports); var LG = mg.exports, yg = { exports: {} }; (function (r, e) { Object.defineProperty(e, "__esModule", { value: !0 }), e.default = t; function t(n, i, s, a, o, l, u) { var d = new Date(0); return d.setUTCFullYear(n, i, s), d.setUTCHours(a, o, l, u), d } r.exports = e.default })(yg, yg.exports); var v_ = yg.exports; (function (r, e) { Object.defineProperty(e, "__esModule", { value: !0 }), e.default = l; var t = i(LG), n = i(v_); function i(y) { return y && y.__esModule ? y : { default: y } } var s = 36e5, a = 6e4, o = { timezone: /([Z+-].*)$/, timezoneZ: /^(Z)$/, timezoneHH: /^([+-]\d{2})$/, timezoneHHMM: /^([+-]\d{2}):?(\d{2})$/ }; function l(y, w, x) { var S, C; if (!y || (S = o.timezoneZ.exec(y), S)) return 0; var O; if (S = o.timezoneHH.exec(y), S) return O = parseInt(S[1], 10), g(O) ? -(O * s) : NaN; if (S = o.timezoneHHMM.exec(y), S) { O = parseInt(S[1], 10); var E = parseInt(S[2], 10); return g(O, E) ? (C = Math.abs(O) * s + E * a, O > 0 ? -C : C) : NaN } if (b(y)) { w = new Date(w || Date.now()); var v = x ? w : u(w), T = d(v, y), I = x ? T : h(w, T, y); return -I } return NaN } function u(y) { return (0, n.default)(y.getFullYear(), y.getMonth(), y.getDate(), y.getHours(), y.getMinutes(), y.getSeconds(), y.getMilliseconds()) } function d(y, w) { var x = (0, t.default)(y, w), S = (0, n.default)(x[0], x[1] - 1, x[2], x[3] % 24, x[4], x[5], 0).getTime(), C = y.getTime(), O = C % 1e3; return C -= O >= 0 ? O : 1e3 + O, S - C } function h(y, w, x) { var S = y.getTime(), C = S - w, O = d(new Date(C), x); if (w === O) return w; C -= O - w; var E = d(new Date(C), x); return O === E ? O : Math.max(O, E) } function g(y, w) { return -23 <= y && y <= 23 && (w == null || 0 <= w && w <= 59) } var m = {}; function b(y) { if (m[y]) return !0; try { return new Intl.DateTimeFormat(void 0, { timeZone: y }), m[y] = !0, !0 } catch { return !1 } } r.exports = e.default })(gg, gg.exports); var Rc = gg.exports; (function (r, e) { Object.defineProperty(e, "__esModule", { value: !0 }), e.default = void 0; var t = i($G), n = i(Rc); function i(m) { return m && m.__esModule ? m : { default: m } } var s = 60 * 1e3, a = { X: function (m, b, y, w) { var x = o(w.timeZone, w._originalDate || m); if (x === 0) return "Z"; switch (b) { case "X": return d(x); case "XXXX": case "XX": return u(x); case "XXXXX": case "XXX": default: return u(x, ":") } }, x: function (m, b, y, w) { var x = o(w.timeZone, w._originalDate || m); switch (b) { case "x": return d(x); case "xxxx": case "xx": return u(x); case "xxxxx": case "xxx": default: return u(x, ":") } }, O: function (m, b, y, w) { var x = o(w.timeZone, w._originalDate || m); switch (b) { case "O": case "OO": case "OOO": return "GMT" + h(x, ":"); case "OOOO": default: return "GMT" + u(x, ":") } }, z: function (m, b, y, w) { var x = w._originalDate || m; switch (b) { case "z": case "zz": case "zzz": return (0, t.default)("short", x, w); case "zzzz": default: return (0, t.default)("long", x, w) } } }; function o(m, b) { var y = m ? (0, n.default)(m, b, !0) / s : b.getTimezoneOffset(); if (Number.isNaN(y)) throw new RangeError("Invalid time zone specified: " + m); return y } function l(m, b) { for (var y = m < 0 ? "-" : "", w = Math.abs(m).toString(); w.length < b;)w = "0" + w; return y + w } function u(m, b) { var y = b || "", w = m > 0 ? "-" : "+", x = Math.abs(m), S = l(Math.floor(x / 60), 2), C = l(Math.floor(x % 60), 2); return w + S + y + C } function d(m, b) { if (m % 60 === 0) { var y = m > 0 ? "-" : "+"; return y + l(Math.abs(m) / 60, 2) } return u(m, b) } function h(m, b) { var y = m > 0 ? "-" : "+", w = Math.abs(m), x = Math.floor(w / 60), S = w % 60; if (S === 0) return y + String(x); var C = b; return y + String(x) + C + l(S, 2) } var g = a; e.default = g, r.exports = e.default })(pg, pg.exports); var MG = pg.exports, bg = { exports: {} }, vg = { exports: {} }; (function (r, e) { Object.defineProperty(e, "__esModule", { value: !0 }), e.default = void 0; var t = /(Z|[+-]\d{2}(?::?\d{2})?| UTC| [a-zA-Z]+\/[a-zA-Z_]+(?:\/[a-zA-Z_]+)?)$/, n = t; e.default = n, r.exports = e.default })(vg, vg.exports); var x_ = vg.exports; (function (r, e) { Object.defineProperty(e, "__esModule", { value: !0 }), e.default = h; var t = a(Pa), n = a(b_), i = a(Rc), s = a(x_); function a(I) { return I && I.__esModule ? I : { default: I } } var o = 36e5, l = 6e4, u = 2, d = { dateTimePattern: /^([0-9W+-]+)(T| )(.*)/, datePattern: /^([0-9W+-]+)(.*)/, plainTime: /:/, YY: /^(\d{2})$/, YYY: [/^([+-]\d{2})$/, /^([+-]\d{3})$/, /^([+-]\d{4})$/], YYYY: /^(\d{4})/, YYYYY: [/^([+-]\d{4})/, /^([+-]\d{5})/, /^([+-]\d{6})/], MM: /^-(\d{2})$/, DDD: /^-?(\d{3})$/, MMDD: /^-?(\d{2})-?(\d{2})$/, Www: /^-?W(\d{2})$/, WwwD: /^-?W(\d{2})-?(\d{1})$/, HH: /^(\d{2}([.,]\d*)?)$/, HHMM: /^(\d{2}):?(\d{2}([.,]\d*)?)$/, HHMMSS: /^(\d{2}):?(\d{2}):?(\d{2}([.,]\d*)?)$/, timeZone: s.default }; function h(I, k) { if (arguments.length < 1) throw new TypeError("1 argument required, but only " + arguments.length + " present"); if (I === null) return new Date(NaN); var P = k || {}, N = P.additionalDigits == null ? u : (0, t.default)(P.additionalDigits); if (N !== 2 && N !== 1 && N !== 0) throw new RangeError("additionalDigits must be 0, 1 or 2"); if (I instanceof Date || typeof I == "object" && Object.prototype.toString.call(I) === "[object Date]") return new Date(I.getTime()); if (typeof I == "number" || Object.prototype.toString.call(I) === "[object Number]") return new Date(I); if (!(typeof I == "string" || Object.prototype.toString.call(I) === "[object String]")) return new Date(NaN); var M = g(I), B = m(M.date, N), K = B.year, U = B.restDateString, W = b(U, K); if (isNaN(W)) return new Date(NaN); if (W) { var Z = W.getTime(), J = 0, ee; if (M.time && (J = y(M.time), isNaN(J))) return new Date(NaN); if (M.timeZone || P.timeZone) { if (ee = (0, i.default)(M.timeZone || P.timeZone, new Date(Z + J)), isNaN(ee)) return new Date(NaN) } else ee = (0, n.default)(new Date(Z + J)), ee = (0, n.default)(new Date(Z + J + ee)); return new Date(Z + J + ee) } else return new Date(NaN) } function g(I) { var k = {}, P = d.dateTimePattern.exec(I), N; if (P ? (k.date = P[1], N = P[3]) : (P = d.datePattern.exec(I), P ? (k.date = P[1], N = P[2]) : (k.date = null, N = I)), N) { var M = d.timeZone.exec(N); M ? (k.time = N.replace(M[1], ""), k.timeZone = M[1].trim()) : k.time = N } return k } function m(I, k) { var P = d.YYY[k], N = d.YYYYY[k], M; if (M = d.YYYY.exec(I) || N.exec(I), M) { var B = M[1]; return { year: parseInt(B, 10), restDateString: I.slice(B.length) } } if (M = d.YY.exec(I) || P.exec(I), M) { var K = M[1]; return { year: parseInt(K, 10) * 100, restDateString: I.slice(K.length) } } return { year: null } } function b(I, k) { if (k === null) return null; var P, N, M, B; if (I.length === 0) return N = new Date(0), N.setUTCFullYear(k), N; if (P = d.MM.exec(I), P) return N = new Date(0), M = parseInt(P[1], 10) - 1, O(k, M) ? (N.setUTCFullYear(k, M), N) : new Date(NaN); if (P = d.DDD.exec(I), P) { N = new Date(0); var K = parseInt(P[1], 10); return E(k, K) ? (N.setUTCFullYear(k, 0, K), N) : new Date(NaN) } if (P = d.MMDD.exec(I), P) { N = new Date(0), M = parseInt(P[1], 10) - 1; var U = parseInt(P[2], 10); return O(k, M, U) ? (N.setUTCFullYear(k, M, U), N) : new Date(NaN) } if (P = d.Www.exec(I), P) return B = parseInt(P[1], 10) - 1, v(k, B) ? w(k, B) : new Date(NaN); if (P = d.WwwD.exec(I), P) { B = parseInt(P[1], 10) - 1; var W = parseInt(P[2], 10) - 1; return v(k, B, W) ? w(k, B, W) : new Date(NaN) } return null } function y(I) { var k, P, N; if (k = d.HH.exec(I), k) return P = parseFloat(k[1].replace(",", ".")), T(P) ? P % 24 * o : NaN; if (k = d.HHMM.exec(I), k) return P = parseInt(k[1], 10), N = parseFloat(k[2].replace(",", ".")), T(P, N) ? P % 24 * o + N * l : NaN; if (k = d.HHMMSS.exec(I), k) { P = parseInt(k[1], 10), N = parseInt(k[2], 10); var M = parseFloat(k[3].replace(",", ".")); return T(P, N, M) ? P % 24 * o + N * l + M * 1e3 : NaN } return null } function w(I, k, P) { k = k || 0, P = P || 0; var N = new Date(0); N.setUTCFullYear(I, 0, 4); var M = N.getUTCDay() || 7, B = k * 7 + P + 1 - M; return N.setUTCDate(N.getUTCDate() + B), N } var x = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31], S = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]; function C(I) { return I % 400 === 0 || I % 4 === 0 && I % 100 !== 0 } function O(I, k, P) { if (k < 0 || k > 11) return !1; if (P != null) { if (P < 1) return !1; var N = C(I); if (N && P > S[k] || !N && P > x[k]) return !1 } return !0 } function E(I, k) { if (k < 1) return !1; var P = C(I); return !(P && k > 366 || !P && k > 365) } function v(I, k, P) { return !(k < 0 || k > 52 || P != null && (P < 0 || P > 6)) } function T(I, k, P) { return !(I != null && (I < 0 || I >= 25) || k != null && (k < 0 || k >= 60) || P != null && (P < 0 || P >= 60)) } r.exports = e.default })(bg, bg.exports); var lh = bg.exports; (function (r, e) { Object.defineProperty(e, "__esModule", { value: !0 }), e.default = o; var t = s(FG), n = s(MG), i = s(lh); function s(l) { return l && l.__esModule ? l : { default: l } } var a = /([xXOz]+)|''|'(''|[^'])+('|$)/g; function o(l, u, d) { var h = String(u), g = d || {}, m = h.match(a); if (m) { var b = (0, i.default)(l, g); h = m.reduce(function (y, w) { if (w[0] === "'") return y; var x = y.indexOf(w), S = y[x - 1] === "'", C = y.replace(w, "'" + n.default[w[0]](b, w, null, g) + "'"); return S ? C.substring(0, x - 1) + C.substring(x + 1) : C }, h) } return (0, t.default)(l, h, g) } r.exports = e.default })(Af, Af.exports); var w_ = Af.exports, xg = { exports: {} }, wg = { exports: {} }, Cg = { exports: {} }; (function (r, e) { Object.defineProperty(e, "__esModule", { value: !0 }), e.default = t; function t(n, i) { if (n == null) throw new TypeError("assign requires that input parameter not be null or undefined"); for (var s in i) Object.prototype.hasOwnProperty.call(i, s) && (n[s] = i[s]); return n } r.exports = e.default })(Cg, Cg.exports); var jG = Cg.exports; (function (r, e) { var t = cn.default; Object.defineProperty(e, "__esModule", { value: !0 }), e.default = i; var n = t(jG); function i(s) { return (0, n.default)({}, s) } r.exports = e.default })(wg, wg.exports); var C_ = wg.exports, Sg = { exports: {} }; (function (r, e) { Object.defineProperty(e, "__esModule", { value: !0 }), e.default = s; var t = i(Rc), n = i(lh); function i(a) { return a && a.__esModule ? a : { default: a } } function s(a, o, l) { var u = (0, n.default)(a, l), d = (0, t.default)(o, u, !0), h = new Date(u.getTime() - d), g = new Date(0); return g.setFullYear(h.getUTCFullYear(), h.getUTCMonth(), h.getUTCDate()), g.setHours(h.getUTCHours(), h.getUTCMinutes(), h.getUTCSeconds(), h.getUTCMilliseconds()), g } r.exports = e.default })(Sg, Sg.exports); var S_ = Sg.exports; (function (r, e) { Object.defineProperty(e, "__esModule", { value: !0 }), e.default = a; var t = s(C_), n = s(w_), i = s(S_); function s(o) { return o && o.__esModule ? o : { default: o } } function a(o, l, u, d) { var h = (0, t.default)(d); return h.timeZone = l, (0, n.default)((0, i.default)(o, l), u, h) } r.exports = e.default })(xg, xg.exports); var VG = xg.exports, Eg = { exports: {} }; (function (r, e) { Object.defineProperty(e, "__esModule", { value: !0 }), e.default = i; var t = n(Rc); function n(s) { return s && s.__esModule ? s : { default: s } } function i(s, a) { return -(0, t.default)(s, a) } r.exports = e.default })(Eg, Eg.exports); var BG = Eg.exports, _g = { exports: {} }; (function (r, e) { Object.defineProperty(e, "__esModule", { value: !0 }), e.default = l; var t = o(C_), n = o(lh), i = o(x_), s = o(Rc), a = o(v_); function o(u) { return u && u.__esModule ? u : { default: u } } function l(u, d, h) { if (typeof u == "string" && !u.match(i.default)) { var g = (0, t.default)(h); return g.timeZone = d, (0, n.default)(u, g) } var m = (0, n.default)(u, h), b = (0, a.default)(m.getFullYear(), m.getMonth(), m.getDate(), m.getHours(), m.getMinutes(), m.getSeconds(), m.getMilliseconds()).getTime(), y = (0, s.default)(d, new Date(b)); return new Date(b + y) } r.exports = e.default })(_g, _g.exports); var zG = _g.exports, E_ = { format: w_, formatInTimeZone: VG, getTimezoneOffset: BG, toDate: lh, utcToZonedTime: S_, zonedTimeToUtc: zG }; const HG = [[-11, ["Pacific/Midway"]], [-10, ["Pacific/Honolulu"]], [-9.5, ["Pacific/Marquesas"]], [-9, ["Pacific/Gambier"]], [-8, ["Pacific/Pitcairn"]], [-7, ["America/Phoenix"]], [-6, ["America/Tegucigalpa"]], [-5, ["America/Bogota"]], [-4, ["America/Puerto_Rico"]], [-3.5, ["America/St_Johns"]], [-3, ["America/Montevideo"]], [-2, ["Atlantic/South_Georgia"]], [-1, ["Atlantic/Cape_Verde"]], [0, ["Africa/Accra"]], [1, ["Africa/Bangui"]], [2, ["Africa/Cairo"]], [3, ["Asia/Bahrain", "Indian/Antananarivo"]], [3.5, ["Asia/Tehran"]], [4, ["Asia/Dubai", "Asia/Muscat"]], [4.5, ["Asia/Kabul"]], [5, ["Asia/Samarkand", "Asia/Karachi"]], [5.5, ["Asia/Kolkata"]], [5.75, ["Asia/Kathmandu"]], [6, ["Asia/Dhaka"]], [6.5, ["Asia/Rangoon", "Asia/Rangoon"]], [7, ["Asia/Jakarta", "Asia/Phnom_Penh", "Asia/Bangkok"]], [8, ["Asia/Shanghai", "Asia/Singapore"]], [8.75, ["Australia/Eucla"]], [9, ["Asia/Tokyo", "Asia/Seoul", "Asia/Pyongyang"]], [9.5, ["Australia/Darwin"]], [10, ["Pacific/Guam"]], [10.5, ["Australia/Adelaide"]], [11, ["Pacific/Guadalcanal"]], [12, ["Pacific/Funafuti"]], [13, ["Pacific/Enderbury"]], [13.75, ["Pacific/Chatham"]], [14, ["Pacific/Kiritimati"]]], i0 = { 0: "Etc/GMT", 1: "Etc/GMT-1", 2: "Etc/GMT-2", 3: "Etc/GMT-3", 4: "Etc/GMT-4", 5: "Etc/GMT-5", 6: "Etc/GMT-6", 7: "Etc/GMT-7", 8: "Etc/GMT-8", 9: "Etc/GMT-9", 10: "Etc/GMT-10", 11: "Etc/GMT-11", 12: "Etc/GMT-12", 13: "Etc/GMT-13", 14: "Etc/GMT-14", "-1": "Etc/GMT+1", "-2": "Etc/GMT+2", "-3": "Etc/GMT+3", "-4": "Etc/GMT+4", "-5": "Etc/GMT+5", "-6": "Etc/GMT+6", "-7": "Etc/GMT+7", "-8": "Etc/GMT+8", "-9": "Etc/GMT+9", "-10": "Etc/GMT+10", "-11": "Etc/GMT+11", "-12": "Etc/GMT+12" }, KG = /([\-\+]{1})(\d{2})\:(\d{2})/, __ = r => { let e = null; if (typeof r == "string") { if (e = r.match(KG), !e) return r; const t = parseInt(e[1] + 1, 10), n = parseInt(e[2], 10), i = parseInt(e[3], 10); r = t * (n + i / 60) } if (typeof r == "number") { if (r in i0) { const n = i0[r]; if (UG(n)) return n } const t = HG.find(n => n[0] === r); return t && t[1][0] } }, s0 = {}; function UG(r) { if (s0[r]) return !0; try { return new Intl.DateTimeFormat(void 0, { timeZone: r }), s0[r] = !0, !0 } catch { return !1 } } const Og = (r, e, t) => E_.utcToZonedTime(r, __(e), t), fo = (r, e, t) => E_.zonedTimeToUtc(r, __(e), t); function sn(r, e, t, n) { let i = null; if (r) { e && (t = t || new Date, i = LS(r, e, t, { locale: n })), Kr(i) || (i = Gr(r)), Kr(i) || (i = new Date(Date.parse(r))); const s = Kr(i) && String(i.getFullYear()).length > 4; (!Kr(i) || s) && (i = null) } return i } function Ru(r) { const { format: e, type: t } = r, n = /([yMd]{0,4}[^a-z\s]*[yMd]{0,4}[^a-z\s]*[yMd]{0,4})/i, i = /([yMd]{0,4}[^a-z\s]*[yMd]{0,4}[^a-z\s]*[yMd]{0,4}) (H{0,2}[^a-z\s]*m{0,2}[^a-z\s]*s{0,2})/i, s = Ps(t); let a; switch (t) { case "dateTime": case "dateTimeRange": const o = i.exec(e); a = o && o[1] && o[2] ? `${o[1]} ${o[2]}` : s; break; case "date": case "month": case "monthRange": case "dateRange": default: const l = n.exec(e); a = l && l[1] || s; break }return a } function Tg(r) { const e = " ", { inputValue: t = "", rangeSeparator: n, type: i } = r; let s, a, o, l; const u = { monthLeft: { dateInput: "", timeInput: "" }, monthRight: { dateInput: "", timeInput: "" } }; switch (i) { case "date": case "month": case "monthRange": u.monthLeft.dateInput = t; break; case "dateRange": [s = "", o = ""] = t.split(n), u.monthLeft.dateInput = s, u.monthRight.dateInput = o; break; case "dateTime": [s = "", a = ""] = t.split(e), u.monthLeft.dateInput = s, u.monthLeft.timeInput = a; break; case "dateTimeRange": const [d = "", h = ""] = t.split(n);[s = "", a = ""] = d.split(e), [o = "", l = ""] = h.split(e), u.monthLeft.dateInput = s, u.monthLeft.timeInput = a, u.monthRight.dateInput = o, u.monthRight.timeInput = l; break }return u } function Du(r) { return ["string", "number"].includes(typeof r) && r !== "" } class WG extends ve { constructor(e) { super(Object.assign({}, e)), this.clearRangeInputFocus = () => { const { type: t } = this._adapter.getProps(), { rangeInputFocus: n } = this._adapter.getStates(); t === "dateTimeRange" && n && this._adapter.setRangeInputFocus(!1) }, this._isRangeType = () => { const t = this._adapter.getProp("type"); return /range/i.test(t) }, this._isRangeValueComplete = t => { let n = !1; return Array.isArray(t) && (n = !t.some(i => ze(i))), n } } init() { const e = this.getProp("timeZone"); this._isControlledComponent() ? this.initFromProps({ timeZone: e, value: this.getProp("value") }) : this._isInProps("defaultValue") && this.initFromProps({ timeZone: e, value: this.getProp("defaultValue") }), this.initPanelOpenStatus(this.getProp("defaultOpen")) } initFromProps(e) { let { value: t, timeZone: n, prevTimeZone: i } = e; const s = (Array.isArray(t) ? [...t] : (t || t === 0) && [t]) || [], a = this.parseWithTimezone(s, n, i); this._adapter.updatePrevTimezone(i), this.clearInputValue(), this._adapter.updateValue(a), this.resetCachedSelectedValue(a), this.initRangeInputFocus(a), this._adapter.needConfirm() && this._adapter.updateCachedSelectedValue(a) } initRangeInputFocus(e) { const { triggerRender: t } = this.getProps(); this._isRangeType() && we(t) && e.length === 0 && this._adapter.setRangeInputFocus("rangeStart") } parseWithTimezone(e, t, n) { const i = []; if (Array.isArray(e) && e.length) for (const s of e) { let a = (s || s === 0) && this._parseValue(s); a ? (Du(n) && (a = fo(a, n)), i.push(Du(t) ? Og(a, t) : a)) : Nt(!0, `[Semi DatePicker] value cannot be parsed, value: ${String(s)}`) } return i } _isMultiple() { return !!this.getProp("multiple") } _parseValue(e) { const t = this._adapter.getProp("dateFnsLocale"); let n; if (!e && e !== 0) return new Date; if (Yr(e)) n = e; else if (Fe(e)) n = sn(e, this.getProp("format"), void 0, t); else if (Df(e)) n = new Date(e); else throw new TypeError("defaultValue should be valid Date object/timestamp or string"); return n } destroy() { this._adapter.togglePanel(!1), this._adapter.unregisterClickOutSide() } initPanelOpenStatus(e) { (this.getProp("open") || e) && !this.getProp("disabled") ? (this._adapter.togglePanel(!0), this._adapter.registerClickOutSide()) : (this._adapter.togglePanel(!1), this._adapter.unregisterClickOutSide()) } openPanel() { this.getProp("disabled") || (this._isControlledComponent("open") || this.open(), this._adapter.notifyOpenChange(!0)) } clearInsetInputValue() { const { insetInput: e } = this._adapter.getProps(); e && this._adapter.updateInsetInputValue(null) } resetCachedSelectedValue(e) { const { value: t, cachedSelectedValue: n } = this._adapter.getStates(), i = Array.isArray(e) ? e : t; ke(i, n) || this._adapter.updateCachedSelectedValue(i) } closePanel() { this._isControlledComponent("open") ? this.resetInnerSelectedStates() : this.close(), this._adapter.notifyOpenChange(!1) } open() { this._adapter.togglePanel(!0), this._adapter.registerClickOutSide() } close() { this._adapter.togglePanel(!1), this.resetInnerSelectedStates(), this._adapter.unregisterClickOutSide() } focus(e) { if (this._isRangeType()) { const t = e ?? "rangeStart"; this._adapter.setRangeInputFocus(t) } else this._adapter.setInputFocus() } blur() { this._isRangeType() ? this._adapter.setRangeInputBlur() : this._adapter.setInputBlur() } resetInnerSelectedStates() { setTimeout(() => { const { value: e, cachedSelectedValue: t } = this._adapter.getStates(); ke(e, t) || this.resetCachedSelectedValue(e) }, 0), this.resetFocus(), this.clearInputValue() } resetFocus(e) { this._adapter.setRangeInputFocus(!1), this._adapter.notifyBlur(e) } isCachedSelectedValueValid(e) { const t = e || this._adapter.getState("cachedSelectedValue"), { type: n } = this._adapter.getProps(); let i = !0; switch (!0) { case n === "dateRange": case n === "dateTimeRange": this._isRangeValueComplete(t) || (i = !1); break; default: const s = t == null ? void 0 : t.filter(a => a); Array.isArray(s) && s.length || (i = !1); break }return i } clearInputValue() { this._adapter.updateInputValue(null), this._adapter.updateInsetInputValue(null) } handleInputChange(e, t) { const n = this._isMultiple() ? this.parseMultipleInput(e) : this.parseInput(e), { value: i } = this.getStates(); if (this._updateCachedSelectedValueFromInput(e), n && n.length || e === "") { if (H(t, Hs.CLEARBTN_CLICKED_EVENT_FLAG) && this._isControlledComponent("value")) { this._notifyChange(n); return } this._updateValueAndInput(n, e === "", e); const s = this._getChangedDates(n); this._someDateDisabled(s, n) || ke(n, i) || this._notifyChange(n) } else this._adapter.updateInputValue(e) } handleInsetInputChange(e) { const { insetInputStr: t, format: n, insetInputValue: i } = e, s = this._isMultiple(), a = s ? this.parseMultipleInput(t, n) : this.parseInput(t, n), { value: o } = this.getStates(); if (this._updateCachedSelectedValueFromInput(t), a && a.length) { const l = this._getChangedDates(a); if (!this._someDateDisabled(l, a)) { ke(a, o) || (!this._isControlledComponent() && !this._adapter.needConfirm() && this._adapter.updateValue(a), this._notifyChange(a)); const u = s ? this.formatMultipleDates(a) : this.formatDates(a); this._adapter.updateInputValue(u) } } this._adapter.updateInsetInputValue(i) } _updateCachedSelectedValueFromInput(e) { const t = this.getLooseDateFromInput(e), n = this._getChangedDates(t); this._someDateDisabled(n, t) || this.resetCachedSelectedValue(t) } handleInputBlur() { } handleRangeEndTabPress(e) { this._adapter.setRangeInputFocus(!1) } handleInputFocus(e, t) { const n = this._adapter.getState("rangeInputFocus"); t && this._adapter.setRangeInputFocus(t), (!t || !["rangeStart", "rangeEnd"].includes(n)) && this._adapter.notifyFocus(e, t) } handleSetRangeFocus(e) { this._adapter.setRangeInputFocus(e) } handleInputClear(e) { this._adapter.notifyClear(e) } handleRangeInputClear(e) { const t = []; this._isControlledComponent("value") || (this._updateValueAndInput(t, !0, ""), this._adapter.updateInsetInputValue(null), this.resetCachedSelectedValue(t)), this._notifyChange(t), this._adapter.setRangeInputFocus(!1), this._adapter.notifyClear(e) } handleRangeInputBlur(e, t) { } handleInputComplete() { let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "", t = e ? this._isMultiple() ? this.parseMultipleInput(e, ",", !0) : this.parseInput(e) : []; if (t = t && t.length ? t : this.getState("value"), !t || !t.length) { const s = new Date; this._isRangeType() ? t = [s, s] : t = [s] } this._updateValueAndInput(t); const { value: n } = this.getStates(), i = this._getChangedDates(t); !this._someDateDisabled(i, t) && !ke(t, n) && this._notifyChange(t) } parseInput() { let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "", t = arguments.length > 1 ? arguments[1] : void 0, n = []; const { dateFnsLocale: i, rangeSeparator: s } = this.getProps(); if (e && e.length) { const a = this.getProp("type"), o = t || this.getProp("format") || Ps(a); let l, u; const d = new Date; switch (a) { case "date": case "dateTime": case "month": l = e ? sn(e, o, d, i) : "", u = l && Kr(l) && this.localeFormat(l, o), l && u === e && (n = [l]); break; case "dateRange": case "dateTimeRange": case "monthRange": const h = s, g = e.split(h); l = g && g.reduce((m, b) => { const y = b && sn(b, o, d, i); return y && m.push(y), m }, []), u = l && l.map(m => m && Kr(m) && this.localeFormat(m, o)).join(h), l && u === e && (l.sort((m, b) => m.getTime() - b.getTime()), n = l); break } } return n } getLooseDateFromInput(e) { return this._isMultiple() ? this.parseMultipleInputLoose(e) : this.parseInputLoose(e) } parseInputLoose() { let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "", t = []; const { dateFnsLocale: n, rangeSeparator: i, type: s, format: a } = this.getProps(); if (e && e.length) { const o = a || Ps(s); let l, u; const d = new Date; switch (s) { case "date": case "dateTime": case "month": const h = sn(e, o, d, n); Yr(h) ? (u = this.localeFormat(h, o), u === e && (l = h)) : l = null, t = [l]; break; case "dateRange": case "dateTimeRange": const g = i, m = e.split(g); l = m && m.reduce((b, y) => { let w = null; const x = sn(y, o, d, n); return Yr(x) && (u = this.localeFormat(x, o), u === y && (w = x)), b.push(w), b }, []), Array.isArray(l) && l.every(b => Kr(b)) && l.sort((b, y) => b.getTime() - y.getTime()), t = l; break } } return t } parseMultipleInputLoose() { let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "", t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : ne.DEFAULT_SEPARATOR_MULTIPLE, n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1; const i = this.getProp("max"), s = e.split(t), a = []; for (const o of s) { let l = o && this.parseInputLoose(o); if (l = Array.isArray(l) ? l : l && [l], l && l.length) n ? !a.filter(u => !!l.find(d => fx(u, d))) && a.push(...l) : a.push(...l); else return []; if (i && i > 0 && a.length > i) return [] } return a } parseMultipleInput() { let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "", t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : ne.DEFAULT_SEPARATOR_MULTIPLE, n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1; const i = this.getProp("max"), s = e.split(t), a = []; for (const o of s) { let l = o && this.parseInput(o); if (l = Array.isArray(l) ? l : l && [l], l && l.length) n ? !a.filter(u => !!l.find(d => fx(u, d))) && a.push(...l) : a.push(...l); else return []; if (i && i > 0 && a.length > i) return [] } return a } formatDates() { let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [], t = arguments.length > 1 ? arguments[1] : void 0, n = ""; const i = this.getProp("rangeSeparator"); if (Array.isArray(e) && e.length) { const s = this.getProp("type"), a = t || this.getProp("format") || Ps(s); switch (s) { case "date": case "dateTime": case "month": n = this.localeFormat(e[0], a); break; case "dateRange": case "dateTimeRange": case "monthRange": const o = !ze(e[0]), l = !ze(e[1]); o && l ? n = `${this.localeFormat(e[0], a)}${i}${this.localeFormat(e[1], a)}` : o ? n = `${this.localeFormat(e[0], a)}${i}` : l && (n = `${i}${this.localeFormat(e[1], a)}`); break } } return n } formatMultipleDates() { let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [], t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : ne.DEFAULT_SEPARATOR_MULTIPLE, n = arguments.length > 2 ? arguments[2] : void 0; const i = []; if (Array.isArray(e) && e.length) switch (this.getProp("type")) { case "date": case "dateTime": case "month": e.forEach(a => i.push(this.formatDates([a], n))); break; case "dateRange": case "dateTimeRange": case "monthRange": for (let a = 0; a < e.length; a += 2)i.push(this.formatDates(e.slice(a, a + 2), n)); break }return i.join(t) } _updateValueAndInput(e, t, n) { let i; if (t || e) { Array.isArray(e) ? i = e : i = e ? [e] : []; const s = this._getChangedDates(i); !this._isControlledComponent() && !this._someDateDisabled(s, i) && !this._adapter.needConfirm() && this._adapter.updateValue(i) } this._adapter.updateInputValue(n) } handleSelectedChange(e, t) { const { type: n, format: i, rangeSeparator: s, insetInput: a } = this._adapter.getProps(), { value: o } = this.getStates(), l = this._isControlledComponent(), u = an(t) ? t.fromPreset : t, d = H(t, "closePanel", !0), h = H(t, "needCheckFocusRecord", !0), g = Array.isArray(e) ? [...e] : e ? [e] : [], m = this._getChangedDates(g); let b, y; if (!this._someDateDisabled(m, g)) { if (this.resetCachedSelectedValue(g), b = this._isMultiple() ? this.formatMultipleDates(g) : this.formatDates(g), a) { const S = Ru({ format: i, type: n }), C = this._isMultiple() ? this.formatMultipleDates(g, void 0, S) : this.formatDates(g, S); y = Tg({ inputValue: C, type: n, rangeSeparator: s }) } if (this._isRangeType() && !this._isRangeValueComplete(g)) { this._adapter.updateInputValue(b), this._adapter.updateInsetInputValue(y); return } else (!l || u) && (this._updateValueAndInput(g, !0, b), this._adapter.updateInsetInputValue(y)); ke(e, o) || this._notifyChange(e) } const w = !h || h && this._adapter.couldPanelClosed(); (n === "date" && !this._isMultiple() && d || n === "dateRange" && this._isRangeValueComplete(g) && d && w) && this.closePanel() } handleYMSelectedChange() { let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}; const { currentMonth: t, currentYear: n } = e, { type: i } = this.getProps(); if (i === "month") { const s = new Date(n.left, t.left - 1); this.handleSelectedChange([s]) } else { const s = new Date(n.left, t.left - 1), a = new Date(n.right, t.right - 1); this.handleSelectedChange([s, a]) } } handleConfirm() { const { cachedSelectedValue: e, value: t } = this._adapter.getStates(), n = this._isRangeValueComplete(e), i = n ? e : t; if (this._adapter.needConfirm() && !this._isControlledComponent() && this._adapter.updateValue(i), this.closePanel(), n) { const { notifyValue: s, notifyDate: a } = this.disposeCallbackArgs(e); this._adapter.notifyConfirm(a, s) } } handleCancel() { this.closePanel(); const e = this.getState("value"), { notifyValue: t, notifyDate: n } = this.disposeCallbackArgs(e); this._adapter.notifyCancel(n, t) } handlePresetClick(e, t) { const { type: n, timeZone: i } = this.getProps(), s = this.getState("prevTimezone"), a = typeof e.start == "function" ? e.start() : e.start, o = typeof e.end == "function" ? e.end() : e.end; let l; switch (n) { case "month": case "dateTime": case "date": l = this.parseWithTimezone([a], i, s), this.handleSelectedChange(l); break; case "dateTimeRange": case "dateRange": l = this.parseWithTimezone([a, o], i, s), this.handleSelectedChange(l, { needCheckFocusRecord: !1 }); break }this._adapter.notifyPresetsClick(e, t) } disposeCallbackArgs(e) { let t = Array.isArray(e) ? e : e && [e] || []; const n = this.getProp("timeZone"); Du(n) && (t = t.map(l => fo(l, n))); const i = this.getProp("type"), s = this.getProp("format") || Ps(i); let a, o; switch (i) { case "date": case "dateTime": case "month": this._isMultiple() ? (a = t.map(l => l && this.localeFormat(l, s)), o = [...t]) : (a = t[0] && this.localeFormat(t[0], s), [o] = t); break; case "dateRange": case "dateTimeRange": case "monthRange": a = t.map(l => l && this.localeFormat(l, s)), o = [...t]; break }return { notifyValue: a, notifyDate: o } } _notifyChange(e) { if (this._isRangeType() && !this._isRangeValueComplete(e)) return; const { onChangeWithDateFirst: t } = this.getProps(), { notifyValue: n, notifyDate: i } = this.disposeCallbackArgs(e); t ? this._adapter.notifyChange(i, n) : this._adapter.notifyChange(n, i) } _getChangedDates(e) { const t = this._adapter.getProp("type"), { cachedSelectedValue: n } = this._adapter.getStates(), i = []; switch (t) { case "dateRange": case "dateTimeRange": const [s, a] = n, [o, l] = e; Qu(o, s) || i.push(o), Qu(l, a) || i.push(l); break; default: const u = new Set; n.forEach(d => u.add(xf(d) && d.valueOf())); for (const d of e) u.has(xf(d) && d.valueOf()) || i.push(d) }return i } _someDateDisabled(e, t) { const { rangeInputFocus: n } = this.getStates(), i = { rangeStart: "", rangeEnd: "", rangeInputFocus: n }; if (this._isRangeType() && Array.isArray(t)) { if (Kr(t[0])) { const a = mt(t[0], "yyyy-MM-dd"); i.rangeStart = a } if (Kr(t[1])) { const a = mt(t[1], "yyyy-MM-dd"); i.rangeEnd = a } } let s = !1; for (const a of e) if (!ze(a) && this.disabledDisposeDate(a, i)) { s = !0; break } return s } localeFormat(e, t) { const n = this._adapter.getProp("dateFnsLocale"); return mt(e, t, { locale: n }) } disposeDateFn(e, t) { const { notifyDate: n } = this.disposeCallbackArgs(t), i = Array.isArray(t), s = Array.isArray(n); let a; i === s ? a = n : a = i ? [n] : n[0]; for (var o = arguments.length, l = new Array(o > 2 ? o - 2 : 0), u = 2; u < o; u++)l[u - 2] = arguments[u]; return e(a, ...l) } disabledDisposeDate(e) { const { disabledDate: t } = this.getProps(); for (var n = arguments.length, i = new Array(n > 1 ? n - 1 : 0), s = 1; s < n; s++)i[s - 1] = arguments[s]; return this.disposeDateFn(t, e, ...i) } disabledDisposeTime(e) { const { disabledTime: t } = this.getProps(); for (var n = arguments.length, i = new Array(n > 1 ? n - 1 : 0), s = 1; s < n; s++)i[s - 1] = arguments[s]; return this.disposeDateFn(t, e, ...i) } handleTriggerWrapperClick(e) { const { disabled: t, triggerRender: n } = this._adapter.getProps(), { rangeInputFocus: i } = this._adapter.getStates(); t || (this._isRangeType() && !i ? (this._adapter.isEventTarget(e) ? setTimeout(() => { this.handleInputFocus(e, "rangeStart") }, 0) : we(n) && this._adapter.setRangeInputFocus("rangeStart"), this.openPanel()) : this.openPanel()) } handlePanelVisibleChange(e) { e ? (this._adapter.setInsetInputFocus(), setTimeout(() => { this._adapter.setTriggerDisabled(!0) }, 0)) : this._adapter.setTriggerDisabled(!1) } } function Wa(r, e) { let { groupInnerSeparator: t = ne.DEFAULT_SEPARATOR_RANGE, groupSize: n = 1, groupSeparator: i = ne.DEFAULT_SEPARATOR_MULTIPLE } = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, s = arguments.length > 3 ? arguments[3] : void 0, a = ""; if ((n <= 0 || typeof n != "number") && (n = 1), Array.isArray(r) && r.length) { const o = [], { length: l } = r; for (let u = 0; u < l; u++) { u % n === 0 && o.push([]); const d = Math.floor(u / n); o[d].push(r[u]) } a = o.map(u => u.map(d => d ? mt(d, e, { locale: s }) : "").join(t)).join(i) } return a } function O_(r) { const { defaultPickerValue: e, format: t, dateFnsLocale: n } = r; let i = Array.isArray(e) ? e[0] : e, s = Array.isArray(e) ? e[1] : void 0; switch (!0) { case Yr(i): break; case Df(i): i = new Date(i); break; case typeof i == "string": i = sn(i, t, void 0, n); break; default: i = new Date; break }switch (!0) { case Yr(s): break; case Df(s): s = new Date(s); break; case typeof s == "string": s = sn(s, t, void 0, n); break; default: s = Is(i, 1); break }return { nowDate: i, nextDate: s } } var GG = Function.prototype.toString, fp = Object.create, YG = Object.prototype.toString, XG = function () { function r() { this._keys = [], this._values = [] } return r.prototype.has = function (e) { return !!~this._keys.indexOf(e) }, r.prototype.get = function (e) { return this._values[this._keys.indexOf(e)] }, r.prototype.set = function (e, t) { this._keys.push(e), this._values.push(t) }, r }(); function qG() { return new XG } function ZG() { return new WeakMap } var JG = typeof WeakMap < "u" ? ZG : qG; function xy(r) { if (!r) return fp(null); var e = r.constructor; if (e === Object) return r === Object.prototype ? {} : fp(r); if (e && ~GG.call(e).indexOf("[native code]")) try { return new e } catch { } return fp(r) } function QG(r) { var e = ""; return r.global && (e += "g"), r.ignoreCase && (e += "i"), r.multiline && (e += "m"), r.unicode && (e += "u"), r.sticky && (e += "y"), e } function eY(r) { return r.flags } var tY = /test/g.flags === "g" ? eY : QG; function T_(r) { var e = YG.call(r); return e.substring(8, e.length - 1) } function nY(r) { return r[Symbol.toStringTag] || T_(r) } var rY = typeof Symbol < "u" ? nY : T_, iY = Object.defineProperty, sY = Object.getOwnPropertyDescriptor, I_ = Object.getOwnPropertyNames, wy = Object.getOwnPropertySymbols, P_ = Object.prototype, k_ = P_.hasOwnProperty, aY = P_.propertyIsEnumerable, R_ = typeof wy == "function"; function oY(r) { return I_(r).concat(wy(r)) } var lY = R_ ? oY : I_; function ch(r, e, t) { for (var n = lY(r), i = 0, s = n.length, a = void 0, o = void 0; i < s; ++i)if (a = n[i], !(a === "callee" || a === "caller")) { if (o = sY(r, a), !o) { e[a] = t.copier(r[a], t); continue } !o.get && !o.set && (o.value = t.copier(o.value, t)); try { iY(e, a, o) } catch { e[a] = o.value } } return e } function cY(r, e) { var t = new e.Constructor; e.cache.set(r, t); for (var n = 0, i = r.length; n < i; ++n)t[n] = e.copier(r[n], e); return t } function uY(r, e) { var t = new e.Constructor; return e.cache.set(r, t), ch(r, t, e) } function D_(r, e) { return r.slice(0) } function dY(r, e) { return r.slice(0, r.size, r.type) } function hY(r, e) { return new e.Constructor(D_(r.buffer)) } function pY(r, e) { return new e.Constructor(r.getTime()) } function A_(r, e) { var t = new e.Constructor; return e.cache.set(r, t), r.forEach(function (n, i) { t.set(i, e.copier(n, e)) }), t } function fY(r, e) { return ch(r, A_(r, e), e) } function gY(r, e) { var t = xy(e.prototype); e.cache.set(r, t); for (var n in r) k_.call(r, n) && (t[n] = e.copier(r[n], e)); return t } function mY(r, e) { var t = xy(e.prototype); e.cache.set(r, t); for (var n in r) k_.call(r, n) && (t[n] = e.copier(r[n], e)); for (var i = wy(r), s = 0, a = i.length, o = void 0; s < a; ++s)o = i[s], aY.call(r, o) && (t[o] = e.copier(r[o], e)); return t } var yY = R_ ? mY : gY; function bY(r, e) { var t = xy(e.prototype); return e.cache.set(r, t), ch(r, t, e) } function gp(r, e) { return new e.Constructor(r.valueOf()) } function vY(r, e) { var t = new e.Constructor(r.source, tY(r)); return t.lastIndex = r.lastIndex, t } function Au(r, e) { return r } function N_(r, e) { var t = new e.Constructor; return e.cache.set(r, t), r.forEach(function (n) { t.add(e.copier(n, e)) }), t } function xY(r, e) { return ch(r, N_(r, e), e) } var wY = Array.isArray, Cy = Object.assign, CY = Object.getPrototypeOf || function (r) { return r.__proto__ }, F_ = { array: cY, arrayBuffer: D_, blob: dY, dataView: hY, date: pY, error: Au, map: A_, object: yY, regExp: vY, set: N_ }, SY = Cy({}, F_, { array: uY, map: fY, object: bY, set: xY }); function EY(r) { return { Arguments: r.object, Array: r.array, ArrayBuffer: r.arrayBuffer, Blob: r.blob, Boolean: gp, DataView: r.dataView, Date: r.date, Error: r.error, Float32Array: r.arrayBuffer, Float64Array: r.arrayBuffer, Int8Array: r.arrayBuffer, Int16Array: r.arrayBuffer, Int32Array: r.arrayBuffer, Map: r.map, Number: gp, Object: r.object, Promise: Au, RegExp: r.regExp, Set: r.set, String: gp, WeakMap: Au, WeakSet: Au, Uint8Array: r.arrayBuffer, Uint8ClampedArray: r.arrayBuffer, Uint16Array: r.arrayBuffer, Uint32Array: r.arrayBuffer, Uint64Array: r.arrayBuffer } } function $_(r) { var e = Cy({}, F_, r), t = EY(e), n = t.Array, i = t.Object; function s(a, o) { if (o.prototype = o.Constructor = void 0, !a || typeof a != "object") return a; if (o.cache.has(a)) return o.cache.get(a); if (o.prototype = CY(a), o.Constructor = o.prototype && o.prototype.constructor, !o.Constructor || o.Constructor === Object) return i(a, o); if (wY(a)) return n(a, o); var l = t[rY(a)]; return l ? l(a, o) : typeof a.then == "function" ? a : i(a, o) } return function (o) { return s(o, { Constructor: void 0, cache: JG(), copier: s, prototype: void 0 }) } } function _Y(r) { return $_(Cy({}, SY, r)) } _Y({}); var cs = $_({}); const a0 = "Enter", OY = "Tab"; class TY extends ve { constructor(e) { super(Object.assign({}, e)) } init() { } destroy() { } handleClick(e) { this._adapter.notifyClick(e) } handleChange(e, t) { this._adapter.notifyChange(e, t) } handleInputComplete(e) { e.key === a0 && this._adapter.notifyEnter(e.target.value) } handleInputClear(e) { this._adapter.notifyClear(e) } handleRangeInputClear(e) { this.stopPropagation(e), this._adapter.notifyRangeInputClear(e) } handleRangeInputEnterPress(e, t) { e.key === a0 && this._adapter.notifyEnter(t) } handleRangeInputEndKeyPress(e) { e.key === OY && this._adapter.notifyTabPress(e) } handleRangeInputFocus(e, t) { this._adapter.notifyRangeInputFocus(e, t) } formatShowText(e, t) { const { type: n, dateFnsLocale: i, format: s, rangeSeparator: a } = this._adapter.getProps(), o = t || s || Ps(n); let l = ""; switch (n) { case "date": l = Wa(e, o, void 0, i); break; case "dateRange": l = Wa(e, o, { groupSize: 2, groupInnerSeparator: a }, i); break; case "dateTime": l = Wa(e, o, void 0, i); break; case "dateTimeRange": l = Wa(e, o, { groupSize: 2, groupInnerSeparator: a }, i); break; case "month": l = Wa(e, o, void 0, i); break; case "monthRange": l = Wa(e, o, { groupSize: 2, groupInnerSeparator: a }, i); break }return l } handleInsetInputChange(e) { const { value: t, valuePath: n, insetInputValue: i } = e, { format: s, type: a, rangeSeparator: o } = this._adapter.getProps(), l = Ru({ type: a, format: s }), u = yr(cs(i), n, t), d = this.concatInsetInputValue({ insetInputValue: u }), h = Tg({ inputValue: d, type: a, rangeSeparator: o }), g = this._autoFillTimeToInsetInputValue({ insetInputValue: h, valuePath: n, format: l }), m = this.concatInsetInputValue({ insetInputValue: g }); this._adapter.notifyInsetInputChange({ insetInputValue: g, format: l, insetInputStr: m }) } _autoFillTimeToInsetInputValue(e) { const { valuePath: t, insetInputValue: n, format: i } = e, { type: s, defaultPickerValue: a, dateFnsLocale: o } = this._adapter.getProps(), l = cs(n), { nowDate: u, nextDate: d } = O_({ defaultPickerValue: a, format: i, dateFnsLocale: o }); if (s.includes("Time")) { let h = ""; const g = H(i.split(" "), "0", ne.FORMAT_FULL_DATE), m = H(i.split(" "), "1", ne.FORMAT_TIME_PICKER); switch (t) { case "monthLeft.dateInput": const b = l.monthLeft.dateInput; if (!l.monthLeft.timeInput && b.length === g.length) { const w = sn(l.monthLeft.dateInput, g); Yr(w) && (h = mt(u, m), l.monthLeft.timeInput = h) } break; case "monthRight.dateInput": const y = l.monthRight.dateInput; if (!l.monthRight.timeInput && y.length === g.length) { const w = sn(y, g); Yr(w) && (h = mt(d, m), l.monthRight.timeInput = h) } break } } return l } getInsetInputPlaceholder() { const { type: e, format: t, rangeSeparator: n } = this._adapter.getProps(), i = Ru({ type: e, format: t }); let s, a; switch (e) { case "date": case "month": case "dateRange": s = i; break; case "dateTime": case "dateTimeRange": [s, a] = i.split(" "); break; case "monthRange": s = i + n + i; break }return { datePlaceholder: s, timePlaceholder: a } } getInsetInputValue(e) { let { value: t, insetInputValue: n } = e; const { type: i, rangeSeparator: s, format: a } = this._adapter.getProps(); let o = ""; if (an(n)) o = this.concatInsetInputValue({ insetInputValue: n }); else { const u = Ru({ format: a, type: i }); o = this.formatShowText(t, u) } return Tg({ inputValue: o, type: i, rangeSeparator: s }) } concatInsetDateAndTime(e) { let { date: t, time: n } = e; return `${t} ${n}` } concatInsetDateRange(e) { let { rangeStart: t, rangeEnd: n } = e; const { rangeSeparator: i } = this._adapter.getProps(); return `${t}${i}${n}` } concatInsetInputValue(e) { let { insetInputValue: t } = e; const { type: n } = this._adapter.getProps(); let i = ""; switch (n) { case "date": case "month": case "monthRange": i = t.monthLeft.dateInput; break; case "dateRange": i = this.concatInsetDateRange({ rangeStart: t.monthLeft.dateInput, rangeEnd: t.monthRight.dateInput }); break; case "dateTime": i = this.concatInsetDateAndTime({ date: t.monthLeft.dateInput, time: t.monthLeft.timeInput }); break; case "dateTimeRange": const s = this.concatInsetDateAndTime({ date: t.monthLeft.dateInput, time: t.monthLeft.timeInput }), a = this.concatInsetDateAndTime({ date: t.monthRight.dateInput, time: t.monthRight.timeInput }); i = this.concatInsetDateRange({ rangeStart: s, rangeEnd: a }); break }return i } } function o0(r) { const { insetInputValue: e, valuePath: t, onFocus: n, onChange: i, placeholder: s, forwardRef: a } = r, o = H(e, t); return f.createElement(xr, { value: o, onChange: (l, u) => { i({ value: l, event: u, insetInputValue: e, valuePath: t }) }, onFocus: n, placeholder: s, ref: a }) } function l0(r) { const { insetInputValue: e, valuePath: t, type: n, onFocus: i, onChange: s, placeholder: a, disabled: o } = r; if (!n.includes("Time")) return null; const u = H(e, t); return f.createElement(xr, { value: u, onChange: (d, h) => { s({ value: d, event: h, insetInputValue: e, valuePath: t }) }, onFocus: i, placeholder: a, disabled: o }) } var IY = function (r, e) { var t = {}; for (var n in r) Object.prototype.hasOwnProperty.call(r, n) && e.indexOf(n) < 0 && (t[n] = r[n]); if (r != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, n = Object.getOwnPropertySymbols(r); i < n.length; i++)e.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(r, n[i]) && (t[n[i]] = r[n[i]]); return t }; class hd extends de { constructor(e) { super(e), this.handleChange = (t, n) => this.foundation.handleChange(t, n), this.handleEnterPress = t => this.foundation.handleInputComplete(t), this.handleInputClear = t => this.foundation.handleInputClear(t), this.handleRangeInputChange = (t, n, i) => { const s = this.getRangeInputValue(t, n); this.foundation.handleChange(s, i) }, this.handleRangeInputClear = t => { this.foundation.handleRangeInputClear(t) }, this.handleRangeInputEnterPress = (t, n, i) => { const s = this.getRangeInputValue(n, i); this.foundation.handleRangeInputEnterPress(t, s) }, this.handleRangeInputEndKeyPress = t => { this.foundation.handleRangeInputEndKeyPress(t) }, this.handleRangeInputFocus = (t, n) => { this.foundation.handleRangeInputFocus(t, n) }, this.handleRangeStartFocus = t => { this.handleRangeInputFocus(t, "rangeStart") }, this.handleInsetInputChange = t => { this.foundation.handleInsetInputChange(t) }, this.getRangeInputValue = (t, n) => { const { rangeSeparator: i } = this.props; return `${t}${i}${n}` }, this.foundation = new TY(this.adapter) } get adapter() { var e = this; return Object.assign(Object.assign({}, super.adapter), { updateIsFocusing: t => this.setState({ isFocusing: t }), notifyClick: function () { return e.props.onClick(...arguments) }, notifyChange: function () { return e.props.onChange(...arguments) }, notifyEnter: function () { return e.props.onEnterPress(...arguments) }, notifyBlur: function () { return e.props.onBlur(...arguments) }, notifyClear: function () { return e.props.onClear(...arguments) }, notifyFocus: function () { return e.props.onFocus(...arguments) }, notifyRangeInputClear: function () { return e.props.onRangeClear(...arguments) }, notifyRangeInputFocus: function () { return e.props.onFocus(...arguments) }, notifyTabPress: function () { return e.props.onRangeEndTabPress(...arguments) }, notifyInsetInputChange: t => this.props.onInsetInputChange(t) }) } componentDidMount() { this.foundation.init() } componentWillUnmount() { this.foundation.destroy() } formatText(e) { return e && e.length ? this.foundation.formatShowText(e) : "" } renderRangePrefix() { const { prefix: e, insetLabel: t, prefixCls: n, disabled: i, rangeInputFocus: s } = this.props, a = e || t; return a ? f.createElement("div", { className: `${n}-range-input-prefix`, onClick: o => !i && !s && this.handleRangeStartFocus(o), "x-semi-prop": "prefix,insetLabel" }, a) : null } renderRangeSeparator(e, t) { const { disabled: n, rangeSeparator: i } = this.props, s = F({ [`${Ae.PREFIX}-range-input-separator`]: !0, [`${Ae.PREFIX}-range-input-separator-active`]: (e || t) && !n }); return f.createElement("span", { onClick: a => !n && this.handleRangeStartFocus(a), className: s }, i) } renderRangeClearBtn(e, t) { const { showClear: n, prefixCls: i, disabled: s, clearIcon: a, showClearIgnoreDisabled: o } = this.props; return (e || t) && n && !(s && !o) ? f.createElement("div", { role: "button", tabIndex: 0, "aria-label": "Clear range input value", className: `${i}-range-input-clearbtn`, onMouseDown: d => this.handleRangeInputClear(d) }, a || f.createElement(us, { "aria-hidden": !0 })) : null } renderRangeSuffix(e) { const { prefixCls: t, disabled: n, rangeInputFocus: i } = this.props; return e ? f.createElement("div", { className: `${t}-range-input-suffix`, onClick: a => !n && !i && this.handleRangeStartFocus(a) }, e) : null } renderRangeInput(e) { const { placeholder: t, inputStyle: n, disabled: i, inputReadOnly: s, autofocus: a, size: o, text: l, suffix: u, inputCls: d, rangeInputStartRef: h, rangeInputEndRef: g, rangeInputFocus: m, prefixCls: b, rangeSeparator: y, borderless: w } = e, [x, S = ""] = l.split(y) || [], C = o === "large" ? "default" : "small", O = Array.isArray(t) ? t : [t, t], [E, v] = O, T = F(`${b}-range-input-wrapper-start`, `${b}-range-input-wrapper`, { [`${b}-range-input-wrapper-active`]: m === "rangeStart" && !i, [`${b}-range-input-wrapper-start-with-prefix`]: this.props.prefix || this.props.insetLabel, [`${b}-borderless`]: w }), I = F(`${b}-range-input-wrapper-end`, `${b}-range-input-wrapper`, { [`${b}-range-input-wrapper-active`]: m === "rangeEnd" && !i, [`${b}-borderless`]: w }); return f.createElement(f.Fragment, null, this.renderRangePrefix(), f.createElement("div", { onClick: k => !i && this.handleRangeInputFocus(k, "rangeStart"), className: `${d} ${T}` }, f.createElement(xr, { borderless: w, size: C, style: n, disabled: i, readonly: s, placeholder: E, value: x, onChange: (k, P) => this.handleRangeInputChange(k, S, P), onEnterPress: k => this.handleRangeInputEnterPress(k, x, S), onFocus: k => this.handleRangeInputFocus(k, "rangeStart"), autoFocus: a, ref: h })), this.renderRangeSeparator(x, S), f.createElement("div", { className: `${d} ${I}`, onClick: k => !i && this.handleRangeInputFocus(k, "rangeEnd") }, f.createElement(xr, { borderless: w, size: C, style: n, disabled: i, readonly: s, placeholder: v, value: S, onChange: (k, P) => this.handleRangeInputChange(x, k, P), onEnterPress: k => this.handleRangeInputEnterPress(k, x, S), onFocus: k => this.handleRangeInputFocus(k, "rangeEnd"), onKeyDown: this.handleRangeInputEndKeyPress, ref: g })), this.renderRangeClearBtn(x, S), this.renderRangeSuffix(u)) } isRenderMultipleInputs() { const { type: e } = this.props; return e.includes("Range") && e !== "monthRange" } renderInputInset() { const { type: e, handleInsetDateFocus: t, handleInsetTimeFocus: n, value: i, insetInputValue: s, prefixCls: a, rangeInputStartRef: o, rangeInputEndRef: l, density: u, insetInput: d } = this.props, h = this.foundation.getInsetInputValue({ value: i, insetInputValue: s }), { dateStart: g, dateEnd: m, timeStart: b, timeEnd: y } = H(d, "placeholder", {}), { datePlaceholder: w, timePlaceholder: x } = this.foundation.getInsetInputPlaceholder(), S = `${a}-inset-input-wrapper`, C = `${a}-inset-input-separator`; return f.createElement("div", { className: S, "x-type": e }, f.createElement(o0, { forwardRef: o, insetInputValue: h, placeholder: g ?? w, valuePath: "monthLeft.dateInput", onChange: this.handleInsetInputChange, onFocus: O => t(O, "rangeStart") }), f.createElement(l0, { disabled: !h.monthLeft.dateInput, insetInputValue: h, placeholder: b ?? x, type: e, valuePath: "monthLeft.timeInput", onChange: this.handleInsetInputChange, onFocus: n }), this.isRenderMultipleInputs() && f.createElement(f.Fragment, null, f.createElement("div", { className: C }, u === "compact" ? null : "-"), f.createElement(o0, { forwardRef: l, insetInputValue: h, placeholder: m ?? w, valuePath: "monthRight.dateInput", onChange: this.handleInsetInputChange, onFocus: O => t(O, "rangeEnd") }), f.createElement(l0, { disabled: !h.monthRight.dateInput, insetInputValue: h, placeholder: y ?? x, type: e, valuePath: "monthRight.timeInput", onChange: this.handleInsetInputChange, onFocus: n }))) } renderTriggerInput() { const e = this.props, { placeholder: t, type: n, value: i, inputValue: s, inputStyle: a, disabled: o, showClear: l, inputReadOnly: u, insetLabel: d, validateStatus: h, block: g, prefixCls: m, multiple: b, dateFnsLocale: y, onBlur: w, onClear: x, onFocus: S, prefix: C, autofocus: O, size: E, inputRef: v, rangeInputStartRef: T, rangeInputEndRef: I, onRangeClear: k, onRangeBlur: P, onRangeEndTabPress: N, rangeInputFocus: M, rangeSeparator: B, insetInput: K, insetInputValue: U, defaultPickerValue: W, showClearIgnoreDisabled: Z } = e, J = IY(e, ["placeholder", "type", "value", "inputValue", "inputStyle", "disabled", "showClear", "inputReadOnly", "insetLabel", "validateStatus", "block", "prefixCls", "multiple", "dateFnsLocale", "onBlur", "onClear", "onFocus", "prefix", "autofocus", "size", "inputRef", "rangeInputStartRef", "rangeInputEndRef", "onRangeClear", "onRangeBlur", "onRangeEndTabPress", "rangeInputFocus", "rangeSeparator", "insetInput", "insetInputValue", "defaultPickerValue", "showClearIgnoreDisabled"]), ee = f.createElement(zS, { "aria-hidden": !0 }), $ = f.createElement(Tz, { "aria-hidden": !0 }), pe = n.includes("Time") ? $ : ee; let re = ""; ze(s) ? i && (re = this.formatText(i)) : re = s; const j = F({ [`${m}-input-readonly`]: u, [`${m}-monthRange-input`]: n === "monthRange" }), ae = Object.assign(Object.assign({}, this.props), { text: re, suffix: pe, inputCls: j }); return this.isRenderMultipleInputs() ? this.renderRangeInput(ae) : f.createElement(xr, Object.assign({}, J, { ref: v, insetLabel: d, disabled: o, showClearIgnoreDisabled: Z, readonly: u, className: j, style: a, hideSuffix: l, placeholder: n === "monthRange" && Array.isArray(t) ? t[0] + B + t[1] : t, onEnterPress: this.handleEnterPress, onChange: this.handleChange, onClear: this.handleInputClear, suffix: pe, showClear: l, value: re, validateStatus: h, prefix: C, autoFocus: O, size: E, onBlur: w, onFocus: S })) } render() { const { insetInput: e } = this.props; return e ? this.renderInputInset() : this.renderTriggerInput() } } hd.propTypes = { borderless: c.bool, onClick: c.func, onChange: c.func, onEnterPress: c.func, onBlur: c.func, onClear: c.func, onFocus: c.func, value: c.array, disabled: c.bool, type: c.oneOf(ne.TYPE_SET), showClear: c.bool, format: c.string, inputStyle: c.object, inputReadOnly: c.bool, insetLabel: c.node, validateStatus: c.string, prefix: c.node, prefixCls: c.string, dateFnsLocale: c.object.isRequired, placeholder: c.oneOfType([c.string, c.array]), rangeInputFocus: c.oneOfType([c.string, c.bool]), rangeInputStartRef: c.object, rangeInputEndRef: c.object, rangeSeparator: c.string, insetInput: c.oneOfType([c.bool, c.object]), insetInputValue: c.object, defaultPickerValue: c.oneOfType([c.string, c.number, c.object, c.array]) }; hd.defaultProps = { borderless: !1, showClear: !0, onClick: Ct, onChange: Ct, onEnterPress: Ct, onBlur: Ct, onClear: Ct, onFocus: Ct, type: "date", inputStyle: {}, inputReadOnly: !1, prefixCls: Ae.PREFIX, rangeSeparator: ne.DEFAULT_SEPARATOR_RANGE }; function L_() { let r = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "", e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "", t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "", n = ""; const i = typeof e == "number" && e < 10 ? `0${e}` : e.toString(), s = typeof t == "number" && t < 10 ? `0${t}` : t.toString(); return n = `${String(r)}-${i}-${s}`, n } function PY(r) { let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0; const t = { dayNumber: "", dateNumberFull: "", fullDate: "" }, n = PS(r), i = mt(r, "yyyy"), s = mt(r, "MM"), a = wB(r), o = TV(r), l = Number(mt(o, "e", { weekStartsOn: e })), u = []; let d = []; for (let h = 1; h < l; h++)d.push(t); for (let h = 0; h < n; h++) { const g = h + 1, m = g < 10 ? `0${g}` : g.toString(), b = L_(i, s, g); d.push({ dayNumber: g, dayNumberFull: m, fullDate: b }), d.length === 7 ? (u.push(d), d = []) : b === mt(a, "yyyy-MM-dd") && (u.push(d), d = []) } return u } const kY = (r, e) => { const t = PY(r, e); return { monthText: mt(r, "yyyy-MM"), weeks: t, month: r } }, c0 = { month: ea, year: OV }, RY = { prevMonth: $4, nextMonth: Is, prevYear: L4, nextYear: Zu }; class DY extends ve { constructor(e) { super(Object.assign({}, e)), this.newBiMonthPanelDate = [this.getState("monthLeft").pickerDate, this.getState("monthRight").pickerDate] } init() { const e = this.getProp("defaultValue"); this.initDefaultPickerValue(), this.updateSelectedFromProps(e) } initDefaultPickerValue() { const e = sn(this.getProp("defaultPickerValue")); e && Yr(e) && (this._updatePanelDetail(ne.PANEL_TYPE_LEFT, { pickerDate: e }), this._updatePanelDetail(ne.PANEL_TYPE_RIGHT, { pickerDate: Is(e, 1) })) } updateSelectedFromProps(e) { let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0; const n = this.getProp("type"), { selected: i, rangeStart: s, rangeEnd: a } = this.getStates(); if (e && (e != null && e.length)) switch (n) { case "date": this._initDatePickerFromValue(e, t); break; case "dateRange": this._initDateRangePickerFromValue(e); break; case "dateTime": this._initDateTimePickerFromValue(e); break; case "dateTimeRange": this._initDateTimeRangePickerFormValue(e); break } else (Array.isArray(e) && !e.length || !e) && (Ri(i) && i.size && this._adapter.updateDaySelected(new Set), s && this._adapter.setRangeStart(""), a && this._adapter.setRangeEnd("")) } calcDisabledTime(e) { const { disabledTime: t, type: n } = this.getProps(); if (typeof t == "function" && e && ["dateTime", "dateTimeRange"].includes(n)) { const { rangeStart: i, rangeEnd: s, monthLeft: a } = this.getStates(), o = []; n === "dateTimeRange" ? (i && o.push(i), i && s && o.push(s)) : a && a.showDate && o.push(a.showDate); const l = o.map(d => d instanceof Date ? d : Gr(d)), u = n === "dateTimeRange" ? l : l[0]; return t(u, e) } } _initDatePickerFromValue(e) { let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0; const { monthLeft: n } = this._adapter.getStates(), i = Object.assign({}, n); this._adapter.updateMonthOnLeft(i); const s = new Set, a = this._isMultiple(); a ? e.forEach(o => { o && s.add(mt(o, ne.FORMAT_FULL_DATE)) }) : e[0] && s.add(mt(e[0], ne.FORMAT_FULL_DATE)), t ? a ? !(e != null && e.some(l => l && ea(l, n.pickerDate) === 0)) && this.handleShowDateAndTime(ne.PANEL_TYPE_LEFT, e[0] || i.pickerDate) : this.handleShowDateAndTime(ne.PANEL_TYPE_LEFT, e[0] || i.pickerDate) : this.handleShowDateAndTime(ne.PANEL_TYPE_LEFT, i.pickerDate), this._adapter.updateDaySelected(s) } _initDateRangePickerFromValue(e) { let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1; const n = this.getState("monthLeft"), i = this.getState("monthRight"), s = this._autoAdjustMonth(Object.assign(Object.assign({}, n), { pickerDate: e[0] || n.pickerDate }), Object.assign(Object.assign({}, i), { pickerDate: e[1] || i.pickerDate })); if (Array.isArray(e) && e.filter(d => d).length > 1) this.handleShowDateAndTime(ne.PANEL_TYPE_LEFT, s.monthLeft.pickerDate), this.handleShowDateAndTime(ne.PANEL_TYPE_RIGHT, s.monthRight.pickerDate); else { const d = e.find(h => h); if (d) { const h = Math.abs(ea(d, n.pickerDate)) > 0, g = Math.abs(ea(d, i.pickerDate)) > 0; h && g && (this.handleShowDateAndTime(ne.PANEL_TYPE_LEFT, s.monthLeft.pickerDate), this.handleShowDateAndTime(ne.PANEL_TYPE_RIGHT, s.monthRight.pickerDate)) } } const o = t ? ne.FORMAT_DATE_TIME : ne.FORMAT_FULL_DATE; let l = e[0] && mt(e[0], o), u = e[1] && mt(e[1], o); this._isNeedSwap(l, u) && ([l, u] = [u, l]), this._adapter.setRangeStart(l), this._adapter.setRangeEnd(u), this._adapter.setHoverDay(u) } _initDateTimePickerFromValue(e) { this._initDatePickerFromValue(e) } _initDateTimeRangePickerFormValue(e) { this._initDateRangePickerFromValue(e, !0) } destroy() { } handleSyncChangeMonths(e) { const { panelType: t, target: n } = e, { type: i } = this._adapter.getProps(), { monthLeft: s, monthRight: a } = this._adapter.getStates(); this.isRangeType(i) && (t === "right" && ea(n, s.pickerDate) === 0 ? this.handleYearOrMonthChange("prevMonth", "left", 1, !0) : t === "left" && ea(a.pickerDate, n) === 0 && this.handleYearOrMonthChange("nextMonth", "right", 1, !0)) } getTargetChangeDate(e) { const { panelType: t, switchType: n } = e, { monthRight: i, monthLeft: s } = this._adapter.getStates(), a = t === "left" ? s.pickerDate : i.pickerDate; let o; switch (n) { case "prevMonth": o = Is(a, -1); break; case "nextMonth": o = Is(a, 1); break; case "prevYear": o = Zu(a, -1); break; case "nextYear": o = Zu(a, 1); break }return o } toMonth(e, t) { const { type: n } = this._adapter.getProps(), i = this._getDiff("month", t, e); this.handleYearOrMonthChange(i < 0 ? "prevMonth" : "nextMonth", e, Math.abs(i), !1), this.isRangeType(n) && this.handleSyncChangeMonths({ panelType: e, target: t }) } toYear(e, t) { const n = this._getDiff("year", t, e); this.handleYearOrMonthChange(n < 0 ? "prevYear" : "nextYear", e, Math.abs(n), !1) } toYearMonth(e, t) { this.toYear(e, t), this.toMonth(e, t) } isRangeType(e) { const { type: t } = this.getProps(), n = e || t; return typeof n == "string" && /range/i.test(n) } handleSwitchMonthOrYear(e, t) { const { type: n, syncSwitchMonth: i } = this.getProps(), s = this.isRangeType(n); if (s && i) this.handleYearOrMonthChange(e, "left", 1, !0), this.handleYearOrMonthChange(e, "right", 1, !0); else if (this.handleYearOrMonthChange(e, t), s) { const a = this.getTargetChangeDate({ panelType: t, switchType: e }); this.handleSyncChangeMonths({ panelType: t, target: a }) } } prevMonth(e) { this.handleSwitchMonthOrYear("prevMonth", e) } nextMonth(e) { this.handleSwitchMonthOrYear("nextMonth", e) } prevYear(e) { this.handleSwitchMonthOrYear("prevYear", e) } nextYear(e) { this.handleSwitchMonthOrYear("nextYear", e) } _getDiff(e, t, n) { const i = this._getPanelDetail(n); return c0[e] && c0[e](t, i.pickerDate) } _getPanelDetail(e) { return e === ne.PANEL_TYPE_RIGHT ? this.getState("monthRight") : this.getState("monthLeft") } localeFormat(e, t) { const n = this._adapter.getProp("dateFnsLocale"); return mt(e, t, { locale: n }) } disposeCallbackArgs(e) { let t = Array.isArray(e) ? e : e && [e] || []; const n = this.getProp("timeZone"); Du(n) && (t = t.map(l => fo(l, n))); const i = this.getProp("type"), s = this.getProp("format") || Ps(i); let a, o; switch (i) { case "date": case "dateTime": case "month": this._isMultiple() ? (a = t.map(l => l && this.localeFormat(l, s)), o = [...t]) : (a = t[0] && this.localeFormat(t[0], s), [o] = t); break; case "dateRange": case "dateTimeRange": a = t.map(l => l && this.localeFormat(l, s)), o = [...t]; break }return { notifyValue: a, notifyDate: o } } handleYearOrMonthChange(e) { let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : ne.PANEL_TYPE_LEFT, n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1, i = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : !1; const { autoSwitchDate: s, type: a } = this.getProps(), { monthLeft: o, monthRight: l } = this.getStates(), u = this.isRangeType(a), d = u && t === ne.PANEL_TYPE_LEFT, h = this._getPanelDetail(t), { pickerDate: g } = h, m = RY[e], b = m(g, n), y = t === ne.PANEL_TYPE_LEFT && !ke(b, o.pickerDate) || t === ne.PANEL_TYPE_RIGHT && !ke(b, l.pickerDate); if (this._updatePanelDetail(t, { pickerDate: b }), y) if (u) { if (d ? this.newBiMonthPanelDate[0] = b : this.newBiMonthPanelDate[1] = b, !(d && i)) { const { notifyValue: w, notifyDate: x } = this.disposeCallbackArgs(this.newBiMonthPanelDate); this._adapter.notifyPanelChange(x, w) } } else { const { notifyValue: w, notifyDate: x } = this.disposeCallbackArgs(b); this._adapter.notifyPanelChange(x, w) } s && this.updateDateAfterChangeYM(e, b) } updateDateAfterChangeYM(e, t) { const { multiple: n, disabledDate: i, type: s } = this.getProps(), { selected: a, rangeStart: o, rangeEnd: l, monthLeft: u } = this.getStates(), d = ["dateRange", "dateTimeRange"].includes(e), h = { closePanel: !1 }; if (!n && !d && a.size) { const g = Array.from(a)[0], m = new Date(g), b = t.getFullYear(), y = t.getMonth(); let w = jS(m, { year: b, month: y }); if (s === "dateTime" && (w = this._mergeDateAndTime(w, u.pickerDate)), i(w, { rangeStart: o, rangeEnd: l })) return; this._adapter.notifySelectedChange([w], h) } } _isMultiple() { return !!this.getProp("multiple") && this.getProp("type") === "date" } _isRange() { } handleDayClick(e, t) { const n = this.getProp("type"); switch (!0) { case (n === "date" || n === "dateTime"): this.handleDateSelected(e, t); break; case (n === "dateRange" || n === "dateTimeRange"): this.handleRangeSelected(e); break } } handleDateSelected(e, t) { const { max: n, type: i, isControlledComponent: s, dateFnsLocale: a } = this.getProps(), o = this._isMultiple(), { selected: l } = this.getStates(), u = this._getPanelDetail(t), d = new Set(o ? [...l] : []), { fullDate: h } = e, g = u.pickerDate, m = h; o ? d.has(m) ? d.delete(m) : n && d.size === n ? this._adapter.notifyMaxLimit() : d.add(m) : d.add(m); const b = [...d].map(y => i === "dateTime" ? this._mergeDateAndTime(y, g) : sn(y, ne.FORMAT_FULL_DATE, void 0, a)); this.handleShowDateAndTime(t, g), s || this._adapter.updateDaySelected(d), this._adapter.notifySelectedChange(b) } handleShowDateAndTime(e, t, n) { const i = n || t; this._updatePanelDetail(e, { showDate: i, pickerDate: t }) } _mergeDateAndTime(e, t) { const n = this._adapter.getProp("dateFnsLocale"), i = mt(Yr(e) ? e : sn(e, ne.FORMAT_FULL_DATE, void 0, n), ne.FORMAT_FULL_DATE), s = mt(Yr(t) ? t : sn(t, ne.FORMAT_TIME_PICKER, void 0, n), ne.FORMAT_TIME_PICKER), a = this.getValidTimeFormat(); return sn(`${i} ${s}`, a, void 0, n) } handleRangeSelected(e) { let { rangeStart: t, rangeEnd: n } = this.getStates(); const { startDateOffset: i, endDateOffset: s, type: a, dateFnsLocale: o, rangeInputFocus: l, triggerRender: u } = this._adapter.getProps(), { fullDate: d } = e; let h = !1, g = !1; const m = (i || s) && a === "dateRange"; m ? (t = ou(i, d), n = ou(s, d)) : l === "rangeEnd" ? (n = d, t && n && io(n, t.trim().split(/\s+/)[0]) && (t = null, h = !0)) : (l === "rangeStart" || !l) && (t = d, t && n && io(n.trim().split(/\s+/)[0], t) && (n = null, g = !0)), /range/i.test(a) && (m ? (this._adapter.setRangeStart(t), this._adapter.setRangeEnd(n)) : l === "rangeEnd" ? (this._adapter.setRangeEnd(n), h && this._adapter.setRangeStart(t), (!this._adapter.isAnotherPanelHasOpened("rangeEnd") || !t) && this._adapter.setRangeInputFocus("rangeStart")) : (l === "rangeStart" || !l) && (this._adapter.setRangeStart(t), g && this._adapter.setRangeEnd(n), (!this._adapter.isAnotherPanelHasOpened("rangeStart") || !n) && this._adapter.setRangeInputFocus("rangeEnd"))); const y = this.getValidDateFormat(); if (t || n) { const [w, x] = [sn(t, y, void 0, o), sn(n, y, void 0, o)]; let S = [w, x]; if (a === "dateTimeRange") { const O = this.getState("monthLeft").pickerDate, E = this.getState("monthRight").pickerDate, v = t ? this._mergeDateAndTime(t, O) : null, T = n ? this._mergeDateAndTime(n, E) : null; Mm(w, x) && io(T, v) ? S = [v, v] : S = [v, T] } const C = !(a === "dateRange" && m); this._adapter.notifySelectedChange(S, { needCheckFocusRecord: C }) } } _isNeedSwap(e, t) { return e && t && io(t, e) } handleDayHover() { let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : { fullDate: "" }; const { fullDate: t } = e, { startDateOffset: n, endDateOffset: i, type: s } = this.getProps(); if (this._adapter.setHoverDay(t), (n || i) && s === "dateRange") { const a = ou(n, t), o = ou(i, t); this._adapter.setOffsetRangeStart(a), this._adapter.setOffsetRangeEnd(o) } } _autoAdjustMonth(e, t) { let n = e, i = t; const s = ea(e.pickerDate, t.pickerDate); return s > 0 ? (n = Object.assign({}, t), i = Object.assign({}, e)) : s === 0 && (n = e, i = Object.assign(Object.assign({}, t), { pickerDate: Is(t.pickerDate, 1) })), { monthLeft: n, monthRight: i } } getValidTimeFormat() { const e = this.getProp("format") || ne.FORMAT_TIME_PICKER, t = []; return ($i(e, "h") || $i(e, "H")) && t.push("HH"), $i(e, "m") && t.push("mm"), $i(e, "s") && t.push("ss"), t.join(":") } getValidDateFormat() { return this.getProp("format") || rG(this.getProp("type")) } handleTimeChange(e, t) { const { rangeEnd: n, rangeStart: i } = this.getStates(), s = this.getProp("dateFnsLocale"), a = e.timeStampValue, o = this.getProp("type"), l = this._getPanelDetail(t), { showDate: u } = l, d = new Date(a), h = this.getValidDateFormat(), g = t === ne.PANEL_TYPE_RIGHT ? n : i; let m, b, y; if (o === "dateTimeRange" && g) { const v = sn(g, h, void 0, s); m = v.getFullYear(), b = v.getMonth(), y = v.getDate() } else m = u.getFullYear(), b = u.getMonth(), y = u.getDate(); const w = d.getHours(), x = d.getMinutes(), S = d.getSeconds(), C = d.getMilliseconds(), O = [m, b, y, w, x, S, C], E = new Date(...O); if (o === "dateTimeRange") this.handleShowDateAndTime(t, E, u), this._updateTimeInDateRange(t, E); else { const v = L_(m, b + 1, y); this.handleDateSelected({ fullDate: v, fullValidDate: E }, t), this.handleShowDateAndTime(t, E), this._adapter.notifySelectedChange([E]) } } _updateTimeInDateRange(e, t) { const { isControlledComponent: n, dateFnsLocale: i } = this.getProps(); let s = this.getState("rangeStart"), a = this.getState("rangeEnd"); const o = this.getValidDateFormat(); if (s && a) { let l = sn(s, o, void 0, i), u = sn(a, o, void 0, i); e === ne.PANEL_TYPE_RIGHT ? (u = this._mergeDateAndTime(t, t), a = mt(u, ne.FORMAT_DATE_TIME), this._isNeedSwap(s, a) && ([s, a] = [a, s], [l, u] = [u, l]), n || this._adapter.setRangeEnd(a)) : (l = this._mergeDateAndTime(t, t), s = mt(l, ne.FORMAT_DATE_TIME), this._isNeedSwap(s, a) && ([s, a] = [a, s], [l, u] = [u, l]), n || this._adapter.setRangeStart(s)), this._adapter.notifySelectedChange([l, u]) } } _updatePanelDetail(e, t) { const { monthLeft: n, monthRight: i } = this.getStates(); e === ne.PANEL_TYPE_RIGHT ? this._adapter.updateMonthOnRight(Object.assign(Object.assign({}, i), t)) : this._adapter.updateMonthOnLeft(Object.assign(Object.assign({}, n), t)) } showYearPicker(e) { this._updatePanelDetail(e, { isTimePickerOpen: !1, isYearPickerOpen: !0 }) } showTimePicker(e, t) { this.getProp("disabledTimePicker") || this._updatePanelDetail(e, { isTimePickerOpen: !0, isYearPickerOpen: !1 }) } showDatePanel(e) { this._updatePanelDetail(e, { isTimePickerOpen: !1, isYearPickerOpen: !1 }) } getYAMOpenType() { const { monthLeft: e, monthRight: t } = this._adapter.getStates(), n = e.isYearPickerOpen, i = t.isYearPickerOpen; return n && i ? "both" : n ? "left" : i ? "right" : "none" } } const u0 = Ae.NAVIGATION; class Sy extends R.PureComponent { constructor(e) { super(e), this.navRef = f.createRef() } render() { const { forwardRef: e, monthText: t, onMonthClick: n, onNextMonth: i, onPrevMonth: s, onPrevYear: a, onNextYear: o, density: l, shouldBimonthSwitch: u, panelType: d } = this.props, h = "borderless", g = l === "compact" ? "default" : "large", m = !0, b = l === "compact" ? "small" : "default", y = d === ne.PANEL_TYPE_LEFT, w = d === ne.PANEL_TYPE_RIGHT, x = u && y, S = u && w, C = {}, O = {}; S && (C.visibility = "hidden"), x && (O.visibility = "hidden"); const E = e || this.navRef; return f.createElement("div", { className: u0, ref: E }, f.createElement(br, { key: "double-chevron-left", "aria-label": "Previous year", icon: f.createElement(iH, { "aria-hidden": !0, size: g }), size: b, theme: h, noHorizontalPadding: m, onClick: a, style: C }), f.createElement(br, { key: "chevron-left", "aria-label": "Previous month", icon: f.createElement(bc, { "aria-hidden": !0, size: g }), size: b, onClick: s, theme: h, noHorizontalPadding: m, style: C }), f.createElement("div", { className: `${u0}-month` }, f.createElement(St, { onClick: n, theme: h, size: b }, f.createElement("span", null, t))), f.createElement(br, { key: "chevron-right", "aria-label": "Next month", icon: f.createElement(Ms, { "aria-hidden": !0, size: g }), size: b, onClick: i, theme: h, noHorizontalPadding: m, style: O }), f.createElement(br, { key: "double-chevron-right", "aria-label": "Next year", icon: f.createElement(aH, { "aria-hidden": !0, size: g }), size: b, theme: h, noHorizontalPadding: m, onClick: o, style: O })) } } Sy.propTypes = { monthText: c.string, density: c.string, onMonthClick: c.func, onNextMonth: c.func, onPrevMonth: c.func, onNextYear: c.func, onPrevYear: c.func, navPrev: c.node, navNext: c.node, shouldBimonthSwitch: c.bool, panelType: c.oneOf([ne.PANEL_TYPE_LEFT, ne.PANEL_TYPE_RIGHT]) }; Sy.defaultProps = { monthText: "", onMonthClick: z, onNextMonth: z, onPrevMonth: z, onNextYear: z, onPrevYear: z }; const AY = r => { let { weekStartsOn: e = 0 } = r; const t = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"]; for (let n = 0; n < e; n++)t.push(t.shift()); return t }; class NY extends ve { constructor(e) { super(Object.assign({}, e)) } init() { this._getToday(), this.getMonthTable() } _getToday() { const t = mt(new Date, "yyyy-MM-dd"); this._adapter.updateToday(t) } getMonthTable() { const e = this._adapter.getProp("month"), t = this.getState("weeksRowNum"); if (e) { this.updateWeekDays(); const n = this._adapter.getProp("weekStartsOn"), i = kY(e, n), { weeks: s } = i; this._adapter.updateMonthTable(i), ze(t) ? this._adapter.setWeeksRowNum(s.length) : Array.isArray(s) && s.length !== t && this._adapter.setWeeksRowNum(s.length, () => { this._adapter.notifyWeeksRowNumChange(s.length) }) } } updateWeekDays() { const e = this._adapter.getProp("weekStartsOn"), t = AY({ weekStartsOn: e }); this._adapter.setWeekDays(t) } destroy() { } handleClick(e) { this._adapter.notifyDayClick(e) } handleHover(e) { this._adapter.notifyDayHover(e) } } const FY = Ae.PREFIX; class Ey extends de { constructor(e) { super(e), this.state = { weekdays: [], month: { weeks: [], monthText: "" }, todayText: "", weeksRowNum: e.weeksRowNum }, this.monthRef = f.createRef() } get adapter() { return Object.assign(Object.assign({}, super.adapter), { updateToday: e => this.setState({ todayText: e }), setWeekDays: e => this.setState({ weekdays: e }), setWeeksRowNum: (e, t) => this.setState({ weeksRowNum: e }, t), updateMonthTable: e => this.setState({ month: e }), notifyDayClick: e => this.props.onDayClick(e), notifyDayHover: e => this.props.onDayHover(e), notifyWeeksRowNumChange: e => this.props.onWeeksRowNumChange(e) }) } componentDidMount() { this.foundation = new NY(this.adapter), this.foundation.init() } componentWillUnmount() { this.foundation.destroy() } componentDidUpdate(e, t) { e.month !== this.props.month && this.foundation.getMonthTable() } getSingleDayStatus(e) { const { rangeInputFocus: t } = this.props, { fullDate: n, todayText: i, selected: s, disabledDate: a, rangeStart: o, rangeEnd: l } = e, u = { rangeStart: o, rangeEnd: l, rangeInputFocus: t }, d = n === i, h = s.has(n); let g = a && a(Gr(n), u); return !g && this.props.rangeInputFocus === "rangeStart" && l && this.props.focusRecordsRef && this.props.focusRecordsRef.current.rangeEnd && (g = n0(n, l.trim().split(/\s+/)[0])), !g && this.props.rangeInputFocus === "rangeEnd" && o && this.props.focusRecordsRef && this.props.focusRecordsRef.current.rangeStart && (g = io(n, o.trim().split(/\s+/)[0])), { isToday: d, isSelected: h, isDisabled: g } } getDateRangeStatus(e) { const { rangeStart: t, rangeEnd: n, fullDate: i, hoverDay: s, offsetRangeStart: a, offsetRangeEnd: o, rangeInputFocus: l } = e, u = !!(t || n), d = !!(t && n), h = a || o; if (!u) return {}; const g = vs(s, i); let m, b, y, w, x; t && (y = vs(i, t), l === "rangeEnd" && (m = Ua(i, { start: t, end: s }))), n && (w = vs(i, n), l === "rangeStart" && (b = Ua(i, { start: s, end: n }))), !d && u && (x = g); let S; h || (S = m || b || g); let C, O, E, v, T, I; return d && (C = Ua(i, { start: t, end: n }), h || (O = y && n0(t, s), E = w && io(n, s), v = g && l === "rangeStart", T = g && l === "rangeEnd", I = g && Ua(s, { start: t, end: n }))), { isHoverDay: g, isSelectedStart: y, isSelectedEnd: w, isInRange: C, isHover: S, isSelectedStartAfterHover: O, isSelectedEndBeforeHover: E, isHoverDayInRange: I, isHoverDayInStartSelection: v, isHoverDayInEndSelection: T, isHoverDayAroundOneSelected: x } } getOffsetDateStatus(e) { const { offsetRangeStart: t, offsetRangeEnd: n, rangeStart: i, rangeEnd: s, fullDate: a, hoverDay: o } = e; if (!(t || n)) return {}; const u = Ua(a, { start: i, end: s }), d = vs(o, a), h = i && vs(a, i), g = s && vs(a, s), m = !!(i && s), b = vs(a, t), y = vs(a, n), w = d; let x, S; return m && (x = u && d), !!(t && n) && (S = h || Ua(a, { start: t, end: n }) || g), { isOffsetRangeStart: b, isOffsetRangeEnd: y, isHoverInOffsetRange: x, isHoverDayOffset: w, isInOffsetRange: S } } getDayStatus(e, t) { const { fullDate: n } = e, { hoverDay: i, rangeStart: s, rangeEnd: a, todayText: o, offsetRangeStart: l, offsetRangeEnd: u, disabledDate: d, selected: h, rangeInputFocus: g } = t, m = this.getSingleDayStatus({ fullDate: n, todayText: o, hoverDay: i, selected: h, disabledDate: d, rangeStart: s, rangeEnd: a }), b = this.getDateRangeStatus(Object.assign({ fullDate: n, rangeStart: s, rangeEnd: a, hoverDay: i, offsetRangeStart: l, offsetRangeEnd: u, rangeInputFocus: g }, m)), y = this.getOffsetDateStatus(Object.assign(Object.assign({ offsetRangeStart: l, offsetRangeEnd: u, rangeStart: s, rangeEnd: a, fullDate: n, hoverDay: i }, m), b)); return Object.assign(Object.assign(Object.assign({}, m), b), y) } renderDayOfWeek() { const { locale: e } = this.props, t = F(Ae.WEEKDAY), n = F(`${FY}-weekday-item`), { weekdays: i } = this.state, s = i.map(a => e.weeks[a]); return f.createElement("div", { role: "row", className: t }, s.map((a, o) => f.createElement("div", { role: "columnheader", key: a + o, className: n }, a))) } renderWeeks() { const { month: e } = this.state, { weeks: t } = e, { weeksRowNum: n } = this.props; let i = {}; n && (i = { height: n * Oo.WEEK_HEIGHT }); const s = F(Ae.WEEKS); return f.createElement("div", { className: s, style: i }, t.map((a, o) => this.renderWeek(a, o))) } renderWeek(e, t) { const n = Ae.WEEK; return f.createElement("div", { role: "row", className: n, key: t }, e.map((i, s) => this.renderDay(i, s))) } renderDay(e, t) { const { todayText: n } = this.state, { renderFullDate: i, renderDate: s } = this.props, { fullDate: a, dayNumber: o } = e; if (!a) return f.createElement("div", { role: "gridcell", tabIndex: -1, key: o + t, className: Ae.DAY }, f.createElement("span", null)); const l = this.getDayStatus(e, Object.assign({ todayText: n }, this.props)), u = F(Ae.DAY, { [Ae.DAY_TODAY]: l.isToday, [Ae.DAY_IN_RANGE]: l.isInRange, [Ae.DAY_HOVER]: l.isHover, [Ae.DAY_SELECTED]: l.isSelected, [Ae.DAY_SELECTED_START]: l.isSelectedStart, [Ae.DAY_SELECTED_END]: l.isSelectedEnd, [Ae.DAY_DISABLED]: l.isDisabled, [Ae.DAY_HOVER_DAY]: l.isHoverDayOffset, [Ae.DAY_IN_OFFSET_RANGE]: l.isInOffsetRange, [Ae.DAY_SELECTED_RANGE_HOVER]: l.isHoverInOffsetRange, [Ae.DAY_OFFSET_RANGE_START]: l.isOffsetRangeStart, [Ae.DAY_OFFSET_RANGE_END]: l.isOffsetRangeEnd, [Ae.DAY_SELECTED_START_AFTER_HOVER]: l.isSelectedStartAfterHover, [Ae.DAY_SELECTED_END_BEFORE_HOVER]: l.isSelectedEndBeforeHover, [Ae.DAY_HOVER_DAY_BEFORE_RANGE]: l.isHoverDayInStartSelection, [Ae.DAY_HOVER_DAY_AFTER_RANGE]: l.isHoverDayInEndSelection, [Ae.DAY_HOVER_DAY_AROUND_SINGLE_SELECTED]: l.isHoverDayAroundOneSelected }), d = F({ [`${Ae.DAY}-main`]: !0 }), h = [o, a, l], g = we(i); return f.createElement("div", { role: "gridcell", tabIndex: l.isDisabled ? -1 : 0, "aria-disabled": l.isDisabled, "aria-selected": l.isSelected, "aria-label": a, className: g ? Ae.DAY : u, title: a, key: o + t, onClick: m => !l.isDisabled && this.foundation.handleClick(e), onMouseEnter: () => this.foundation.handleHover(e), onMouseLeave: () => this.foundation.handleHover() }, g ? i(...h) : f.createElement("div", { className: d }, we(s) ? s(o, a) : f.createElement("span", null, o))) } render() { const { forwardRef: e, multiple: t } = this.props, n = this.renderDayOfWeek(), i = this.renderWeeks(), s = F(Ae.MONTH), a = e || this.monthRef; return f.createElement("div", { role: "grid", "aria-multiselectable": t, ref: a, className: s }, n, i) } } Ey.propTypes = { month: c.object, selected: c.object, rangeStart: c.string, rangeEnd: c.string, offsetRangeStart: c.string, offsetRangeEnd: c.string, onDayClick: c.func, onDayHover: c.func, weekStartsOn: c.number, disabledDate: c.func, weeksRowNum: c.number, onWeeksRowNumChange: c.func, renderDate: c.func, renderFullDate: c.func, hoverDay: c.string, startDateOffset: c.func, endDateOffset: c.func, rangeInputFocus: c.oneOfType([c.string, c.bool]), focusRecordsRef: c.object, multiple: c.bool }; Ey.defaultProps = { month: new Date, selected: new Set, rangeStart: "", rangeEnd: "", onDayClick: z, onDayHover: z, onWeeksRowNumChange: z, weekStartsOn: Oo.WEEK_START_ON, disabledDate: jl, weeksRowNum: 0 }; const lu = "time", mp = "timeRange", $Y = " ~ ", LY = ",", Ig = { PREFIX: `${G}-timepicker`, RANGE_PICKER: `${G}-timepicker-range-panel`, RANGE_PANEL_LISTS: `${G}-timepicker-lists` }, hn = { TYPES: [lu, mp], TYPE_TIME_PICKER: lu, TYPE_TIME_RANGE_PICKER: mp, DEFAULT_TYPE: lu, DEFAULT_RANGE_SEPARATOR: $Y, DEFAULT_MULTIPLE_SEPARATOR: LY, SIZE: Hs.SIZE, DEFAULT_FORMAT: "HH:mm:ss", DEFAULT_FORMAT_A: "a h:mm:ss", STATUS: Vo, DEFAULT_POSITION: { [lu]: "bottomLeft", [mp]: "bottomLeft" } }, mr = { PREFIX: `${G}-scrolllist`, SELECTED: `${G}-scrolllist-item-selected` }, MY = { MODE: ["normal", "wheel"] }, cu = { DEFAULT_ITEM_HEIGHT: 36, DEFAULT_SCROLL_DURATION: 120 }; var jY = M1, VY = uS, BY = Go, zY = 9007199254740991, yp = 4294967295, HY = Math.min; function KY(r, e) { if (r = BY(r), r < 1 || r > zY) return []; var t = yp, n = HY(r, yp); e = VY(e), r -= yp; for (var i = jY(n, e); ++t < r;)e(t); return i } var UY = KY; const pd = _e(UY); var WY = jd, GY = Ud, YY = 1, XY = 2; function qY(r, e, t, n) { var i = t.length, s = i, a = !n; if (r == null) return !s; for (r = Object(r); i--;) { var o = t[i]; if (a && o[2] ? o[1] !== r[o[0]] : !(o[0] in r)) return !1 } for (; ++i < s;) { o = t[i]; var l = o[0], u = r[l], d = o[1]; if (a && o[2]) { if (u === void 0 && !(l in r)) return !1 } else { var h = new WY; if (n) var g = n(u, d, l, r, e, h); if (!(g === void 0 ? GY(d, u, YY | XY, n, h) : g)) return !1 } } return !0 } var ZY = qY, JY = Er; function QY(r) { return r === r && !JY(r) } var M_ = QY, eX = M_, tX = zs; function nX(r) { for (var e = tX(r), t = e.length; t--;) { var n = e[t], i = r[n]; e[t] = [n, i, eX(i)] } return e } var rX = nX; function iX(r, e) { return function (t) { return t == null ? !1 : t[r] === e && (e !== void 0 || r in Object(t)) } } var j_ = iX, sX = ZY, aX = rX, oX = j_; function lX(r) { var e = aX(r); return e.length == 1 && e[0][2] ? oX(e[0][0], e[0][1]) : function (t) { return t === r || sX(t, r, e) } } var cX = lX, uX = Ud, dX = b1, hX = yE, pX = hm, fX = M_, gX = j_, mX = Sa, yX = 1, bX = 2; function vX(r, e) { return pX(r) && fX(e) ? gX(mX(r), e) : function (t) { var n = dX(t, r); return n === void 0 && n === e ? hX(t, r) : uX(e, n, yX | bX) } } var xX = vX; function wX(r) { return function (e) { return e == null ? void 0 : e[r] } } var V_ = wX, CX = Fd; function SX(r) { return function (e) { return CX(e, r) } } var EX = SX, _X = V_, OX = EX, TX = hm, IX = Sa; function PX(r) { return TX(r) ? _X(IX(r)) : OX(r) } var kX = PX, RX = cX, DX = xX, AX = fc, NX = Dn, FX = kX; function $X(r) { return typeof r == "function" ? r : r == null ? AX : typeof r == "object" ? NX(r) ? DX(r[0], r[1]) : RX(r) : FX(r) } var Jo = $X, LX = iy, MX = Jo, jX = Go, VX = Math.max; function BX(r, e, t) { var n = r == null ? 0 : r.length; if (!n) return -1; var i = t == null ? 0 : jX(t); return i < 0 && (i = VX(n + i, 0)), LX(r, MX(e), i) } var B_ = BX; const Ur = _e(B_); var zX = Wd, HX = Ei; function KX(r, e) { var t = -1, n = HX(r) ? Array(r.length) : []; return zX(r, function (i, s, a) { n[++t] = e(i, s, a) }), n } var UX = KX, WX = Ca, GX = Jo, YX = UX, XX = Dn; function qX(r, e) { var t = XX(r) ? WX : YX; return t(r, GX(e)) } var ZX = qX; const Gl = _e(ZX); var JX = Jo, QX = Ei, eq = zs; function tq(r) { return function (e, t, n) { var i = Object(e); if (!QX(e)) { var s = JX(t); e = eq(e), t = function (o) { return s(i[o], o, i) } } var a = r(e, t, n); return a > -1 ? i[s ? e[a] : a] : void 0 } } var nq = tq, rq = nq, iq = B_, sq = rq(iq), aq = sq; const Ui = _e(aq); var oq = Im, lq = Kd, d0 = Go; function cq(r, e, t) { var n = r == null ? 0 : r.length; return n ? (t && typeof t != "number" && lq(r, e, t) ? (e = 0, t = n) : (e = e == null ? 0 : d0(e), t = t === void 0 ? n : d0(t)), oq(r, e, t)) : [] } var uq = cq; const Nu = _e(uq); let dq = class extends ve { constructor() { super(...arguments), this._cachedSelectedNode = null } selectIndex(e, t) { const { type: n, list: i } = this.getProps(); if (e > -1 && Array.isArray(i) && i.length && ct(t)) { const s = e % i.length, a = i[s], o = t.children[e]; this._adapter.setSelectedNode(o), this._adapter.notifySelectItem(Object.assign(Object.assign({}, a), { value: a.value, type: n, index: s })) } } selectNode(e, t) { const { type: n, list: i } = this.getProps(); if (ct(e) && ct(t)) { const a = Ur(t.children, d => d === e) % i.length, l = Ur(t.children, d => d === this._cachedSelectedNode) % i.length, u = i[a]; this._adapter.setSelectedNode(e), this._adapter.scrollToCenter(e), this._cachedSelectedNode !== e && (this._cachedSelectedNode = e, l !== a && this._adapter.notifySelectItem(Object.assign(Object.assign({}, u), { value: u.value, type: n, index: a }))) } } shouldAppend(e, t) { let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 2; const i = "li"; if (ct(e) && ct(t)) { const s = e.querySelectorAll(i), a = s[s.length - 1], { list: o } = this.getProps(); if (a) { const l = t.getBoundingClientRect(), u = a.getBoundingClientRect(), d = u.height * o.length; let h = u.top, g = 0; for (; h <= l.top + l.height * n;)g += 1, h += d; return g } } return !1 } shouldPrepend(e, t) { let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 2; const i = "li"; if (ct(e) && ct(t)) { const a = e.querySelectorAll(i)[0], { list: o } = this.getProps(); if (a) { const l = t.getBoundingClientRect(), u = a.getBoundingClientRect(), d = u.height * o.length; let h = u.top, g = 0; for (; h + u.height >= l.top - l.height * n;)g += 1, h -= d; return g } } return 0 } initWheelList(e, t, n) { const { list: i } = this.getProps(); if (ct(t) && ct(e) && i && i.length) { const s = e.children; Nu(s, 0, i.length); const a = this.shouldPrepend(e, t), o = this.shouldAppend(e, t); this._adapter.setState({ prependCount: a, appendCount: o }, n) } } adjustInfiniteList(e, t, n) { const { list: i } = this.getProps(), s = "li"; if (ct(t) && ct(e) && i && i.length) { const a = e.querySelectorAll(s), o = a.length, l = 1, u = this.shouldPrepend(e, t, l), d = this.shouldAppend(e, t, l); if (u) for (let h = 0; h < u; h++) { const g = Nu(a, o - i.length * (h + 1), o - i.length * h); L3(e, ...g) } if (d) for (let h = 0; h < d; h++) { const g = Nu(a, h * i.length, (h + 1) * i.length); hS(e, ...g) } } } getNearestNodeInfo(e, t) { if (ct(e) && ct(t)) { const i = t.getBoundingClientRect().top, s = e.querySelectorAll("li"); let a = null, o = -1, l = 1 / 0; return Array.from(s).map((u, d) => { const g = u.getBoundingClientRect().top, m = Math.abs(g - i); m < l && !this._adapter.isDisabledIndex(d) && (l = m, a = u, o = d) }), { nearestNode: a, nearestIndex: o } } } getTargetNode(e, t) { if (e && ct(t)) { const n = "li", i = e.target, s = t.querySelectorAll(n), a = this.getProp("list"), o = Array.isArray(a) ? a.length : 0; let l = -1, u = -1, d = null; const h = Ui(s, (g, m) => { if (g === i || g.contains(i)) return l = m, o > 0 && (u = m % o), !0 }); return u > -1 && (d = a[u]), { targetNode: h, targetIndex: l, indexInList: u, infoInList: d } } return null } }; const hq = (r, e, t) => { const n = new Jm({ from: { scrollTop: r.scrollTop }, to: { scrollTop: e } }, { duration: t }); return n.on("frame", i => { let { scrollTop: s } = i; r.scrollTop = s }), n }, h0 = 1e3 / 60, p0 = /^\s*$/, Fu = "wheel"; class ts extends de { constructor() { var e; let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}; super(t), e = this, this._cacheNode = (n, i) => n && i && Object.prototype.hasOwnProperty.call(this, n) && (this[n] = i), this._cacheSelectedNode = n => this._cacheNode("selectedNode", n), this._cacheWillSelectNode = n => this._cacheNode("willSelectNode", n), this._cacheListNode = n => this._cacheNode("list", n), this._cacheSelectorNode = n => this._cacheNode("selector", n), this._cacheWrapperNode = n => this._cacheNode("wrapper", n), this._isFirst = n => { const { list: i } = this; if (ct(n) && ct(i)) { const s = i.children; return Ur(s, n) === 0 } return !1 }, this._isLast = n => { const { list: i } = this; if (ct(n) && ct(i)) { const { children: s } = i; return Ur(s, n) === s.length - 1 } return !1 }, this.indexIsSame = (n, i) => { const { list: s } = this.props; if (s.length) return n % s.length === i % s.length }, this.isDisabledIndex = n => { const { list: i } = this.props; if (Array.isArray(i) && i.length && n > -1) { const s = i.length, a = n % s; return this.isDisabledData(i[a]) } return !1 }, this.isDisabledNode = n => { const i = this.list; if (ct(n) && ct(i)) { const s = Ur(i.children, a => a === n); return this.isDisabledIndex(s) } return !1 }, this.isDisabledData = n => n && typeof n == "object" && n.disabled, this.isWheelMode = () => this.props.mode === Fu, this.addClassToNode = function (n) { let i = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : mr.SELECTED; const { list: s } = e; if (n = n || e.selectedNode, ct(n) && ct(s)) { const { children: a } = s, o = new RegExp(`\\s*${i}\\s*`, "g"); Gl(a, l => { l.className = l.className && l.className.replace(o, " "), p0.test(l.className) && (l.className = "") }), n.className && !p0.test(n.className) ? n.className += ` ${i}` : n.className = i } }, this.getIndexByNode = n => Ur(this.list.children, n), this.getNodeByIndex = n => n > -1 ? Ui(this.list.children, (s, a) => a === n) : Ui(this.list.children, s => !this.isDisabledNode(s)), this.scrollToIndex = (n, i) => { i = typeof i == "number" ? i : cu.DEFAULT_SCROLL_DURATION, n = n ?? this.props.selectedIndex, this.scrollToNode(this.selectedNode, i) }, this.scrollToNode = (n, i) => { const { wrapper: s } = this, a = s.offsetHeight, o = this.getItmHeight(n), l = (n.offsetTop || this.list.children.length * o / 2) - (a - o) / 2; this.scrollToPos(l, i) }, this.scrollToPos = function (n) { let i = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : cu.DEFAULT_SCROLL_DURATION; const { wrapper: s } = e; if (i && e.props.motion) if (e.scrollAnimation && (e.scrollAnimation.destroy(), e.scrolling = !1), s.scrollTop === n) { if (e.isWheelMode()) { const a = e.foundation.getNearestNodeInfo(e.list, e.selector); e.addClassToNode(a.nearestNode) } } else e.scrollAnimation = hq(s, n, i), e.scrollAnimation.on("rest", () => { if (e.isWheelMode()) { const a = e.foundation.getNearestNodeInfo(e.list, e.selector); e.addClassToNode(a.nearestNode) } }), e.scrollAnimation.start(); else s.scrollTop = n }, this.scrollToSelectItem = n => { const { nearestNode: i } = this.foundation.getNearestNodeInfo(this.list, this.selector); this.props.cycled && this.throttledAdjustList(n, i), this.debouncedSelect(n, i) }, this.scrollToCenter = (n, i, s) => { if (n = n || this.selectedNode, i = i || this.wrapper, ct(n) && ct(i)) { const a = i.getBoundingClientRect(), o = n.getBoundingClientRect(), l = i.scrollTop + (o.top - (a.top + a.height / 2 - o.height / 2)); this.scrollToPos(l, typeof s == "number" ? s : cu.DEFAULT_SCROLL_DURATION) } }, this.clickToSelectItem = n => { n && n.nativeEvent && n.nativeEvent.stopImmediatePropagation(); const { targetNode: i, infoInList: s } = this.foundation.getTargetNode(n, this.list); i && s && !s.disabled && this.debouncedSelect(null, i) }, this.getItmHeight = n => n && n.offsetHeight || cu.DEFAULT_ITEM_HEIGHT, this.renderItemList = function () { let n = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : ""; const { selectedIndex: i, mode: s, transform: a, list: o } = e.props; return o.map((l, u) => { const { transform: d } = l, h = typeof d == "function" ? d : a, g = i === u, m = F({ [`${mr.PREFIX}-item-sel`]: g && s !== Fu, [`${mr.PREFIX}-item-disabled`]: !!l.disabled }); let b = ""; g && typeof h == "function" ? b = h(l.value, l.text) : b = l.text == null ? l.value : l.text; const y = {}; return !e.isWheelMode() && !l.disabled && (y.onClick = () => e.foundation.selectIndex(u, e.list)), f.createElement("li", Object.assign({ key: n + u }, y, { className: m, role: "option", "aria-selected": g, "aria-disabled": l.disabled }), b) }) }, this.renderNormalList = () => { const { list: n, className: i, style: s } = this.props, a = this.renderItemList(), o = F(`${mr.PREFIX}-item`, i); return f.createElement("div", { style: s, className: o, ref: this._cacheWrapperNode }, f.createElement("ul", { role: "listbox", "aria-multiselectable": !1, "aria-label": this.props["aria-label"], ref: this._cacheListNode }, a)) }, this.renderInfiniteList = () => { const { list: n, cycled: i, className: s, style: a } = this.props, { prependCount: o, appendCount: l } = this.state, u = pd(o).reduce((x, S) => { const C = this.renderItemList(`pre_${S}_`); return x.unshift(...C), x }, []), d = pd(l).reduce((x, S) => { const C = this.renderItemList(`app_${S}_`); return x.push(...C), x }, []), h = this.renderItemList(), g = F(`${mr.PREFIX}-list-outer`, { [`${mr.PREFIX}-list-outer-nocycle`]: !i }), m = F(`${mr.PREFIX}-item-wheel`, s), b = F(`${mr.PREFIX}-selector`), y = F(`${mr.PREFIX}-shade`, `${mr.PREFIX}-shade-pre`), w = F(`${mr.PREFIX}-shade`, `${mr.PREFIX}-shade-post`); return f.createElement("div", { className: m, style: a }, f.createElement("div", { className: y }), f.createElement("div", { className: b, ref: this._cacheSelectorNode }), f.createElement("div", { className: w }), f.createElement("div", { className: g, ref: this._cacheWrapperNode, onScroll: this.scrollToSelectItem }, f.createElement("ul", { role: "listbox", "aria-label": this.props["aria-label"], "aria-multiselectable": !1, ref: this._cacheListNode, onClick: this.clickToSelectItem }, u, h, d))) }, this.state = { prependCount: 0, appendCount: 0 }, this.selectedNode = null, this.willSelectNode = null, this.list = null, this.wrapper = null, this.selector = null, this.scrollAnimation = null, this.foundation = new dq(this.adapter), this.throttledAdjustList = xo((n, i) => { this.foundation.adjustInfiniteList(this.list, this.wrapper, i) }, h0), this.debouncedSelect = $d((n, i) => { this._cacheSelectedNode(i), this.foundation.selectNode(i, this.list) }, h0 * 2) } get adapter() { var e = this; return Object.assign(Object.assign({}, super.adapter), { setState: (t, n) => this.setState(Object.assign({}, t), n), setPrependCount: t => this.setState({ prependCount: t }), setAppendCount: t => this.setState({ appendCount: t }), isDisabledIndex: this.isDisabledIndex, setSelectedNode: t => this._cacheWillSelectNode(t), notifySelectItem: function () { return e.props.onSelect(...arguments) }, scrollToCenter: this.scrollToCenter }) } componentWillUnmount() { this.props.cycled && (this.throttledAdjustList.cancel(), this.debouncedSelect.cancel()) } componentDidMount() { this.foundation.init(); const { mode: e, cycled: t, selectedIndex: n, list: i } = this.props, s = this.getNodeByIndex(typeof n == "number" && n > -1 ? n : 0); this._cacheSelectedNode(s), this._cacheWillSelectNode(s), e === Fu && t ? this.foundation.initWheelList(this.list, this.wrapper, () => { this.scrollToNode(s, 0) }) : this.scrollToNode(s, 0) } componentDidUpdate(e) { const { selectedIndex: t } = this.props; if (e.selectedIndex !== t) { const n = this.getIndexByNode(this.willSelectNode); if (!this.indexIsSame(n, t)) { const i = this.getNodeByOffset(this.selectedNode, t - e.selectedIndex, this.list); this._cacheWillSelectNode(i) } this._cacheSelectedNode(this.willSelectNode), this.scrollToIndex(t) } } getNodeByOffset(e, t, n) { const { list: i } = this.props; if (ct(e) && ct(n) && typeof t == "number" && Array.isArray(i) && i.length) { t = t % i.length; let a = this.getIndexByNode(e) + t; for (; a < 0;)a += i.length; if (t) return this.getNodeByIndex(a) } return e } render() { return this.isWheelMode() ? this.renderInfiniteList() : this.renderNormalList() } } ts.propTypes = { mode: c.oneOf(MY.MODE), cycled: c.bool, list: c.array, selectedIndex: c.number, onSelect: c.func, transform: c.func, className: c.string, style: c.object, motion: c.oneOfType([c.func, c.bool]), type: c.oneOfType([c.string, c.number]) }; ts.defaultProps = { selectedIndex: 0, motion: !0, list: [], onSelect: z, cycled: !1, mode: Fu }; class pq extends ve { } var fq = function (r, e) { var t = {}; for (var n in r) Object.prototype.hasOwnProperty.call(r, n) && e.indexOf(n) < 0 && (t[n] = r[n]); if (r != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, n = Object.getOwnPropertySymbols(r); i < n.length; i++)e.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(r, n[i]) && (t[n[i]] = r[n[i]]); return t }; class uh extends de { constructor(e) { super(e), this.foundation = new pq(this.adapter) } render() { const e = this.props, { children: t, header: n, footer: i, prefixCls: s, bodyHeight: a, className: o, style: l } = e, u = fq(e, ["children", "header", "footer", "prefixCls", "bodyHeight", "className", "style"]), d = F(o, { [s || mr.PREFIX]: !0 }), h = F({ [`${s || mr.PREFIX}-header`]: !0 }); return f.createElement("div", Object.assign({ className: d, style: l }, this.getDataAttr(u)), n ? f.createElement("div", { className: h }, f.createElement("div", { className: `${h}-title`, "x-semi-prop": this.props["x-semi-header-alias"] || "header" }, n), f.createElement("div", { className: `${d}-line` })) : null, f.createElement("div", { className: `${d}-body`, style: { height: a || "" }, "x-semi-prop": "children" }, t), i ? f.createElement("div", { className: `${d}-footer`, "x-semi-prop": this.props["x-semi-footer-alias"] || "footer" }, i) : null) } } uh.Item = ts; uh.propTypes = { className: c.string, header: c.node, footer: c.node, children: c.node, bodyHeight: c.oneOfType([c.number, c.string]) }; const z_ = 1e3 * 60 * 60, f0 = 24 * z_, bp = (r, e) => { let t = `${r}`; r < 10 && (t = `0${r}`); let n = !1; return e && e.indexOf(r) >= 0 && (n = !0), { value: t, disabled: n } }; function vp(r, e, t) { let n = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 1; const i = []; for (let s = 0; s < r; s += n)(!e || e.indexOf(s) < 0 || !t) && i.push(s); return i } class gq extends ve { constructor(e) { super(Object.assign({}, e)) } isAM() { return this.getProp("isAM") } initData() { const { timeStampValue: e, hourStep: t, disabledMinutes: n, disabledSeconds: i, hideDisabledOptions: s, minuteStep: a, secondStep: o } = this.getProps(), l = this.getValidFormat(), u = this.getDisplayDateFromTimeStamp(e), d = this.disabledHours(), h = n(u ? u.getHours() : null), g = i(u ? u.getHours() : null, u ? u.getMinutes() : null), m = vp(24, d, s, t), b = vp(60, h, s, a), y = vp(60, g, s, o); return { showHour: !!l.match(/HH|hh|H|h/g), showMinute: !!l.match(/mm/g), showSecond: !!l.match(/ss/g), hourOptions: m, minuteOptions: b, secondOptions: y } } getPosition() { const e = this.getProp("position"), t = this.getProp("type") || hn.DEFAULT_TYPE; return e || hn.DEFAULT_POSITION[t] } getDefaultFormatIfNeed() { return this._isInProps("format") ? this.getProp("format") : this.getProp("use12Hours") ? hn.DEFAULT_FORMAT_A : hn.DEFAULT_FORMAT } disabledHours() { const { use12Hours: e, disabledHours: t } = this.getProps(); let n = t && t(); return e && Array.isArray(n) && (this.isAM() ? n = n.filter(i => i < 12).map(i => i === 0 ? 12 : i) : n = n.map(i => i === 12 ? 12 : i - 12)), n } getValidFormat(e) { let t = ze(e) ? this.getProp("format") : e; return t = this.getDefaultFormatIfNeed(), t = typeof t == "string" ? t : hn.DEFAULT_FORMAT, t } getDisplayDateFromTimeStamp(e) { let t; return e && (t = new Date(e)), !e || !Yr(t) ? this.createDateDefault() : t } createDateDefault() { return new Date(parseInt(String(Date.now() / f0), 10) * f0 - 8 * z_) } } class Yl extends de { constructor(e) { super(e), this.cacheRefCurrent = (t, n) => { t && typeof t == "string" && this.adapter.setCache(t, n) }, this.reselect = () => { ["ampm", "hour", "minute", "second"].forEach(n => { const i = this.adapter.getCache(n); i && i.scrollToIndex && i.scrollToIndex() }) }, this.onItemChange = t => { let { type: n, value: i, disabled: s } = t, { onChange: a, use12Hours: o, isAM: l, format: u, timeStampValue: d } = this.props; const h = this.foundation.getDisplayDateFromTimeStamp(d); if (n === "hour") o ? l ? h.setHours(Number(i) % 12) : h.setHours(Number(i) % 12 + 12) : h.setHours(Number(i)); else if (n === "minute") h.setMinutes(Number(i)); else if (n === "ampm") { const g = i.toUpperCase(); o && (g === "PM" && (l = !1, h.getHours() < 12 && h.setHours(h.getHours() % 12 + 12)), g === "AM" && (l = !0, h.getHours() >= 12 && h.setHours(h.getHours() - 12))) } else h.setSeconds(Number(i)); a && a({ isAM: l, value: mt(h, u && u.replace(/(\s+)A/g, "$1a")), timeStampValue: Number(h) }) }, this.onEnterSelectPanel = t => { const { onCurrentSelectPanelChange: n } = this.props; n(t) }, this.getDisplayDateFromTimeStamp = t => this.foundation.getDisplayDateFromTimeStamp(t), this.foundation = new gq(this.adapter), this.state = Object.assign({}, this.foundation.initData()) } componentDidUpdate(e, t) { (e.timeStampValue !== this.props.timeStampValue || e.format !== this.props.format) && this.setState(Object.assign({}, this.foundation.initData())) } componentWillUnmount() { } componentDidMount() { } renderHourSelect(e, t) { const { prefixCls: n, disabledHours: i, use12Hours: s, scrollItemProps: a } = this.props, { showHour: o, hourOptions: l } = this.state; if (!o) return null; const u = i(); let d, h; s ? (d = [12].concat(l.filter(b => b < 12 && b > 0)), h = e % 12 || 12) : (d = l, h = e); const g = b => b + t.hour, m = `${n}-list-hour`; return f.createElement(ts, Object.assign({ ref: b => this.cacheRefCurrent("hour", b), mode: "normal", transform: g, className: m, list: d.map(b => bp(b, u)), selectedIndex: d.indexOf(h), type: "hour", onSelect: this.onItemChange }, a)) } renderMinuteSelect(e, t) { const { prefixCls: n, disabledMinutes: i, timeStampValue: s, scrollItemProps: a } = this.props, { showMinute: o, minuteOptions: l } = this.state; if (!o) return null; const u = new Date(s), d = i && i(u.getHours()), h = `${n}-list-minute`, g = m => m + t.minute; return f.createElement(ts, Object.assign({ ref: m => this.cacheRefCurrent("minute", m), mode: "normal", transform: g, list: l.map(m => bp(m, d)), selectedIndex: l.indexOf(e), type: "minute", onSelect: this.onItemChange, className: h }, a)) } renderSecondSelect(e, t) { const { prefixCls: n, disabledSeconds: i, timeStampValue: s, scrollItemProps: a } = this.props, { showSecond: o, secondOptions: l } = this.state; if (!o) return null; const u = new Date(s), d = i && i(u.getHours(), u.getMinutes()), h = `${n}-list-second`, g = m => String(m) + t.second; return f.createElement(ts, Object.assign({ ref: m => this.cacheRefCurrent("second", m), mode: "normal", transform: g, list: l.map(m => bp(m, d)), selectedIndex: l.indexOf(e), className: h, type: "second", onSelect: this.onItemChange }, a)) } renderAMPMSelect(e, t) { const { prefixCls: n, use12Hours: i, isAM: s, scrollItemProps: a } = this.props; if (!i) return null; const o = [{ value: "AM", text: e.AM || "上午" }, { value: "PM", text: e.PM || "下午" }], l = s ? 0 : 1, u = `${n}-list-ampm`; return f.createElement(ts, Object.assign({ ref: d => this.cacheRefCurrent("ampm", d), mode: "normal", className: u, list: o, selectedIndex: l, type: "ampm", onSelect: this.onItemChange }, a)) } render() { const { timeStampValue: e, panelHeader: t, panelFooter: n } = this.props, i = this.getDisplayDateFromTimeStamp(e); return f.createElement(Ke, { componentName: "TimePicker" }, (s, a) => f.createElement(uh, { header: t, footer: n, "x-semi-header-alias": "panelHeader", "x-semi-footer-alias": "panelFooter" }, this.renderAMPMSelect(s, a), this.renderHourSelect(i.getHours(), s), this.renderMinuteSelect(i.getMinutes(), s), this.renderSecondSelect(i.getSeconds(), s))) } } Yl.propTypes = { format: c.string, defaultOpenValue: c.object, prefixCls: c.string, onChange: c.func, showHour: c.bool, showMinute: c.bool, showSecond: c.bool, disabledHours: c.func, disabledMinutes: c.func, disabledSeconds: c.func, hideDisabledOptions: c.bool, onCurrentSelectPanelChange: c.func, use12Hours: c.bool, isAM: c.bool, timeStampValue: c.any, scrollItemProps: c.object }; Yl.defaultProps = { disabledHours: z, disabledMinutes: z, disabledSeconds: z, format: hn.DEFAULT_FORMAT }; class mq extends ve { constructor(e) { super(Object.assign({}, e)) } init() { } destroy() { } selectYear(e, t) { const { currentYear: n, currentMonth: i } = this.getStates(), { type: s } = this.getProps(), a = ne.PANEL_TYPE_LEFT, o = ne.PANEL_TYPE_RIGHT, l = cs(n); if (l[t] = e.value, s === "monthRange") { const u = l[a] === l[o] && i[a] > i[o]; t === a && e.value > l[o] || t === a && u ? l[o] = e.value + 1 : t === o && u && (l[a] = e.value - 1) } this._adapter.setCurrentYear(l, () => this.autoSelectMonth(e, t, l)), this._adapter.notifySelectYear(l) } selectMonth(e, t) { const { currentMonth: n, currentYear: i } = this.getStates(), { type: s } = this.getProps(), a = ne.PANEL_TYPE_LEFT, o = ne.PANEL_TYPE_RIGHT, l = cs(n); l[t] = e.month, s === "monthRange" && t === a && i[a] === i[o] && e.value > l[o] && (l[o] = e.month), this._adapter.setCurrentMonth(l), this._adapter.notifySelectMonth(l) } autoSelectMonth(e, t, n) { const { disabledDate: i, locale: s } = this._adapter.getProps(), { months: a, currentMonth: o } = this._adapter.getStates(), l = t === ne.PANEL_TYPE_LEFT ? "right" : "left", u = Cf(Date.now(), e.year), d = i(aa(u, o[t] - 1)), h = i(aa(Cf(Date.now(), n[l]), o[l] - 1)); if (!d && !h) return; let g = n, m = o; if (d) { const b = a.findIndex(w => { let { month: x } = w; return x === o[t] }); let y; y = a.slice(b).find(w => { let { month: x } = w; return !i(aa(u, x - 1)) }), y || (y = a.slice(0, b).find(w => { let { month: x } = w; return !i(aa(u, x - 1)) })), y && !h ? m[t] = y.month : y && h && (g = { left: e.year, right: e.year }, m = { left: y.month, right: y.month }) } else !d && h && (g = { left: e.year, right: e.year }, m = { left: o[t], right: o[t] }); this._adapter.setCurrentYearAndMonth(g, m), this._adapter.notifySelectYearAndMonth(g, m) } backToMain() { this._adapter.notifyBackToMain() } } const g0 = `${G}-datepicker`; class dh extends de { constructor(e) { super(e), this.selectYear = (a, o) => { this.foundation.selectYear(a, o) }, this.selectMonth = (a, o) => { this.foundation.selectMonth(a, o) }, this.reselect = () => { ["yearRef", "monthRef"].forEach(o => { const l = this[o]; l && l.current && l.current.scrollToIndex && l.current.scrollToIndex() }) }, this.backToMain = a => { a.nativeEvent.stopImmediatePropagation(), this.foundation.backToMain() }; let { currentYear: t, currentMonth: n } = e; const { year: i, month: s } = r0(t, n); this.state = { years: iG(e.startYear, e.endYear).map(a => ({ value: a, year: a })), months: Array(12).fill(0).map((a, o) => ({ value: o + 1, month: o + 1 })), currentYear: i, currentMonth: s }, this.yearRef = f.createRef(), this.monthRef = f.createRef(), this.foundation = new mq(this.adapter) } get adapter() { return Object.assign(Object.assign({}, super.adapter), { setCurrentYear: (e, t) => this.setState({ currentYear: e }, t), setCurrentMonth: e => this.setState({ currentMonth: e }), setCurrentYearAndMonth: (e, t) => this.setState({ currentYear: e, currentMonth: t }), notifySelectYear: e => this.props.onSelect({ currentMonth: this.state.currentMonth, currentYear: e }), notifySelectMonth: e => this.props.onSelect({ currentYear: this.state.currentYear, currentMonth: e }), notifySelectYearAndMonth: (e, t) => this.props.onSelect({ currentYear: e, currentMonth: t }), notifyBackToMain: () => this.props.onBackToMain() }) } static getDerivedStateFromProps(e, t) { const n = {}, { year: i, month: s } = r0(e.currentYear, e.currentMonth); return ke(e.currentYear, t.currentYear) || (n.currentYear = i), ke(e.currentMonth, t.currentMonth) || (n.currentMonth = s), n } renderColYear(e) { const { years: t, currentYear: n, currentMonth: i, months: s } = this.state, { disabledDate: a, localeCode: o, yearCycled: l, yearAndMonthOpts: u } = this.props, d = aa(Date.now(), i[e] - 1), h = ne.PANEL_TYPE_LEFT, g = ne.PANEL_TYPE_RIGHT, m = w => e === g && n[h] ? n[h] > w : !1, b = t.map(w => { let { value: x, year: S } = w; const C = s.every(E => { let { month: v } = E; return a(jS(d, { year: S, month: v - 1 })) }), O = m(S); return { year: S, value: x, disabled: C || O } }); let y = w => w; return (o === "zh-CN" || o === "zh-TW") && (y = w => `${w}年`), f.createElement(ts, Object.assign({ ref: this.yearRef, cycled: l, list: b, transform: y, selectedIndex: t.findIndex(w => w.value === n[e]), type: "year", onSelect: w => this.selectYear(w, e), mode: "normal" }, u)) } renderColMonth(e) { const { months: t, currentMonth: n, currentYear: i } = this.state, { locale: s, localeCode: a, monthCycled: o, disabledDate: l, yearAndMonthOpts: u } = this.props; let d = w => w; const h = Cf(Date.now(), i[e]), g = ne.PANEL_TYPE_LEFT, m = ne.PANEL_TYPE_RIGHT; (a === "zh-CN" || a === "zh-TW") && (d = w => `${w}月`); const b = t.map(w => { let { value: x, month: S } = w; const C = e === m && n[g] && i[g] === i[m] && n[g] > S; return { month: S, disabled: l(aa(h, S - 1)) || C, value: s.fullMonths[x] } }), y = b.findIndex(w => w.month === n[e]); return f.createElement(ts, Object.assign({ ref: this.monthRef, cycled: o, list: b, transform: d, selectedIndex: y, type: "month", onSelect: w => this.selectMonth(w, e), mode: "normal" }, u)) } renderPanel(e) { return f.createElement(f.Fragment, null, f.createElement(uh, null, this.renderColYear(e), this.renderColMonth(e))) } render() { const { locale: e, noBackBtn: t, density: n, presetPosition: i, renderQuickControls: s, renderDateInput: a, type: o } = this.props, l = `${g0}-yearmonth-header`, u = `${g0}-yearmonth-body`, d = e.selectDate, h = n === "compact" ? "default" : "large", g = n === "compact" ? "small" : "default", m = ne.PANEL_TYPE_LEFT, b = ne.PANEL_TYPE_RIGHT; let y = null; return o === "month" ? y = this.renderPanel(m) : y = f.createElement("div", { className: u }, this.renderPanel(m), this.renderPanel(b)), f.createElement(f.Fragment, null, t ? null : f.createElement("div", { className: l }, f.createElement(br, { noHorizontalPadding: !1, icon: f.createElement(bc, { "aria-hidden": !0, size: h }), size: g, onClick: this.backToMain }, f.createElement("span", null, d))), i ? f.createElement("div", { style: { display: "flex" } }, i === "left" && o !== "monthRange" && s, f.createElement("div", null, a, y), i === "right" && o !== "monthRange" && s) : f.createElement(f.Fragment, null, a, y)) } } dh.propTypes = { currentYear: c.object, currentMonth: c.object, onSelect: c.func, locale: c.object, localeCode: c.string, monthCycled: c.bool, yearCycled: c.bool, noBackBtn: c.bool, disabledDate: c.func, density: c.string, presetPosition: c.oneOf(ne.PRESET_POSITION_SET), renderQuickControls: c.node, renderDateInput: c.node, type: c.oneOf(ne.TYPE_SET), startYear: c.number, endYear: c.number }; dh.defaultProps = { disabledDate: jl, monthCycled: !1, yearCycled: !1, noBackBtn: !1, onSelect: z, type: "month" }; const Or = Ae.PREFIX; class _y extends de { constructor(e) { super(e), this.cacheRefCurrent = (o, l) => { typeof o == "string" && o.length && this.adapter.setCache(o, l) }, this.leftIsYearOrTime = o => { const { monthLeft: l } = o || this.state; return !!(l && (l.isTimePickerOpen || l.isYearPickerOpen)) }, this.rightIsYearOrTime = o => { const { monthRight: l } = o || this.state; return !!(l && (l.isTimePickerOpen || l.isYearPickerOpen)) }, this.calcScrollListHeight = () => { const o = this.adapter.getCache(`wrap-${ne.PANEL_TYPE_LEFT}`), l = this.adapter.getCache(`wrap-${ne.PANEL_TYPE_RIGHT}`), u = this.adapter.getCache(`switch-${ne.PANEL_TYPE_LEFT}`), d = this.adapter.getCache(`switch-${ne.PANEL_TYPE_RIGHT}`), h = o && o.getBoundingClientRect(), g = l && l.getBoundingClientRect(); let m = h && h.height || 0, b = g && g.height || 0; return u && (m += u.getBoundingClientRect().height), d && (b += d.getBoundingClientRect().height), Math.max(m, b) }, this.handleWeeksRowNumChange = (o, l) => { const u = l === ne.PANEL_TYPE_RIGHT, d = l === ne.PANEL_TYPE_RIGHT, h = this.leftIsYearOrTime() && this.rightIsYearOrTime(); if (this.foundation.isRangeType() && !h) { const g = { weeksRowNum: o, currentPanelHeight: this.calcScrollListHeight() }; this.setState(g, () => { (this.leftIsYearOrTime() && d || this.rightIsYearOrTime() && u) && this.reselect() }) } }, this.reselect = () => { [`timepicker-${ne.PANEL_TYPE_LEFT}`, `timepicker-${ne.PANEL_TYPE_RIGHT}`, `yam-${ne.PANEL_TYPE_LEFT}`, `yam-${ne.PANEL_TYPE_RIGHT}`].forEach(l => { const u = this.adapter.getCache(l); u && typeof u.reselect == "function" && u.reselect() }) }, this.getYAMOpenType = () => this.foundation.getYAMOpenType(); const t = e.format || Ps(e.type), { nowDate: n, nextDate: i } = O_({ defaultPickerValue: e.defaultPickerValue, format: t, dateFnsLocale: e.dateFnsLocale }), s = { selected: new Set }, a = { monthLeft: { pickerDate: n, showDate: n, isTimePickerOpen: !1, isYearPickerOpen: !1 }, monthRight: { pickerDate: i, showDate: i, isTimePickerOpen: !1, isYearPickerOpen: !1 }, maxWeekNum: 0, hoverDay: "", rangeStart: e.rangeStart, rangeEnd: "", currentPanelHeight: 0, offsetRangeStart: "", offsetRangeEnd: "" }; this.state = Object.assign(Object.assign({}, s), a), this.foundation = new DY(this.adapter) } get dateAdapter() { return { updateDaySelected: e => this.setState({ selected: e }) } } get rangeAdapter() { return { setRangeStart: e => this.setState({ rangeStart: e }), setRangeEnd: e => this.setState({ rangeEnd: e }), setHoverDay: e => this.setState({ hoverDay: e }), setWeeksHeight: e => this.setState({ maxWeekNum: e }), setOffsetRangeStart: e => this.setState({ offsetRangeStart: e }), setOffsetRangeEnd: e => this.setState({ offsetRangeEnd: e }) } } get adapter() { return Object.assign(Object.assign(Object.assign(Object.assign({}, super.adapter), this.dateAdapter), this.rangeAdapter), { updateMonthOnLeft: e => this.setState({ monthLeft: e }), updateMonthOnRight: e => this.setState({ monthRight: e }), notifySelectedChange: (e, t) => this.props.onChange(e, t), notifyMaxLimit: e => this.props.onMaxSelect(e), notifyPanelChange: (e, t) => this.props.onPanelChange(e, t), setRangeInputFocus: e => this.props.setRangeInputFocus(e), isAnotherPanelHasOpened: e => this.props.isAnotherPanelHasOpened(e) }) } componentDidMount() { super.componentDidMount() } componentDidUpdate(e, t) { const { defaultValue: n, defaultPickerValue: i } = this.props; if (e.defaultValue !== n && this.foundation.updateSelectedFromProps(n), e.defaultPickerValue !== i && this.foundation.initDefaultPickerValue(), this.foundation.isRangeType()) { const a = this.leftIsYearOrTime(t) && this.rightIsYearOrTime(t), o = this.leftIsYearOrTime(t) && !this.rightIsYearOrTime(t) || !this.leftIsYearOrTime(t) && this.rightIsYearOrTime(t), l = this.leftIsYearOrTime() && this.rightIsYearOrTime(), u = this.leftIsYearOrTime() && !this.rightIsYearOrTime() || !this.leftIsYearOrTime() && this.rightIsYearOrTime(); o && l ? this.setState({ currentPanelHeight: this.calcScrollListHeight() }, this.reselect) : a && u && this.reselect() } } renderPanel(e, t) { let n = F(`${Or}-month-grid-${t}`); const { monthLeft: i, monthRight: s, currentPanelHeight: a } = this.state, { insetInput: o } = this.props, l = t === ne.PANEL_TYPE_RIGHT ? s : i, { isTimePickerOpen: u, isYearPickerOpen: d } = l, h = this.renderMonth(e, t), g = d ? f.createElement("div", { className: `${Or}-yam` }, this.renderYearAndMonth(t, l)) : null, m = u ? f.createElement("div", { className: `${Or}-tpk` }, this.renderTimePicker(t, l)) : null, b = {}, y = this.adapter.getCache(`wrap-${ne.PANEL_TYPE_LEFT}`), w = this.adapter.getCache(`wrap-${ne.PANEL_TYPE_RIGHT}`), x = t === ne.PANEL_TYPE_RIGHT ? w : y; this.foundation.isRangeType() ? ((d || u) && (b.minWidth = x.getBoundingClientRect().width), this.leftIsYearOrTime() && this.rightIsYearOrTime() && !o && (b.minHeight = a || this.calcScrollListHeight())) : this.props.type !== "year" && this.props.type !== "month" && (u || d) && (n = F(n, `${Or}-yam-showing`)); const C = !(d || u) ? "date" : d ? "year" : "time"; return f.createElement("div", { className: n, key: t, style: b, "x-open-type": C }, g, m, this.foundation.isRangeType() ? h : d || u ? null : h, this.renderSwitch(t)) } showYearPicker(e, t) { t.nativeEvent.stopImmediatePropagation(), this.foundation.showYearPicker(e) } renderMonth(e, t) { const { selected: n, rangeStart: i, rangeEnd: s, hoverDay: a, maxWeekNum: o, offsetRangeStart: l, offsetRangeEnd: u } = this.state, { weekStartsOn: d, disabledDate: h, locale: g, localeCode: m, renderDate: b, renderFullDate: y, startDateOffset: w, endDateOffset: x, density: S, rangeInputFocus: C, syncSwitchMonth: O, multiple: E } = this.props; let v = ""; if (e) { const N = e ? mt(e, "yyyy") : "", M = e ? mt(e, "L") : "", B = g.months[M]; v = g.monthText.replace("${year}", N).replace("${month}", B) } let T = {}; const I = t === ne.PANEL_TYPE_RIGHT ? this.state.monthRight : this.state.monthLeft, k = this.foundation.isRangeType(), P = k && O; return k && I && (I.isYearPickerOpen || I.isTimePickerOpen) && (T = { visibility: "hidden", position: "absolute", pointerEvents: "none" }), f.createElement("div", { ref: N => this.cacheRefCurrent(`wrap-${t}`, N), style: T }, f.createElement(Sy, { forwardRef: N => this.cacheRefCurrent(`nav-${t}`, N), monthText: v, density: S, onMonthClick: N => this.showYearPicker(t, N), onPrevMonth: () => this.foundation.prevMonth(t), onNextMonth: () => this.foundation.nextMonth(t), onNextYear: () => this.foundation.nextYear(t), onPrevYear: () => this.foundation.prevYear(t), shouldBimonthSwitch: P, panelType: t }), f.createElement(Ey, { locale: g, localeCode: m, forwardRef: N => this.cacheRefCurrent(`month-${t}`, N), disabledDate: h, weekStartsOn: d, month: e, selected: n, rangeStart: i, rangeEnd: s, rangeInputFocus: C, offsetRangeStart: l, offsetRangeEnd: u, hoverDay: a, weeksRowNum: o, renderDate: b, renderFullDate: y, onDayClick: N => this.foundation.handleDayClick(N, t), onDayHover: N => this.foundation.handleDayHover(N, t), onWeeksRowNumChange: N => this.handleWeeksRowNumChange(N, t), startDateOffset: w, endDateOffset: x, focusRecordsRef: this.props.focusRecordsRef, multiple: E })) } renderTimePicker(e, t) { const { type: n, locale: i, format: s, hideDisabledOptions: a, timePickerOpts: o, dateFnsLocale: l } = this.props, { pickerDate: u } = t, d = F(`${Or}-time`), h = Object.assign(Object.assign({}, o), { hideDisabledOptions: a }), g = this.foundation.calcDisabledTime(e); g && ["disabledHours", "disabledMinutes", "disabledSeconds"].forEach(C => { g[C] && (h[C] = g[C]) }); const { rangeStart: m, rangeEnd: b } = this.state, y = this.foundation.getValidDateFormat(); let w, x; n === "dateTimeRange" && m && b && Mm(w = sn(m, y, void 0, l), x = sn(b, y, void 0, l)) && (e === ne.PANEL_TYPE_RIGHT ? m && (h.startDate = w) : b && (h.endDate = x)); const S = i.selectTime; return f.createElement("div", { className: d }, f.createElement(Yl, Object.assign({ ref: C => this.cacheRefCurrent(`timepicker-${e}`, C), panelHeader: S, format: s || ne.FORMAT_TIME_PICKER, timeStampValue: u, onChange: C => this.foundation.handleTimeChange(C, e) }, h))) } renderYearAndMonth(e, t) { const { pickerDate: n } = t, { locale: i, localeCode: s, density: a, yearAndMonthOpts: o, startYear: l, endYear: u } = this.props, d = n.getFullYear(), h = n.getMonth() + 1; return f.createElement(dh, { ref: g => this.cacheRefCurrent(`yam-${e}`, g), locale: i, localeCode: s, currentYear: { left: d, right: 0 }, currentMonth: { left: h, right: 0 }, onSelect: g => this.foundation.toYearMonth(e, new Date(g.currentYear.left, g.currentMonth.left - 1)), onBackToMain: () => { this.foundation.showDatePanel(e); const g = this.adapter.getCache(`wrap-${e}`); g && (g.style.height = "auto") }, density: a, yearAndMonthOpts: o, startYear: l, endYear: u }) } renderSwitch(e) { const { rangeStart: t, rangeEnd: n, monthLeft: i, monthRight: s } = this.state, { type: a, locale: o, disabledTimePicker: l, density: u, dateFnsLocale: d, insetInput: h } = this.props; if (!a.includes("Time") || h) return null; let g, m; const { FORMAT_SWITCH_DATE: b } = o.localeFormatToken, y = this.foundation.getValidTimeFormat(), w = this.foundation.getValidDateFormat(); e === ne.PANEL_TYPE_LEFT ? (g = i, m = t ? mt(sn(t, w, void 0, d), b) : "") : (g = s, m = n ? mt(sn(n, w, void 0, d), b) : ""); const { isTimePickerOpen: x, showDate: S } = g, C = S ? mt(S, b) : "", O = S ? mt(S, y) : "", E = ["default"].includes(u), v = F(`${Or}-switch`), T = F({ [`${Or}-switch-date`]: !0, [`${Or}-switch-date-active`]: !x }), I = F({ [`${Or}-switch-time`]: !0, [`${Or}-switch-time-disabled`]: l, [`${Or}-switch-date-active`]: x }), k = F(`${Or}-switch-text`); return f.createElement("div", { className: v, ref: P => this.adapter.setCache(`switch-${e}`, P) }, f.createElement("div", { role: "button", "aria-label": "Switch to date panel", className: T, onClick: P => this.foundation.showDatePanel(e) }, E && f.createElement(zS, { "aria-hidden": !0 }), f.createElement("span", { className: k }, m || C)), f.createElement("div", { role: "button", "aria-label": "Switch to time panel", className: I, onClick: P => this.foundation.showTimePicker(e, !0) }, E && f.createElement(HS, { "aria-hidden": !0 }), f.createElement("span", { className: k }, O))) } render() { const { monthLeft: e, monthRight: t } = this.state, { type: n, insetInput: i, presetPosition: s, renderQuickControls: a, renderDateInput: o } = this.props, l = F({ [`${Or}-month-grid`]: !0 }), u = ne.PANEL_TYPE_LEFT, d = ne.PANEL_TYPE_RIGHT; let h = null; n === "date" || n === "dateTime" ? h = this.renderPanel(e.pickerDate, u) : n === "dateRange" || n === "dateTimeRange" ? h = [this.renderPanel(e.pickerDate, u), this.renderPanel(t.pickerDate, d)] : (n === "year" || n === "month") && (h = "year month"); const g = this.getYAMOpenType(); return f.createElement("div", { style: { display: "flex" } }, s === "left" && a, f.createElement("div", null, o, f.createElement("div", { className: l, "x-type": n, "x-panel-yearandmonth-open-type": g, "x-insetinput": i ? "true" : "false", "x-preset-position": a === null ? "null" : s, ref: m => this.cacheRefCurrent("monthGrid", m) }, h)), s === "right" && a) } } _y.propTypes = { type: c.oneOf(ne.TYPE_SET), defaultValue: c.array, defaultPickerValue: c.oneOfType([c.string, c.number, c.object, c.array]), multiple: c.bool, max: c.number, weekStartsOn: c.number, disabledDate: c.func, disabledTime: c.func, disabledTimePicker: c.bool, hideDisabledOptions: c.bool, navPrev: c.node, navNext: c.node, onMaxSelect: c.func, timePickerOpts: c.object, isControlledComponent: c.bool, rangeStart: c.oneOfType([c.string]), rangeInputFocus: c.oneOfType([c.bool, c.string]), locale: c.object, localeCode: c.string, format: c.string, renderDate: c.func, renderFullDate: c.func, startDateOffset: c.func, endDateOffset: c.func, autoSwitchDate: c.bool, density: c.string, dateFnsLocale: c.object.isRequired, timeZone: c.oneOfType([c.string, c.number]), syncSwitchMonth: c.bool, onPanelChange: c.func, focusRecordsRef: c.object, triggerRender: c.func, presetPosition: c.oneOf(ne.PRESET_POSITION_SET), renderQuickControls: c.node, renderDateInput: c.node }; _y.defaultProps = { type: "date", rangeStart: "", multiple: !1, weekStartsOn: Oo.WEEK_START_ON, disabledDate: jl, onMaxSelect: z, locale: {} }; const pr = Ae.PREFIX, { Text: yq } = zn; class Oy extends R.PureComponent { render() { const { presets: e, onPresetClick: t, type: n, presetPosition: i, insetInput: s, locale: a } = this.props, o = n === "dateRange" || n === "dateTimeRange", l = i === "top" || i === "bottom", u = n === "month", d = l && o, h = l && u, g = F(`${pr}-quick-control`, { [`${pr}-quick-control-${n}`]: n, [`${pr}-quick-control-${i}`]: !0 }), m = F({ [`${pr}-quick-control-header`]: !0 }), b = F({ [`${pr}-quick-control-${i}-content-wrapper`]: !0 }), y = F({ [`${pr}-quick-control-${i}-content`]: !d && !h, [`${pr}-quick-control-${i}-range-content`]: d, [`${pr}-quick-control-${i}-month-content`]: h }), w = F({ [`${pr}-quick-control-${i}-content-item`]: !d && !h, [`${pr}-quick-control-${i}-range-content-item`]: d, [`${pr}-quick-control-${i}-month-content-item`]: h }), x = F({ [`${pr}-quick-control-${i}-content-item-ellipsis`]: !d && !h, [`${pr}-quick-control-${i}-range-content-item-ellipsis`]: d, [`${pr}-quick-control-${i}-month-content-item-ellipsis`]: h }); return e.length ? f.createElement("div", { className: g, "x-insetinput": s ? "true" : "false" }, !l && f.createElement("div", { className: m }, a.presets), f.createElement("div", { className: b }, f.createElement("div", { className: y }, e.map((S, C) => { const O = typeof S == "function" ? S() : S; return f.createElement(St, { size: "small", type: "primary", onClick: E => t(O, E), key: C }, f.createElement("div", { className: w }, f.createElement(yq, { ellipsis: { showTooltip: !0 }, className: x }, O.text))) })))) : null } } Oy.propTypes = { presets: c.array, presetPosition: c.oneOf(ne.PRESET_POSITION_SET), onPresetClick: c.func, type: c.string, insetInput: c.oneOfType([c.bool, c.object]), locale: c.object }; Oy.defaultProps = { presets: [], presetPosition: "bottom", onPresetClick: Ct }; function bq() { let r = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}; const { prefixCls: e, locale: t, onCancelClick: n, onConfirmClick: i } = r, s = F(`${e}-footer`); return f.createElement("div", { className: s }, f.createElement(St, { theme: "borderless", onClick: n }, H(t, "footer.cancel", "")), f.createElement(St, { theme: "solid", onClick: i }, H(t, "footer.confirm", ""))) } var vq = function (r, e) { var t = {}; for (var n in r) Object.prototype.hasOwnProperty.call(r, n) && e.indexOf(n) < 0 && (t[n] = r[n]); if (r != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, n = Object.getOwnPropertySymbols(r); i < n.length; i++)e.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(r, n[i]) && (t[n[i]] = r[n[i]]); return t }; let ya = class extends de { constructor(e) { var t; super(e), t = this, this.setTriggerRef = n => this.triggerElRef.current = n, this.handleSelectedChange = (n, i) => this.foundation.handleSelectedChange(n, i), this.handleYMSelectedChange = n => this.foundation.handleYMSelectedChange(n), this.disabledDisposeDate = function (n) { for (var i = arguments.length, s = new Array(i > 1 ? i - 1 : 0), a = 1; a < i; a++)s[a - 1] = arguments[a]; return t.foundation.disabledDisposeDate(n, ...s) }, this.disabledDisposeTime = function (n) { for (var i = arguments.length, s = new Array(i > 1 ? i - 1 : 0), a = 1; a < i; a++)s[a - 1] = arguments[a]; return t.foundation.disabledDisposeTime(n, ...s) }, this.handleOpenPanel = () => this.foundation.openPanel(), this.handleInputChange = function () { return t.foundation.handleInputChange(...arguments) }, this.handleInsetInputChange = n => this.foundation.handleInsetInputChange(n), this.handleInputComplete = n => this.foundation.handleInputComplete(n), this.handleInputBlur = n => this.foundation.handleInputBlur(H(n, "nativeEvent.target.value"), n), this.handleInputFocus = function () { return t.foundation.handleInputFocus(...arguments) }, this.handleInputClear = n => this.foundation.handleInputClear(n), this.handleTriggerWrapperClick = n => this.foundation.handleTriggerWrapperClick(n), this.handleSetRangeFocus = n => this.foundation.handleSetRangeFocus(n), this.handleRangeInputBlur = (n, i) => this.foundation.handleRangeInputBlur(n, i), this.handleRangeInputClear = n => this.foundation.handleRangeInputClear(n), this.handleRangeEndTabPress = n => this.foundation.handleRangeEndTabPress(n), this.isAnotherPanelHasOpened = n => n === "rangeStart" ? this.focusRecordsRef.current.rangeEnd : this.focusRecordsRef.current.rangeStart, this.handleInsetDateFocus = (n, i) => { const s = H(this, "monthGrid.current.foundation"); s && (s.showDatePanel(ne.PANEL_TYPE_LEFT), s.showDatePanel(ne.PANEL_TYPE_RIGHT)), this.handleInputFocus(n, i) }, this.handleInsetTimeFocus = () => { const n = H(this, "monthGrid.current.foundation"); n && (n.showTimePicker(ne.PANEL_TYPE_LEFT), n.showTimePicker(ne.PANEL_TYPE_RIGHT)) }, this.handlePanelVisibleChange = n => { this.foundation.handlePanelVisibleChange(n) }, this.handleConfirm = n => this.foundation.handleConfirm(), this.handleCancel = n => this.foundation.handleCancel(), this.renderFooter = (n, i) => this.adapter.needConfirm() ? f.createElement(bq, Object.assign({}, this.props, { locale: n, localeCode: i, onConfirmClick: this.handleConfirm, onCancelClick: this.handleCancel })) : null, this.renderPanel = (n, i, s) => { const { dropdownClassName: a, dropdownStyle: o, density: l, topSlot: u, bottomSlot: d, presetPosition: h, type: g, leftSlot: m, rightSlot: b } = this.props, y = F(Ae.PREFIX, { [Ae.PANEL_YAM]: this.adapter.typeIsYearOrMonth(), [`${Ae.PREFIX}-compact`]: l === "compact" }, a); return f.createElement("div", { ref: this.panelRef, className: y, style: o, "x-type": g }, f.createElement("div", { className: `${Ae.PREFIX}-container` }, m && f.createElement("div", { className: `${Ae.PREFIX}-leftSlot`, "x-semi-prop": "leftSlot" }, m), f.createElement("div", null, u && f.createElement("div", { className: `${Ae.PREFIX}-topSlot`, "x-semi-prop": "topSlot" }, u), h === "top" && g !== "monthRange" && this.renderQuickControls(), this.adapter.typeIsYearOrMonth() ? this.renderYearMonthPanel(n, i) : this.renderMonthGrid(n, i, s), h === "bottom" && g !== "monthRange" && this.renderQuickControls(), d && f.createElement("div", { className: `${Ae.PREFIX}-bottomSlot`, "x-semi-prop": "bottomSlot" }, d)), b && f.createElement("div", { className: `${Ae.PREFIX}-rightSlot`, "x-semi-prop": "rightSlot" }, b)), this.renderFooter(n, i)) }, this.renderYearMonthPanel = (n, i) => { const { density: s, presetPosition: a, yearAndMonthOpts: o, type: l, startYear: u, endYear: d } = this.props, h = this.state.value[0], g = { left: 0, right: 0 }, m = { left: 0, right: 0 }; if (t0(h) && (g.left = h.getFullYear(), m.left = h.getMonth() + 1), l === "monthRange") { const b = this.state.value[1]; t0(b) && (g.right = b.getFullYear(), m.right = b.getMonth() + 1) } return f.createElement(dh, { locale: n, localeCode: i, disabledDate: this.disabledDisposeDate, noBackBtn: !0, monthCycled: !0, onSelect: this.handleYMSelectedChange, currentYear: g, currentMonth: m, density: s, presetPosition: a, renderQuickControls: this.renderQuickControls(), renderDateInput: this.renderDateInput(), type: l, yearAndMonthOpts: o, startYear: u, endYear: d }) }, this.wrapPopover = n => { const { panelShow: i } = this.state, { direction: s } = this.context, a = s === "rtl" ? "bottomRight" : "bottomLeft", { motion: o, zIndex: l, position: u = a, getPopupContainer: d, locale: h, localeCode: g, dateFnsLocale: m, stopPropagation: b, autoAdjustOverflow: y, spacing: w, dropdownMargin: x } = this.props; return f.createElement(kn, { getPopupContainer: d, autoAdjustOverflow: y, zIndex: l, motion: o, margin: x, content: this.renderPanel(h, g, m), trigger: "custom", position: u, visible: i, stopPropagation: b, spacing: w, onVisibleChange: this.handlePanelVisibleChange }, n) }, this.state = { panelShow: e.open || e.defaultOpen, isRange: !1, inputValue: null, value: [], cachedSelectedValue: [], prevTimeZone: null, rangeInputFocus: void 0, autofocus: e.autoFocus || this.isRangeType(e.type, e.triggerRender) && (e.open || e.defaultOpen), insetInputValue: null, triggerDisabled: void 0 }, this.triggerElRef = f.createRef(), this.panelRef = f.createRef(), this.monthGrid = f.createRef(), this.inputRef = f.createRef(), this.rangeInputStartRef = f.createRef(), this.rangeInputEndRef = f.createRef(), this.focusRecordsRef = f.createRef(), this.focusRecordsRef.current = { rangeStart: !1, rangeEnd: !1 }, this.foundation = new WG(this.adapter) } get adapter() { var e = this; return Object.assign(Object.assign({}, super.adapter), { togglePanel: (t, n) => { this.setState({ panelShow: t }, n), t || (this.focusRecordsRef.current.rangeEnd = !1, this.focusRecordsRef.current.rangeStart = !1) }, registerClickOutSide: () => { this.clickOutSideHandler && (this.adapter.unregisterClickOutSide(), this.clickOutSideHandler = null), this.clickOutSideHandler = t => { const n = this.triggerElRef && this.triggerElRef.current, i = this.panelRef && this.panelRef.current, s = t.target, a = t.composedPath && t.composedPath() || [s]; !(n && n.contains(s)) && !(i && i.contains(s)) && !(a.includes(n) || a.includes(i)) && (this.props.onClickOutSide(t), this.adapter.needConfirm() || this.foundation.closePanel()) }, document.addEventListener("mousedown", this.clickOutSideHandler) }, unregisterClickOutSide: () => { document.removeEventListener("mousedown", this.clickOutSideHandler) }, notifyBlur: function () { return e.props.onBlur(...arguments) }, notifyFocus: function () { return e.props.onFocus(...arguments) }, notifyClear: function () { return e.props.onClear(...arguments) }, notifyChange: function () { return e.props.onChange(...arguments) }, notifyCancel: function () { return e.props.onCancel(...arguments) }, notifyConfirm: function () { return e.props.onConfirm(...arguments) }, notifyOpenChange: function () { return e.props.onOpenChange(...arguments) }, notifyPresetsClick: function () { return e.props.onPresetClick(...arguments) }, updateValue: t => this.setState({ value: t }), updatePrevTimezone: t => this.setState({ prevTimeZone: t }), updateCachedSelectedValue: t => { let n = t; t && !Array.isArray(t) && (n = [...t]), this.setState({ cachedSelectedValue: n }) }, updateInputValue: t => { this.setState({ inputValue: t }) }, updateInsetInputValue: t => { const { insetInput: n } = this.props; n && !ke(t, this.state.insetInputValue) && this.setState({ insetInputValue: t }) }, needConfirm: () => ["dateTime", "dateTimeRange"].includes(this.props.type) && this.props.needConfirm === !0, typeIsYearOrMonth: () => ["month", "year", "monthRange"].includes(this.props.type), setRangeInputFocus: t => { const { preventScroll: n } = this.props; switch (t !== this.state.rangeInputFocus && this.setState({ rangeInputFocus: t }), t) { case "rangeStart": const i = H(this, "rangeInputStartRef.current"); i && i.focus({ preventScroll: n }), setTimeout(() => { this.focusRecordsRef.current.rangeStart = !0 }, 0); break; case "rangeEnd": const s = H(this, "rangeInputEndRef.current"); s && s.focus({ preventScroll: n }), setTimeout(() => { this.focusRecordsRef.current.rangeEnd = !0 }, 0); break; default: return } }, couldPanelClosed: () => this.focusRecordsRef.current.rangeStart && this.focusRecordsRef.current.rangeEnd, isEventTarget: t => t && t.target === t.currentTarget, setInsetInputFocus: () => { const { preventScroll: t } = this.props, { rangeInputFocus: n } = this.state; switch (n) { case "rangeEnd": if (document.activeElement !== this.rangeInputEndRef.current) { const i = H(this, "rangeInputEndRef.current"); i && i.focus({ preventScroll: t }) } break; case "rangeStart": default: if (document.activeElement !== this.rangeInputStartRef.current) { const i = H(this, "rangeInputStartRef.current"); i && i.focus({ preventScroll: t }) } break } }, setInputFocus: () => { const { preventScroll: t } = this.props, n = H(this, "inputRef.current"); n && n.focus({ preventScroll: t }) }, setInputBlur: () => { const t = H(this, "inputRef.current"); t && t.blur() }, setRangeInputBlur: () => { const { rangeInputFocus: t } = this.state; if (t === "rangeStart") { const n = H(this, "rangeInputStartRef.current"); n && n.blur() } else if (t === "rangeEnd") { const n = H(this, "rangeInputEndRef.current"); n && n.blur() } this.adapter.setRangeInputFocus(!1) }, setTriggerDisabled: t => { this.setState({ triggerDisabled: t }) } }) } isRangeType(e, t) { return /range/i.test(e) && !we(t) } componentDidUpdate(e) { ke(e.value, this.props.value) ? this.props.timeZone !== e.timeZone && this.foundation.initFromProps({ value: this.state.value, timeZone: this.props.timeZone, prevTimeZone: e.timeZone }) : this.foundation.initFromProps(Object.assign({}, this.props)), e.open !== this.props.open && (this.foundation.initPanelOpenStatus(), this.props.open || this.foundation.clearRangeInputFocus()) } componentDidMount() { this._mounted = !0, super.componentDidMount() } componentWillUnmount() { this._mounted = !1, super.componentWillUnmount() } open() { this.foundation.open() } close() { this.foundation.close() } focus(e) { this.foundation.focus(e) } blur() { this.foundation.blur() } renderMonthGrid(e, t, n) { const { type: i, multiple: s, max: a, weekStartsOn: o, timePickerOpts: l, defaultPickerValue: u, format: d, hideDisabledOptions: h, disabledTimePicker: g, renderDate: m, renderFullDate: b, startDateOffset: y, endDateOffset: w, autoSwitchDate: x, density: S, syncSwitchMonth: C, onPanelChange: O, timeZone: E, triggerRender: v, insetInput: T, presetPosition: I, yearAndMonthOpts: k, startYear: P, endYear: N } = this.props, { cachedSelectedValue: M, rangeInputFocus: B } = this.state, K = M; return f.createElement(_y, { ref: this.monthGrid, locale: e, localeCode: t, dateFnsLocale: n, weekStartsOn: o, type: i, multiple: s, max: a, format: d, disabledDate: this.disabledDisposeDate, hideDisabledOptions: h, disabledTimePicker: g, disabledTime: this.disabledDisposeTime, defaultValue: K, defaultPickerValue: u, timePickerOpts: l, isControlledComponent: !this.adapter.needConfirm() && this.isControlled("value"), onChange: this.handleSelectedChange, renderDate: m, renderFullDate: b, startDateOffset: y, endDateOffset: w, autoSwitchDate: x, density: S, rangeInputFocus: B, setRangeInputFocus: this.handleSetRangeFocus, isAnotherPanelHasOpened: this.isAnotherPanelHasOpened, syncSwitchMonth: C, onPanelChange: O, timeZone: E, focusRecordsRef: this.focusRecordsRef, triggerRender: v, insetInput: T, presetPosition: I, renderQuickControls: this.renderQuickControls(), renderDateInput: this.renderDateInput(), yearAndMonthOpts: k, startYear: P, endYear: N }) } renderQuickControls() { const { presets: e, type: t, presetPosition: n, insetInput: i, locale: s } = this.props; return f.createElement(Oy, { type: t, presets: e, insetInput: i, presetPosition: n, onPresetClick: (a, o) => this.foundation.handlePresetClick(a, o), locale: s }) } renderDateInput() { const { insetInput: e, dateFnsLocale: t, density: n, type: i, format: s, rangeSeparator: a, defaultPickerValue: o } = this.props, { insetInputValue: l, value: u } = this.state, d = { dateFnsLocale: t, format: s, insetInputValue: l, rangeSeparator: a, type: i, value: u, handleInsetDateFocus: this.handleInsetDateFocus, handleInsetTimeFocus: this.handleInsetTimeFocus, onInsetInputChange: this.handleInsetInputChange, rangeInputStartRef: this.rangeInputStartRef, rangeInputEndRef: this.rangeInputEndRef, density: n, defaultPickerValue: o }; return e ? f.createElement(hd, Object.assign({}, d, { insetInput: e })) : null } renderInner(e) { const { clearIcon: t, type: n, format: i, multiple: s, disabled: a, showClear: o, insetLabel: l, insetLabelId: u, placeholder: d, validateStatus: h, inputStyle: g, prefix: m, locale: b, dateFnsLocale: y, triggerRender: w, size: x, inputReadOnly: S, rangeSeparator: C, insetInput: O, defaultPickerValue: E, borderless: v } = this.props, { value: T, inputValue: I, rangeInputFocus: k, triggerDisabled: P } = this.state, N = this.isRangeType(n, w), M = a || O && P, B = F(`${Ae.PREFIX}-input`, { [`${Ae.PREFIX}-range-input`]: N, [`${Ae.PREFIX}-range-input-${x}`]: N && x, [`${Ae.PREFIX}-range-input-active`]: N && k && !M, [`${Ae.PREFIX}-range-input-disabled`]: N && M, [`${Ae.PREFIX}-range-input-${h}`]: N && h, [`${Ae.PREFIX}-borderless`]: v }), K = d || b.placeholder[n], U = Object.assign(Object.assign({}, e), { showClearIgnoreDisabled: !!O, placeholder: K, clearIcon: t, disabled: M, inputValue: I, value: T, defaultPickerValue: E, onChange: this.handleInputChange, onEnterPress: this.handleInputComplete, block: !0, inputStyle: g, showClear: o, insetLabel: l, insetLabelId: u, type: n, format: i, multiple: s, validateStatus: h, inputReadOnly: S || !!O, onBlur: this.handleInputBlur, onFocus: this.handleInputFocus, onClear: this.handleInputClear, prefix: m, size: x, autofocus: this.state.autofocus, dateFnsLocale: y, rangeInputFocus: k, rangeSeparator: C, onRangeBlur: this.handleRangeInputBlur, onRangeClear: this.handleRangeInputClear, onRangeEndTabPress: this.handleRangeEndTabPress, rangeInputStartRef: O ? null : this.rangeInputStartRef, rangeInputEndRef: O ? null : this.rangeInputEndRef, inputRef: this.inputRef }); return f.createElement("div", { role: "combobox", "aria-label": Array.isArray(T) && T.length ? "Change date" : "Choose date", "aria-disabled": a, onClick: this.handleTriggerWrapperClick, className: B }, typeof w == "function" ? f.createElement(Ia, Object.assign({}, U, { triggerRender: w, componentName: "DatePicker", componentProps: Object.assign({}, this.props) })) : f.createElement(hd, Object.assign({}, U))) } render() { const e = this.props, { style: t, className: n, prefixCls: i, type: s } = e, a = vq(e, ["style", "className", "prefixCls", "type"]), o = Object.assign({ style: t, className: F(n, { [i]: !0 }), ref: this.setTriggerRef, "aria-invalid": this.props["aria-invalid"], "aria-errormessage": this.props["aria-errormessage"], "aria-labelledby": this.props["aria-labelledby"], "aria-describedby": this.props["aria-describedby"], "aria-required": this.props["aria-required"] }, this.getDataAttr(a)), l = []; s.toLowerCase().includes("range") || l.push("borderless"); const u = this.renderInner(cr(this.props, l)), d = this.wrapPopover(u); return f.createElement("div", Object.assign({}, o), d) } }; ya.contextType = An; ya.propTypes = { "aria-describedby": c.string, "aria-errormessage": c.string, "aria-invalid": c.bool, "aria-labelledby": c.string, "aria-required": c.bool, borderless: c.bool, type: c.oneOf(ne.TYPE_SET), size: c.oneOf(ne.SIZE_SET), clearIcon: c.node, density: c.oneOf(ne.DENSITY_SET), defaultValue: c.oneOfType([c.string, c.number, c.object, c.array]), value: c.oneOfType([c.string, c.number, c.object, c.array]), defaultPickerValue: c.oneOfType([c.string, c.number, c.object, c.array]), disabledTime: c.func, disabledTimePicker: c.bool, hideDisabledOptions: c.bool, format: c.string, disabled: c.bool, multiple: c.bool, max: c.number, placeholder: c.oneOfType([c.string, c.array]), presets: c.array, presetPosition: c.oneOf(ne.PRESET_POSITION_SET), onChange: c.func, onChangeWithDateFirst: c.bool, weekStartsOn: c.number, disabledDate: c.func, timePickerOpts: c.object, showClear: c.bool, onOpenChange: c.func, open: c.bool, defaultOpen: c.bool, motion: c.oneOfType([c.bool, c.func, c.object]), className: c.string, prefixCls: c.string, prefix: c.node, insetLabel: c.node, insetLabelId: c.string, zIndex: c.number, position: c.oneOf(ha.POSITION_SET), getPopupContainer: c.func, onCancel: c.func, onConfirm: c.func, needConfirm: c.bool, inputStyle: c.object, timeZone: c.oneOfType([c.string, c.number]), triggerRender: c.func, stopPropagation: c.oneOfType([c.bool, c.string]), autoAdjustOverflow: c.bool, onBlur: c.func, onFocus: c.func, onClear: c.func, style: c.object, autoFocus: c.bool, inputReadOnly: c.bool, validateStatus: c.oneOf(ne.STATUS), renderDate: c.func, renderFullDate: c.func, spacing: c.oneOfType([c.number, c.object]), startDateOffset: c.func, endDateOffset: c.func, autoSwitchDate: c.bool, dropdownClassName: c.string, dropdownStyle: c.object, dropdownMargin: c.oneOfType([c.number, c.object]), topSlot: c.node, bottomSlot: c.node, dateFnsLocale: c.object, syncSwitchMonth: c.bool, onPanelChange: c.func, rangeSeparator: c.string, preventScroll: c.bool, yearAndMonthOpts: c.object, onClickOutSide: c.func }; ya.__SemiComponentName__ = "DatePicker"; ya.defaultProps = xn(ya.__SemiComponentName__, { onChangeWithDateFirst: !0, borderless: !1, autoAdjustOverflow: !0, stopPropagation: !0, motion: !0, prefixCls: Ae.PREFIX, presetPosition: "bottom", zIndex: Cr.DEFAULT_Z_INDEX, type: "date", size: "default", density: "default", multiple: !1, defaultOpen: !1, disabledHours: z, disabledMinutes: z, disabledSeconds: z, hideDisabledOptions: !1, onBlur: z, onFocus: z, onClear: z, onCancel: z, onConfirm: z, onChange: z, onOpenChange: z, onPanelChange: z, onPresetClick: z, weekStartsOn: Oo.WEEK_START_ON, disabledDate: jl, disabledTime: jl, inputReadOnly: !1, spacing: Oo.SPACING, autoSwitchDate: !0, syncSwitchMonth: !1, rangeSeparator: ne.DEFAULT_SEPARATOR_RANGE, insetInput: !1, onClickOutSide: z }); const xq = c_(f.forwardRef((r, e) => { const t = Object.assign({}, r), { type: n, format: i, rangeSeparator: s } = t; return typeof i == "string" && i && (/[Hhms]+/.test(i) || (n === "dateTime" ? t.type = "date" : n === "dateTimeRange" && (t.type = "dateRange"))), s && typeof s == "string" && (t.rangeSeparator = ` ${s.trim()} `), t.insetInput && (t.position || (t.position = ne.POSITION_INLINE_INPUT), t.position.includes("Over") && !t.spacing && (t.spacing = Oo.SPACING_INSET_INPUT)), f.createElement(An.Consumer, null, a => { let { timeZone: o } = a; return f.createElement(Ke, { componentName: "DatePicker" }, (l, u, d) => f.createElement(ya, Object.assign({ timeZone: o, localeCode: u, locale: l, dateFnsLocale: d }, t, { ref: e }))) }) }), ya), H_ = { PREFIX: `${G}-descriptions` }, xp = { ALIGN_SET: ["left", "justify", "plain", "center"], SIZE_SET: ["small", "medium", "large"], LAYOUT_SET: ["horizontal", "vertical"] }, Ty = f.createContext(null); var wq = function (r, e) { var t = {}; for (var n in r) Object.prototype.hasOwnProperty.call(r, n) && e.indexOf(n) < 0 && (t[n] = r[n]); if (r != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, n = Object.getOwnPropertySymbols(r); i < n.length; i++)e.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(r, n[i]) && (t[n[i]] = r[n[i]]); return t }; const ia = H_.PREFIX, m0 = `${ia}-key`, y0 = `${ia}-value`; let Xl = class extends R.PureComponent { render() { const e = this.props, { itemKey: t, hidden: n, className: i, span: s, style: a, children: o } = e, l = wq(e, ["itemKey", "hidden", "className", "span", "style", "children"]), { align: u, layout: d } = this.context; if (n) return null; const h = f.createElement("td", { className: `${ia}-item`, colSpan: s || 1 }, f.createElement("span", { className: m0 }, t, ":"), f.createElement("span", { className: y0 }, typeof o == "function" ? o() : o)), g = f.createElement(f.Fragment, null, f.createElement("th", { className: `${ia}-item ${ia}-item-th` }, f.createElement("span", { className: m0 }, t)), f.createElement("td", { className: `${ia}-item ${ia}-item-td`, colSpan: s ? s * 2 - 1 : 1 }, f.createElement("span", { className: y0 }, typeof o == "function" ? o() : o))), m = u === "plain" ? f.createElement("tr", Object.assign({ className: i, style: a }, Xr(l)), h) : f.createElement("tr", Object.assign({ className: i, style: a }, Xr(l)), g); return d === "horizontal" ? u === "plain" ? h : g : m } }; Xl.propTypes = { itemKey: c.node, hidden: c.bool, className: c.string, style: c.object }; Xl.contextType = Ty; class Cq extends ve { constructor(e) { super(Object.assign({}, e)) } getHorizontalList() { const { column: e, data: t, children: n } = this.getProps(), i = this._adapter.getColumns(), s = [], a = { totalSpan: 0, itemList: [] }; for (const o of i) a.totalSpan += o.span || 1, a.itemList.push(o), a.totalSpan >= e && (s.push(a.itemList), a.itemList = [], a.totalSpan = 0); if (a.itemList.length != 0) { const o = a.itemList[a.itemList.length - 1]; if (isNaN(o.span)) { let l = 0; a.itemList.forEach(u => l += isNaN(u.span) ? 1 : u.span), l < e && (o.span = e - l + 1) } s.push(a.itemList) } return s } } var Sq = function (r, e) { var t = {}; for (var n in r) Object.prototype.hasOwnProperty.call(r, n) && e.indexOf(n) < 0 && (t[n] = r[n]); if (r != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, n = Object.getOwnPropertySymbols(r); i < n.length; i++)e.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(r, n[i]) && (t[n[i]] = r[n[i]]); return t }; const Ga = H_.PREFIX; class hh extends de { constructor(e) { super(e), this.renderChildrenList = () => { const t = this.props, { layout: n, data: i, children: s } = t; return n === "horizontal" ? this.foundation.getHorizontalList().map((o, l) => f.createElement("tr", { key: l }, o.map((u, d) => Wu(u) ? f.createElement(Xl, Object.assign({ itemKey: u.key }, u, { key: l + "-" + d }), u.value) : null))) : i && i.length ? i.map((a, o) => Wu(a) ? f.createElement(Xl, Object.assign({ itemKey: a.key }, a, { key: o }), a.value) : null) : s }, this.foundation = new Cq(this.adapter) } get adapter() { return Object.assign(Object.assign({}, super.adapter), { getColumns: () => { var e, t; return !((e = this.props.data) === null || e === void 0) && e.length ? this.props.data : this.props.children ? (t = f.Children.toArray(this.props.children)) === null || t === void 0 ? void 0 : t.map(n => R.isValidElement(n) ? Object.assign({ value: n.props.children }, n.props) : []) : [] } }) } render() { const e = this.props, { align: t, row: n, size: i, className: s, style: a, children: o, data: l, layout: u } = e, d = Sq(e, ["align", "row", "size", "className", "style", "children", "data", "layout"]), h = F(Ga, s, { [`${Ga}-${t}`]: !n, [`${Ga}-double`]: n, [`${Ga}-double-${i}`]: n, [`${Ga}-horizontal`]: u === "horizontal", [`${Ga}-vertical`]: u === "vertical" }); return f.createElement("div", Object.assign({ className: h, style: a }, Xr(d)), f.createElement("table", null, f.createElement("tbody", null, f.createElement(Ty.Provider, { value: { align: t, layout: u } }, this.renderChildrenList())))) } } hh.Item = Xl; hh.contextType = Ty; hh.propTypes = { align: c.oneOf(xp.ALIGN_SET), row: c.bool, size: c.oneOf(xp.SIZE_SET), style: c.object, className: c.string, data: c.arrayOf(c.shape({ key: c.node, value: c.oneOfType([c.node, c.func]), hidden: c.bool, className: c.string, style: c.object })), layout: c.oneOf(xp.LAYOUT_SET), column: c.number }; hh.defaultProps = { align: "center", row: !1, size: "medium", data: [], layout: "vertical", column: 3 }; const Eq = { PREFIX: `${G}` }; var _q = function (r, e) { var t = {}; for (var n in r) Object.prototype.hasOwnProperty.call(r, n) && e.indexOf(n) < 0 && (t[n] = r[n]); if (r != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, n = Object.getOwnPropertySymbols(r); i < n.length; i++)e.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(r, n[i]) && (t[n[i]] = r[n[i]]); return t }; const Gs = Eq.PREFIX, Pg = r => { const { layout: e = "horizontal", dashed: t, align: n = "center", className: i, margin: s, style: a, children: o } = r, l = _q(r, ["layout", "dashed", "align", "className", "margin", "style", "children"]), u = F(`${Gs}-divider`, i, { [`${Gs}-divider-horizontal`]: e === "horizontal", [`${Gs}-divider-vertical`]: e === "vertical", [`${Gs}-divider-dashed`]: !!t, [`${Gs}-divider-with-text`]: o && e === "horizontal", [`${Gs}-divider-with-text-${n}`]: o && e === "horizontal" }); let d = {}; return s !== void 0 && (e === "vertical" ? d = { marginLeft: s, marginRight: s } : e === "horizontal" && (d = { marginTop: s, marginBottom: s })), f.createElement("div", Object.assign({}, l, { className: u, style: Object.assign(Object.assign({}, d), a) }), o && e === "horizontal" ? typeof o == "string" ? f.createElement("span", { className: `${Gs}-divider_inner-text`, "x-semi-prop": "children" }, o) : o : null) }, bt = { DIALOG: `${G}-modal` }, b0 = { cancelKey: "cancel", confirmKey: "confirm", SIZE: ["small", "medium", "large", "full-width"], directions: ["ltr", "rtl"] }; function Oq(r) { return r !== null && typeof r == "object" } function ba(r) { return Oq(r) && typeof r.then == "function" } class Tq extends ve { constructor(e) { super(Object.assign({}, e)), this.toggleDisplayNone = (t, n) => { this._adapter.toggleDisplayNone(t, n) } } destroy() { this.afterHide() } handleCancel(e) { var t; const n = this._adapter.notifyCancel(e); ba(n) && (this._adapter.setState({ onCancelReturnPromiseStatus: "pending" }), (t = n == null ? void 0 : n.then(() => { this._adapter.setState({ onCancelReturnPromiseStatus: "fulfilled" }) })) === null || t === void 0 || t.catch(i => { throw this._adapter.setState({ onCancelReturnPromiseStatus: "rejected" }), i })) } handleOk(e) { var t; const n = this._adapter.notifyOk(e); ba(n) && (this._adapter.setState({ onOKReturnPromiseStatus: "pending" }), (t = n == null ? void 0 : n.then(() => { this._adapter.setState({ onOKReturnPromiseStatus: "fulfilled" }) })) === null || t === void 0 || t.catch(i => { throw this._adapter.setState({ onOKReturnPromiseStatus: "rejected" }), i })) } beforeShow() { this._adapter.disabledBodyScroll() } afterHide() { this._adapter.enabledBodyScroll(), this._adapter.notifyClose() } enabledBodyScroll() { this._adapter.enabledBodyScroll() } } class Iy extends ve { constructor(e) { super(Object.assign(Object.assign({}, Iy.defaultAdapter), e)), this.handleKeyDown = t => { const { closeOnEsc: n } = this.getProps(); if (n && t.keyCode === Tn.ESC) { t.stopPropagation(), this.close(t); return } } } destroy() { this.handleKeyDownEventListenerUnmount(), this.modalDialogBlur(), this.prevFocusElementReFocus() } handleDialogMouseDown() { this._adapter.notifyDialogMouseDown() } handleMaskMouseUp() { this._adapter.notifyDialogMouseUp() } handleKeyDownEventListenerMount() { this._adapter.addKeyDownEventListener() } handleKeyDownEventListenerUnmount() { this._adapter.removeKeyDownEventListener() } getMouseState() { this._adapter.getMouseState() } handleMaskClick(e) { const { dialogMouseDown: t } = this.getStates(); e.target === e.currentTarget && !t && this.close(e) } close(e) { this._adapter.notifyClose(e) } modalDialogFocus() { this._adapter.modalDialogFocus() } modalDialogBlur() { this._adapter.modalDialogBlur() } prevFocusElementReFocus() { this._adapter.prevFocusElementReFocus() } } var Iq = mE, Pq = Hd, kq = Cm, Rq = Pq(function (r, e) { return kq(r) ? Iq(r, e) : [] }), Dq = Rq; const Aq = _e(Dq); class ks { constructor(e, t) { var n; this.addFocusRedirectListener = i => (this.focusRedirectListenerList.push(i), () => this.removeFocusRedirectListener(i)), this.removeFocusRedirectListener = i => { this.focusRedirectListenerList = Aq(this.focusRedirectListenerList, i) }, this.destroy = () => { var i; (i = this.container) === null || i === void 0 || i.removeEventListener("keydown", this.onKeyPress) }, this.shouldFocusRedirect = i => { if (!this.enable) return !1; for (const s of this.focusRedirectListenerList) if (!s(i)) return !1; return !0 }, this.focusElement = (i, s) => { const { preventScroll: a } = this.options; i == null || i.focus({ preventScroll: a }), s.preventDefault() }, this.onKeyPress = i => { if (i && i.key === "Tab") { const s = ks.getFocusableElements(this.container); s.length && (i.shiftKey ? this.handleContainerShiftTabKeyDown(s, i) : this.handleContainerTabKeyDown(s, i)) } }, this.handleContainerTabKeyDown = (i, s) => { const a = ks.getActiveElement(), o = i[i.length - 1] === a, l = i[0]; o && this.shouldFocusRedirect(l) && this.focusElement(l, s) }, this.handleContainerShiftTabKeyDown = (i, s) => { const a = ks.getActiveElement(), o = i[0] === a, l = i[i.length - 1]; o && this.shouldFocusRedirect(l) && this.focusElement(l, s) }, Object.freeze(t), this.container = e, this.options = t, this.enable = (n = t == null ? void 0 : t.enable) !== null && n !== void 0 ? n : !0, this.focusRedirectListenerList = t != null && t.onFocusRedirectListener ? Array.isArray(t.onFocusRedirectListener) ? [...t.onFocusRedirectListener] : [t.onFocusRedirectListener] : [], this.container.addEventListener("keydown", this.onKeyPress) } get enable() { return this._enable } set enable(e) { this._enable = e } static getFocusableElements(e) { if (!ct(e)) return []; const n = ["input:not([disabled]):not([tabindex='-1'])", "textarea:not([disabled]):not([tabindex='-1'])", "button:not([disabled]):not([tabindex='-1'])", "a[href]:not([tabindex='-1'])", "select:not([disabled]):not([tabindex='-1'])", "area[href]:not([tabindex='-1'])", "iframe:not([tabindex='-1'])", "object:not([tabindex='-1'])", "*[tabindex]:not([tabindex='-1'])", "*[contenteditable]:not([tabindex='-1'])"].join(","); return Array.from(e.querySelectorAll(n)) } static getActiveElement() { return document ? document.activeElement : null } } var wp = function (r, e) { var t = {}; for (var n in r) Object.prototype.hasOwnProperty.call(r, n) && e.indexOf(n) < 0 && (t[n] = r[n]); if (r != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, n = Object.getOwnPropertySymbols(r); i < n.length; i++)e.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(r, n[i]) && (t[n[i]] = r[n[i]]); return t }; let Nq = 0; class ph extends de { constructor(e) { super(e), this.onKeyDown = t => { this.foundation.handleKeyDown(t) }, this.onDialogMouseDown = () => { this.foundation.handleDialogMouseDown() }, this.onMaskMouseUp = () => { this.foundation.handleMaskMouseUp() }, this.onMaskClick = t => { this.foundation.handleMaskClick(t) }, this.close = t => { this.foundation.close(t) }, this.getMaskElement = () => { const t = wp(this.props, []), { mask: n, maskClassName: i } = t; if (n) { const s = F(`${bt.DIALOG}-mask`, {}); return f.createElement("div", Object.assign({ key: "mask" }, this.props.maskExtraProps, { className: F(s, i), style: t.maskStyle })) } return null }, this.renderCloseBtn = () => { const { closable: t, closeIcon: n } = this.props; let i; if (t) { const s = n || f.createElement(ds, { "x-semi-prop": "closeIcon" }); i = f.createElement(br, { "aria-label": "close", className: `${bt.DIALOG}-close`, key: "close-btn", onClick: this.close, type: "tertiary", icon: s, theme: "borderless", size: "small" }) } return i }, this.renderIcon = () => { const { icon: t } = this.props; return t ? f.createElement("span", { className: `${bt.DIALOG}-icon-wrapper`, "x-semi-prop": "icon" }, t) : null }, this.renderHeader = () => { if ("header" in this.props) return this.props.header; const { title: t } = this.props, n = this.renderCloseBtn(), i = this.renderIcon(); return t == null ? null : f.createElement("div", { className: `${bt.DIALOG}-header` }, i, f.createElement(zn.Title, { heading: 5, className: `${bt.DIALOG}-title`, id: `${bt.DIALOG}-title`, "x-semi-prop": "title" }, t), n) }, this.renderBody = () => { const { bodyStyle: t, children: n, title: i } = this.props, s = F(`${bt.DIALOG}-body`, { [`${bt.DIALOG}-withIcon`]: this.props.icon }), a = this.renderCloseBtn(), o = this.renderIcon(); return i != null || "header" in this.props ? f.createElement("div", { className: s, id: `${bt.DIALOG}-body`, style: t, "x-semi-prop": "children" }, n) : f.createElement("div", { className: `${bt.DIALOG}-body-wrapper` }, o, f.createElement("div", { className: s, style: t, "x-semi-prop": "children" }, n), a) }, this.getDialogElement = () => { const t = wp(this.props, []), n = {}, i = F(`${bt.DIALOG}`, { [`${bt.DIALOG}-centered`]: t.centered, [`${bt.DIALOG}-${t.size}`]: t.size }); t.width && (n.width = t.width), t.height && (n.height = t.height), t.isFullScreen && (n.width = "100%", n.height = "100%", n.margin = "unset"); const s = this.renderBody(), a = this.renderHeader(), o = t.footer ? f.createElement("div", { className: `${bt.DIALOG}-footer`, "x-semi-prop": "footer" }, t.footer) : null; return f.createElement("div", { key: "dialog-element", className: i, onMouseDown: this.onDialogMouseDown, style: Object.assign(Object.assign({}, t.style), n), id: this.dialogId }, f.createElement("div", { role: "dialog", ref: this.modalDialogRef, "aria-modal": "true", "aria-labelledby": `${bt.DIALOG}-title`, "aria-describedby": `${bt.DIALOG}-body`, onAnimationEnd: t.onAnimationEnd, className: F([`${bt.DIALOG}-content`, t.contentClassName, { [`${bt.DIALOG}-content-fullScreen`]: t.isFullScreen }]) }, a, s, o)) }, this.state = { dialogMouseDown: !1, prevFocusElement: ks.getActiveElement() }, this.foundation = new Iy(this.adapter), this.dialogId = `dialog-${Nq++}`, this.modalDialogRef = f.createRef() } get adapter() { return Object.assign(Object.assign({}, super.adapter), { notifyClose: e => { this.props.onClose(e) }, notifyDialogMouseDown: () => { this.setState({ dialogMouseDown: !0 }) }, notifyDialogMouseUp: () => { this.state.dialogMouseDown && (this.timeoutId = setTimeout(() => { this.setState({ dialogMouseDown: !1 }) }, 0)) }, addKeyDownEventListener: () => { this.props.closeOnEsc && document.addEventListener("keydown", this.foundation.handleKeyDown) }, removeKeyDownEventListener: () => { this.props.closeOnEsc && document.removeEventListener("keydown", this.foundation.handleKeyDown) }, getMouseState: () => this.state.dialogMouseDown, modalDialogFocus: () => { var e, t, n; const { preventScroll: i } = this.props; let s; if (this.modalDialogRef) { const a = ks.getActiveElement(); s = this.modalDialogRef.current.contains(a), (e = this.focusTrapHandle) === null || e === void 0 || e.destroy(), this.focusTrapHandle = new ks(this.modalDialogRef.current, { preventScroll: i }) } s || (n = (t = this.modalDialogRef) === null || t === void 0 ? void 0 : t.current) === null || n === void 0 || n.focus({ preventScroll: i }) }, modalDialogBlur: () => { var e, t; (e = this.modalDialogRef) === null || e === void 0 || e.current.blur(), (t = this.focusTrapHandle) === null || t === void 0 || t.destroy() }, prevFocusElementReFocus: () => { const { prevFocusElement: e } = this.state, { preventScroll: t } = this.props, n = H(e, "focus"); we(n) && e.focus({ preventScroll: t }) } }) } componentDidMount() { var e; this.foundation.handleKeyDownEventListenerMount(), this.foundation.modalDialogFocus(); const t = ks.getFocusableElements(this.modalDialogRef.current); this.modalDialogRef.current.contains(document.activeElement) || (e = t[0]) === null || e === void 0 || e.focus() } componentWillUnmount() { clearTimeout(this.timeoutId), this.foundation.destroy() } render() { var e; const t = this.props, { maskClosable: n, className: i, getPopupContainer: s, maskFixed: a, getContainerContext: o } = t, l = wp(t, ["maskClosable", "className", "getPopupContainer", "maskFixed", "getContainerContext"]), { direction: u } = this.context, d = F(i, { [`${bt.DIALOG}-popup`]: s && s() !== ((e = globalThis == null ? void 0 : globalThis.document) === null || e === void 0 ? void 0 : e.body) && !a, [`${bt.DIALOG}-fixed`]: a, [`${bt.DIALOG}-rtl`]: u === "rtl" }), h = o(), g = this.getDataAttr(l), m = f.createElement("div", Object.assign({ className: d }, g), this.getMaskElement(), f.createElement("div", Object.assign({ role: "none", className: F({ [`${bt.DIALOG}-wrap`]: !0, [`${bt.DIALOG}-wrap-center`]: this.props.centered }), onClick: n ? this.onMaskClick : null, onMouseUp: n ? this.onMaskMouseUp : null }, this.props.contentExtraProps), this.getDialogElement())); return h && h.Provider ? f.createElement(h.Provider, { value: h.value }, m) : m } } ph.contextType = An; ph.propTypes = { close: c.func, getContainerContext: c.func, contentClassName: c.string, maskClassName: c.string, onAnimationEnd: c.func, preventScroll: c.bool }; ph.defaultProps = { close: z, getContainerContext: z, contentClassName: "", maskClassName: "" }; var Fq = function (r, e) { var t = {}; for (var n in r) Object.prototype.hasOwnProperty.call(r, n) && e.indexOf(n) < 0 && (t[n] = r[n]); if (r != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, n = Object.getOwnPropertySymbols(r); i < n.length; i++)e.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(r, n[i]) && (t[n[i]] = r[n[i]]); return t }; const K_ = r => { const [e, t] = R.useState(!0), [n, i] = R.useState(), [s, a] = R.useState(), { direction: o } = r, { title: l, content: u, icon: d, type: h, onCancel: g, onOk: m, className: b } = r, y = Fq(r, ["title", "content", "icon", "type", "onCancel", "onOk", "className"]), w = R.useCallback(I => { const k = m && m(I); k && k.then ? (i(!0), k.then(function () { t(!1), i(!1) }, P => { i(!1) })) : t(!1) }, [m]), x = R.useCallback(I => { const k = g && g(I); k && k.then ? (a(!0), k.then(function () { t(!1), a(!1) }, P => { a(!1) })) : t(!1) }, [g]), S = `${bt.DIALOG}-confirm`, C = F(b, S, { [`${S}-rtl`]: o === "rtl" }), O = F(`${bt.DIALOG}-${h}`), E = Bn(d) ? f.cloneElement(d, { className: `${S}-icon ${O}-icon`, size: "extra-large" }) : d, v = l == null ? null : f.createElement("span", { className: `${S}-title-text` }, l), T = F(`${S}-content`, { [`${S}-content-withIcon`]: r.icon }); return f.createElement(qr, Object.assign({ className: C, title: v, confirmLoading: n, cancelLoading: s, onOk: w, onCancel: x, icon: E, visible: e }, y), f.createElement("div", { className: T, "x-semi-prop": "content" }, u)) }; function Dc(r) { const e = document.createElement("div"); document.body.appendChild(e); let t = Object.assign({}, r); const n = () => { lr.unmountComponentAtNode(e) && e.parentNode && e.parentNode.removeChild(e); for (let l = 0; l < la.length; l++)if (la[l] === s) { la.splice(l, 1); break } }; function i(o) { const { afterClose: l } = o; lr.render(f.createElement(K_, Object.assign({}, o, { afterClose: function () { l == null || l(...arguments), n() }, motion: r.motion })), e) } function s() { t = Object.assign(Object.assign({}, t), { visible: !1 }), i(t) } function a(o) { t = Object.assign(Object.assign({}, t), o), i(t) } return i(t), la.push(s), { destroy: s, update: a } } function U_(r) { return Object.assign({ type: "info", icon: f.createElement(Hm, null) }, r) } function W_(r) { return Object.assign({ type: "success", icon: f.createElement(Km, null) }, r) } function G_(r) { return Object.assign({ type: "warning", icon: f.createElement(yc, null) }, r) } function Y_(r) { return Object.assign({ type: "error", icon: f.createElement(Co, null), okButtonProps: Object.assign({ type: "danger" }, r.okButtonProps) }, Ht(r, ["okButtonProps"])) } function X_(r) { return Object.assign({ type: "confirm", icon: f.createElement(EH, null) }, r) } var $q = function (r, e) { var t = {}; for (var n in r) Object.prototype.hasOwnProperty.call(r, n) && e.indexOf(n) < 0 && (t[n] = r[n]); if (r != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, n = Object.getOwnPropertySymbols(r); i < n.length; i++)e.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(r, n[i]) && (t[n[i]] = r[n[i]]); return t }; const Lq = (r, e) => { var { afterClose: t, config: n } = r; $q(r, ["afterClose", "config"]); const [i, s] = f.useState(n); f.useImperativeHandle(e, () => ({ destroy: () => { s(o => Object.assign(Object.assign({}, o), { visible: !1 })) }, update: o => { s(l => Object.assign(Object.assign({}, l), o)) } })); const a = () => { var o; (o = n == null ? void 0 : n.afterClose) === null || o === void 0 || o.call(n), t() }; return f.createElement(K_, Object.assign({}, i, { afterClose: a })) }, Mq = f.forwardRef(Lq); let v0 = 0; function jq() { const [r, e] = f.useState([]); function t(n) { return e(i => [...i, n]), () => { e(i => i.filter(s => s !== n)) } } return [r, t] } function Vq() { const [r, e] = jq(); function t(n) { return function (s) { v0 += 1; const a = f.createRef(); let o; const l = f.createElement(Mq, { key: `semi-modal-${v0}`, config: n(s), ref: a, afterClose: () => { o() } }); return o = e(l), { destroy: () => { a.current && a.current.destroy() }, update: u => { a.current && a.current.update(u) } } } } return [{ info: t(U_), success: t(W_), error: t(Y_), warning: t(G_), confirm: t(X_) }, f.createElement(f.Fragment, null, r)] } var Bq = function (r, e) { var t = {}; for (var n in r) Object.prototype.hasOwnProperty.call(r, n) && e.indexOf(n) < 0 && (t[n] = r[n]); if (r != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, n = Object.getOwnPropertySymbols(r); i < n.length; i++)e.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(r, n[i]) && (t[n[i]] = r[n[i]]); return t }; let la = []; class qr extends de { constructor(e) { super(e), this.bodyOverflow = null, this.handleCancel = t => { this.foundation.handleCancel(t) }, this.handleOk = t => { this.foundation.handleOk(t) }, this.updateState = () => { const { visible: t } = this.props; this.foundation.toggleDisplayNone(!t) }, this.renderFooter = () => { const { okText: t, okType: n, cancelText: i, confirmLoading: s, cancelLoading: a, hasCancel: o, footerFill: l } = this.props, u = d => { var h; return o ? f.createElement(St, Object.assign({ "aria-label": "cancel", onClick: this.handleCancel, loading: a === void 0 ? this.state.onCancelReturnPromiseStatus === "pending" : a, type: "tertiary", block: l, autoFocus: !0 }, this.props.cancelButtonProps, { style: Object.assign(Object.assign({}, l ? { marginLeft: "unset" } : {}), (h = this.props.cancelButtonProps) === null || h === void 0 ? void 0 : h.style), "x-semi-children-alias": "cancelText" }), i || d.cancel) : null }; return f.createElement(Ke, { componentName: "Modal" }, (d, h) => f.createElement("div", { className: F({ [`${bt.DIALOG}-footerfill`]: l }) }, u(d), f.createElement(St, Object.assign({ "aria-label": "confirm", type: n, theme: "solid", block: l, loading: s === void 0 ? this.state.onOKReturnPromiseStatus === "pending" : s, onClick: this.handleOk }, this.props.okButtonProps, { "x-semi-children-alias": "okText" }), t || d.confirm))) }, this.renderDialog = () => { var t; let n = this.props, { footer: i, className: s, motion: a, maskStyle: o, keepDOM: l, style: u, zIndex: d, getPopupContainer: h, visible: g, modalContentClass: m } = n, b = Bq(n, ["footer", "className", "motion", "maskStyle", "keepDOM", "style", "zIndex", "getPopupContainer", "visible", "modalContentClass"]), y = u; const w = o, x = "footer" in this.props ? i : this.renderFooter(); let S = { zIndex: d }; h && h() !== ((t = globalThis == null ? void 0 : globalThis.document) === null || t === void 0 ? void 0 : t.body) && (S = { zIndex: d, position: "static" }); const C = F(s, { [`${bt.DIALOG}-displayNone`]: l && this.state.displayNone }), O = this.props.visible || this.props.keepDOM && (!this.props.lazyRender || this._haveRendered) || this.props.motion && !this.state.displayNone; return O && (this._haveRendered = !0), f.createElement(Hi, { motion: this.props.motion, animationState: g ? "enter" : "leave", startClassName: g ? `${bt.DIALOG}-content-animate-show` : `${bt.DIALOG}-content-animate-hide`, onAnimationEnd: () => { this.updateState() } }, E => { let { animationClassName: v, animationEventsNeedBind: T } = E; return f.createElement(Hi, { motion: this.props.motion, animationState: g ? "enter" : "leave", startClassName: g ? `${bt.DIALOG}-mask-animate-show` : `${bt.DIALOG}-mask-animate-hide`, onAnimationEnd: () => { this.updateState() } }, I => { let { animationClassName: k, animationEventsNeedBind: P } = I; return O ? f.createElement(Oa, { style: S, getPopupContainer: h }, " ", f.createElement(ph, Object.assign({}, b, { contentExtraProps: T, maskExtraProps: P, isFullScreen: this.state.isFullScreen, contentClassName: `${v} ${m}`, maskClassName: k, className: C, getPopupContainer: h, maskStyle: w, style: y, ref: this.modalRef, footer: x, onClose: this.handleCancel }))) : f.createElement(f.Fragment, null) }) }) }, this.state = { displayNone: !e.visible, isFullScreen: e.fullScreen }, this.foundation = new Tq(this.adapter), this.modalRef = f.createRef(), this.scrollBarWidth = 0, this.originBodyWidth = "100%" } get adapter() { return Object.assign(Object.assign({}, super.adapter), { getProps: () => this.props, disabledBodyScroll: () => { var e; const { getPopupContainer: t } = this.props; this.bodyOverflow = document.body.style.overflow || "", (!t || t() === ((e = globalThis == null ? void 0 : globalThis.document) === null || e === void 0 ? void 0 : e.body)) && this.bodyOverflow !== "hidden" && (document.body.style.overflow = "hidden", document.body.style.width = `calc(${this.originBodyWidth || "100%"} - ${this.scrollBarWidth}px)`) }, enabledBodyScroll: () => { var e; const { getPopupContainer: t } = this.props; (!t || t() === ((e = globalThis == null ? void 0 : globalThis.document) === null || e === void 0 ? void 0 : e.body)) && this.bodyOverflow !== null && this.bodyOverflow !== "hidden" && (document.body.style.overflow = this.bodyOverflow, document.body.style.width = this.originBodyWidth) }, notifyCancel: e => this.props.onCancel(e), notifyOk: e => this.props.onOk(e), notifyClose: () => { this.props.afterClose() }, toggleDisplayNone: (e, t) => { e !== this.state.displayNone && this.setState({ displayNone: e }, t || z) }, notifyFullScreen: e => { e !== this.state.isFullScreen && this.setState({ isFullScreen: e }) } }) } static getDerivedStateFromProps(e, t) { const n = {}; return e.fullScreen !== t.isFullScreen && (n.isFullScreen = e.fullScreen), e.visible && t.displayNone && (n.displayNone = !1), n } componentDidMount() { this.scrollBarWidth = Nm(), this.originBodyWidth = document.body.style.width, this.props.visible && this.foundation.beforeShow() } componentDidUpdate(e, t, n) { !e.visible && this.props.visible && this.foundation.beforeShow(), !t.displayNone && this.state.displayNone && this.foundation.afterHide() } componentWillUnmount() { this.props.visible ? this.foundation.destroy() : this.foundation.enabledBodyScroll() } render() { return this.props, this.renderDialog() } } qr.propTypes = { mask: c.bool, closable: c.bool, centered: c.bool, visible: c.bool, width: c.oneOfType([c.string, c.number]), height: c.oneOfType([c.string, c.number]), confirmLoading: c.bool, cancelLoading: c.bool, okText: c.string, okType: c.string, cancelText: c.string, maskClosable: c.bool, onCancel: c.func, onOk: c.func, afterClose: c.func, okButtonProps: c.object, cancelButtonProps: c.object, style: c.object, className: c.string, maskStyle: c.object, bodyStyle: c.object, zIndex: c.number, title: c.node, icon: c.node, header: c.node, footer: c.node, hasCancel: c.bool, motion: c.bool, children: c.node, getPopupContainer: c.func, getContainerContext: c.func, maskFixed: c.bool, closeIcon: c.node, closeOnEsc: c.bool, size: c.oneOf(b0.SIZE), keepDOM: c.bool, lazyRender: c.bool, direction: c.oneOf(b0.directions), fullScreen: c.bool, footerFill: c.bool }; qr.__SemiComponentName__ = "Modal"; qr.defaultProps = xn(qr.__SemiComponentName__, { zIndex: 1e3, motion: !0, mask: !0, centered: !1, closable: !0, visible: !1, okType: "primary", maskClosable: !0, hasCancel: !0, onCancel: z, onOk: z, afterClose: z, maskFixed: !1, closeOnEsc: !0, size: "small", keepDOM: !1, lazyRender: !0, fullScreen: !1 }); qr.useModal = Vq; qr.info = function (r) { return Dc(U_(r)) }; qr.success = function (r) { return Dc(W_(r)) }; qr.error = function (r) { return Dc(Y_(r)) }; qr.warning = function (r) { return Dc(G_(r)) }; qr.confirm = function (r) { return Dc(X_(r)) }; qr.destroyAll = function () { for (let e = 0, t = la.length; e < t; e++) { const n = la[e]; n && n() } la = [] }; const Ac = { PREFIX: `${G}-dropdown`, SELECTED: `${G}-dropdown-item-selected`, DISABLED: `${G}-dropdown-item-disabled` }, fh = { POSITION_SET: Ds.POSITION_SET, TRIGGER_SET: ["hover", "focus", "click", "custom", "contextMenu"], DEFAULT_LEAVE_DELAY: 100, ITEM_TYPE: ["primary", "secondary", "tertiary", "warning", "danger"] }, x0 = { SPACING: 4, NESTED_SPACING: 2 }; class zq extends ve { handleVisibleChange(e) { this._adapter.setPopVisible(e), this._adapter.notifyVisibleChange(e); const { trigger: t } = this.getProps(); if (e && t === "click") { const n = this._adapter.getPopupId(); this.setFocusToFirstMenuItem(n) } } getMenuItemNodes(e) { const t = document.getElementById(e); return t ? Array.from(t.getElementsByTagName("li")).filter(n => n.ariaDisabled === "false") : null } setFocusToFirstMenuItem(e) { const t = this.getMenuItemNodes(e); t && V3(t) } setFocusToLastMenuItem(e) { const t = this.getMenuItemNodes(e); t && B3(t) } handleKeyDown(e) { var t, n; const i = (n = (t = e.target) === null || t === void 0 ? void 0 : t.attributes["data-popupid"]) === null || n === void 0 ? void 0 : n.value, { visible: s } = this._adapter.getStates(); switch (e.key) { case " ": case "Enter": e.target.click(); break; case "ArrowDown": this.setFocusToFirstMenuItem(i), s && yn(e); break; case "ArrowUp": this.setFocusToLastMenuItem(i), s && yn(e); break } } } class Hq extends ve { constructor() { super(...arguments), this.menuItemNodes = null, this.firstChars = [] } handleEscape(e) { this._adapter.getContext("trigger") === "custom" && (e && W3(document.querySelectorAll("[data-popupid]"), e.id)).focus() } setFocusByFirstCharacter(e, t) { const n = K3(this.menuItemNodes, e, this.firstChars, t); n >= 0 && mc(this.menuItemNodes, this.menuItemNodes[n]) } onMenuKeydown(e) { const t = U3(e.target, "tooltip"); this.menuItemNodes || (this.menuItemNodes = [...e.target.parentNode.getElementsByTagName("li")].filter(i => i.ariaDisabled !== "true")), this.firstChars.length === 0 && this.menuItemNodes.forEach(i => { var s; this.firstChars.push((s = i.textContent.trim()[0]) === null || s === void 0 ? void 0 : s.toLowerCase()) }); const n = this.menuItemNodes.find(i => i.tabIndex === 0); switch (e.key) { case " ": case "Enter": e.target.click(); break; case "Escape": this.handleEscape(t); break; case "ArrowUp": z3(this.menuItemNodes, n), yn(e); break; case "ArrowDown": H3(this.menuItemNodes, n), yn(e); break; default: j3(e.key) && this.setFocusByFirstCharacter(n, e.key); break } } } const To = f.createContext({ level: 0 }); var Kq = function (r, e) { var t = {}; for (var n in r) Object.prototype.hasOwnProperty.call(r, n) && e.indexOf(n) < 0 && (t[n] = r[n]); if (r != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, n = Object.getOwnPropertySymbols(r); i < n.length; i++)e.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(r, n[i]) && (t[n[i]] = r[n[i]]); return t }; const Uq = Ac.PREFIX; class Py extends de { constructor(e) { super(e), this.foundation = new Hq(this.adapter) } get adapter() { return Object.assign({}, super.adapter) } render() { const e = this.props, { children: t, className: n, style: i } = e, s = Kq(e, ["children", "className", "style"]); return f.createElement("ul", Object.assign({ role: "menu", "aria-orientation": "vertical" }, s, { className: F(`${Uq}-menu`, n), style: i, onKeyDown: a => this.foundation.onMenuKeydown(a) }), t) } } Py.propTypes = { children: c.node, className: c.string, style: c.object }; Py.contextType = To; const Ys = Ac.PREFIX; class Nc extends de { render() { const { children: e, disabled: t, className: n, forwardRef: i, style: s, type: a, active: o, icon: l, onKeyDown: u, showTick: d, hover: h } = this.props, { showTick: g } = this.context, m = g ?? d, b = F(n, { [`${Ys}-item`]: !0, [`${Ys}-item-disabled`]: t, [`${Ys}-item-hover`]: h, [`${Ys}-item-withTick`]: m, [`${Ys}-item-${a}`]: a, [`${Ys}-item-active`]: o }), y = {}; t || ["onClick", "onMouseEnter", "onMouseLeave", "onContextMenu"].forEach(S => { this.context.level !== 1 && S === "onClick" ? y.onMouseDown = O => { var E, v; O.button === 0 && ((v = (E = this.props)[S]) === null || v === void 0 || v.call(E, O)) } : y[S] = this.props[S] }); let w = null; switch (!0) { case (m && o): w = f.createElement(ga, null); break; case (m && !o): w = f.createElement(ga, { style: { color: "transparent" } }); break; default: w = null; break }let x = null; return l && (x = f.createElement("div", { className: `${Ys}-item-icon` }, l)), f.createElement("li", Object.assign({ role: "menuitem", tabIndex: -1, "aria-disabled": t }, y, { onKeyDown: u, ref: S => i(S), className: b, style: s }, this.getDataAttr(this.props)), w, x, e) } } Nc.propTypes = { children: c.oneOfType([c.string, c.node]), name: c.string, disabled: c.bool, selected: c.bool, onClick: c.func, onMouseEnter: c.func, onMouseLeave: c.func, onContextMenu: c.func, className: c.string, style: c.object, forwardRef: c.func, type: c.oneOf(fh.ITEM_TYPE), active: c.bool, icon: c.node }; Nc.contextType = To; Nc.defaultProps = { disabled: !1, divided: !1, selected: !1, onMouseEnter: z, onMouseLeave: z, forwardRef: z }; Nc.elementType = "Dropdown.Item"; const Wq = Ac.PREFIX, q_ = function () { let r = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}; const { style: e, className: t } = r; return f.createElement("div", { className: F(`${Wq}-divider`, t), style: e }) }; q_.propTypes = { style: c.object, className: c.string }; const w0 = Ac.PREFIX; class ky extends R.PureComponent { render() { const { className: e, style: t, children: n } = this.props, { showTick: i } = this.context, s = F({ [`${w0}-title`]: !0, [`${w0}-title-withTick`]: i }, e); return f.createElement("div", { className: s, style: t }, n) } } ky.propTypes = { children: c.node, className: c.string, style: c.object }; ky.contextType = To; var Cp = function (r, e) { var t = {}; for (var n in r) Object.prototype.hasOwnProperty.call(r, n) && e.indexOf(n) < 0 && (t[n] = r[n]); if (r != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, n = Object.getOwnPropertySymbols(r); i < n.length; i++)e.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(r, n[i]) && (t[n[i]] = r[n[i]]); return t }; const Gq = fh.POSITION_SET, Yq = fh.TRIGGER_SET; class Jt extends de { constructor(e) { super(e), this.handleVisibleChange = t => this.foundation.handleVisibleChange(t), this.state = { popVisible: e.visible }, this.foundation = new zq(this.adapter), this.tooltipRef = f.createRef() } get adapter() { return Object.assign(Object.assign({}, super.adapter), { setPopVisible: e => this.setState({ popVisible: e }), notifyVisibleChange: e => { var t, n; return (n = (t = this.props).onVisibleChange) === null || n === void 0 ? void 0 : n.call(t, e) }, getPopupId: () => this.tooltipRef.current.getPopupId() }) } renderContent() { const { render: e, menu: t, contentClassName: n, style: i, showTick: s, prefixCls: a, trigger: o } = this.props, l = F(a, n), { level: u = 0 } = this.context, d = { showTick: s, level: u + 1, trigger: o }; let h = null; return f.isValidElement(e) ? h = e : Array.isArray(t) && (h = this.renderMenu()), f.createElement(To.Provider, { value: d }, f.createElement("div", { className: l, style: i }, f.createElement("div", { className: `${a}-content`, "x-semi-prop": "render" }, h))) } renderMenu() { const { menu: e } = this.props, t = e.map((n, i) => { switch (n.node) { case "title": { const { name: s, node: a } = n, o = Cp(n, ["name", "node"]); return f.createElement(Jt.Title, Object.assign({}, o, { key: a + s + i }), s) } case "item": { const { node: s, name: a } = n, o = Cp(n, ["node", "name"]); return f.createElement(Jt.Item, Object.assign({}, o, { key: s + a + i }), a) } case "divider": return f.createElement(Jt.Divider, { key: n.node + i }); default: return null } }); return f.createElement(Jt.Menu, null, t) } renderPopCard() { const { render: e, contentClassName: t, style: n, showTick: i, prefixCls: s } = this.props, a = F(s, t), { level: o = 0 } = this.context, l = { showTick: i, level: o + 1 }; return f.createElement(To.Provider, { value: l }, f.createElement("div", { className: a, style: n }, f.createElement("div", { className: `${s}-content` }, e))) } render() { const e = this.props, { children: t, position: n, trigger: i, onVisibleChange: s, zIndex: a, className: o, motion: l, margin: u, style: d, prefixCls: h } = e, g = Cp(e, ["children", "position", "trigger", "onVisibleChange", "zIndex", "className", "motion", "margin", "style", "prefixCls"]); let { spacing: m } = this.props; const { level: b } = this.context, { popVisible: y } = this.state, w = this.renderContent(); return b > 0 ? m = typeof m == "number" ? m : x0.NESTED_SPACING : (m === null || typeof m > "u") && (m = x0.SPACING), f.createElement(ln, Object.assign({ zIndex: a, motion: l, margin: u, content: w, className: o, prefixCls: h, spacing: m, position: n, trigger: i, onVisibleChange: this.handleVisibleChange, showArrow: !1, returnFocusOnClose: !0, ref: this.tooltipRef }, g), f.isValidElement(t) ? f.cloneElement(t, { className: F(H(t, "props.className"), { [`${h}-showing`]: y }), "aria-haspopup": !0, "aria-expanded": y, onKeyDown: x => { this.foundation.handleKeyDown(x); const S = H(t, "props.onKeyDown"); S && S(x) } }) : t) } } Jt.Menu = Py; Jt.Item = Nc; Jt.Divider = q_; Jt.Title = ky; Jt.contextType = To; Jt.propTypes = { children: c.node, contentClassName: c.oneOfType([c.string, c.array]), className: c.string, getPopupContainer: c.func, margin: c.oneOfType([c.number, c.object]), mouseEnterDelay: c.number, mouseLeaveDelay: c.number, menu: c.array, motion: c.oneOfType([c.bool, c.func, c.object]), onVisibleChange: c.func, prefixCls: c.string, position: c.oneOf(Gq), rePosKey: c.oneOfType([c.string, c.number]), render: c.node, spacing: c.oneOfType([c.number, c.object]), showTick: c.bool, style: c.object, trigger: c.oneOf(Yq), visible: c.bool, zIndex: c.number }; Jt.__SemiComponentName__ = "Dropdown"; Jt.defaultProps = xn(Jt.__SemiComponentName__, { onVisibleChange: z, prefixCls: Ac.PREFIX, zIndex: Es.DEFAULT_Z_INDEX, motion: !0, trigger: "hover", position: "bottom", mouseLeaveDelay: fh.DEFAULT_LEAVE_DELAY, showTick: !1, closeOnEsc: !0, onEscKeyDown: z }); const Z_ = { PREFIX: `${G}` }; var Xq = function (r, e) { var t = {}; for (var n in r) Object.prototype.hasOwnProperty.call(r, n) && e.indexOf(n) < 0 && (t[n] = r[n]); if (r != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, n = Object.getOwnPropertySymbols(r); i < n.length; i++)e.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(r, n[i]) && (t[n[i]] = r[n[i]]); return t }; const C0 = ["xxl", "xl", "lg", "md", "sm", "xs"], J_ = f.createContext(null), S0 = { xs: "(max-width: 575px)", sm: "(min-width: 576px)", md: "(min-width: 768px)", lg: "(min-width: 992px)", xl: "(min-width: 1200px)", xxl: "(min-width: 1600px)" }; class gh extends f.Component { constructor() { super(...arguments), this.state = { screens: { xs: !0, sm: !0, md: !0, lg: !0, xl: !0, xxl: !0 } }, this.unRegisters = [] } componentDidMount() { this.unRegisters = Object.keys(S0).map(e => gS(S0[e], { match: () => { typeof this.props.gutter == "object" && this.setState(t => ({ screens: Object.assign(Object.assign({}, t.screens), { [e]: !0 }) })) }, unmatch: () => { typeof this.props.gutter == "object" && this.setState(t => ({ screens: Object.assign(Object.assign({}, t.screens), { [e]: !1 }) })) } })) } componentWillUnmount() { this.unRegisters.forEach(e => e()) } getGutter() { const { gutter: e = 0 } = this.props, t = [0, 0]; return (Array.isArray(e) ? e.slice(0, 2) : [e, 0]).forEach((i, s) => { if (typeof i == "object") for (let a = 0; a < C0.length; a++) { const o = C0[a]; if (this.state.screens[o] && i[o] !== void 0) { t[s] = i[o]; break } } else t[s] = i || 0 }), t } render() { const e = this.props, { prefixCls: t, type: n, justify: i, align: s, className: a, style: o, children: l } = e, u = Xq(e, ["prefixCls", "type", "justify", "align", "className", "style", "children"]), d = this.getGutter(), h = `${t}-row`, g = F({ [h]: n !== "flex", [`${h}-${n}`]: n, [`${h}-${n}-${i}`]: n && i, [`${h}-${n}-${s}`]: n && s }, a), m = Object.assign(Object.assign(Object.assign({}, d[0] > 0 ? { marginLeft: d[0] / -2, marginRight: d[0] / -2 } : {}), d[1] > 0 ? { marginTop: d[1] / -2, marginBottom: d[1] / -2 } : {}), o), b = Object.assign({}, u); return delete b.gutter, f.createElement(J_.Provider, { value: { gutters: d } }, f.createElement("div", Object.assign({}, b, { className: g, style: m, "x-semi-prop": "children" }), l)) } } gh.propTypes = { type: c.oneOf(["flex"]), align: c.oneOf(["top", "middle", "bottom"]), justify: c.oneOf(["start", "end", "center", "space-around", "space-between"]), className: c.string, style: c.object, children: c.node, gutter: c.oneOfType([c.object, c.number, c.array]), prefixCls: c.string }; gh.defaultProps = { prefixCls: Z_.PREFIX }; gh.RowContext = { gutters: c.any }; var qq = function (r, e) { var t = {}; for (var n in r) Object.prototype.hasOwnProperty.call(r, n) && e.indexOf(n) < 0 && (t[n] = r[n]); if (r != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, n = Object.getOwnPropertySymbols(r); i < n.length; i++)e.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(r, n[i]) && (t[n[i]] = r[n[i]]); return t }; const Ya = c.oneOfType([c.object, c.number]); class vr extends f.Component { render() { const { props: e } = this, { prefixCls: t, span: n, order: i, offset: s, push: a, pull: o, className: l, children: u } = e, d = qq(e, ["prefixCls", "span", "order", "offset", "push", "pull", "className", "children"]); let h = {}; const g = `${t}-col`;["xs", "sm", "md", "lg", "xl", "xxl"].forEach(w => { let x = {}; typeof e[w] == "number" ? x.span = e[w] : typeof e[w] == "object" && (x = e[w] || {}), delete d[w], h = Object.assign(Object.assign({}, h), { [`${g}-${w}-${x.span}`]: x.span !== void 0, [`${g}-${w}-order-${x.order}`]: x.order || x.order === 0, [`${g}-${w}-offset-${x.offset}`]: x.offset || x.offset === 0, [`${g}-${w}-push-${x.push}`]: x.push || x.push === 0, [`${g}-${w}-pull-${x.pull}`]: x.pull || x.pull === 0 }) }); const m = F(g, { [`${g}-${n}`]: n !== void 0, [`${g}-order-${i}`]: i, [`${g}-offset-${s}`]: s, [`${g}-push-${a}`]: a, [`${g}-pull-${o}`]: o }, l, h); let { style: b } = d, y; try { y = this.context.gutters } catch { throw new Error("please make sure <Col> inside <Row>") } return b = Object.assign(Object.assign(Object.assign({}, y[0] > 0 ? { paddingLeft: y[0] / 2, paddingRight: y[0] / 2 } : {}), y[1] > 0 ? { paddingTop: y[1] / 2, paddingBottom: y[1] / 2 } : {}), b), f.createElement("div", Object.assign({}, d, { style: b, className: m, "x-semi-prop": "children" }), u) } } vr.contextType = J_; vr.propTypes = { span: c.number, order: c.number, offset: c.number, push: c.number, pull: c.number, className: c.string, children: c.node, xs: Ya, sm: Ya, md: Ya, lg: Ya, xl: Ya, xxl: Ya, prefixCls: c.string }; vr.defaultProps = { prefixCls: Z_.PREFIX }; const mh = { PREFIX: `${G}-layout` }, Zq = { BREAKPOINT: ["xs", "sm", "md", "lg", "xl", "xxl"] }, Q_ = f.createContext({ siderHook: { addSider: Ct, removeSider: Ct } }); var Jq = function (r, e) { var t = {}; for (var n in r) Object.prototype.hasOwnProperty.call(r, n) && e.indexOf(n) < 0 && (t[n] = r[n]); if (r != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, n = Object.getOwnPropertySymbols(r); i < n.length; i++)e.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(r, n[i]) && (t[n[i]] = r[n[i]]); return t }; const E0 = { xs: "(max-width: 575px)", sm: "(min-width: 576px)", md: "(min-width: 768px)", lg: "(min-width: 992px)", xl: "(min-width: 1200px)", xxl: "(min-width: 1600px)" }, Qq = (() => { let r = 0; return () => (r += 1, `${mh.PREFIX}-sider-${r}`) })(), eZ = Zq.BREAKPOINT; class Fc extends f.PureComponent { constructor(e) { super(e), this.unRegisters = [], this.uniqueId = "", this.uniqueId = Qq() } componentDidMount() { const { breakpoint: e } = this.props, n = Object.keys(E0).filter(i => e && e.indexOf(i) !== -1).map(i => gS(E0[i], { match: () => { this.responsiveHandler(i, !0) }, unmatch: () => { this.responsiveHandler(i, !1) } })); this.unRegisters = n, this.context.siderHook && this.context.siderHook.addSider(this.uniqueId) } componentWillUnmount() { this.unRegisters.forEach(e => e()), this.context.siderHook && this.context.siderHook.removeSider(this.uniqueId) } responsiveHandler(e, t) { const { onBreakpoint: n } = this.props; n && n(e, t) } render() { const e = this.props, { prefixCls: t, className: n, children: i, style: s } = e, a = Jq(e, ["prefixCls", "className", "children", "style"]), o = F(n, { [`${t}-sider`]: !0 }); return f.createElement("aside", Object.assign({ className: o, "aria-label": this.props["aria-label"], style: s }, Xr(a)), f.createElement("div", { className: `${t}-sider-children` }, i)) } } Fc.propTypes = { prefixCls: c.string, style: c.object, className: c.string, breakpoint: c.arrayOf(c.oneOf(eZ)), onBreakpoint: c.func, "aria-label": c.string, role: c.string }; Fc.defaultProps = { prefixCls: mh.PREFIX }; Fc.contextType = Q_; Fc.elementType = "Layout.Sider"; var eO = function (r, e) { var t = {}; for (var n in r) Object.prototype.hasOwnProperty.call(r, n) && e.indexOf(n) < 0 && (t[n] = r[n]); if (r != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, n = Object.getOwnPropertySymbols(r); i < n.length; i++)e.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(r, n[i]) && (t[n[i]] = r[n[i]]); return t }; const tZ = { Header: "header", Footer: "footer", Content: "main", Layout: "section" }; function Ry(r) { const e = tZ[r], t = r.toLowerCase(); return n => class extends f.PureComponent { render() { return f.createElement(n, Object.assign({ role: this.props.role, "aria-label": this.props["aria-label"], type: t, tagName: e }, this.props)) } } } class $c extends f.PureComponent { render() { const e = this.props, { prefixCls: t, type: n, className: i, children: s, tagName: a } = e, o = eO(e, ["prefixCls", "type", "className", "children", "tagName"]), l = F(i, `${t}-${n}`); return f.createElement(a, Object.assign({ className: l }, o), s) } } $c.propTypes = { prefixCls: c.string, style: c.object, className: c.string }; $c.defaultProps = { prefixCls: mh.PREFIX }; const nZ = Ry("Header")($c), rZ = Ry("Footer")($c), iZ = Ry("Content")($c); class Qo extends f.Component { constructor(e) { super(e), this.state = { siders: [] } } getSiderHook() { return { addSider: e => { this.setState(t => ({ siders: [...t.siders, e] })) }, removeSider: e => { this.setState(t => ({ siders: t.siders.filter(n => n !== e) })) } } } render() { const e = this.props, { prefixCls: t, className: n, children: i, hasSider: s, tagName: a } = e, o = eO(e, ["prefixCls", "className", "children", "hasSider", "tagName"]), { siders: l } = this.state, u = F(n, t, { [`${t}-has-sider`]: typeof s == "boolean" && s || l.length > 0 || f.Children.toArray(i).some(h => f.isValidElement(h) && h.type && h.type.elementType === "Layout.Sider") }), d = a; return f.createElement(Q_.Provider, { value: { siderHook: this.getSiderHook() } }, f.createElement(d, Object.assign({ className: u }, o), i)) } } Qo.propTypes = { prefixCls: c.string, style: c.object, className: c.string }; Qo.defaultProps = { prefixCls: mh.PREFIX, tagName: "section" }; Qo.Header = nZ; Qo.Footer = rZ; Qo.Content = iZ; Qo.Sider = Fc; const pi = { PREFIX: `${G}-form` }, Tl = { LAYOUT: ["horizontal", "vertical"], LABEL_POS: ["left", "top", "inset"], LABEL_ALIGN: ["left", "right"], EXTRA_POS: ["middle", "bottom"], DEFAULT_TRIGGER: "change" }, Ji = pi.PREFIX; class Vi extends R.PureComponent { render() { const { children: e, required: t, text: n, disabled: i, name: s, width: a, align: o, style: l, className: u, extra: d, id: h, optional: g } = this.props, m = F(u, { [`${Ji}-field-label`]: !0, [`${Ji}-field-label-left`]: o === "left", [`${Ji}-field-label-right`]: o === "right", [`${Ji}-field-label-required`]: t, [`${Ji}-field-label-disabled`]: i, [`${Ji}-field-label-with-extra`]: d }), b = l || {}; a && (b.width = a); const y = f.createElement(Ke, { componentName: "Form" }, S => f.createElement("span", { className: `${Ji}-field-label-optional-text` }, S.optional)), w = f.createElement("div", { className: `${Ji}-field-label-text`, "x-semi-prop": "label" }, typeof n < "u" ? n : e, g ? y : null), x = f.createElement(f.Fragment, null, w, f.createElement("div", { className: `${Ji}-field-label-extra` }, d)); return f.createElement("label", { className: m, htmlFor: s, style: b, id: h }, d ? x : w) } } Vi.defaultProps = { required: !1, name: "", align: "left", className: "", optional: !1 }; Vi.propTypes = { id: c.string, children: c.node, required: c.bool, text: c.node, disabled: c.bool, name: c.string, align: c.string, width: c.oneOfType([c.number, c.string]), style: c.object, className: c.string, extra: c.node, optional: c.bool }; var _0 = function (r, e) { var t = {}; for (var n in r) Object.prototype.hasOwnProperty.call(r, n) && e.indexOf(n) < 0 && (t[n] = r[n]); if (r != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, n = Object.getOwnPropertySymbols(r); i < n.length; i++)e.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(r, n[i]) && (t[n[i]] = r[n[i]]); return t }; const Xs = Xd.PREFIX, sZ = Hs.SIZE; class Dy extends de { renderGroupWithLabel(e) { const t = this.props, { size: n, className: i, label: s, labelPosition: a } = t; _0(t, ["size", "className", "label", "labelPosition"]); const o = F({ [`${Xs}-group-wrapper`]: !0, [`${Xs}-group-wrapper-with-top-label`]: a === "top", [`${Xs}-group-wrapper-with-left-label`]: a === "left" }), l = F(`${Xs}-group`, i, { [`${Xs}-${n}`]: n !== "default" }), u = "input-group"; return f.createElement("div", { className: o }, s && s.text ? f.createElement(Vi, Object.assign({ name: u }, s)) : null, f.createElement("span", { role: "group", "aria-disabled": this.props.disabled, id: s && s.name || u, className: l, style: this.props.style, onFocus: this.props.onFocus, onBlur: this.props.onBlur }, e)) } render() { const e = this.props, { size: t, style: n, className: i, children: s, label: a, onBlur: o, onFocus: l, disabled: u } = e, d = _0(e, ["size", "style", "className", "children", "label", "onBlur", "onFocus", "disabled"]), h = F(`${Xs}-group`, { [`${Xs}-${t}`]: t !== "default" }, i); let g; return s && (g = (Array.isArray(s) ? s : [s]).map((m, b) => { if (m) { const { onBlur: y, onFocus: w, disabled: x } = m.props, S = we(y) && H(y, "name") !== "noop" ? y : o, C = we(w) && H(w, "name") !== "noop" ? w : l, O = typeof x == "boolean" ? x : u; return f.cloneElement(m, Object.assign(Object.assign({ key: b }, d), { size: t, onBlur: S, onFocus: C, disabled: O })) } return null })), a && a.text ? this.renderGroupWithLabel(g) : f.createElement("span", { role: "group", "aria-label": "Input group", "aria-disabled": this.props.disabled, className: h, style: n, onFocus: this.props.onFocus, onBlur: this.props.onBlur }, g) } } Dy.propTypes = { className: c.string, children: c.node, size: c.oneOf(sZ), style: c.object, onBlur: c.func, onFocus: c.func, label: c.object, labelPosition: c.string }; Dy.defaultProps = { size: "default", className: "", onBlur: Ct, onFocus: Ct }; let Tr = null; const O0 = { "min-height": "0", "max-height": "none", height: "0", visibility: "hidden", overflow: "hidden", position: "absolute", "z-index": "-1000", top: "0", right: "0" }, T0 = r => { Object.keys(O0).forEach(e => { r.style.setProperty(e, O0[e], "important") }) }, I0 = (r, e) => { const t = r.scrollHeight; return e.sizingStyle.boxSizing === "border-box" ? t + e.borderSize : t - e.paddingSize }; function aZ(r, e) { let t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1, n = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 1 / 0; Tr || (Tr = document.createElement("textarea"), Tr.setAttribute("tab-index", "-1"), Tr.setAttribute("aria-hidden", "true"), T0(Tr)), Tr.parentNode === null && document.body.appendChild(Tr); const { paddingSize: i, borderSize: s, sizingStyle: a } = r, { boxSizing: o } = a; Object.keys(a).forEach(g => { Tr.style[g] = a[g] }), T0(Tr), Tr.value = e; let l = I0(Tr, r); Tr.value = "x"; const u = I0(Tr, r) - i - s; let d = u * t; o === "border-box" && (d = d + i + s), l = Math.max(d, l); let h = u * n; return o === "border-box" && (h = h + i + s), l = Math.min(h, l), l } const oZ = ["borderBottomWidth", "borderLeftWidth", "borderRightWidth", "borderTopWidth", "boxSizing", "fontFamily", "fontSize", "fontStyle", "fontWeight", "letterSpacing", "lineHeight", "paddingBottom", "paddingLeft", "paddingRight", "paddingTop", "tabSize", "textIndent", "textRendering", "textTransform", "width"], lZ = r => { const e = window.getComputedStyle(r); if (e === null) return null; const t = cr(e, oZ), { boxSizing: n } = t; if (n === "") return null; const i = parseFloat(t.paddingBottom) + parseFloat(t.paddingTop), s = parseFloat(t.borderBottomWidth) + parseFloat(t.borderTopWidth); return { sizingStyle: t, paddingSize: i, borderSize: s } }; class Ay extends ve { static get textAreaDefaultAdapter() { return { notifyChange: z, setValue: z, toggleFocusing: z, toggleHovering: z, notifyFocus: z, notifyBlur: z, notifyKeyDown: z, notifyEnterPress: z } } constructor(e) { super(Object.assign(Object.assign({}, Ay.textAreaDefaultAdapter), e)), this.resizeTextarea = () => { var t; const { height: n } = this.getStates(), { rows: i, autosize: s } = this.getProps(), a = this._adapter.getRef(), o = lZ(a); if (!o) return; const [l, u] = s !== null && typeof s == "object" ? [(t = s == null ? void 0 : s.minRows) !== null && t !== void 0 ? t : i, s == null ? void 0 : s.maxRows] : [i], d = aZ(o, a.value || a.placeholder || "x", l, u); if (n !== d) { this._adapter.notifyHeightUpdate(d), a.style.height = `${d}px`; return } } } destroy() { } handleValueChange(e) { this._adapter.setValue(e) } handleChange(e, t) { const { maxLength: n, minLength: i, getValueLength: s } = this._adapter.getProps(); let a = e; n && we(s) && (a = this.handleVisibleMaxLength(e)), i && we(s) && this.handleVisibleMinLength(a), this._isControlledComponent() ? this._adapter.notifyChange(a, t) : (this._adapter.setValue(a), this._adapter.notifyChange(a, t)) } handleVisibleMinLength(e) { const { minLength: t, getValueLength: n } = this._adapter.getProps(), { minLength: i } = this._adapter.getStates(); if (Zt(t) && t >= 0 && we(n) && Fe(e)) { const s = n(e); if (s < t) { const a = e.length + (t - s); a !== i && this._adapter.setMinLength(a) } else i !== t && this._adapter.setMinLength(t) } } handleVisibleMaxLength(e) { const { maxLength: t, getValueLength: n } = this._adapter.getProps(); if (Zt(t) && t >= 0 && Fe(e)) { if (we(n)) { if (n(e) > t) return console.warn("[Semi TextArea] The input character is truncated because the input length exceeds the maximum length limit"), this.handleTruncateValue(e, t) } else if (e.length > t) return console.warn("[Semi TextArea] The input character is truncated because the input length exceeds the maximum length limit"), e.slice(0, t); return e } } handleTruncateValue(e, t) { const { getValueLength: n } = this._adapter.getProps(); return rE({ value: e, maxLength: t, getValueLength: n }) } handleFocus(e) { const { value: t } = this.getStates(); this._adapter.toggleFocusing(!0), this._adapter.notifyFocus(t, e) } handleBlur(e) { const { value: t } = this.getStates(), { maxLength: n } = this.getProps(); let i = t; n && (i = this.handleVisibleMaxLength(t), i !== t && (this._isControlledComponent() || this._adapter.setValue(i), this._adapter.notifyChange(i, e))), this._adapter.toggleFocusing(!1), this._adapter.notifyBlur(i, e) } handleKeyDown(e) { const { disabledEnterStartNewLine: t } = this.getProps(); t && e.key === "Enter" && !e.shiftKey && e.preventDefault(), this._adapter.notifyKeyDown(e), e.keyCode === 13 && this._adapter.notifyPressEnter(e) } handleMouseEnter(e) { this._adapter.toggleHovering(!0) } handleMouseLeave(e) { this._adapter.toggleHovering(!1) } isAllowClear() { const { value: e, isFocus: t, isHover: n } = this._adapter.getStates(), { showClear: i, disabled: s, readonly: a } = this._adapter.getProps(); return e && i && !s && (t || n) && !a } handleClear(e) { const { isFocus: t } = this.getStates(); this._isControlledComponent("value") ? this._adapter.setState({ isFocus: !1 }) : this._adapter.setState({ value: "", isFocus: !1 }), t && this._adapter.notifyBlur("", e), this._adapter.notifyChange("", e), this._adapter.notifyClear(e), this.stopPropagation(e) } } var cZ = function (r, e) { var t = {}; for (var n in r) Object.prototype.hasOwnProperty.call(r, n) && e.indexOf(n) < 0 && (t[n] = r[n]); if (r != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, n = Object.getOwnPropertySymbols(r); i < n.length; i++)e.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(r, n[i]) && (t[n[i]] = r[n[i]]); return t }; const er = Xd.PREFIX; class Ny extends de { constructor(e) { super(e), this.handleClear = n => { this.foundation.handleClear(n) }, this.setRef = n => { this.libRef.current = n; const { forwardRef: i } = this.props; typeof i == "function" ? i(n) : i && typeof i == "object" && (i.current = n) }; const t = "value" in e ? e.value : e.defaultValue; this.state = { value: t, isFocus: !1, isHover: !1, height: 0, minLength: e.minLength, cachedValue: e.value }, this.focusing = !1, this.foundation = new Ay(this.adapter), this.libRef = f.createRef(), this.throttledResizeTextarea = xo(this.foundation.resizeTextarea, 10) } get adapter() { return Object.assign(Object.assign({}, super.adapter), { setValue: e => this.setState({ value: e }, () => { this.props.autosize && this.foundation.resizeTextarea() }), getRef: () => this.libRef.current, toggleFocusing: e => this.setState({ isFocus: e }), toggleHovering: e => this.setState({ isHover: e }), notifyChange: (e, t) => { this.props.onChange(e, t) }, notifyClear: e => this.props.onClear(e), notifyBlur: (e, t) => this.props.onBlur(t), notifyFocus: (e, t) => this.props.onFocus(t), notifyKeyDown: e => { this.props.onKeyDown(e) }, notifyHeightUpdate: e => { this.setState({ height: e }), this.props.onResize({ height: e }) }, notifyPressEnter: e => { this.props.onEnterPress && this.props.onEnterPress(e) }, setMinLength: e => this.setState({ minLength: e }) }) } static getDerivedStateFromProps(e, t) { const n = {}; return e.value !== t.cachedValue && (n.value = e.value, n.cachedValue = e.value), n } componentWillUnmount() { var e, t; this.throttledResizeTextarea && ((t = (e = this.throttledResizeTextarea) === null || e === void 0 ? void 0 : e.cancel) === null || t === void 0 || t.call(e), this.throttledResizeTextarea = null) } componentDidUpdate(e, t) { (this.props.value !== e.value || this.props.placeholder !== e.placeholder) && this.props.autosize && this.foundation.resizeTextarea() } renderClearBtn() { const { showClear: e } = this.props, t = this.foundation.isAllowClear(), n = F(`${er}-clearbtn`, { [`${er}-clearbtn-hidden`]: !t }); return e ? f.createElement("div", { className: n, onClick: this.handleClear }, f.createElement(us, null)) : null } renderCounter() { let e, t, n, i; const { showCounter: s, maxCount: a, getValueLength: o } = this.props; if (s || a) { const { value: l } = this.state; t = l ? we(o) ? o(l) : l.length : 0, n = a || null, i = F(`${er}-textarea-counter`, { [`${er}-textarea-counter-exceed`]: t > n }), e = f.createElement("div", { className: i }, t, n ? "/" : null, n) } else e = null; return e } render() { const e = this.props, { autosize: t, placeholder: n, onEnterPress: i, onResize: s, disabled: a, readonly: o, className: l, showCounter: u, validateStatus: d, maxCount: h, defaultValue: g, style: m, forwardRef: b, getValueLength: y, maxLength: w, minLength: x, showClear: S, borderless: C, autoFocus: O } = e, E = cZ(e, ["autosize", "placeholder", "onEnterPress", "onResize", "disabled", "readonly", "className", "showCounter", "validateStatus", "maxCount", "defaultValue", "style", "forwardRef", "getValueLength", "maxLength", "minLength", "showClear", "borderless", "autoFocus"]), { isFocus: v, value: T, minLength: I } = this.state, k = F(l, `${er}-textarea-wrapper`, { [`${er}-textarea-borderless`]: C, [`${er}-textarea-wrapper-disabled`]: a, [`${er}-textarea-wrapper-readonly`]: o, [`${er}-textarea-wrapper-${d}`]: !!d, [`${er}-textarea-wrapper-focus`]: v }), P = F(`${er}-textarea`, { [`${er}-textarea-disabled`]: a, [`${er}-textarea-readonly`]: o, [`${er}-textarea-autosize`]: an(t) ? st(t == null ? void 0 : t.maxRows) : t, [`${er}-textarea-showClear`]: S }), N = Object.assign(Object.assign({}, Ht(E, "insetLabel", "insetLabelId", "getValueLength", "onClear", "showClear", "disabledEnterStartNewLine")), { autoFocus: O || this.props.autofocus, className: P, disabled: a, readOnly: o, placeholder: n || null, onChange: M => this.foundation.handleChange(M.target.value, M), onFocus: M => this.foundation.handleFocus(M), onBlur: M => this.foundation.handleBlur(M.nativeEvent), onKeyDown: M => this.foundation.handleKeyDown(M), value: T ?? "" }); return we(y) || (N.maxLength = w), I && (N.minLength = I), f.createElement("div", { className: k, style: m, onMouseEnter: M => this.foundation.handleMouseEnter(M), onMouseLeave: M => this.foundation.handleMouseLeave(M) }, t ? f.createElement(As, { onResize: this.throttledResizeTextarea }, f.createElement("textarea", Object.assign({}, N, { ref: this.setRef }))) : f.createElement("textarea", Object.assign({}, N, { ref: this.setRef })), this.renderClearBtn(), this.renderCounter()) } } Ny.propTypes = { autosize: c.oneOfType([c.bool, c.object]), borderless: c.bool, placeholder: c.string, value: c.string, rows: c.number, cols: c.number, maxCount: c.number, onEnterPress: c.func, validateStatus: c.string, className: c.string, style: c.object, showClear: c.bool, onClear: c.func, onResize: c.func, getValueLength: c.func, disabledEnterStartNewLine: c.bool }; Ny.defaultProps = { autosize: !1, borderless: !1, rows: 4, cols: 20, showCounter: !1, showClear: !1, onEnterPress: z, onChange: z, onBlur: z, onFocus: z, onKeyDown: z, onResize: z, onClear: z }; const tO = f.forwardRef((r, e) => f.createElement(Ny, Object.assign({}, r, { forwardRef: e }))); var uZ = tE; function dZ(r) { return uZ(r) && r != +r } var hZ = dZ; const pZ = _e(hZ), fZ = (r, e) => { const { isNaN: t } = Number; return t(r) && t(e) }, gZ = Object.assign({}, Xd), ca = Object.assign(Object.assign({}, LK), { DEFAULT_STEP: 1, DEFAULT_SHIFT_STEP: 10, DEFAULT_PRESS_TIMEOUT: 250, DEFAULT_PRESS_INTERVAL: 0, MOUSE_BUTTON_LEFT: 0 }), mZ = Object.assign({}, Hs); function yZ(r, e) { const t = (r.toString().split(".")[1] || "").length, n = (e.toString().split(".")[1] || "").length, i = Math.pow(10, Math.max(t, n)); return (r * i + e * i) / i } function P0(r, e) { return yZ(r, -e) } class bZ extends ve { init() { this._setInitValue() } destroy() { this._unregisterInterval(), this._unregisterTimer(), this._adapter.unregisterGlobalEvent("mouseup") } isControlled() { return this._isControlledComponent("value") } _doInput() { let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "", t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null, n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null, i = e, s = e, a = !0; const o = this.isControlled(); typeof e != "number" && (s = this.doParse(e, !1), a = !isNaN(s)), a && (i = s, o || this._adapter.setNumber(s)), o || this._adapter.setValue(e, n), this.getProp("keepFocus") && this._adapter.setFocusing(!0, () => { this._adapter.setClickUpOrDown(!0) }), this.notifyChange(i, t) } _registerInterval(e) { const t = this.getProp("pressInterval") || ca.DEFAULT_PRESS_INTERVAL; this._intervalHasRegistered = !0, this._interval = setInterval(() => { typeof e == "function" && this._intervalHasRegistered && e() }, t) } _unregisterInterval() { this._interval && (this._intervalHasRegistered = !1, clearInterval(this._interval), this._interval = null) } _registerTimer(e) { const t = this.getProp("pressTimeout") || ca.DEFAULT_PRESS_TIMEOUT; this._timerHasRegistered = !0, this._timer = setTimeout(() => { this._timerHasRegistered && typeof e == "function" && e() }, t) } _unregisterTimer() { this._timer && (this._timerHasRegistered = !1, clearTimeout(this._timer), this._timer = null) } handleInputFocus(e) { this.getState("value"), this._adapter.recordCursorPosition(), this._adapter.setFocusing(!0, null), this._adapter.setClickUpOrDown(!1), this._adapter.notifyFocus(e) } handleInputChange(e, t) { const n = this.doParse(e, !0, !0, !0), i = this.doParse(e, !1, !1, !1), s = this.afterParser(e); this._adapter.recordCursorPosition(); let a, o = i, l = e; if (e === "") this.isControlled() || (o = null); else if (this.isValidNumber(i) && this.isValidNumber(n)) a = i, l = this.doFormat(i, !1); else { if (typeof i == "number" && !isNaN(i)) { l = this.doFormat(i, !1); const u = s.lastIndexOf("."), d = s.length - 1 - u, h = this._getPrecLen(i); if (h) { if (h < d) for (let g = 0; g < d - h; g++)l += "0" } else { const g = u > -1 ? s.slice(u) : ""; l += g } o = i } else l = this.doFormat(s, !1); a = s } !this.isControlled() && (o === null || typeof o == "number" && !isNaN(o)) && this._adapter.setNumber(o), this._adapter.setValue(this.isControlled() ? l : this.doFormat(s, !1), () => { this._adapter.restoreCursor() }), this.notifyChange(a, t) } handleInputKeyDown(e) { const t = e.keyCode; if (t === Tn.UP || t === Tn.DOWN) { this._adapter.setClickUpOrDown(!0), this._adapter.recordCursorPosition(); const n = t === Tn.UP ? this.add(null, e) : this.minus(null, e); this._doInput(n, e, () => { this._adapter.restoreCursor() }), e.preventDefault() } this._adapter.notifyKeyDown(e) } handleInputBlur(e) { const t = Ss(this.getState("value")); let n = this.getState("number"); if (n != null || t != null && t !== "") { const i = this.doParse(t, !1, !0, !0); let s = !1, a = !1, o, l; this.isValidNumber(i) && n !== i && (o = i, this.isControlled() || (n = o), s = !0); const u = this.doFormat(n, !0); if (u !== t && (l = u, a = !0), a || s) { const d = l ?? o; l != null && this._adapter.setValue(l), o != null && (this._isControlledComponent("value") || this._adapter.setNumber(o)), this.notifyChange(d, e) } } this._adapter.setFocusing(!1), this._adapter.notifyBlur(e) } handleInputMouseEnter(e) { this._adapter.setHovering(!0) } handleInputMouseLeave(e) { this._adapter.setHovering(!1) } handleInputMouseMove(e) { this._adapter.setHovering(!0) } handleMouseUp(e) { this._unregisterInterval(), this._unregisterTimer(), this._adapter.unregisterGlobalEvent("mouseup") } handleUpClick(e) { const { readonly: t } = this.getProps(); !this._isMouseButtonLeft(e) || t || (this._adapter.setClickUpOrDown(!0), e && (this._persistEvent(e), e.stopPropagation(), this._preventDefault(e)), this.upClick(e), this._registerTimer(() => { this._registerInterval(() => { this.upClick(e) }) })) } handleDownClick(e) { const { readonly: t } = this.getProps(); !this._isMouseButtonLeft(e) || t || (this._adapter.setClickUpOrDown(!0), e && (this._persistEvent(e), e.stopPropagation(), this._preventDefault(e)), this.downClick(e), this._registerTimer(() => { this._registerInterval(() => { this.downClick(e) }) })) } _isMouseButtonLeft(e) { return H(e, "button") === ca.MOUSE_BUTTON_LEFT } _preventDefault(e) { const t = this._adapter.getProp("keepFocus"), n = this._adapter.getProp("innerButtons"); (t || n) && e.preventDefault() } handleMouseLeave(e) { this._adapter.registerGlobalEvent("mouseup", () => { this.handleMouseUp(e) }) } upClick(e) { const t = this.add(null, e); this._doInput(t, e), this._adapter.notifyUpClick(t, e) } downClick(e) { const t = this.minus(null, e); this._doInput(t, e), this._adapter.notifyDownClick(t, e) } _setInitValue() { const { defaultValue: e, value: t } = this.getProps(), n = this._isControlledComponent("value") ? t : e, i = this.doParse(Ss(n), !1, !0, !0); let s = null; typeof i == "number" && !isNaN(i) && (s = i); const a = typeof s == "number" ? this.doFormat(s, !0) : ""; this._adapter.setNumber(s), this._adapter.setValue(a), Fe(a) && a !== String(n ?? "") && this.notifyChange(a, null) } add(e, t) { const i = t && t.shiftKey ? this.getProp("shiftStep") : this.getProp("step"); e = e == null ? i : Number(e); const s = Math.abs(zr(e)), a = this.getState("number"); let o = this.toNumber(a) || 0; const l = this.getProp("min"), u = this.getProp("max"), d = this._getPrecLen(l), h = this._getPrecLen(u), g = this._getPrecLen(o), m = this._getPrecLen(e), b = Math.pow(10, Math.max(d, h, g, m)); return e < 0 ? Math.abs(P0(l, o)) >= s && (o = (o * b + e * b) / b) : e > 0 && Math.abs(P0(u, o)) >= s && (o = (o * b + e * b) / b), typeof l == "number" && l > o && (o = l), typeof u == "number" && u < o && (o = u), this.doFormat(o, !0) } minus(e, t) { const i = t && t.shiftKey ? this.getProp("shiftStep") : this.getProp("step"); return e = e == null ? i : Number(e), this.add(-e, t) } _getPrecLen(e) { typeof e != "string" && (e = String(Math.abs(Number(e || "")))); const t = e.indexOf(".") + 1; return t ? e.length - t : 0 } _adjustPrec(e) { const t = this.getProp("precision"); return typeof t == "number" && e !== "" && e !== null && !Number.isNaN(Number(e)) && (e = Number(e).toFixed(t)), Ss(e) } doFormat() { let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0, t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0, n; const i = this.getProp("formatter"); return t ? n = this._adjustPrec(e) : n = Ss(e), typeof i == "function" && (n = i(n)), n } fetchMinOrMax(e) { const { min: t, max: n } = this.getProps(); return e < t ? t : e > n ? n : e } doParse(e) { let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0, n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1, i = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : !1; if (typeof e == "number") return i && (e = this.fetchMinOrMax(e)), n && (e = this._adjustPrec(e)), zr(e); const s = this.getProp("parser"); if (typeof s == "function" && (e = s(e)), t && typeof e == "string") { const a = e.indexOf(".") === -1 || e.indexOf(".") > -1 && (e === "0" || e.lastIndexOf("0") < e.length - 1), o = e.lastIndexOf(".") < e.length - 1 && e.split("").filter(l => l === ".").length < 2; if (!a || !o) return NaN } return n && (e = this._adjustPrec(e)), typeof e == "string" && e.length ? i ? this.fetchMinOrMax(zr(e)) : zr(e) : NaN } afterParser(e) { const t = this.getProp("parser"); return Ss(typeof e == "string" && typeof t == "function" ? t(e) : e) } toNumber(e) { let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0; if (typeof e == "number") return e; if (typeof e == "string") { const n = this.getProp("parser"); typeof n == "function" && (e = n(e)), t && (e = this._adjustPrec(e)) } return zr(e) } isValidNumber(e) { let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0; if (typeof e == "number" && !isNaN(e)) { const { min: n, max: i, precision: s } = this.getProps(), a = this._getPrecLen(e), o = t ? typeof s == "number" && a <= s || typeof s != "number" : !0; if (e >= n && e <= i && o) return !0 } return !1 } isValidString(e) { if (typeof e == "string" && e.length) { const t = this.doParse(e); return this.isValidNumber(t) } return !1 } notifyChange(e, t) { if (e == null || e === "") this._adapter.notifyChange("", t); else { const n = this.toNumber(e, !0); typeof n == "number" && !isNaN(n) ? (this._adapter.notifyChange(n, t), this.notifyNumberChange(n, t)) : this._adapter.notifyChange(this.afterParser(e), t) } } notifyNumberChange(e, t) { const { number: n } = this.getStates(); this.isValidNumber(e) && e !== n && this._adapter.notifyNumberChange(e, t) } updateStates(e, t) { this._adapter.updateStates(e, t) } } var vZ = function (r, e) { var t = {}; for (var n in r) Object.prototype.hasOwnProperty.call(r, n) && e.indexOf(n) < 0 && (t[n] = r[n]); if (r != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, n = Object.getOwnPropertySymbols(r); i < n.length; i++)e.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(r, n[i]) && (t[n[i]] = r[n[i]]); return t }; class fd extends de { get adapter() { var e = this; return Object.assign(Object.assign({}, super.adapter), { setValue: (t, n) => this.setState({ value: t }, n), setNumber: (t, n) => this.setState({ number: t }, n), setFocusing: (t, n) => this.setState({ focusing: t }, n), setHovering: t => this.setState({ hovering: t }), notifyChange: function () { return e.props.onChange(...arguments) }, notifyNumberChange: function () { return e.props.onNumberChange(...arguments) }, notifyBlur: t => this.props.onBlur(t), notifyFocus: t => this.props.onFocus(t), notifyUpClick: (t, n) => this.props.onUpClick(t, n), notifyDownClick: (t, n) => this.props.onDownClick(t, n), notifyKeyDown: t => this.props.onKeyDown(t), registerGlobalEvent: (t, n) => { t && typeof n == "function" && (this.adapter.unregisterGlobalEvent(t), this.adapter.setCache(t, n), document.addEventListener(t, n)) }, unregisterGlobalEvent: t => { if (t) { const n = this.adapter.getCache(t); document.removeEventListener(t, n), this.adapter.setCache(t, null) } }, recordCursorPosition: () => { try { this.inputNode && (this.cursorStart = this.inputNode.selectionStart, this.cursorEnd = this.inputNode.selectionEnd, this.currentValue = this.inputNode.value, this.cursorBefore = this.inputNode.value.substring(0, this.cursorStart), this.cursorAfter = this.inputNode.value.substring(this.cursorEnd)) } catch (t) { console.warn(t) } }, restoreByAfter: t => { if (ze(t)) return !1; const n = this.inputNode.value, i = n.lastIndexOf(t); return i === -1 ? !1 : i + t.length === n.length ? (this.adapter.fixCaret(i, i), !0) : !1 }, restoreCursor: function () { let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : e.cursorAfter; return ze(t) ? !1 : Array.prototype.some.call(t, (n, i) => { const s = t.substring(i); return e.adapter.restoreByAfter(s) }) }, fixCaret: (t, n) => { if (!(t === void 0 || n === void 0 || !this.inputNode || !this.inputNode.value)) try { const i = this.inputNode.selectionStart, s = this.inputNode.selectionEnd; (t !== i || n !== s) && this.inputNode.setSelectionRange(t, n) } catch { } }, setClickUpOrDown: t => { this.clickUpOrDown = t }, updateStates: (t, n) => { this.setState(t, n) } }) } constructor(e) { super(e), this.setInputRef = t => { const { forwardedRef: n } = this.props; this.inputNode = t, n && typeof n == "object" ? n.current = t : typeof n == "function" && n(t) }, this.handleInputFocus = t => this.foundation.handleInputFocus(t), this.handleInputChange = (t, n) => this.foundation.handleInputChange(t, n), this.handleInputBlur = t => this.foundation.handleInputBlur(t), this.handleInputKeyDown = t => this.foundation.handleInputKeyDown(t), this.handleInputMouseEnter = t => this.foundation.handleInputMouseEnter(t), this.handleInputMouseLeave = t => this.foundation.handleInputMouseLeave(t), this.handleInputMouseMove = t => this.foundation.handleInputMouseMove(t), this.handleUpClick = t => this.foundation.handleUpClick(t), this.handleDownClick = t => this.foundation.handleDownClick(t), this.handleMouseUp = t => this.foundation.handleMouseUp(t), this.handleMouseLeave = t => this.foundation.handleMouseLeave(t), this.renderButtons = () => { const { prefixCls: t, disabled: n, innerButtons: i, max: s, min: a } = this.props, { hovering: o, focusing: l, number: u } = this.state, d = n || u === s, h = n || u === a, g = F(`${t}-number-suffix-btns`, { [`${t}-number-suffix-btns-inner`]: i, [`${t}-number-suffix-btns-inner-hover`]: i && o && !l }), m = F(`${t}-number-button`, `${t}-number-button-up`, { [`${t}-number-button-up-disabled`]: n, [`${t}-number-button-up-not-allowed`]: d }), b = F(`${t}-number-button`, `${t}-number-button-down`, { [`${t}-number-button-down-disabled`]: n, [`${t}-number-button-down-not-allowed`]: h }); return f.createElement("div", { className: g }, f.createElement("span", { className: m, onMouseDown: d ? z : this.handleUpClick, onMouseUp: this.handleMouseUp, onMouseLeave: this.handleMouseLeave }, f.createElement(Hz, { size: "extra-small" })), f.createElement("span", { className: b, onMouseDown: h ? z : this.handleDownClick, onMouseUp: this.handleMouseUp, onMouseLeave: this.handleMouseLeave }, f.createElement(os, { size: "extra-small" }))) }, this.renderSuffix = () => { const { innerButtons: t, suffix: n } = this.props, { hovering: i, focusing: s } = this.state; return t && (i || s) ? this.renderButtons() : n }, this.state = { value: "", number: null, focusing: !!e.autofocus || !1, hovering: !1 }, this.inputNode = null, this.foundation = new bZ(this.adapter), this.clickUpOrDown = !1 } componentDidUpdate(e) { const { value: t, preventScroll: n } = this.props, { focusing: i } = this.state; let s; if (t !== e.value && !fZ(t, e.value)) { if (ze(t) || t === "") s = "", this.foundation.updateStates({ value: s, number: null }); else { let a = t; typeof t == "number" && (a = this.foundation.doFormat(t)); const o = this.foundation.doParse(a, !1, !0, !0), l = typeof t == "number" ? t : this.foundation.doParse(a, !1, !1, !1); if (i) if (this.foundation.isValidNumber(o) && o !== this.state.number) { const u = { number: o }; this.clickUpOrDown && (u.value = this.foundation.doFormat(u.number, !0), s = u.value), this.foundation.updateStates(u, () => this.adapter.restoreCursor()) } else pZ(l) ? this.foundation.updateStates({ value: a }) : (s = this.foundation.doFormat(l, !1), this.foundation.updateStates({ value: s })); else this.foundation.isValidNumber(o) ? (s = this.foundation.doFormat(o), this.foundation.updateStates({ number: o, value: s })) : (s = "", this.foundation.updateStates({ number: null, value: s })) } s && Fe(s) && s !== String(this.props.value) && this.foundation.notifyChange(s, null) } this.clickUpOrDown && this.props.keepFocus && this.state.focusing && document.activeElement !== this.inputNode && this.inputNode.focus({ preventScroll: n }) } render() { const e = this.props, { disabled: t, className: n, prefixCls: i, min: s, max: a, step: o, shiftStep: l, precision: u, formatter: d, parser: h, forwardedRef: g, onUpClick: m, onDownClick: b, pressInterval: y, pressTimeout: w, suffix: x, size: S, hideButtons: C, innerButtons: O, style: E, onNumberChange: v, keepFocus: T, defaultValue: I } = e, k = vZ(e, ["disabled", "className", "prefixCls", "min", "max", "step", "shiftStep", "precision", "formatter", "parser", "forwardedRef", "onUpClick", "onDownClick", "pressInterval", "pressTimeout", "suffix", "size", "hideButtons", "innerButtons", "style", "onNumberChange", "keepFocus", "defaultValue"]), { value: P, number: N } = this.state, M = F(n, `${i}-number`, { [`${i}-number-size-${S}`]: S }), B = this.renderButtons(), K = { "aria-disabled": t, step: o }; return N && (K["aria-valuenow"] = N), a !== 1 / 0 && (K["aria-valuemax"] = a), s !== -1 / 0 && (K["aria-valuemin"] = s), f.createElement("div", { className: M, style: E, onMouseMove: W => this.handleInputMouseMove(W), onMouseEnter: W => this.handleInputMouseEnter(W), onMouseLeave: W => this.handleInputMouseLeave(W) }, f.createElement(xr, Object.assign({ role: "spinbutton" }, K, k, { size: S, disabled: t, ref: this.setInputRef, value: P, onFocus: this.handleInputFocus, onChange: this.handleInputChange, onBlur: this.handleInputBlur, onKeyDown: this.handleInputKeyDown, suffix: this.renderSuffix() })), C || O ? null : B) } } fd.propTypes = { "aria-label": c.string, "aria-labelledby": c.string, "aria-invalid": c.bool, "aria-errormessage": c.string, "aria-describedby": c.string, "aria-required": c.bool, autofocus: c.bool, clearIcon: c.node, className: c.string, defaultValue: c.oneOfType([c.number, c.string]), disabled: c.bool, formatter: c.func, forwardedRef: c.any, hideButtons: c.bool, innerButtons: c.bool, insetLabel: c.node, insetLabelId: c.string, keepFocus: c.bool, max: c.number, min: c.number, parser: c.func, precision: c.number, prefixCls: c.string, pressInterval: c.number, pressTimeout: c.number, preventScroll: c.bool, shiftStep: c.number, step: c.number, style: c.object, suffix: c.any, value: c.oneOfType([c.number, c.string]), onBlur: c.func, onChange: c.func, onDownClick: c.func, onKeyDown: c.func, onNumberChange: c.func, onUpClick: c.func }; fd.defaultProps = { forwardedRef: z, innerButtons: !1, keepFocus: !1, max: 1 / 0, min: -1 / 0, prefixCls: gZ.PREFIX, pressInterval: ca.DEFAULT_PRESS_TIMEOUT, pressTimeout: ca.DEFAULT_PRESS_TIMEOUT, shiftStep: ca.DEFAULT_SHIFT_STEP, size: mZ.DEFAULT_SIZE, step: ca.DEFAULT_STEP, onBlur: z, onChange: z, onDownClick: z, onFocus: z, onKeyDown: z, onNumberChange: z, onUpClick: z }; const nO = c_(f.forwardRef(function (e, t) { return f.createElement(fd, Object.assign({}, e, { forwardedRef: t })) }), fd), k0 = "horizontal", R0 = "vertical", fi = { PREFIX: `${G}-navigation` }, Pt = { MODE: [R0, k0], MODE_VERTICAL: R0, MODE_HORIZONTAL: k0, ICON_POS_LEFT: "left", ICON_POS_RIGHT: "right", DEFAULT_LOGO_ICON_SIZE: "extra-large", TOGGLE_ICON_LEFT: "left", TOGGLE_ICON_RIGHT: "right" }, so = { DEFAULT_SUBNAV_MAX_HEIGHT: 999, DEFAULT_TOOLTIP_SHOW_DELAY: 0, DEFAULT_TOOLTIP_HIDE_DELAY: 100, DEFAULT_SUBNAV_OPEN_DELAY: 0, DEFAULT_SUBNAV_CLOSE_DELAY: 100 }, D0 = { open: "chevron_up", closed: "chevron_down" }; let xZ = class kg { constructor() { let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}; (e == null || typeof e != "object") && (e = { text: e, itemKey: e, maxHeight: so.DEFAULT_SUBNAV_MAX_HEIGHT, link: null, items: null, icon: "", indent: !1 }); for (const t of Object.keys(e)) this[t] = e[t]; e.items && Array.isArray(e.items) && e.items.length ? (this.items = e.items.map(t => new kg(t)), "toggleIcon" in e ? this.toggleIcon = kg.isValidToggleIcon(e.toggleIcon) ? Object.assign({}, e.toggleIcon) : Object.assign({}, D0) : this.toggleIcon = Object.assign({}, D0)) : this.items = null } static isValidToggleIcon(e) { return !!(e && typeof e == "object" && typeof e.open == "string" && e.open.length && typeof e.closed == "string" && e.closed.length) } }; class ao extends ve { constructor(e) { super(Object.assign({}, e)) } static getZeroParentKeys() { let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}; const t = []; for (var n = arguments.length, i = new Array(n > 1 ? n - 1 : 0), s = 1; s < n; s++)i[s - 1] = arguments[s]; if (i.length) { for (const a of i) if (Array.isArray(e[a]) && e[a].length) { const o = e[a][0]; ze(o) || t.push(o) } } return t } static buildItemKeysMap() { let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [], t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [], i = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : "itemKey"; if (Array.isArray(e) && e.length) for (const s of e) if (Array.isArray(s)) ao.buildItemKeysMap(s, t, [...n], i); else { let a; if (s && typeof s == "object" && (a = s[i] || s.props && s.props[i]), a) { if (t[a] = [...n], Array.isArray(s.items) && s.items.length) ao.buildItemKeysMap(s.items, t, [...n, a], i); else if (s.props && s.props.children) { const o = Array.isArray(s.props.children) ? s.props.children : [s.props.children]; ao.buildItemKeysMap(o, t, [...n, a], i) } } } return t } init(e) { const { defaultSelectedKeys: t, selectedKeys: n } = this.getProps(); let i = n || t || []; const { itemKeysMap: s, willOpenKeys: a, formattedItems: o } = this.getCalcState(), l = this.selectLevelZeroParentKeys(s, i); if (i = i.concat(l), e === "constructor") return { selectedKeys: i, itemKeysMap: s, openKeys: a, items: o }; this._adapter.updateSelectedKeys(i, !1), this._adapter.setItemKeysMap(s), this._adapter.updateOpenKeys(a), this._adapter.updateItems(o), this._adapter.setItemsChanged(!0) } getCalcState() { const { itemKeysMap: e, formattedItems: t } = this.getFormattedItems(), n = this.getWillOpenKeys(e); return { itemKeysMap: e, willOpenKeys: n, formattedItems: t } } getFormattedItems() { const { items: e, children: t } = this.getProps(), n = this.formatItems(e), i = Array.isArray(e) && e.length ? n : t; return { itemKeysMap: ao.buildItemKeysMap(i), formattedItems: n } } getWillOpenKeys(e) { const { defaultOpenKeys: t, openKeys: n, defaultSelectedKeys: i, selectedKeys: s, mode: a } = this.getProps(), { openKeys: o = [] } = this.getStates(); let l = n || t || []; if (!(Array.isArray(t) || Array.isArray(n)) && a === Pt.MODE_VERTICAL && (Array.isArray(i) || Array.isArray(s))) { const u = Array.isArray(s) ? s : i; l = o.concat(this.getShouldOpenKeys(e, u)), l = Array.from(new Set(l)) } return [...l] } getShouldOpenKeys() { let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : []; const n = new Set; return Array.isArray(t) && t.length && t.forEach(i => { if (i) { const s = H(e, i); Array.isArray(s) && s.forEach(a => n.add(a)) } }), [...n] } destroy() { } selectLevelZeroParentKeys(e, t) { const n = ze(e) ? this.getState("itemKeysMap") : e, i = []; if (t.length) { for (const s of t) if (Array.isArray(n[s]) && n[s].length) { const a = n[s][0]; ze(a) || i.push(a) } } return i.length ? i : [] } formatItems() { let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : []; const t = []; for (const n of e) t.push(new xZ(n)); return t } handleSelect(e) { this._adapter.notifySelect(e) } judgeIfOpen(e, t) { let n = !1; const i = Array.isArray(e) ? e : e && [e]; if (i && Array.isArray(t) && t.length) { for (const s of t) if (n = i.includes(s.itemKey) || this.judgeIfOpen(i, s.items), n) break } return n } handleCollapseChange() { const e = !this.getState("isCollapsed"); this._isControlledComponent("isCollapsed") || this._adapter.setIsCollapsed(e), this._adapter.notifyCollapseChange(e) } handleItemsChange(e) { this._adapter.setItemsChanged(e) } } const A0 = function () { let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : []; const t = new Set(e); for (var n = arguments.length, i = new Array(n > 1 ? n - 1 : 0), s = 1; s < n; s++)i[s - 1] = arguments[s]; return i.forEach(a => a && t.add(a)), Array.from(t) }, N0 = function () { let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : []; const t = new Set(e); for (var n = arguments.length, i = new Array(n > 1 ? n - 1 : 0), s = 1; s < n; s++)i[s - 1] = arguments[s]; return i.forEach(a => a && t.delete(a)), Array.from(t) }; class wZ extends ve { constructor(e) { super(Object.assign({}, e)) } init() { this._timer = null } destroy() { this.clearDelayTimer() } clearDelayTimer() { this._timer && (clearTimeout(this._timer), this._timer = null) } isValidKey(e) { return e != null && (typeof e == "number" || typeof e == "string") } handleDropdownVisibleChange(e) { const t = this.getProp("itemKey"), n = this._adapter.getOpenKeysIsControlled(), i = this._adapter.getCanUpdateOpenKeys(), s = this._adapter.getOpenKeys(), a = e ? A0(s, t) : N0(s, t); this.clearDelayTimer(), n || i && this._adapter.updateOpen(e), this._adapter.notifyGlobalOpenChange({ itemKey: t, openKeys: a, isOpen: e }) } handleClick(e, t) { const { itemKey: n, disabled: i } = this.getProps(); if (i) return; const s = t && t.contains(e.target); let a = !!this._adapter.getIsOpen(); s ? a = !a : a = !1; const o = a ? A0(this._adapter.getOpenKeys(), n) : N0(this._adapter.getOpenKeys(), n), l = { itemKey: n, openKeys: o, isOpen: a, domEvent: e }, u = this._adapter.getOpenKeysIsControlled(), d = this._adapter.getCanUpdateOpenKeys(); !u && d && this._adapter.updateOpen(a), this._adapter.notifyGlobalOpenChange(l), this._adapter.notifyGlobalOnClick(l) } handleKeyPress(e, t) { Jn(e) && this.handleClick(e, t) } } class CZ extends ve { constructor(e) { super(Object.assign({}, e)) } init() { this._timer = null, this._mounted = !0 } destroy() { this._mounted = !1 } isValidKey(e) { return e != null && (typeof e == "string" || typeof e == "number") } handleClick(e) { const { isSubNav: t, itemKey: n, text: i, disabled: s } = this.getProps(); if (s) return; !t && this.isValidKey(n) && !this._adapter.getSelectedKeysIsControlled() && !this._adapter.getSelected() && this._adapter.updateSelected(!0); const a = [n]; if (!t) { if (!this._adapter.getSelected()) { const o = [this._adapter.cloneDeep(this.getProps())]; this._adapter.notifyGlobalOnSelect({ itemKey: n, selectedKeys: a, selectedItems: o, domEvent: e }) } this._adapter.notifyGlobalOnClick({ itemKey: n, text: i, domEvent: e }) } this._adapter.notifyClick({ itemKey: n, text: i, domEvent: e }) } handleKeyPress(e) { if (Jn(e)) { const { link: t, linkOptions: n } = this.getProps(), i = H(n, "target", "_self"); this.handleClick(e), typeof t == "string" && (i === "_blank" ? window.open(t) : window.location.href = t) } } } const el = f.createContext({ isCollapsed: !1, selectedKeys: [], openKeys: [] }), tr = `${fi.PREFIX}-item`; class tl extends de { constructor(e) { super(e), this.setItemRef = t => { this.props.forwardRef && this.props.forwardRef(t) }, this.wrapTooltip = t => { const { text: n, tooltipHideDelay: i, tooltipShowDelay: s } = this.props, a = i ?? this.context.tooltipHideDelay, o = s ?? this.context.tooltipShowDelay; return f.createElement(ln, { content: n, wrapWhenSpecial: !1, position: "right", trigger: "hover", mouseEnterDelay: o, mouseLeaveDelay: a }, t) }, this.handleClick = t => this.foundation.handleClick(t), this.handleKeyPress = t => this.foundation.handleKeyPress(t), this.state = { tooltipShow: !1 }, this.foundation = new CZ(this.adapter) } _invokeContextFunc(e) { if (e && this.context && typeof this.context[e] == "function") { for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), i = 1; i < t; i++)n[i - 1] = arguments[i]; return this.context[e](...n) } return null } get adapter() { var e = this; return Object.assign(Object.assign({}, super.adapter), { cloneDeep: Hr, updateTooltipShow: t => this.setState({ tooltipShow: t }), updateSelected: t => this._invokeContextFunc("updateSelectedKeys", [this.props.itemKey]), updateGlobalSelectedKeys: t => this._invokeContextFunc("updateSelectedKeys", [...t]), getSelectedKeys: () => this.context && this.context.selectedKeys, getSelectedKeysIsControlled: () => this.context && this.context.selectedKeysIsControlled, notifyGlobalOnSelect: function () { for (var t = arguments.length, n = new Array(t), i = 0; i < t; i++)n[i] = arguments[i]; return e._invokeContextFunc("onSelect", ...n) }, notifyGlobalOnClick: function () { for (var t = arguments.length, n = new Array(t), i = 0; i < t; i++)n[i] = arguments[i]; return e._invokeContextFunc("onClick", ...n) }, notifyClick: function () { return e.props.onClick(...arguments) }, notifyMouseEnter: function () { return e.props.onMouseEnter(...arguments) }, notifyMouseLeave: function () { return e.props.onMouseLeave(...arguments) }, getIsCollapsed: () => this.props.isCollapsed || !!(this.context && this.context.isCollapsed) || !1, getSelected: () => !!(this.context && this.context.selectedKeys && this.context.selectedKeys.includes(this.props.itemKey)), getIsOpen: () => !!(this.context && this.context.openKeys && this.context.openKeys.includes(this.props.itemKey)) }) } renderIcon(e, t) { let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1, i = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0; if (this.props.isSubNav || !e && this.context.mode === Pt.MODE_HORIZONTAL) return null; let s = "large"; t === Pt.ICON_POS_RIGHT && (s = "default"); const a = F(`${tr}-icon`, { [`${tr}-icon-toggle-${this.context.toggleIconPosition}`]: n, [`${tr}-icon-info`]: !n }); return f.createElement("i", { className: a, key: i }, Bn(e) ? f.cloneElement(e, { size: e.props.size || s }) : e) } render() { const { text: e, children: t, icon: n, toggleIcon: i, className: s, isSubNav: a, style: o, indent: l, onMouseEnter: u, onMouseLeave: d, link: h, linkOptions: g, disabled: m, level: b = 0, tabIndex: y } = this.props, { mode: w, isInSubNav: x, prefixCls: S, limitIndent: C } = this.context, O = this.adapter.getIsCollapsed(), E = this.adapter.getSelected(); let v = null; if (!ze(t)) v = t; else { let I = null; if (w === Pt.MODE_VERTICAL && !C && !O) { const k = n && !l ? b : b - 1; I = pd(k, P => this.renderIcon(null, Pt.ICON_POS_RIGHT, !1, P)) } v = f.createElement(f.Fragment, null, I, this.context.toggleIconPosition === Pt.TOGGLE_ICON_LEFT && this.renderIcon(i, Pt.ICON_POS_RIGHT, !0, "key-toggle-pos-right"), n || l || x ? this.renderIcon(n, Pt.ICON_POS_LEFT, !1, "key-position-left") : null, ze(e) ? "" : f.createElement("span", { className: `${fi.PREFIX}-item-text` }, e), this.context.toggleIconPosition === Pt.TOGGLE_ICON_RIGHT && this.renderIcon(i, Pt.ICON_POS_RIGHT, !0, "key-toggle-pos-right")) } typeof h == "string" && (v = f.createElement("a", Object.assign({ className: `${S}-item-link`, href: h, tabIndex: -1 }, g), v)); let T = ""; if (x && (O || w === Pt.MODE_HORIZONTAL)) { const I = F({ [tr]: !0, [`${tr}-sub`]: a, [`${tr}-selected`]: E, [`${tr}-collapsed`]: O, [`${tr}-disabled`]: m }); T = f.createElement(Jt.Item, { selected: E, active: E, forwardRef: this.setItemRef, className: I, onClick: this.handleClick, onMouseEnter: u, onMouseLeave: d, disabled: m, onKeyDown: this.handleKeyPress }, v) } else { const I = F(`${s || `${tr}-normal`}`, { [tr]: !0, [`${tr}-sub`]: a, [`${tr}-selected`]: E && !a, [`${tr}-collapsed`]: O, [`${tr}-disabled`]: m, [`${tr}-has-link`]: typeof h == "string" }), k = { "aria-disabled": m }; if (a) { const P = this.adapter.getIsOpen(); k["aria-expanded"] = P } T = f.createElement("li", Object.assign({ role: a ? null : "menuitem", tabIndex: a ? -1 : y }, k, { style: o, ref: this.setItemRef, className: I, onClick: this.handleClick, onMouseEnter: u, onMouseLeave: d, onKeyPress: this.handleKeyPress }, this.getDataAttr(this.props)), v) } return (O && !x && !a || O && a && m) && (T = this.wrapTooltip(T)), typeof this.context.renderWrapper == "function" ? this.context.renderWrapper({ itemElement: T, isSubNav: a, isInSubNav: x, props: this.props }) : T } } tl.contextType = el; tl.propTypes = { text: c.oneOfType([c.string, c.node]), itemKey: c.oneOfType([c.string, c.number]), onClick: c.func, onMouseEnter: c.func, onMouseLeave: c.func, children: c.node, icon: c.oneOfType([c.node]), className: c.string, toggleIcon: c.string, style: c.object, forwardRef: c.func, indent: c.oneOfType([c.bool, c.number]), isCollapsed: c.bool, isSubNav: c.bool, link: c.string, linkOptions: c.object, disabled: c.bool, tabIndex: c.number }; tl.defaultProps = { isSubNav: !1, indent: !1, forwardRef: z, isCollapsed: !1, onClick: z, onMouseEnter: z, onMouseLeave: z, disabled: !1, tabIndex: 0 }; class Lc extends de { constructor(e) { super(e), this.setItemRef = t => { t && t.current ? this.itemRef = t : this.itemRef = { current: t } }, this.setTitleRef = t => { t && t.current ? this.titleRef = t : this.titleRef = { current: t } }, this.handleClick = t => { this.foundation.handleClick(t && t.nativeEvent, this.titleRef && this.titleRef.current) }, this.handleKeyPress = t => { this.foundation.handleKeyPress(t && t.nativeEvent, this.titleRef && this.titleRef.current) }, this.handleDropdownVisible = t => this.foundation.handleDropdownVisibleChange(t), this.state = { isHovered: !1 }, this.adapter.setCache("firstMounted", !0), this.titleRef = f.createRef(), this.itemRef = f.createRef(), this.foundation = new wZ(this.adapter) } _invokeContextFunc(e) { if (e && this.context && typeof this.context[e] == "function") { for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), i = 1; i < t; i++)n[i - 1] = arguments[i]; return this.context[e](...n) } return null } get adapter() { var e = this; return Object.assign(Object.assign({}, super.adapter), { updateIsHovered: t => this.setState({ isHovered: t }), getOpenKeys: () => this.context && this.context.openKeys, getOpenKeysIsControlled: () => this.context && this.context.openKeysIsControlled, getCanUpdateOpenKeys: () => this.context && this.context.canUpdateOpenKeys, updateOpen: t => this._invokeContextFunc(t ? "addOpenKeys" : "removeOpenKeys", this.props.itemKey), notifyGlobalOpenChange: function () { for (var t = arguments.length, n = new Array(t), i = 0; i < t; i++)n[i] = arguments[i]; return e._invokeContextFunc("onOpenChange", ...n) }, notifyGlobalOnSelect: function () { for (var t = arguments.length, n = new Array(t), i = 0; i < t; i++)n[i] = arguments[i]; return e._invokeContextFunc("onSelect", ...n) }, notifyGlobalOnClick: function () { for (var t = arguments.length, n = new Array(t), i = 0; i < t; i++)n[i] = arguments[i]; return e._invokeContextFunc("onClick", ...n) }, getIsSelected: t => !!(!ze(t) && H(this.context, "selectedKeys", []).includes(String(t))), getIsOpen: () => (this.props, !!(this.context && this.context.openKeys && this.context.openKeys.includes(this.props.itemKey))) }) } renderIcon(e, t, n) { let i = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : !1, s = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 0; const { prefixCls: a } = this.context; let o = "large"; t === Pt.ICON_POS_RIGHT && (o = "default"); const l = F(`${a}-item-icon`, { [`${a}-item-icon-toggle-${this.context.toggleIconPosition}`]: i, [`${a}-item-icon-info`]: !i }), u = this.adapter.getIsOpen(), d = f.isValidElement(e) ? n ? f.createElement(Hi, { animationState: u ? "enter" : "leave", startClassName: `${fi.PREFIX}-icon-rotate-${u ? "180" : "0"}` }, h => { let { animationClassName: g } = h; return f.cloneElement(e, { size: o, className: g }) }) : f.cloneElement(e, { size: o }) : null; return f.createElement("i", { key: s, className: l }, d) } renderTitleDiv() { const { text: e, icon: t, itemKey: n, indent: i, disabled: s, level: a, expandIcon: o } = this.props, { mode: l, isInSubNav: u, isCollapsed: d, prefixCls: h, subNavMotion: g, limitIndent: m } = this.context, b = this.adapter.getIsOpen(), y = F(`${h}-sub-title`, { [`${h}-sub-title-selected`]: this.adapter.getIsSelected(n), [`${h}-sub-title-disabled`]: s }); let w = !1, x = ""; d ? u ? x = f.createElement(Ms, null) : x = null : l === Pt.MODE_HORIZONTAL ? u ? x = f.createElement(Ms, { "aria-hidden": !0 }) : x = o || f.createElement(os, { "aria-hidden": !0 }) : (g && (w = !0), x = o || f.createElement(os, { "aria-hidden": !0 })); let S = null; if (l === Pt.MODE_VERTICAL && !m && !d) { const E = t && !i ? a : a - 1; S = pd(E, v => this.renderIcon(null, Pt.ICON_POS_RIGHT, !1, !1, v)) } const C = !d && u && l === Pt.MODE_HORIZONTAL || d && u; return f.createElement("div", { role: "menuitem", tabIndex: C ? -1 : 0, ref: this.setTitleRef, className: y, onClick: this.handleClick, onKeyPress: this.handleKeyPress, "aria-expanded": b ? "true" : "false" }, f.createElement("div", { className: `${h}-item-inner` }, S, this.context.toggleIconPosition === Pt.TOGGLE_ICON_LEFT && this.renderIcon(x, Pt.ICON_POS_RIGHT, w, !0, "key-toggle-position-left"), t || i || u && l !== Pt.MODE_HORIZONTAL ? this.renderIcon(t, Pt.ICON_POS_LEFT, !1, !1, "key-inSubNav-position-left") : null, f.createElement("span", { className: `${h}-item-text` }, e), this.context.toggleIconPosition === Pt.TOGGLE_ICON_RIGHT && this.renderIcon(x, Pt.ICON_POS_RIGHT, w, !0, "key-toggle-position-right"))) } renderSubUl() { const { children: e, maxHeight: t } = this.props, { isCollapsed: n, mode: i, subNavMotion: s, prefixCls: a } = this.context, o = this.adapter.getIsOpen(), l = i === Pt.MODE_HORIZONTAL, u = F(`${a}-sub`, { [`${a}-sub-open`]: o, [`${a}-sub-popover`]: n || l }); return l ? null : s ? f.createElement(ls, { motion: s, isOpen: o, keepDOM: !1, fade: !0 }, n ? null : f.createElement("ul", { className: u }, e)) : o && !n ? f.createElement("ul", { className: u }, e) : null } wrapDropdown() { let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : ""; const { children: n, dropdownStyle: i, disabled: s, subDropdownProps: a, dropdownProps: o } = this.props, { mode: l, isInSubNav: u, isCollapsed: d, subNavCloseDelay: h, subNavOpenDelay: g, prefixCls: m, getPopupContainer: b } = this.context, y = this.adapter.getIsOpen(), w = this.adapter.getOpenKeysIsControlled(), x = F({ [`${m}-popover`]: d }), S = { trigger: "hover", style: i }; return w && (S.trigger = "custom", S.visible = y), b && (S.getPopupContainer = b), (d || l === Pt.MODE_HORIZONTAL) && (t = s ? t : f.createElement(Jt, Object.assign({ className: x, render: f.createElement(Jt.Menu, null, n), position: l === Pt.MODE_HORIZONTAL && !u ? "bottomLeft" : "rightTop", mouseEnterDelay: g, mouseLeaveDelay: h, onVisibleChange: this.handleDropdownVisible }, o || a, S), t)), t } render() { const { itemKey: e, style: t, onMouseEnter: n, onMouseLeave: i, disabled: s, text: a } = this.props, { mode: o, isCollapsed: l, prefixCls: u } = this.context; let d = this.renderTitleDiv(); const h = this.renderSubUl(); return (l || o === Pt.MODE_HORIZONTAL) && (d = this.wrapDropdown(d)), f.createElement(tl, { style: t, isSubNav: !0, itemKey: e, forwardRef: this.setItemRef, isCollapsed: l, className: `${u}-sub-wrap`, onMouseEnter: n, onMouseLeave: i, disabled: s, text: a }, f.createElement(el.Provider, { value: Object.assign(Object.assign({}, this.context), { isInSubNav: !0 }) }, d, h)) } } Lc.contextType = el; Lc.propTypes = { itemKey: c.oneOfType([c.string, c.number]), text: c.oneOfType([c.string, c.node]), isOpen: c.bool, isCollapsed: c.bool, indent: c.oneOfType([c.bool, c.number]), children: c.node, style: c.object, icon: c.node, maxHeight: c.number, onMouseEnter: c.func, onMouseLeave: c.func, disabled: c.bool, level: c.number }; Lc.defaultProps = { level: 0, indent: !1, isCollapsed: !1, isOpen: !1, maxHeight: so.DEFAULT_SUBNAV_MAX_HEIGHT, disabled: !1 }; function SZ(r) { let { prefixCls: e, locale: t, collapseText: n, isCollapsed: i, onClick: s = z } = r; const a = () => { typeof s == "function" && s(!i) }, o = { icon: f.createElement(QH, null), type: "tertiary", theme: "borderless", onClick: a }; let l = i ? t == null ? void 0 : t.expandText : t == null ? void 0 : t.collapseText; return typeof n == "function" && (l = n(i)), f.createElement("div", { className: `${e}-collapse-btn` }, i ? f.createElement(ln, { content: l, position: "right" }, f.createElement(St, Object.assign({}, o))) : f.createElement(St, Object.assign({}, o), l)) } class Ns extends R.PureComponent { constructor() { super(...arguments), this.renderCollapseButton = () => { const { collapseButton: e, collapseText: t } = this.props; if (f.isValidElement(e)) return e; const { onCollapseChange: n, prefixCls: i, locale: s, isCollapsed: a } = this.context; return f.createElement(SZ, { prefixCls: i, isCollapsed: a, locale: s, onClick: n, collapseText: t }) } } render() { const { style: e, className: t, collapseButton: n, onClick: i } = this.props; let { children: s } = this.props; const { isCollapsed: a, mode: o } = this.context; !f.isValidElement(s) && n && o !== Pt.MODE_HORIZONTAL && (s = this.renderCollapseButton()); const l = F(t, `${fi.PREFIX}-footer`, { [`${fi.PREFIX}-footer-collapsed`]: a }); return f.createElement("div", { className: l, style: e, onClick: i }, s) } } Ns.contextType = el; Ns.propTypes = { children: c.node, style: c.object, className: c.string, collapseButton: c.oneOfType([c.node, c.bool]), collapseText: c.func, onClick: c.func }; Ns.defaultProps = { collapseButton: !1, onClick: z }; Ns.elementType = "NavFooter"; class Fs extends R.PureComponent { renderLogo(e) { return f.isValidElement(e) ? e : null } render() { const { children: e, style: t, className: n, logo: i, text: s, link: a, linkOptions: o, prefixCls: l } = this.props, { isCollapsed: u } = this.context, d = F(n, `${fi.PREFIX}-header`, { [`${fi.PREFIX}-header-collapsed`]: u }); let h = f.createElement(f.Fragment, null, i ? f.createElement("i", { className: `${fi.PREFIX}-header-logo` }, this.renderLogo(i)) : null, !ze(s) && !u ? f.createElement("span", { className: `${fi.PREFIX}-header-text` }, s) : null, e); return typeof a == "string" && (h = f.createElement("a", Object.assign({ className: `${l}-header-link`, href: a }, o), h)), f.createElement("div", { className: d, style: t }, h) } } Fs.contextType = el; Fs.propTypes = { prefixCls: c.string, logo: c.oneOfType([c.string, c.object, c.node]), text: c.oneOfType([c.string, c.node]), children: c.node, style: c.object, className: c.string, link: c.string, linkOptions: c.object }; Fs.defaultProps = { prefixCls: fi.PREFIX }; Fs.elementType = "NavHeader"; var EZ = function (r, e) { var t = {}; for (var n in r) Object.prototype.hasOwnProperty.call(r, n) && e.indexOf(n) < 0 && (t[n] = r[n]); if (r != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, n = Object.getOwnPropertySymbols(r); i < n.length; i++)e.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(r, n[i]) && (t[n[i]] = r[n[i]]); return t }; function F0(r, e) { return function () { const n = new Set(r.state[e]); for (var i = arguments.length, s = new Array(i), a = 0; a < i; a++)s[a] = arguments[a]; s.forEach(o => o && n.add(o)), r.setState({ [e]: Array.from(n) }) } } function $0(r, e) { return function () { const n = new Set(r.state[e]); for (var i = arguments.length, s = new Array(i), a = 0; a < i; a++)s[a] = arguments[a]; s.forEach(o => o && n.delete(o)), r.setState({ [e]: Array.from(n) }) } } const { hasOwnProperty: _Z } = Object.prototype; class Vs extends de { constructor(e) { super(e), this.onCollapseChange = () => { this.foundation.handleCollapseChange() }, this.foundation = new ao(this.adapter), this.itemsChanged = !0; const { isCollapsed: t, defaultIsCollapsed: n, items: i, children: s } = e, a = { isCollapsed: !!(this.isControlled("isCollapsed") ? t : n), openKeys: [], items: [], itemKeysMap: {}, selectedKeys: [] }; if (this.state = Object.assign({}, a), i && i.length || s) { const o = this.foundation.init("constructor"); this.state = Object.assign(Object.assign({}, a), o) } } static getDerivedStateFromProps(e, t) { const n = {}; return _Z.call(e, "isCollapsed") && e.isCollapsed !== t.isCollapsed && (n.isCollapsed = e.isCollapsed), n } componentDidMount() { } componentDidUpdate(e) { if (e.items !== this.props.items || e.children !== this.props.children) this.foundation.init(); else { if (this.foundation.handleItemsChange(!1), this.props.selectedKeys && !ke(e.selectedKeys, this.props.selectedKeys)) { this.adapter.updateSelectedKeys(this.props.selectedKeys); const t = this.foundation.getWillOpenKeys(this.state.itemKeysMap); this.adapter.updateOpenKeys(t) } this.props.openKeys && !ke(e.openKeys, this.props.openKeys) && this.adapter.updateOpenKeys(this.props.openKeys) } } get adapter() { var e = this; return Object.assign(Object.assign({}, super.adapter), { notifySelect: function () { return e.props.onSelect(...arguments) }, notifyOpenChange: function () { return e.props.onOpenChange(...arguments) }, setIsCollapsed: t => this.setState({ isCollapsed: t }), notifyCollapseChange: function () { return e.props.onCollapseChange(...arguments) }, updateItems: t => this.setState({ items: [...t] }), setItemKeysMap: t => this.setState({ itemKeysMap: Object.assign({}, t) }), addSelectedKeys: F0(this, "selectedKeys"), removeSelectedKeys: $0(this, "selectedKeys"), updateSelectedKeys: function (t) { let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0, i = t; if (n) { const s = e.foundation.selectLevelZeroParentKeys(null, t); i = Array.from(new Set(t.concat(s))) } e.setState({ selectedKeys: i }) }, updateOpenKeys: t => this.setState({ openKeys: [...t] }), addOpenKeys: F0(this, "openKeys"), removeOpenKeys: $0(this, "openKeys"), setItemsChanged: t => { this.itemsChanged = t } }) } renderItems() { let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [], t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0; const { expandIcon: n, subDropdownProps: i } = this.props; return f.createElement(f.Fragment, null, e.map((a, o) => Array.isArray(a.items) && a.items.length ? f.createElement(Lc, Object.assign({ key: a.itemKey || String(t) + o }, a, { level: t, expandIcon: n, subDropdownProps: i }), this.renderItems(a.items, t + 1)) : f.createElement(tl, Object.assign({ key: a.itemKey || String(t) + o }, a, { level: t })))) } render() { const e = this.props, { children: t, mode: n, onOpenChange: i, onSelect: s, onClick: a, style: o, className: l, subNavCloseDelay: u, subNavOpenDelay: d, subNavMotion: h, tooltipShowDelay: g, tooltipHideDelay: m, prefixCls: b, bodyStyle: y, footer: w, header: x, toggleIconPosition: S, limitIndent: C, renderWrapper: O, getPopupContainer: E } = e, v = EZ(e, ["children", "mode", "onOpenChange", "onSelect", "onClick", "style", "className", "subNavCloseDelay", "subNavOpenDelay", "subNavMotion", "tooltipShowDelay", "tooltipHideDelay", "prefixCls", "bodyStyle", "footer", "header", "toggleIconPosition", "limitIndent", "renderWrapper", "getPopupContainer"]), { selectedKeys: T, openKeys: I, items: k, isCollapsed: P } = this.state, { updateOpenKeys: N, addOpenKeys: M, removeOpenKeys: B, updateSelectedKeys: K, addSelectedKeys: U, removeSelectedKeys: W } = this.adapter, Z = Object.assign({}, o); let J = R.Children.toArray(t); const ee = [], $ = []; if (f.isValidElement(w) ? ee.push(f.createElement(Ns, { key: 0 }, w)) : w && typeof w == "object" && ee.push(f.createElement(Ns, Object.assign({ key: 0 }, w))), f.isValidElement(x) ? $.push(f.createElement(Fs, { key: 0 }, x)) : x && typeof x == "object" && $.push(f.createElement(Fs, Object.assign({ key: 0 }, x))), Array.isArray(J) && J.length) { J = [...J]; let j = J.length; for (let ae = 0; ae < j; ae++) { const be = J[ae]; be.type === Ns || H(be, "type.elementType") === "NavFooter" ? (ee.push(be), J.splice(ae, 1), ae--, j--) : (be.type === Fs || H(be, "type.elementType") === "NavHeader") && ($.push(be), J.splice(ae, 1), ae--, j--) } } const pe = F(b, l, { [`${b}-collapsed`]: P, [`${b}-horizontal`]: n === "horizontal", [`${b}-vertical`]: n === "vertical" }), re = F(`${b}-header-list-outer`, { [`${b}-header-list-outer-collapsed`]: P }); return this.itemsChanged && this.adapter.setCache("itemElems", this.renderItems(k)), f.createElement(Ke, { componentName: "Navigation" }, j => f.createElement(el.Provider, { value: { subNavCloseDelay: u, subNavOpenDelay: d, subNavMotion: h, tooltipShowDelay: g, tooltipHideDelay: m, openKeys: I, openKeysIsControlled: this.isControlled("openKeys") && n === "vertical" && !P, canUpdateOpenKeys: !0, selectedKeys: T, selectedKeysIsControlled: this.isControlled("selectedKeys"), isCollapsed: P, onCollapseChange: this.onCollapseChange, mode: n, onSelect: s, onOpenChange: i, updateOpenKeys: N, addOpenKeys: M, removeOpenKeys: B, updateSelectedKeys: K, addSelectedKeys: U, removeSelectedKeys: W, onClick: a, locale: j, prefixCls: b, toggleIconPosition: S, limitIndent: C, renderWrapper: O, getPopupContainer: E } }, f.createElement("div", Object.assign({ className: pe, style: Z }, this.getDataAttr(v)), f.createElement("div", { className: `${b}-inner` }, f.createElement("div", { className: re }, $, f.createElement("div", { style: y, className: `${b}-list-wrapper` }, f.createElement("ul", { role: "menu", "aria-orientation": n, className: `${b}-list` }, this.adapter.getCache("itemElems"), J))), ee)))) } } Vs.Sub = Lc; Vs.Item = tl; Vs.Header = Fs; Vs.Footer = Ns; Vs.propTypes = { collapseIcon: c.node, defaultOpenKeys: c.arrayOf(c.oneOfType([c.string, c.number])), openKeys: c.arrayOf(c.oneOfType([c.string, c.number])), defaultSelectedKeys: c.arrayOf(c.oneOfType([c.string, c.number])), expandIcon: c.node, selectedKeys: c.arrayOf(c.oneOfType([c.string, c.number])), mode: c.oneOf([...Pt.MODE]), onSelect: c.func, onClick: c.func, onOpenChange: c.func, items: c.array, isCollapsed: c.bool, defaultIsCollapsed: c.bool, onCollapseChange: c.func, multiple: c.bool, onDeselect: c.func, subNavMotion: c.oneOfType([c.bool, c.object, c.func]), subNavCloseDelay: c.number, subNavOpenDelay: c.number, tooltipShowDelay: c.number, tooltipHideDelay: c.number, children: c.node, style: c.object, bodyStyle: c.object, className: c.string, toggleIconPosition: c.string, prefixCls: c.string, header: c.oneOfType([c.node, c.object]), footer: c.oneOfType([c.node, c.object]), limitIndent: c.bool, getPopupContainer: c.func }; Vs.__SemiComponentName__ = "Navigation"; Vs.defaultProps = xn(Vs.__SemiComponentName__, { subNavCloseDelay: so.DEFAULT_SUBNAV_CLOSE_DELAY, subNavOpenDelay: so.DEFAULT_SUBNAV_OPEN_DELAY, tooltipHideDelay: so.DEFAULT_TOOLTIP_HIDE_DELAY, tooltipShowDelay: so.DEFAULT_TOOLTIP_SHOW_DELAY, onCollapseChange: z, onSelect: z, onClick: z, onOpenChange: z, toggleIconPosition: "right", limitIndent: !0, prefixCls: fi.PREFIX, subNavMotion: !0, mode: Pt.MODE_VERTICAL }); const OZ = { PREFIX: G + "-overflow-list" }, L0 = { COLLAPSE: "collapse", SCROLL: "scroll" }, M0 = { START: "start", END: "end" }, TZ = { NONE: 0, GROW: 1, SHRINK: 2 }, pa = { BOUNDARY_SET: Object.values(M0), POSITION_SET: ["vertical", "horizontal"], MODE_SET: Object.values(L0), MODE_MAP: L0, BOUNDARY_MAP: M0, OVERFLOW_DIR: TZ }, j0 = { MINIMUM_HTML_ELEMENT_WIDTH: 4 }; class Fy extends f.PureComponent { componentDidMount() { const { items: e } = this.props; this.cachedKeys = Object.keys(e); const { root: t, threshold: n, rootMargin: i, option: s, onIntersect: a } = this.props; this.observer = new IntersectionObserver(a, Object.assign({ root: t, threshold: n, rootMargin: i }, s)), this.observeElement() } componentDidUpdate() { const { items: e } = this.props, t = Object.keys(e); ke(this.cachedKeys, t) || (this.observeElement(!0), this.cachedKeys = t) } componentWillUnmount() { this.observer && (this.observer.disconnect(), this.observer = null) } observeElement() { let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !1; const { items: t } = this.props; if (kt(t)) { this.observer.disconnect(); return } e && this.observer.disconnect(), Object.keys(t).forEach(n => { const i = t[n]; i && ct(i) && this.observer.observe(i) }) } render() { const { children: e } = this.props; return e } } Fy.propTypes = { onIntersect: c.func, option: c.object, root: c.any, threshold: c.number, rootMargin: c.string, items: c.object }; Fy.defaultProps = { onIntersect: () => { }, threshold: .75, rootMargin: "0px", option: {}, items: {} }; const IZ = pa.BOUNDARY_MAP; class PZ extends ve { constructor(e) { super(Object.assign({}, e)), this.previousY = void 0, this.isScrollMode = () => { const { renderMode: t } = this.getProps(); return t === "scroll" }, this.getReversedItems = () => { const { items: t } = this.getProps(); return cs(t).reverse() } } getOverflowItem() { const { items: e } = this.getProps(), { visibleState: t, overflow: n } = this.getStates(); if (!this.isScrollMode()) return n; const i = e.map(l => { let { key: u } = l; return !!t.get(u) }), s = i.indexOf(!0), a = i.lastIndexOf(!0), o = []; return o[0] = s >= 0 ? e.slice(0, s) : [], o[1] = a >= 0 ? e.slice(a + 1, e.length) : e.slice(), o } handleIntersect(e) { const t = cs(this.getState("visibleState")), n = {}; e.forEach(l => { const u = H(l, "target.dataset.scrollkey"), d = l.isIntersecting; n[u] = l, t.set(u, d) }); let i = !1; for (const l of t.values()) if (l) { i = !0; break } const s = i, [a] = e, o = a.boundingClientRect.y; if (!s && this.previousY !== void 0 && o !== this.previousY) { this.previousY = o; return } this.previousY = o, this._adapter.updateVisibleState(t), this._adapter.notifyIntersect(n) } handleCollapseOverflow() { const { minVisibleItems: e, collapseFrom: t } = this.getProps(), { overflowWidth: n, containerWidth: i, pivot: s, overflowStatus: a } = this.getStates(), { items: o, onOverflow: l } = this.getProps(); let u = n, d = 0, h = !1; for (const g of this._adapter.getItemSizeMap().values()) { if (u += g, u > i) { h = !0; break } if (d === o.length - 1) { this._adapter.updateStates({ overflowStatus: "normal", pivot: o.length - 1, visible: o, overflow: [] }); break } d++ } if (h) { const g = Math.max(e, d), m = t === IZ.START, b = m ? this.getReversedItems().slice(0, g).reverse() : o.slice(0, g), y = m ? this.getReversedItems().slice(g).reverse() : o.slice(g); this._adapter.updateStates({ overflowStatus: "overflowed", pivot: g, visible: b, overflow: y }), s !== g && l(y); return } } } const fl = OZ.PREFIX, Sp = pa.BOUNDARY_MAP, V0 = pa.OVERFLOW_DIR, gl = pa.MODE_MAP; class Io extends de { constructor(e) { var t; super(e), t = this, this.scroller = null, this.spacer = null, this.isScrollMode = () => { const { renderMode: n } = this.props; return n === gl.SCROLL }, this.resize = function () { let n = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : []; var i; const s = (i = n[0]) === null || i === void 0 ? void 0 : i.target.clientWidth; t.setState({ containerWidth: s, overflowStatus: "calculating" }) }, this.reintersect = n => { this.foundation.handleIntersect(n) }, this.mergeRef = (n, i, s) => { this.itemRefs[s] = i, typeof n == "function" ? n(i) : typeof n == "object" && n && "current" in n && (n.current = i) }, this.renderOverflow = () => { const n = this.foundation.getOverflowItem(); return this.props.overflowRenderer(n) }, this.getItemKey = (n, i) => { const { itemKey: s } = this.props; return we(s) ? s(n) : H(n, s || "key", i) }, this.renderItemList = () => { const { className: n, wrapperClassName: i, wrapperStyle: s, style: a, visibleItemRenderer: o, renderMode: l, collapseFrom: u } = this.props, { visible: d, overflowStatus: h } = this.state; let g = this.renderOverflow(); if (!this.isScrollMode() && (Array.isArray(g) && (g = f.createElement(f.Fragment, null, g)), f.isValidElement(g))) { const y = f.cloneElement(g); g = f.createElement(As, { onResize: w => { let [x] = w; this.setState({ overflowWidth: x.target.clientWidth, overflowStatus: "calculating" }) } }, f.createElement("div", { className: `${fl}-overflow` }, y)) } const m = l === gl.SCROLL ? (() => { const y = [f.createElement("div", { className: F(i, `${fl}-scroll-wrapper`), ref: w => { this.scroller = w }, style: Object.assign({}, s), key: `${fl}-scroll-wrapper` }, d.map(o).map(w => { const { forwardRef: x, key: S } = w; return f.cloneElement(w, { ref: C => this.mergeRef(x, C, S), "data-scrollkey": `${S}`, key: S }) }))]; return this.props.overflowRenderDirection === "both" ? (y.unshift(g[0]), y.push(g[1])) : this.props.overflowRenderDirection === "start" ? (y.unshift(g[1]), y.unshift(g[0])) : (y.push(g[0]), y.push(g[1])), y })() : [u === Sp.START ? g : null, d.map((y, w) => { const { key: x } = y, S = o(y, w), C = f.cloneElement(S); return f.createElement(As, { key: x ?? w, onResize: O => { let [E] = O; return this.onItemResize(E, y, w) } }, f.createElement("div", { key: x ?? w, className: `${fl}-item` }, C)) }), u === Sp.END ? g : null]; return f.createElement("div", { className: F(`${fl}`, n), style: Object.assign(Object.assign({}, a), l === gl.COLLAPSE ? { maxWidth: "100%", visibility: h === "calculating" ? "hidden" : "visible" } : null) }, ...m) }, this.onItemResize = (n, i, s) => { const a = this.getItemKey(i, s), o = this.itemSizeMap.get(a); o ? o !== n.target.clientWidth && (this.itemSizeMap.set(a, n.target.clientWidth), this.setState({ overflowStatus: "calculating" })) : this.itemSizeMap.set(a, n.target.clientWidth); const { maxCount: l } = this.state; this.itemSizeMap.size === l && this.setState({ overflowStatus: "calculating" }) }, this.state = { direction: V0.GROW, lastOverflowCount: 0, overflow: [], visible: [], containerWidth: 0, visibleState: new Map, itemSizeMap: new Map, overflowStatus: "calculating", pivot: -1, overflowWidth: 0, maxCount: 0 }, this.foundation = new PZ(this.adapter), this.previousWidths = new Map, this.itemRefs = {}, this.itemSizeMap = new Map } static getDerivedStateFromProps(e, t) { const { prevProps: n } = t, i = {}; i.prevProps = e; const s = a => !n && a in e || n && !ke(n[a], e[a]); if (s("items") || s("style")) { if (i.direction = V0.GROW, i.lastOverflowCount = 0, i.maxCount = 0, e.renderMode === gl.SCROLL) i.visible = e.items, i.overflow = []; else { let a = e.items.length; Math.floor(t.containerWidth / j0.MINIMUM_HTML_ELEMENT_WIDTH) !== 0 && (a = Math.min(a, Math.floor(t.containerWidth / j0.MINIMUM_HTML_ELEMENT_WIDTH))); const o = e.collapseFrom === Sp.START, l = o ? cs(e.items).reverse().slice(0, a) : e.items.slice(0, a), u = o ? cs(e.items).reverse().slice(a) : e.items.slice(a); i.visible = l, i.overflow = u, i.maxCount = a } i.pivot = -1, i.overflowStatus = "calculating" } return i } get adapter() { return Object.assign(Object.assign({}, super.adapter), { updateVisibleState: e => { this.setState({ visibleState: e }, () => { var t, n; (n = (t = this.props).onVisibleStateChange) === null || n === void 0 || n.call(t, e) }) }, updateStates: e => { this.setState(Object.assign({}, e)) }, notifyIntersect: e => { this.props.onIntersect && this.props.onIntersect(e) }, getItemSizeMap: () => this.itemSizeMap }) } componentDidUpdate(e, t) { const n = e.items.map(u => u.key), i = this.props.items.map(u => u.key); ke(n, i) || (this.itemRefs = {}, this.setState({ visibleState: new Map })); const { overflow: s, containerWidth: a, visible: o, overflowStatus: l } = this.state; this.isScrollMode() || l !== "calculating" || this.foundation.handleCollapseOverflow() } render() { const e = this.renderItemList(), { renderMode: t } = this.props; return t === gl.SCROLL ? f.createElement(Fy, { onIntersect: this.reintersect, root: this.scroller, threshold: this.props.threshold, items: this.itemRefs }, e) : f.createElement(As, { onResize: this.resize }, e) } } Io.__SemiComponentName__ = "OverflowList"; Io.defaultProps = xn(Io.__SemiComponentName__, { collapseFrom: "end", minVisibleItems: 0, overflowRenderer: () => null, renderMode: "collapse", threshold: .75, visibleItemRenderer: () => null, onOverflow: () => null, overflowRenderDirection: "both" }); Io.propTypes = { className: c.string, collapseFrom: c.oneOf(pa.BOUNDARY_SET), direction: c.oneOf(pa.POSITION_SET), items: c.array, minVisibleItems: c.number, onIntersect: c.func, onOverflow: c.func, overflowRenderer: c.func, renderMode: c.oneOf(pa.MODE_SET), style: c.object, threshold: c.number, visibleItemRenderer: c.func, wrapperClassName: c.string, wrapperStyle: c.object, collapseMask: c.object, overflowRenderDirection: c.string }; const kZ = { PREFIX: `${G}-page` }, $y = { PAGE_SHOW_MAX: 7, REST_PAGE_SHOW_MAX: 5, DEFAULT_PAGE_SIZE: 10, PAGE_SIZE_OPTION: [10, 20, 40, 100], REST_PAGE_MAX_SIZE: 1e6 }; class RZ extends ve { constructor(e) { super(Object.assign({}, e)) } init() { const { currentPage: e, total: t, pageSize: n } = this.getStates(); this._updateDisabled({ currentPage: e, total: t, pageSize: n }), this._updatePageList({ currentPage: e, total: t, pageSize: n }), this._registerEventHandler() } destroy() { this._unregisterEventHandler() } _registerEventHandler() { this._adapter.registerKeyDownHandler(this.handleKeyDown) } _unregisterEventHandler() { this._adapter.unregisterKeyDownHandler(this.handleKeyDown) } _updateDisabled(e) { const { currentPage: t, total: n, pageSize: i } = e, s = this._getTotalPageNumber(n, i); let a = !1, o = !1; t === 1 ? (a = !0, o = s < 2) : t === s && (a = !1, o = !0), this._adapter.setDisabled(a, o) } goPage(e) { if (e === "...") return; const { pageSize: t, currentPage: n } = this.getStates(), i = this._isInProps("currentPage"); e !== n && (i ? (this._adapter.notifyPageChange(e), this._adapter.notifyChange(e, t)) : (this.updatePage(e), this._adapter.notifyPageChange(e), this._adapter.notifyChange(e, t))) } updatePage() { let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 1, t = arguments.length > 1 ? arguments[1] : void 0, n = arguments.length > 2 ? arguments[2] : void 0; (t === null || typeof t > "u") && (t = this.getState("total")), (n === null || typeof n > "u") && (n = this.getState("pageSize")), this._updateDisabled({ currentPage: e, total: t, pageSize: n }), this._updatePageList({ currentPage: e, total: t, pageSize: n }), this._adapter.updateTotal(t), this._adapter.setCurrentPage(e), this._adapter.updatePageSize(n) } updateAllPageNumbers(e, t) { const { size: n, hoverShowPageSelect: i, disabled: s } = this.getProps(); if (!(n !== "small" || !i || s)) { const a = Array.from({ length: Math.ceil(e / t) }, (o, l) => l + 1); this._adapter.updateAllPageNumbers(a) } } goPrev() { const { currentPage: e } = this.getStates(); e > 1 && this.goPage(e - 1) } goNext() { const { currentPage: e, total: t, pageSize: n } = this.getStates(), i = this._getTotalPageNumber(t, n); e <= i - 1 && this.goPage(e + 1) } _updatePageList(e) { const { currentPage: t, total: n, pageSize: i } = e; let s = [], a = [], o = []; const l = this._getTotalPageNumber(n, i), { PAGE_SHOW_MAX: u, REST_PAGE_MAX_SIZE: d } = $y; if (l <= u) s = Array.from({ length: l }, (h, g) => g + 1), a = [], o = []; else switch (!0) { case t < 4: s = [1, 2, 3, 4, "...", l - 1, l], o = Array.from({ length: Math.min(l - 6, d) }, (m, b) => b + 5), a = []; break; case t === 4: s = [1, 2, 3, 4, 5, "...", l], o = Array.from({ length: Math.min(l - 6, d) }, (m, b) => b + 6), a = []; break; case (4 < t && t < l - 3): const h = Array.from({ length: 3 }, (m, b) => t + (b - 1)); s = [1].concat("...", h, "...", l), o = Array.from({ length: Math.min(l - t - 2, d) }, (m, b) => t + b + 2), a = Array.from({ length: Math.min(t - 3, d) }, (m, b) => b + 2); break; case (t - 3 <= t && t <= l): const g = Array.from({ length: 5 }, (m, b) => l - (4 - b)); s = [1, "..."].concat(g), o = [], a = Array.from({ length: Math.min(g[0] - 2, d) }, (m, b) => b + 2); break }this._adapter.setPageList({ pageList: s, restLeftPageList: a, restRightPageList: o }) } changePageSize(e) { const { pageSize: t } = this.getStates(); this._adapter.updatePageSize(e), this._adapter.notifyPageSizeChange(e); const { total: n, currentPage: i } = this.getStates(), s = (i - 1) * t + 1, a = Math.ceil(s / e); this.updatePage(a, n, e), i !== a && this._adapter.notifyPageChange(a), this._adapter.notifyChange(a, e) } handleKeyDown() { } pageSizeInOpts() { const { pageSizeOpts: e } = this.getProps(), { pageSize: t } = this.getStates(), n = [...e]; if (n.indexOf(t) === -1) { const i = n.findIndex(s => s > t); n.splice(i, 0, t) } return n } handleQuickJumpNumberChange(e) { this._adapter.updateQuickJumpPage(e) } _handleQuickJump(e) { let t = Number(e); const { pageSize: n, total: i } = this.getStates(), s = this._getTotalPageNumber(i, n); Number.isNaN(t) || (t > s && (t = s), t <= 0 && (t = 1), this._adapter.updateQuickJumpPage(""), this.goPage(t)) } handleQuickJumpBlur() { const { quickJumpPage: e } = this.getStates(); (typeof e == "string" && e || typeof e == "number") && this._handleQuickJump(e) } handleQuickJumpEnterPress(e) { this._handleQuickJump(e) } _getTotalPageNumber(e, t) { return Math.ceil(e / t) } } const Ly = { PREFIX: `${G}-select`, PREFIX_OPTION: `${G}-select-option`, PREFIX_GROUP: `${G}-select-group` }, is = { SIZE_SET: ["small", "large", "default"], POSITION_SET: Ds.POSITION_SET, MODE_SELECT: "select", MODE_AUTOCOMPLETE: "autoComplete", STATUS: Vo, SEARCH_POSITION_TRIGGER: "trigger", SEARCH_POSITION_DROPDOWN: "dropdown" }, rO = { LIST_HEIGHT: 270 }; var B0 = function (r, e) { var t = {}; for (var n in r) Object.prototype.hasOwnProperty.call(r, n) && e.indexOf(n) < 0 && (t[n] = r[n]); if (r != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, n = Object.getOwnPropertySymbols(r); i < n.length; i++)e.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(r, n[i]) && (t[n[i]] = r[n[i]]); return t }; class DZ extends ve {
  constructor(e) { super(Object.assign({}, e)), this._keydownHandler = null } init() { this._setDropdownWidth(); const e = this.getProp("defaultOpen"), t = this.getProp("open"), n = this._collectOptions(); this._setDefaultSelection(n), (e || t) && this.open(void 0, n), this.getProp("autoFocus") && this.focus() } focus() { const e = this._isFilterable(), t = this._isMultiple(); this._adapter.updateFocusState(!0), this._adapter.setIsFocusInContainer(!1), e && t ? this.focusInput() : e && !t ? this.toggle2SearchInput(!0) : this._focusTrigger() } _focusTrigger() { this._adapter.focusTrigger() } destroy() { this._adapter.unregisterClickOutsideHandler() } _setDropdownWidth() { const { style: e, dropdownMatchSelectWidth: t } = this.getProps(); let n; t && (e && Zt(e.width) || e && Fe(e.width) && !e.width.includes("%") ? n = e.width : n = this._adapter.getTriggerWidth(), this._adapter.setOptionWrapperWidth(n)) } _collectOptions() { const e = this._adapter.getOptionsFromChildren(); return this._adapter.updateOptions(e), this._adapter.rePositionDropdown(), e } _setDefaultSelection(e) { let { value: t } = this.getProps(); const { defaultValue: n } = this.getProps(); this._isControlledComponent() || (t = n), this._update(t, e) } handleOptionListChange() { const e = this._collectOptions(), { selections: t } = this.getStates(); this.updateOptionsActiveStatus(t, e); const { defaultActiveFirstOption: n } = this.getProps(); n && this._adapter.updateFocusIndex(0) } handleOptionListChangeHadDefaultValue() { const e = this.getState("selections"); let t; const { onChangeWithObject: n } = this.getProps(), i = this._isMultiple(); switch (!0) { case (i && !!e.size): try { t = [...e].map(a => n ? a[1] : a[1].value) } catch { t = [] } break; case (i && !e.size): t = []; break; case (!i && !!e.size): try { t = n ? [...e][0][1] : [...e][0][1].value } catch { } break; case (!i && !e.size): break }const s = this._adapter.getOptionsFromChildren(); this._update(t, s) } handleValueChange(e) { const { allowCreate: t, autoClearSearchValue: n, remote: i } = this.getProps(), { inputValue: s } = this.getStates(); let a; t && this._isControlledComponent() ? (a = this.getState("options"), a.forEach(o => o._show = !0)) : a = this._adapter.getOptionsFromChildren(), this._adapter.rePositionDropdown(), this._isFilterable() && !n && s && !i && (a = this._filterOption(a, s)), this._update(e, a) } _update(e, t) { let n; this._isMultiple() ? (n = this._updateMultiple(e, t), this.updateOverflowItemCount(n.size)) : n = this._updateSingle(e, t), this._adapter.updateSelection(n), this.updateOptionsActiveStatus(n, t) } _updateSingle(e, t) { const n = new Map, { onChangeWithObject: i } = this.getProps(), s = i && typeof e < "u" ? e.value : e, a = t.filter(l => l.value === s), o = !a.length && typeof s < "u" && s !== null; if (a.length) { const l = a[0], u = Object.assign({}, l); n.set(u.label, u) } else if (o) { let l = { value: e, label: e, _notExist: !0, _scrollIndex: -1 }; i && (l = Object.assign(Object.assign({}, e), { _notExist: !0, _scrollIndex: -1 })), n.set(l.label, l) } return n } _updateMultiple(e, t) { const n = this.getState("selections"); let i = []; const s = Array.isArray(e); this.checkMultipleProps(), n.size && (i = [...n].map(u => u[1])); const a = new Map; let o = e; const { onChangeWithObject: l } = this.getProps(); return l && s && (o = e.map(u => u.value)), s && o.length && o.forEach((u, d) => { const h = t.findIndex(g => g.value === u); if (h !== -1) a.set(t[h].label, t[h]); else { const g = i.findIndex(m => m.value === u); if (g !== -1) { const m = i[g]; if (l) { const b = Object.assign({}, e[d]); ke(b, m) ? a.set(m.label, m) : a.set(b.label, b) } else a.set(m.label, m) } else { let m = { value: u, label: u, _notExist: !0 }; l && (m = Object.assign(Object.assign({}, e[d]), { _notExist: !0 })), a.set(m.label, Object.assign(Object.assign({}, m), { _scrollIndex: -1 })) } } }), a } _isMultiple() { return this.getProp("multiple") } _isDisabled() { return this.getProp("disabled") } _isFilterable() { return !!this.getProp("filter") } handleClick(e) { const { clickToHide: t } = this.getProps(), { isOpen: n } = this.getStates(); this._isDisabled() || (n ? n && t ? this.close({ event: e }) : n && !t && this.focusInput() : (this.open(), this._notifyFocus(e))) } open(e, t) { const n = this._isFilterable(), i = t || this.getState("options"); if (n) { const a = this._filterOption(i, "").filter(o => !o._inputCreateOnly); this._adapter.updateOptions(a), this.toggle2SearchInput(!0) } else this._adapter.updateFocusState(!0); this._adapter.openMenu(() => { const { searchPosition: s, autoFocus: a } = this.getProps(); a && s === is.SEARCH_POSITION_DROPDOWN && this._adapter.focusDropdownInput() }), this._setDropdownWidth(), this._adapter.notifyDropdownVisibleChange(!0), this.bindKeyBoardEvent(), this._adapter.registerClickOutsideHandler(s => { this.close({ event: s }), this._notifyBlur(s), this._adapter.updateFocusState(!1) }) } toggle2SearchInput(e) { e ? this._adapter.toggleInputShow(e, () => this.focusInput()) : this._adapter.toggleInputShow(e, () => { }) } close(e) { const { event: t, closeCb: n, notToggleInput: i } = e || {}, { isFocus: s } = this.getStates(); this._adapter.closeMenu(), this._adapter.notifyDropdownVisibleChange(!1), this._adapter.setIsFocusInContainer(!1), s && this._focusTrigger(), this._adapter.unregisterClickOutsideHandler(); const a = this._isFilterable(); a && !i && this.toggle2SearchInput(!1), this._adapter.once("popoverClose", () => { a && this.clearInput(t), n && n() }) } onSelect(e, t, n) { if (this._isDisabled()) return; e._inputCreateOnly && this._adapter.notifyCreate(e), this._isMultiple() ? this._handleMultipleSelect(e, n) : this._handleSingleSelect(e, n), this._adapter.updateFocusIndex(t) } _handleSingleSelect(e, t) { var { value: n, label: i } = e, s = B0(e, ["value", "label"]); const a = new Map().set(i, Object.assign({ value: n, label: i }, s)); this._notifySelect(n, Object.assign({ value: n, label: i }, s)); const o = this._isFilterable(); this._isControlledComponent() ? this.close({ event: t, notToggleInput: !0, closeCb: () => { this._notifyChange(a), o && this.toggle2SearchInput(!1) } }) : (this._adapter.updateSelection(a), this._notifyChange(a), this.close({ event: t, closeCb: () => { this.updateOptionsActiveStatus(a) } })) } _handleMultipleSelect(e, t) { var { value: n, label: i } = e, s = B0(e, ["value", "label"]); const a = this._adapter.getMaxLimit(), o = this._adapter.getSelections(), { autoClearSearchValue: l } = this.getProps(); if (o.has(i)) this._notifyDeselect(n, Object.assign({ value: n, label: i }, s)), o.delete(i); else if (a && o.size === a) { this._adapter.notifyMaxLimit(Object.assign({ value: n, label: i }, Ht(s, "_scrollIndex"))); return } else this._notifySelect(n, Object.assign({ value: n, label: i }, s)), o.set(i, Object.assign({ value: n, label: i }, s)); if (this._isControlledComponent()) this._notifyChange(o), this._isFilterable() && (l && this.clearInput(t), this.focusInput()); else { this._adapter.updateSelection(o), this.updateOverflowItemCount(o.size), this._adapter.rePositionDropdown(); let { options: u } = this.getStates(); this._isFilterable() && (l && (this.clearInput(t), u = this._filterOption(u, "")), this.focusInput()), this.updateOptionsActiveStatus(o, u), this._notifyChange(o) } } clearSelected() { const e = new Map; this._isControlledComponent() ? (this._notifyChange(e), this._adapter.notifyClear()) : (this._adapter.updateSelection(e), this.updateOptionsActiveStatus(e), this._notifyChange(e), this._adapter.notifyClear()); const { isOpen: t } = this.getStates(); t && this._adapter.rePositionDropdown() } updateOptionsActiveStatus(e) { let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.getState("options"); const { allowCreate: n } = this.getProps(), i = t.map(s => (e.has(s.label) ? (s._selected = !0, n && delete s._inputCreateOnly) : (s._inputCreateOnly && (s._show = !1), s._selected = !1), s)); this._adapter.updateOptions(i) } removeTag(e) { const t = this._adapter.getSelections(); t.delete(e.label), this._isControlledComponent() ? (this._notifyDeselect(e.value, e), this._notifyChange(t)) : (this._notifyDeselect(e.value, e), this._adapter.updateSelection(t), this.updateOverflowItemCount(t.size), this.updateOptionsActiveStatus(t), this._adapter.rePositionDropdown(), this._notifyChange(t)) } clearInput(e) { const { inputValue: t } = this.getStates(); if (t !== "") { this._adapter.updateInputValue(""), this._adapter.notifySearch("", e); const { options: n } = this.getStates(), { remote: i } = this.getProps(); let s = n; i || (s = this._filterOption(n, "")), this._adapter.updateOptions(s) } } focusInput() { this._adapter.focusInput(), this._adapter.updateFocusState(!0), this._adapter.setIsFocusInContainer(!1) } handleInputChange(e, t) { this._adapter.updateInputValue(e); const { options: n, isOpen: i } = this.getStates(), { allowCreate: s, remote: a } = this.getProps(); let o = n; a || (o = this._filterOption(n, e)), o = this._createOptionByInput(s, o, e), this._adapter.updateOptions(o), this._adapter.notifySearch(e, t), this._isMultiple() && this._adapter.rePositionDropdown() } _filterOption(e, t) { const n = this.getProp("filter"); if (n) { if (typeof n == "boolean" && n) { const i = t.toLowerCase(); return e.map(s => { const a = s.label.toString().toLowerCase(), o = s._parentGroup && s._parentGroup.label, l = a.includes(i), u = Fe(o) && o.toLowerCase().includes(i); return l || u ? s._show = !0 : s._show = !1, s }) } else if (typeof n == "function") return e.map(i => (n(t, i) ? i._show = !0 : i._show = !1, i)) } else return e } _createOptionByInput(e, t, n) { if (e) if (n) { const i = { _show: !0, _selected: !1, value: n, label: n, _inputCreateOnly: !0 }; let s = -1, a = -1; t.forEach((o, l) => { !o._show && !o._inputCreateOnly || (o.label === n && (a = l), o._inputCreateOnly && (s = l, o.value = n, o.label = n, o._show = !0)) }), s === -1 && a === -1 && t.push(i), a !== -1 && (t = t.filter(o => !o._inputCreateOnly)) } else t = t.filter(i => !i._inputCreateOnly); return t } bindKeyBoardEvent() { this._keydownHandler = e => { this._handleKeyDown(e) }, this._adapter.registerKeyDown(this._keydownHandler) } unBindKeyBoardEvent() { this._keydownHandler && this._adapter.unregisterKeyDown() } _handleKeyDown(e) { const t = e.keyCode, { loading: n, filter: i, multiple: s, disabled: a } = this.getProps(), { isOpen: o } = this.getStates(); if (!(n || a)) switch (t) { case Tn.UP: e.preventDefault(), this._handleArrowKeyDown(-1); break; case Tn.DOWN: e.preventDefault(), this._handleArrowKeyDown(1); break; case Tn.BACKSPACE: this._handleBackspaceKeyDown(); break; case Tn.ENTER: yn(e), this._handleEnterKeyDown(e); break; case Tn.ESC: o && this.close({ event: e }), i && !s && this._focusTrigger(); break; case Tn.TAB: this._handleTabKeyDown(e); break } } handleContainerKeyDown(e) { const t = e.keyCode, { isOpen: n } = this.getStates(); switch (t) { case Tn.TAB: n && this._handleTabKeyDown(e); break } } _getEnableFocusIndex(e) { const { focusIndex: t, options: n } = this.getStates(), i = n.filter(o => o._show), s = i.length; let a = t + e; if (a < 0 && (a = s - 1), a >= s && (a = 0), e > 0) { let o = -1; for (let l = 0; l < i.length && (!i[l].disabled && (o = l), !(o >= a)); l++); a = o } else { let o = i.length; for (let l = s - 1; l >= 0 && (!i[l].disabled && (o = l), !(o <= a)); l--); a = o } this._adapter.updateFocusIndex(a), this._adapter.updateScrollTop(a) } _handleArrowKeyDown(e) { const { isOpen: t } = this.getStates(); t ? this._getEnableFocusIndex(e) : this.open() } _handleTabKeyDown(e) { const { isOpen: t } = this.getStates(); if (this._adapter.updateFocusState(!1), t) { const n = this._adapter.getContainer(), i = this._adapter.getFocusableElements(n); i.length > 0 ? e.shiftKey ? this._handlePanelOpenShiftTabKeyDown(i, e) : this._handlePanelOpenTabKeyDown(i, e) : (this.close({ event: e }), this._notifyBlur(e)) } else this._notifyBlur(e) } _handlePanelOpenTabKeyDown(e, t) { const n = this._adapter.getActiveElement(); this._adapter.getIsFocusInContainer() ? n === e[e.length - 1] && (this._focusTrigger(), this.close({ event: t }), yn(t)) : (e[0].focus(), this._adapter.setIsFocusInContainer(!0), yn(t)) } _handlePanelOpenShiftTabKeyDown(e, t) { const n = this._adapter.getActiveElement(); this._adapter.getIsFocusInContainer() ? n === e[0] && (this._focusTrigger(), this._adapter.setIsFocusInContainer(!1), yn(t)) : (this.close({ event: t }), this._notifyBlur(t)) } _handleEnterKeyDown(e) { const { isOpen: t, options: n, focusIndex: i } = this.getStates(); if (!t) this.open(); else if (i !== -1) { const s = n.filter(o => o._show), { length: a } = s; if (a <= i) return; if (s && a) { const o = s[i]; if (o.disabled) return; this.onSelect(o, i, e) } } else this.close({ event: e }) } _handleBackspaceKeyDown() { if (this._isMultiple()) { const e = this._adapter.getSelections(), { inputValue: t } = this.getStates(), n = e.size; if (n && !t) { const i = [...e.keys()]; let s = n - 1, a = i[s], o = e.get(a), l = !1; if (o.disabled && s === 0) return; for (; o.disabled && s !== 0;)s = s - 1, a = i[s], o = e.get(a), s == 0 && o.disabled && (l = !0); l || this.removeTag(o) } } } _notifyChange(e) { const { onChangeWithObject: t } = this.getProps(), n = this.getState("selections"); let i; const s = [...e.values()], a = this._isMultiple(); if (this._diffSelections(e, n, a)) switch (!0) { case t: this._notifyChangeWithObject(e); break; case (!t && !a): i = s.length ? s[0].value : void 0, this._adapter.notifyChange(i); break; case (!t && a): i = s.length ? s.map(l => l.value) : [], this._adapter.notifyChange(i); break } } _removeInternalKey(e) { let t = Object.assign({}, e); return delete t._parentGroup, delete t._show, delete t._selected, delete t._scrollIndex, delete t._keyInJsx, "_keyInOptionList" in t && (t.key = t._keyInOptionList, delete t._keyInOptionList), t } _notifySelect(e, t) { const n = this._removeInternalKey(t); this._adapter.notifySelect(e, n) } _notifyDeselect(e, t) { const n = this._removeInternalKey(t); this._adapter.notifyDeselect(e, n) } _diffSelections(e, t, n) { let i = !0, s = !0; if (!n) { const a = [...e.values()], o = [...t.values()], l = a[0] ? a[0].value : a[0], u = o[0] ? o[0].value : o[0]; s = !ke(l, u); const d = a[0] ? a[0].label : a[0], h = o[0] ? o[0].label : o[0]; i = !ke(d, h) } return s || i } _notifyChangeWithObject(e) { this.getState("selections"); const t = []; for (const n of e.entries()) { let i = Object.assign({ label: n[0] }, n[1]); i = this._removeInternalKey(i), t.push(i) } this._isMultiple() ? this._adapter.notifyChange(t) : this._adapter.notifyChange(t[0]) } _notifyBlur(e) { this._adapter.notifyBlur(e) } _notifyFocus(e) { this._adapter.notifyFocus(e) } handleMouseEnter(e) { this._adapter.updateHovering(!0), this._adapter.notifyMouseEnter(e) } handleMouseLeave(e) { this._adapter.updateHovering(!1), this._adapter.notifyMouseLeave(e) } handleClearClick(e) { const { filter: t, searchPosition: n } = this.getProps(); t && n === is.SEARCH_POSITION_TRIGGER && this.clearInput(e), this.focus(), this.clearSelected(), e.stopPropagation() } handleKeyPress(e) { e && e.key === Um && this.handleClick(e) } handleClearBtnEnterPress(e) { Jn(e) && this.handleClearClick(e) } handleOptionMouseEnter(e) { this._adapter.updateFocusIndex(e) } handleListScroll(e) { this._adapter.notifyListScroll(e) } handleTriggerFocus(e) { this.bindKeyBoardEvent(), this._adapter.setIsFocusInContainer(!1) } handleTriggerBlur(e) { this.getProps(); const { isOpen: t, isFocus: n } = this.getStates(); n && !t && (this._notifyBlur(e), this._adapter.updateFocusState(!1)) } handleInputBlur(e) { const { filter: t, autoFocus: n } = this.getProps(), { showInput: i } = this.getStates(), s = this._isMultiple(); t && !s && (i || n) && this.toggle2SearchInput(!1) } selectAll() {
    const { options: e } = this.getStates(), { onChangeWithObject: t } = this.getProps(); let n = []; if (!this._isMultiple()) {
      console.warn(`[Semi Select]: It seems that you have called the selectAll method in the single-selection Select.
                Please note that this is not a legal way to use it`); return
    } t ? n = e : n = e.map(s => s.value), this.handleValueChange(n), this._adapter.notifyChange(n)
  } checkMultipleProps(e) { if (this._isMultiple()) { const t = e || this.getProps(), { defaultValue: n, value: i } = t, s = i || n; !ze(s) && !Array.isArray(s) && Nt(!0, "[Semi Select] defaultValue/value should be array type in multiple mode") } } updateScrollTop() { this._adapter.updateScrollTop() } updateOverflowItemCount(e, t) { const { maxTagCount: n, ellipsisTrigger: i } = this.getProps(); i && (t ? this._adapter.updateOverflowItemCount(t) : typeof n == "number" && (e - n > 0 ? this._adapter.updateOverflowItemCount(e - n) : this._adapter.updateOverflowItemCount(0))) } updateIsFullTags() { const { isFullTags: e } = this.getStates(); e || this._adapter.setState({ isFullTags: !0 }) } handlePopoverClose() { this._adapter.emit("popoverClose") } handleSlotMouseEnter() { this._adapter.updateFocusIndex(-1) }
} const ml = PE.PREFIX, iO = Yo.TAG_SIZE, AZ = Yo.AVATAR_SHAPE; class ql extends R.PureComponent { renderNTag(e, t) { const { size: n, showPopover: i, popoverProps: s, onPlusNMouseEnter: a } = this.props; let o = f.createElement(wr, { closable: !1, size: n, color: "grey", style: { backgroundColor: "transparent" }, key: "_+n", onMouseEnter: a }, "+", e); return i && (o = f.createElement(kn, Object.assign({ showArrow: !0, content: t, trigger: "hover", position: "top", autoAdjustOverflow: !0, className: `${ml}-rest-group-popover` }, s, { key: "_+n_Popover" }), o)), o } renderMergeTags(e) { const { maxTagCount: t, tagList: n, restCount: i } = this.props, s = i || n.length - t; let a = e; const o = e.slice(0, t), l = e.slice(t); let u = null; return s > 0 && (u = this.renderNTag(s, l), o.push(u), a = o), a } renderAllTags() { const { tagList: e, size: t, mode: n, avatarShape: i, onTagClose: s } = this.props; return e.map(o => { if (n === "custom") return o; const l = Object.assign({}, o); return l.size || (l.size = t), l.avatarShape || (l.avatarShape = i), l.tagKey || (typeof l.children == "string" || typeof l.children == "number" ? l.tagKey = l.children : l.tagKey = Math.random()), f.createElement(wr, Object.assign({}, l, { key: l.tagKey, onClose: (u, d, h) => { l.onClose && l.onClose(u, d, h), s && s(u, d, h) } })) }) } render() { const { style: e, className: t, maxTagCount: n, size: i } = this.props, s = F({ [`${ml}-group`]: !0, [`${ml}-group-max`]: n, [`${ml}-group-small`]: i === "small", [`${ml}-group-large`]: i === "large" }, t), a = this.renderAllTags(), o = typeof n > "u" ? a : this.renderMergeTags(a); return f.createElement("div", { style: e, className: s }, o) } } ql.defaultProps = { style: {}, className: "", size: iO[0], avatarShape: "square", onTagClose: () => { }, onPlusNMouseEnter: () => { } }; ql.propTypes = { children: c.node, style: c.object, className: c.string, maxTagCount: c.number, restCount: c.number, tagList: c.array, size: c.oneOf(iO), mode: c.string, onTagClose: c.func, showPopover: c.bool, popoverProps: c.object, avatarShape: c.oneOf(AZ) }; var NZ = function (r, e) { var t = {}; for (var n in r) Object.prototype.hasOwnProperty.call(r, n) && e.indexOf(n) < 0 && (t[n] = r[n]); if (r != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, n = Object.getOwnPropertySymbols(r); i < n.length; i++)e.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(r, n[i]) && (t[n[i]] = r[n[i]]); return t }; const z0 = (r, e, t, n) => { const i = r.props; if (!r || !i) return null; const s = Object.assign(Object.assign({ value: i.value, label: i.label || i.children || i.value, _show: !0, _selected: !1, _scrollIndex: t }, i), { _parentGroup: e }); return s._keyInJsx = n || r.key, s }, FZ = r => { let e = [], t = []; const n = { label: "", children: [], _show: !1 }; let i = f.Children.toArray(r); i = i.filter(o => o && o.props); let s = "", a = -1; return i.forEach(o => { if (o.type.isSelectOption) { s = "option", a++; const l = z0(o, void 0, a); n.children.push(l), t.push(l) } else if (o.type.isSelectOptionGroup) { s = "group"; let l = o.props, { children: u } = l, d = NZ(l, ["children"]), h = []; Array.isArray(u) ? h = u.map(b => b.key) : h.push(u.key), u = f.Children.toArray(u); const g = u.map((b, y) => { let w = b.key; return h[y] === null && (w = o.key + "" + b.key), a++, z0(b, d, a, w) }), m = Object.assign(Object.assign({}, o.props), { children: g, key: o.key }); e.push(m), t = t.concat(g) } else Nt(!0, "[Semi Select] The children of `Select` should be `Select.Option` or `Select.OptionGroup`") }), s === "option" && (e = [n]), { optionGroups: e, options: t } }, sO = r => { let { index: e, data: t, style: n } = r; const { visibleOptions: i, renderOption: s } = t, a = i[e]; return s(a, e, n) }; var H0 = function (r, e) { var t = {}; for (var n in r) Object.prototype.hasOwnProperty.call(r, n) && e.indexOf(n) < 0 && (t[n] = r[n]); if (r != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, n = Object.getOwnPropertySymbols(r); i < n.length; i++)e.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(r, n[i]) && (t[n[i]] = r[n[i]]); return t }; let fa = class extends R.PureComponent { onClick(e, t) { var { value: n, label: i, children: s } = e, a = H0(e, ["value", "label", "children"]); const { props: o } = this; o.disabled || o.onSelect(Object.assign(Object.assign({}, a), { value: n, label: i || s }), t) } renderOptionContent(e) { let { config: t, children: n, inputValue: i, prefixCls: s } = e; return Fe(n) && i ? f.createElement(vc, { searchWords: t.searchWords, sourceString: t.sourceString, highlightClassName: t.highlightClassName }) : n } render() { const e = this.props, { children: t, disabled: n, value: i, selected: s, label: a, empty: o, emptyContent: l, onSelect: u, focused: d, showTick: h, className: g, style: m, onMouseEnter: b, prefixCls: y, renderOptionItem: w, inputValue: x, semiOptionId: S } = e, C = H0(e, ["children", "disabled", "value", "selected", "label", "empty", "emptyContent", "onSelect", "focused", "showTick", "className", "style", "onMouseEnter", "prefixCls", "renderOptionItem", "inputValue", "semiOptionId"]), O = F(y, { [`${y}-disabled`]: n, [`${y}-selected`]: s, [`${y}-focused`]: d, [`${y}-empty`]: o, [g]: g }), E = F([`${y}-icon`]); if (o) return l === null ? null : f.createElement(Ke, { componentName: "Select" }, T => f.createElement("div", { className: O, "x-semi-prop": "emptyContent" }, l || T.emptyText)); if (typeof w == "function") { const T = F(g, { [`${y}-custom`]: !0, [`${y}-custom-selected`]: s }); return w(Object.assign({ disabled: n, focused: d, selected: s, style: m, label: a, value: i, inputValue: x, onMouseEnter: I => b(I), onClick: I => this.onClick(Object.assign({ value: i, label: a, children: t }, C), I), className: T }, C)) } const v = { searchWords: [x], sourceString: t, highlightClassName: `${y}-keyword` }; return f.createElement("div", Object.assign({ className: O, onClick: T => { this.onClick(Object.assign({ value: i, label: a, children: t }, C), T) }, onMouseEnter: T => b && b(T), role: "option", id: S, "aria-selected": s ? "true" : "false", "aria-disabled": n ? "true" : "false", style: m }, Xr(C)), h ? f.createElement("div", { className: E }, f.createElement(ga, null)) : null, Fe(t) ? f.createElement("div", { className: `${y}-text` }, this.renderOptionContent({ children: t, config: v, inputValue: x, prefixCls: y })) : t) } }; fa.isSelectOption = !0; fa.propTypes = { children: c.node, disabled: c.bool, value: c.oneOfType([c.string, c.number]), selected: c.bool, label: c.node, empty: c.bool, emptyContent: c.node, onSelect: c.func, focused: c.bool, showTick: c.bool, className: c.string, style: c.object, onMouseEnter: c.func, prefixCls: c.string, renderOptionItem: c.func, inputValue: c.string }; fa.defaultProps = { prefixCls: Ly.PREFIX_OPTION }; var $Z = function (r, e) { var t = {}; for (var n in r) Object.prototype.hasOwnProperty.call(r, n) && e.indexOf(n) < 0 && (t[n] = r[n]); if (r != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, n = Object.getOwnPropertySymbols(r); i < n.length; i++)e.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(r, n[i]) && (t[n[i]] = r[n[i]]); return t }; const LZ = Ly.PREFIX_GROUP; class yh extends de { render() { const e = this.props, { label: t, className: n, style: i } = e, s = $Z(e, ["label", "className", "style"]), a = F(n, { [LZ]: !0 }); return !t && typeof t != "number" ? null : f.createElement("div", Object.assign({ className: a, style: i }, this.getDataAttr(s)), t) } } yh.isSelectOptionGroup = !0; yh.propTypes = { children: c.oneOfType([c.array, c.node]), label: c.node, className: c.string, style: c.object }; var MZ = function (r, e) { var t = {}; for (var n in r) Object.prototype.hasOwnProperty.call(r, n) && e.indexOf(n) < 0 && (t[n] = r[n]); if (r != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, n = Object.getOwnPropertySymbols(r); i < n.length; i++)e.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(r, n[i]) && (t[n[i]] = r[n[i]]); return t }; const Se = Ly.PREFIX, jZ = 0; class Zr extends de { constructor(e) { super(e), this.setOptionContainerEl = t => this.optionContainerEl = { current: t }, this.handleInputChange = (t, n) => this.foundation.handleInputChange(t, n), this.getTagItem = (t, n, i) => { const { size: s, disabled: a } = this.props, o = t[0], { value: l } = t[1], u = t[1].disabled || a, d = (b, y) => { y && typeof y.preventDefault == "function" && y.preventDefault(), this.foundation.removeTag({ label: o, value: l }) }, { content: h, isRenderInTag: g } = i(t[1], { index: n, disabled: u, onClose: d }), m = { disabled: u, closable: !u, onClose: d }; return g ? f.createElement(wr, Object.assign({}, m, { color: "white", size: s || "large", key: l, tabIndex: -1 }), h) : f.createElement(R.Fragment, { key: l }, h) }, this.state = { isOpen: !1, isFocus: !1, options: [], selections: new Map, dropdownMinWidth: null, optionKey: jZ, inputValue: "", showInput: !1, focusIndex: e.defaultActiveFirstOption ? 0 : -1, keyboardEventSet: {}, optionGroups: [], isHovering: !1, isFocusInContainer: !1, isFullTags: !1, overflowItemCount: 0 }, this.selectOptionListID = "", this.selectID = "", this.virtualizeListRef = f.createRef(), this.inputRef = f.createRef(), this.dropdownInputRef = f.createRef(), this.triggerRef = f.createRef(), this.optionsRef = f.createRef(), this.optionContainerEl = f.createRef(), this.clickOutsideHandler = null, this.onSelect = this.onSelect.bind(this), this.onClear = this.onClear.bind(this), this.onMouseEnter = this.onMouseEnter.bind(this), this.onMouseLeave = this.onMouseLeave.bind(this), this.renderOption = this.renderOption.bind(this), this.onKeyPress = this.onKeyPress.bind(this), this.eventManager = new dS, this.foundation = new DZ(this.adapter) } get adapter() { var e = this; const t = { registerKeyDown: s => { const a = { onKeyDown: s }; this.setState({ keyboardEventSet: a }) }, unregisterKeyDown: () => { this.setState({ keyboardEventSet: {} }) }, updateFocusIndex: s => { this.setState({ focusIndex: s }) }, scrollToFocusOption: () => { } }, n = { updateInputValue: s => { this.setState({ inputValue: s }) }, toggleInputShow: (s, a) => { this.setState({ showInput: s }, () => { a() }) }, focusInput: () => { const { preventScroll: s } = this.props; this.inputRef && this.inputRef.current && this.inputRef.current.focus({ preventScroll: s }) }, focusDropdownInput: () => { const { preventScroll: s } = this.props; this.dropdownInputRef && this.dropdownInputRef.current && this.dropdownInputRef.current.focus({ preventScroll: s }) } }, i = { notifyMaxLimit: s => this.props.onExceed(s), getMaxLimit: () => this.props.max, registerClickOutsideHandler: s => { const a = o => { const l = this.optionsRef && this.optionsRef.current, u = this.triggerRef && this.triggerRef.current, d = lr.findDOMNode(l), h = o.target, g = o.composedPath && o.composedPath() || [h]; !(d && d.contains(h)) && !(u && u.contains(h)) && !(g.includes(u) || g.includes(d)) && s(o) }; this.clickOutsideHandler = a, document.addEventListener("mousedown", a, !1) }, unregisterClickOutsideHandler: () => { this.clickOutsideHandler && (document.removeEventListener("mousedown", this.clickOutsideHandler, !1), this.clickOutsideHandler = null) }, rePositionDropdown: () => { let { optionKey: s } = this.state; s = s + 1, this.setState({ optionKey: s }) }, notifyDeselect: (s, a) => { delete a._parentGroup, this.props.onDeselect(s, a) } }; return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, super.adapter), t), n), i), { on: (s, a) => this.eventManager.on(s, a), off: s => this.eventManager.off(s), once: (s, a) => this.eventManager.once(s, a), emit: s => this.eventManager.emit(s), getOptionsFromChildren: function () { let s = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : e.props.children, a = [], o = []; const { optionList: l } = e.props; if (l && l.length) o = l.map((u, d) => Object.assign({ _show: !0, _selected: !1, _scrollIndex: d }, u)), a[0] = { children: o, label: "" }; else { const u = FZ(s); a = u.optionGroups, o = u.options } return e.setState({ optionGroups: a }), o }, updateOptions: s => { this.setState({ options: s }) }, openMenu: s => { this.setState({ isOpen: !0 }, () => { s == null || s() }) }, closeMenu: () => { this.setState({ isOpen: !1 }) }, getTriggerWidth: () => { const s = this.triggerRef.current; return s && s.getBoundingClientRect().width }, setOptionWrapperWidth: s => { this.setState({ dropdownMinWidth: s }) }, updateSelection: s => { this.setState({ selections: s }) }, getSelections: () => new Map(this.state.selections), notifyChange: s => { this.props.onChange(s) }, notifySelect: (s, a) => { delete a._parentGroup, this.props.onSelect(s, a) }, notifyDropdownVisibleChange: s => { this.props.onDropdownVisibleChange(s) }, notifySearch: (s, a) => { this.props.onSearch(s, a) }, notifyCreate: s => { this.props.onCreate(s) }, notifyMouseEnter: s => { this.props.onMouseEnter(s) }, notifyMouseLeave: s => { this.props.onMouseLeave(s) }, notifyFocus: s => { this.props.onFocus(s) }, notifyBlur: s => { this.props.onBlur(s) }, notifyClear: () => { this.props.onClear() }, notifyListScroll: s => { this.props.onListScroll(s) }, updateHovering: s => { this.setState({ isHovering: s }) }, updateFocusState: s => { this.setState({ isFocus: s }) }, updateOverflowItemCount: s => { this.setState({ overflowItemCount: s }) }, focusTrigger: () => { try { const { preventScroll: s } = this.props; this.triggerRef.current.focus({ preventScroll: s }) } catch { } }, getContainer: () => this.optionContainerEl && this.optionContainerEl.current, getFocusableElements: s => yS(s), getActiveElement: () => mS(), setIsFocusInContainer: s => { this.setState({ isFocusInContainer: s }) }, getIsFocusInContainer: () => this.state.isFocusInContainer, updateScrollTop: s => { let a; "renderOptionItem" in this.props ? (a = `.${Se}-option-custom-selected`, s !== void 0 && (a = `.${Se}-option-custom:nth-child(${s + 1})`)) : (a = `.${Se}-option-selected`, s !== void 0 && (a = `.${Se}-option:nth-child(${s + 1})`)); let o = document.querySelector(`#${Se}-${this.selectOptionListID} ${a}`); if (Array.isArray(o) && (o = o[0]), o) { const l = o.parentNode; l.scrollTop = o.offsetTop - l.offsetTop - l.clientHeight / 2 + o.clientHeight / 2 } } }) } componentDidMount() { this.foundation.init(), this.selectOptionListID = zi(), this.selectID = this.props.id || zi() } componentWillUnmount() { this.foundation.destroy() } componentDidUpdate(e, t) { const n = f.Children.toArray(e.children).map(a => a.key), i = f.Children.toArray(this.props.children).map(a => a.key); let s = !1; (!ke(n, i) || !ke(e.optionList, this.props.optionList)) && (s = !0, this.foundation.handleOptionListChange()), (!ke(this.props.value, e.value) || s) && ("value" in this.props ? this.foundation.handleValueChange(this.props.value) : this.foundation.handleOptionListChangeHadDefaultValue()) } renderTriggerInput() { const { size: e, multiple: t, disabled: n, inputProps: i, filter: s } = this.props, a = H(i, "className"), o = F(`${Se}-input`, { [`${Se}-input-single`]: !t, [`${Se}-input-multiple`]: t }, a), { inputValue: l, focusIndex: u } = this.state, d = Object.assign({ value: l, disabled: n, className: o, onChange: this.handleInputChange }, i); let h = {}; return t && (h = { width: l ? `${l.length * 16}px` : "2px" }, d.style = h), f.createElement(xr, Object.assign({ ref: this.inputRef, size: e, "aria-activedescendant": u !== -1 ? `${this.selectID}-option-${u}` : "", onFocus: g => { t && s && this.setState({ isFocus: !0 }), g.stopPropagation() }, onBlur: g => this.foundation.handleInputBlur(g) }, d)) } renderDropdownInput() { const { size: e, multiple: t, disabled: n, inputProps: i, filter: s, searchPosition: a, searchPlaceholder: o } = this.props, { inputValue: l, focusIndex: u } = this.state, d = F(`${Se}-dropdown-search-wrapper`, {}), h = H(i, "className"), g = F(`${Se}-dropdown-input`, { [`${Se}-dropdown-input-single`]: !t, [`${Se}-dropdown-input-multiple`]: t }, h), m = Object.assign(Object.assign({ value: l, disabled: n, className: g, onChange: this.handleInputChange, placeholder: o, showClear: !0 }, i), { onKeyDown: b => this.foundation._handleKeyDown(b) }); return f.createElement("div", { className: d }, f.createElement(xr, Object.assign({ ref: this.dropdownInputRef, prefix: f.createElement(GS, null), "aria-activedescendant": u !== -1 ? `${this.selectID}-option-${u}` : "" }, m))) } close() { this.foundation.close() } open() { this.foundation.open() } clearInput() { this.foundation.clearInput() } selectAll() { this.foundation.selectAll() } deselectAll() { this.foundation.clearSelected() } focus() { this.foundation.focus() } onSelect(e, t, n) { this.foundation.onSelect(e, t, n) } onClear(e) { e.nativeEvent.stopImmediatePropagation(), this.foundation.handleClearClick(e) } search(e, t) { this.handleInputChange(e, t) } renderEmpty() { return f.createElement(fa, { empty: !0, emptyContent: this.props.emptyContent }) } renderLoading() { const e = `${Se}-loading-wrapper`; return f.createElement("div", { className: e }, f.createElement(yi, null)) } renderOption(e, t, n) { const { focusIndex: i, inputValue: s } = this.state, { renderOptionItem: a } = this.props; let o; const l = t === i; let u = n || {}; return e.style && (u = Object.assign(Object.assign({}, u), e.style)), e._inputCreateOnly ? o = this.renderCreateOption(e, l, t, n) : ("key" in e && (e._keyInOptionList = e.key), o = f.createElement(fa, Object.assign({ showTick: !0 }, e, { selected: e._selected, onSelect: (d, h) => this.onSelect(d, t, h), focused: l, onMouseEnter: () => this.onOptionHover(t), style: u, key: e._keyInOptionList || e._keyInJsx || e.label + e.value + t, renderOptionItem: a, inputValue: s, semiOptionId: `${this.selectID}-option-${t}` }), e.label)), o } renderCreateOption(e, t, n, i) { const { renderCreateItem: s } = this.props; if (typeof s > "u") return f.createElement(fa, Object.assign({ key: e.key || e.label + e.value, onSelect: (l, u) => this.onSelect(l, n, u), onMouseEnter: () => this.onOptionHover(n), showTick: !0 }, e, { focused: t, style: i }), f.createElement(Ke, { componentName: "Select" }, l => f.createElement(f.Fragment, null, f.createElement("span", { className: `${Se}-create-tips` }, l.createText), e.value))); const a = s(e.value, t, i); return f.createElement("div", { role: "button", "aria-label": "Use the input box to create an optional item", onClick: o => this.onSelect(e, n, o), key: e.key || e.label }, a) } onOptionHover(e) { this.foundation.handleOptionMouseEnter(e) } renderWithGroup(e) { const t = [], n = new Map; return e.forEach((i, s) => { const a = i._parentGroup, o = this.renderOption(i, s); if (a && !n.has(a.label)) { const l = f.createElement(yh, Object.assign({}, a, { key: a.label })); n.set(a.label, !0), t.push(l) } t.push(o) }), t } renderVirtualizeList(e) { const { virtualize: t } = this.props, { direction: n } = this.context, { height: i, width: s, itemSize: a } = t; return f.createElement(eh, { ref: this.virtualizeListRef, height: i || rO.LIST_HEIGHT, itemCount: e.length, itemSize: a, itemData: { visibleOptions: e, renderOption: this.renderOption }, width: s || "100%", style: { direction: n } }, sO) } renderOptions(e) { const { dropdownMinWidth: t, options: n, selections: i } = this.state, { maxHeight: s, dropdownClassName: a, dropdownStyle: o, outerTopSlot: l, innerTopSlot: u, outerBottomSlot: d, innerBottomSlot: h, loading: g, virtualize: m, multiple: b, emptyContent: y, searchPosition: w, filter: x } = this.props, S = n.filter(T => T._show); let C = this.renderWithGroup(S); m && (C = this.renderVirtualizeList(S)); const O = Object.assign({ minWidth: t }, o), E = F({ [`${Se}-option-list`]: !0, [`${Se}-option-list-chosen`]: i.size }), v = !n.length || !n.some(T => T._show); return f.createElement("div", { id: `${Se}-${this.selectOptionListID}`, className: F({ [`${Se}-option-list-wrapper`]: !(v && y === null) }, a), style: O, ref: this.setOptionContainerEl, onKeyDown: T => this.foundation.handleContainerKeyDown(T) }, l ? f.createElement("div", { className: `${Se}-option-list-outer-top-slot`, onMouseEnter: () => this.foundation.handleSlotMouseEnter() }, l) : null, w === is.SEARCH_POSITION_DROPDOWN && x ? this.renderDropdownInput() : null, f.createElement("div", { style: { maxHeight: `${s}px` }, className: E, role: "listbox", "aria-multiselectable": b, onScroll: T => this.foundation.handleListScroll(T) }, u ? f.createElement("div", { className: `${Se}-option-list-inner-top-slot`, onMouseEnter: () => this.foundation.handleSlotMouseEnter() }, u) : null, g ? this.renderLoading() : v ? this.renderEmpty() : C, h ? f.createElement("div", { className: `${Se}-option-list-inner-bottom-slot`, onMouseEnter: () => this.foundation.handleSlotMouseEnter() }, h) : null), d ? f.createElement("div", { className: `${Se}-option-list-outer-bottom-slot`, onMouseEnter: () => this.foundation.handleSlotMouseEnter() }, d) : null) } renderSingleSelection(e, t) { let { renderSelectedItem: n, searchPosition: i } = this.props; const { placeholder: s } = this.props, { showInput: a, inputValue: o } = this.state; let l = ""; const u = [...e]; if (typeof n > "u" && (n = m => m.label), u.length) { const m = u[0][1]; l = n(m) } const d = i === is.SEARCH_POSITION_TRIGGER, h = F({ [`${Se}-selection-text`]: !0, [`${Se}-selection-placeholder`]: !l && l !== 0, [`${Se}-selection-text-hide`]: o && a && d, [`${Se}-selection-text-inactive`]: !o && a && d }), g = `${Se}-content-wrapper`; return f.createElement(f.Fragment, null, f.createElement("div", { className: g }, f.createElement("span", { className: h, "x-semi-prop": "placeholder" }, l || l === 0 ? l : s), t && a && d ? this.renderTriggerInput() : null)) } renderTag(e, t, n) { const { size: i, disabled: s } = this.props; let { renderSelectedItem: a } = this.props; const o = e[0], { value: l } = e[1], u = e[1].disabled || s, d = (y, w) => { w && typeof w.preventDefault == "function" && w.preventDefault(), this.foundation.removeTag({ label: o, value: l }) }; typeof a > "u" && (a = y => ({ isRenderInTag: !0, content: y.label })); const { content: h, isRenderInTag: g } = a(e[1], { index: t, disabled: u, onClose: d }), m = { disabled: u, closable: !u, onClose: d }, b = n && !we(this.props.renderSelectedItem) ? f.createElement(Gd, { size: "small", ellipsis: { rows: 1, showTooltip: { type: "popover", opts: { style: { width: "auto", fontSize: 12 } } } } }, h) : h; return g ? f.createElement(wr, Object.assign({}, m, { color: "white", size: i || "large", key: l, style: { maxWidth: "100%" } }), b) : f.createElement(R.Fragment, { key: l }, b) } renderNTag(e, t) { const { size: n, showRestTagsPopover: i, restTagsPopoverProps: s } = this.props; let a = f.createElement(wr, { closable: !1, size: n || "large", color: "grey", className: `${Se}-content-wrapper-collapse-tag`, key: `_+${e}`, style: { marginRight: 0, flexShrink: 0 } }, "+", e); return i && (a = f.createElement(kn, Object.assign({ showArrow: !0, content: f.createElement(Zd, { spacing: 2, wrap: !0, style: { maxWidth: "400px" } }, t.map((o, l) => this.renderTag(o, l))), trigger: "hover", position: "top", autoAdjustOverflow: !0 }, s, { key: `_+${e}_Popover` }), a)), a } renderOverflow(e, t) { return e.length && e[0] ? this.renderTag(e[0], t, !0) : null } handleOverflow(e) { const { overflowItemCount: t, selections: n } = this.state, { maxTagCount: i } = this.props, s = n.size - i > 0 ? n.size - i + e.length - 1 : e.length - 1; t !== s && this.foundation.updateOverflowItemCount(n.size, s) } renderCollapsedTags(e, t) { const { overflowItemCount: n } = this.state, i = typeof t == "number" ? e.slice(0, t) : e; return f.createElement("div", { className: `${Se}-content-wrapper-collapse` }, f.createElement(Io, { items: i, key: String(e.length), overflowRenderer: s => this.renderOverflow(s, t - 1), onOverflow: s => this.handleOverflow(s), visibleItemRenderer: (s, a) => this.renderTag(s, a) }), n > 0 && this.renderNTag(n, e.slice(e.length - n))) } renderOneLineTags(e, t) { let { renderSelectedItem: n } = this.props; const { showRestTagsPopover: i, restTagsPopoverProps: s, maxTagCount: a } = this.props, { isFullTags: o } = this.state; let l; if (typeof n > "u" && (n = u => ({ isRenderInTag: !0, content: u.label })), i) { const d = (o ? e : e.slice(0, a)).map((h, g) => this.getTagItem(h, g, n)); l = f.createElement(ql, { tagList: d, maxTagCount: t, restCount: o ? void 0 : e.length - a, size: "large", mode: "custom", showPopover: i, popoverProps: s, onPlusNMouseEnter: () => { this.foundation.updateIsFullTags() } }) } else { const d = e.slice(0, a).map((h, g) => this.getTagItem(h, g, n)); l = f.createElement(ql, { tagList: d, maxTagCount: t, restCount: e.length - a, size: "large", mode: "custom" }) } return l } renderMultipleSelection(e, t) { let { renderSelectedItem: n, searchPosition: i } = this.props; const { placeholder: s, maxTagCount: a, expandRestTagsOnClick: o, ellipsisTrigger: l } = this.props, { inputValue: u, isOpen: d } = this.state, h = [...e]; typeof n > "u" && (n = O => ({ isRenderInTag: !0, content: O.label })); const g = F({ [`${Se}-content-wrapper`]: !0, [`${Se}-content-wrapper-one-line`]: a && !d, [`${Se}-content-wrapper-empty`]: !h.length }), m = F({ [`${Se}-selection-text`]: !0, [`${Se}-selection-placeholder`]: !h.length, [`${Se}-selection-text-hide`]: h.length }), b = s && !u ? f.createElement("span", { className: m }, s) : null, y = h.length > a ? a : void 0, w = !a, x = l ? this.renderCollapsedTags(h, y) : this.renderOneLineTags(h, y), S = w || o && d ? h.map((O, E) => this.renderTag(O, E)) : x, C = t && i === is.SEARCH_POSITION_TRIGGER; return f.createElement(f.Fragment, null, f.createElement("div", { className: g }, h.length ? S : b, C ? this.renderTriggerInput() : null)) } onMouseEnter(e) { this.foundation.handleMouseEnter(e) } onMouseLeave(e) { this.foundation.handleMouseLeave(e) } onKeyPress(e) { this.foundation.handleKeyPress(e) } handlePopoverVisibleChange(e) { const { virtualize: t } = this.props, { selections: n } = this.state; if (e) if (t) { let i = -1; if (n.forEach(s => { const a = H(s, "_scrollIndex"); Zt(a) && a >= 0 && (i = i !== -1 && i < a ? i : a) }), i !== -1) try { this.virtualizeListRef.current.scrollToItem(i, "center") } catch { } } else this.foundation.updateScrollTop() } renderSuffix() { const { suffix: e } = this.props, t = F({ [`${Se}-suffix`]: !0, [`${Se}-suffix-text`]: e && Fe(e), [`${Se}-suffix-icon`]: Bn(e) }); return f.createElement("div", { className: t, "x-semi-prop": "suffix" }, e) } renderPrefix() { const { prefix: e, insetLabel: t, insetLabelId: n } = this.props, i = e || t, s = F({ [`${Se}-prefix`]: !0, [`${Se}-inset-label`]: t, [`${Se}-prefix-text`]: i && Fe(i), [`${Se}-prefix-icon`]: Bn(i) }); return f.createElement("div", { className: s, id: n, "x-semi-prop": "prefix,insetLabel" }, i) } renderSelection() { const e = this.props, { disabled: t, multiple: n, filter: i, style: s, id: a, size: o, className: l, validateStatus: u, showArrow: d, suffix: h, prefix: g, insetLabel: m, placeholder: b, triggerRender: y, arrowIcon: w, clearIcon: x, borderless: S } = e, C = MZ(e, ["disabled", "multiple", "filter", "style", "id", "size", "className", "validateStatus", "showArrow", "suffix", "prefix", "insetLabel", "placeholder", "triggerRender", "arrowIcon", "clearIcon", "borderless"]), { selections: O, isOpen: E, keyboardEventSet: v, inputValue: T, isHovering: I, isFocus: k, showInput: P, focusIndex: N } = this.state, M = typeof y == "function", B = !!i, K = M ? F(l) : F(Se, l, { [`${Se}-borderless`]: S, [`${Se}-open`]: E, [`${Se}-focus`]: k, [`${Se}-disabled`]: t, [`${Se}-single`]: !n, [`${Se}-multiple`]: n, [`${Se}-filterable`]: B, [`${Se}-small`]: o === "small", [`${Se}-large`]: o === "large", [`${Se}-error`]: u === "error", [`${Se}-warning`]: u === "warning", [`${Se}-no-arrow`]: !d, [`${Se}-with-prefix`]: g || m, [`${Se}-with-suffix`]: h }), U = this.props.showClear && (O.size || T) && !t && (I || E), W = d ? f.createElement("div", { className: `${Se}-arrow`, "x-semi-prop": "arrowIcon" }, w) : f.createElement("div", { className: `${Se}-arrow-empty` }), Z = x || f.createElement(us, null), J = M ? f.createElement(Ia, { value: Array.from(O.values()), inputValue: T, onChange: this.handleInputChange, onSearch: this.handleInputChange, onRemove: $ => this.foundation.removeTag($), onClear: this.onClear, disabled: t, triggerRender: y, placeholder: b, componentName: "Select", componentProps: Object.assign({}, this.props) }) : [f.createElement(R.Fragment, { key: "prefix" }, g || m ? this.renderPrefix() : null), f.createElement(R.Fragment, { key: "selection" }, f.createElement("div", { className: F(`${Se}-selection`) }, n ? this.renderMultipleSelection(O, B) : this.renderSingleSelection(O, B))), f.createElement(R.Fragment, { key: "suffix" }, h ? this.renderSuffix() : null), f.createElement(R.Fragment, { key: "clearicon" }, U ? f.createElement("div", { className: F(`${Se}-clear`), onClick: this.onClear }, Z) : W)], ee = t || B && P || B && n ? -1 : 0; return f.createElement("div", Object.assign({ role: "combobox", "aria-disabled": t, "aria-expanded": E, "aria-controls": `${Se}-${this.selectOptionListID}`, "aria-haspopup": "listbox", "aria-label": O.size ? "selected" : "", "aria-invalid": this.props["aria-invalid"], "aria-errormessage": this.props["aria-errormessage"], "aria-labelledby": this.props["aria-labelledby"], "aria-describedby": this.props["aria-describedby"], "aria-required": this.props["aria-required"], className: K, ref: $ => this.triggerRef.current = $, onClick: $ => this.foundation.handleClick($), style: s, id: this.selectID, tabIndex: ee, "aria-activedescendant": N !== -1 ? `${this.selectID}-option-${N}` : "", onMouseEnter: this.onMouseEnter, onMouseLeave: this.onMouseLeave, onFocus: $ => this.foundation.handleTriggerFocus($), onBlur: $ => this.foundation.handleTriggerBlur($), onKeyPress: this.onKeyPress }, v, this.getDataAttr(C)), J) } render() { const { direction: e } = this.context, t = e === "rtl" ? "bottomRight" : "bottomLeft", { children: n, position: i = t, zIndex: s, getPopupContainer: a, motion: o, autoAdjustOverflow: l, mouseLeaveDelay: u, mouseEnterDelay: d, spacing: h, stopPropagation: g, dropdownMargin: m } = this.props, { isOpen: b, optionKey: y } = this.state, w = this.renderSelection(); return f.createElement(kn, { getPopupContainer: a, motion: o, margin: m, autoAdjustOverflow: l, mouseLeaveDelay: u, mouseEnterDelay: d, zIndex: s, ref: this.optionsRef, content: () => this.renderOptions(n), visible: b, trigger: "custom", rePosKey: y, position: i, spacing: h, stopPropagation: g, disableArrowKeyDown: !0, onVisibleChange: x => this.handlePopoverVisibleChange(x), afterClose: () => this.foundation.handlePopoverClose() }, w) } } Zr.contextType = An; Zr.Option = fa; Zr.OptGroup = yh; Zr.propTypes = { "aria-describedby": c.string, "aria-errormessage": c.string, "aria-invalid": c.bool, "aria-labelledby": c.string, "aria-required": c.bool, autoFocus: c.bool, autoClearSearchValue: c.bool, borderless: c.bool, children: c.node, clearIcon: c.node, defaultValue: c.oneOfType([c.string, c.number, c.array, c.object]), ellipsisTrigger: c.bool, value: c.oneOfType([c.string, c.number, c.array, c.object]), placeholder: c.node, onChange: c.func, multiple: c.bool, filter: c.oneOfType([c.func, c.bool]), max: c.number, maxTagCount: c.number, maxHeight: c.oneOfType([c.string, c.number]), style: c.object, className: c.string, size: c.oneOf(is.SIZE_SET), disabled: c.bool, emptyContent: c.node, expandRestTagsOnClick: c.bool, onDropdownVisibleChange: c.func, zIndex: c.number, position: c.oneOf(is.POSITION_SET), onSearch: c.func, getPopupContainer: c.func, dropdownClassName: c.string, dropdownStyle: c.object, dropdownMargin: c.oneOfType([c.number, c.object]), outerTopSlot: c.node, innerTopSlot: c.node, inputProps: c.object, outerBottomSlot: c.node, innerBottomSlot: c.node, optionList: c.array, dropdownMatchSelectWidth: c.bool, loading: c.bool, defaultOpen: c.bool, validateStatus: c.oneOf(is.STATUS), defaultActiveFirstOption: c.bool, triggerRender: c.func, stopPropagation: c.bool, searchPosition: c.string, motion: c.bool, onChangeWithObject: c.bool, suffix: c.node, prefix: c.node, insetLabel: c.node, insetLabelId: c.string, showClear: c.bool, showArrow: c.bool, renderSelectedItem: c.func, allowCreate: c.bool, renderCreateItem: c.func, onMouseEnter: c.func, onMouseLeave: c.func, clickToHide: c.bool, onExceed: c.func, onCreate: c.func, remote: c.bool, onDeselect: c.func, onSelect: c.func, autoAdjustOverflow: c.bool, mouseEnterDelay: c.number, mouseLeaveDelay: c.number, spacing: c.oneOfType([c.number, c.object]), onBlur: c.func, onFocus: c.func, onClear: c.func, virtualize: c.object, renderOptionItem: c.func, onListScroll: c.func, arrowIcon: c.node, preventScroll: c.bool }; Zr.__SemiComponentName__ = "Select"; Zr.defaultProps = xn(Zr.__SemiComponentName__, { stopPropagation: !0, motion: !0, borderless: !1, zIndex: Cr.DEFAULT_Z_INDEX, filter: !1, multiple: !1, disabled: !1, defaultOpen: !1, allowCreate: !1, placeholder: "", onDropdownVisibleChange: z, onChangeWithObject: !1, onChange: z, onSearch: z, onMouseEnter: z, onMouseLeave: z, onDeselect: z, onSelect: z, onCreate: z, onExceed: z, onFocus: z, onBlur: z, onClear: z, onListScroll: z, maxHeight: rO.LIST_HEIGHT, dropdownMatchSelectWidth: !0, defaultActiveFirstOption: !0, showArrow: !0, showClear: !1, searchPosition: is.SEARCH_POSITION_TRIGGER, remote: !1, autoAdjustOverflow: !0, autoClearSearchValue: !0, arrowIcon: f.createElement(os, { "aria-label": "" }), showRestTagsPopover: !1, restTagsPopoverProps: {}, expandRestTagsOnClick: !1, ellipsisTrigger: !1 }); var K0 = function (r, e) { var t = {}; for (var n in r) Object.prototype.hasOwnProperty.call(r, n) && e.indexOf(n) < 0 && (t[n] = r[n]); if (r != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, n = Object.getOwnPropertySymbols(r); i < n.length; i++)e.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(r, n[i]) && (t[n[i]] = r[n[i]]); return t }; const Lt = kZ.PREFIX, { Option: VZ } = Zr; class bh extends de { constructor(e) { super(e); const t = e.total, n = e.pageSize || e.pageSizeOpts[0] || $y.DEFAULT_PAGE_SIZE, i = e.size === "small" && e.hoverShowPageSelect && !e.disabled; this.state = { total: t, showTotal: e.showTotal, currentPage: e.currentPage || e.defaultCurrentPage, pageSize: n, pageList: [], prevDisabled: !1, nextDisabled: !1, restLeftPageList: [], restRightPageList: [], quickJumpPage: "", allPageNumbers: i ? Array.from({ length: Math.ceil(t / n) }, (s, a) => a + 1) : [] }, this.foundation = new RZ(this.adapter), this.renderDefaultPage = this.renderDefaultPage.bind(this), this.renderSmallPage = this.renderSmallPage.bind(this), Nt(!!(e.showSizeChanger && e.hideOnSinglePage), "[Semi Pagination] You should not use showSizeChanger and hideOnSinglePage in ths same time. At this time, hideOnSinglePage no longer takes effect, otherwise there may be a problem that the switch entry disappears") } get adapter() { return Object.assign(Object.assign({}, super.adapter), { setPageList: e => { const { pageList: t, restLeftPageList: n, restRightPageList: i } = e; this.setState({ pageList: t, restLeftPageList: n, restRightPageList: i }) }, setDisabled: (e, t) => { this.setState({ prevDisabled: e, nextDisabled: t }) }, updateTotal: e => this.setState({ total: e }), updatePageSize: e => this.setState({ pageSize: e }), updateQuickJumpPage: e => this.setState({ quickJumpPage: e }), updateAllPageNumbers: e => this.setState({ allPageNumbers: e }), setCurrentPage: e => { this.setState({ currentPage: e }) }, registerKeyDownHandler: e => { document.addEventListener("keydown", e) }, unregisterKeyDownHandler: e => { document.removeEventListener("keydown", e) }, notifyPageChange: e => { this.props.onPageChange(e) }, notifyPageSizeChange: e => { this.props.onPageSizeChange(e) }, notifyChange: (e, t) => { this.props.onChange(e, t) } }) } componentDidMount() { this.foundation.init() } componentWillUnmount() { this.foundation.destroy() } componentDidUpdate(e) { const t = { currentPage: this.props.currentPage, total: this.props.total, pageSize: this.props.pageSize }; let n = !1, i = !1; e.currentPage !== this.props.currentPage && (n = !0), e.total !== this.props.total && (n = !0, i = !0), e.pageSize !== this.props.pageSize && (n = !0, i = !0), n && this.foundation.updatePage(t.currentPage, t.total, t.pageSize), i && this.foundation.updateAllPageNumbers(t.total, t.pageSize) } renderPrevBtn() { const { prevText: e, disabled: t } = this.props, { prevDisabled: n } = this.state, i = n || t, s = F({ [`${Lt}-item`]: !0, [`${Lt}-prev`]: !0, [`${Lt}-item-disabled`]: i }); return f.createElement("li", { role: "button", "aria-disabled": !!i, "aria-label": "Previous", onClick: a => !i && this.foundation.goPrev(a), className: s, "x-semi-prop": "prevText" }, e || f.createElement(bc, { size: "large" })) } renderNextBtn() { const { nextText: e, disabled: t } = this.props, { nextDisabled: n } = this.state, i = n || t, s = F({ [`${Lt}-item`]: !0, [`${Lt}-item-disabled`]: i, [`${Lt}-next`]: !0 }); return f.createElement("li", { role: "button", "aria-disabled": !!i, "aria-label": "Next", onClick: a => !i && this.foundation.goNext(a), className: s, "x-semi-prop": "nextText" }, e || f.createElement(Ms, { size: "large" })) } renderPageSizeSwitch(e) { const { direction: t } = this.context, n = t === "rtl" ? "bottomRight" : "bottomLeft", { showSizeChanger: i, popoverPosition: s = n, disabled: a, popoverZIndex: o } = this.props, { pageSize: l } = this.state, u = F(`${Lt}-switch`); if (!i) return null; const d = this.foundation.pageSizeInOpts(), h = e.pageSize, g = d.map(m => f.createElement(VZ, { value: m, key: m }, f.createElement("span", null, h.replace("${pageSize}", m.toString())))); return f.createElement("div", { className: u }, f.createElement(Zr, { "aria-label": "Page size selector", disabled: a, onChange: m => this.foundation.changePageSize(m), value: l, key: l, position: s || "bottomRight", clickToHide: !0, zIndex: o, dropdownClassName: `${Lt}-select-dropdown` }, g)) } renderQuickJump(e) { const { showQuickJumper: t, disabled: n } = this.props, { quickJumpPage: i, total: s, pageSize: a } = this.state; if (!t) return null; const l = this.foundation._getTotalPageNumber(s, a) === 1 || n, u = F({ [`${Lt}-quickjump`]: !0, [`${Lt}-quickjump-disabled`]: l }); return f.createElement("div", { className: u }, f.createElement("span", null, e.jumpTo), f.createElement(nO, { value: i, className: `${Lt}-quickjump-input-number`, hideButtons: !0, disabled: l, onBlur: d => this.foundation.handleQuickJumpBlur(), onEnterPress: d => this.foundation.handleQuickJumpEnterPress(d.target.value), onChange: d => this.foundation.handleQuickJumpNumberChange(d) }), f.createElement("span", null, e.page)) } renderPageList() { const { pageList: e, currentPage: t, restLeftPageList: n, restRightPageList: i } = this.state, { popoverPosition: s, popoverZIndex: a, disabled: o } = this.props; return e.map((l, u) => { const d = F(`${Lt}-item`, { [`${Lt}-item-active`]: t === l, [`${Lt}-item-all-disabled`]: o, [`${Lt}-item-all-disabled-active`]: t === l && o }), h = f.createElement("li", { key: `${l}${u}`, onClick: () => !o && this.foundation.goPage(l, u), className: d, "aria-label": l === "..." ? "More" : `Page ${l}`, "aria-current": t === l ? "page" : !1 }, l); if (l === "..." && !o) { let g; return u < 3 ? g = n : g = i, f.createElement(kn, { rePosKey: this.props.currentPage, trigger: "hover", content: this.renderRestPageList(g), key: `${l}${u}`, position: s, zIndex: a }, h) } return h }) } renderRestPageList(e) { const { direction: t } = this.context, n = F(`${Lt}-rest-item`), i = e.length, s = l => { const { index: u, style: d } = l, h = e[u]; return f.createElement("div", { role: "listitem", key: `${h}${u}`, className: n, onClick: () => this.foundation.goPage(h, u), style: d, "aria-label": `${h}` }, h) }, a = 32, o = i >= 5 ? a * 5 : a * i; return f.createElement(eh, { className: `${Lt}-rest-list`, itemData: e, itemSize: a, width: 78, itemCount: i, height: o, style: { direction: t } }, s) } renderSmallPageSelect(e) { const t = this.state.allPageNumbers, n = this.renderRestPageList(t); return f.createElement(kn, { content: n }, e) } renderSmallPage(e) { const t = this.props, { className: n, style: i, hideOnSinglePage: s, hoverShowPageSelect: a, showSizeChanger: o, disabled: l } = t, u = K0(t, ["className", "style", "hideOnSinglePage", "hoverShowPageSelect", "showSizeChanger", "disabled"]), d = F(`${Lt}-small`, Lt, n, { [`${Lt}-disabled`]: l }), { currentPage: h, total: g, pageSize: m } = this.state, b = Math.ceil(g / m); if (b < 2 && s && !o) return null; const y = F({ [`${Lt}-item`]: !0, [`${Lt}-item-small`]: !0, [`${Lt}-item-all-disabled`]: l }), w = f.createElement("div", { className: y }, h, "/", b, " "); return f.createElement("div", Object.assign({ className: d, style: i }, this.getDataAttr(u)), this.renderPrevBtn(), a && !l ? this.renderSmallPageSelect(w) : w, this.renderNextBtn(), this.renderQuickJump(e)) } renderDefaultPage(e) { const { total: t, pageSize: n } = this.state, i = this.props, { showTotal: s, className: a, style: o, hideOnSinglePage: l, showSizeChanger: u, disabled: d } = i, h = K0(i, ["showTotal", "className", "style", "hideOnSinglePage", "showSizeChanger", "disabled"]), g = F(a, `${Lt}`, { [`${Lt}-disabled`]: d }), m = `${Lt}-total`; if (Math.ceil(t / n) < 2 && l && !u) return null; const y = Math.ceil(t / n), w = e.total.replace("${total}", y.toString()); return f.createElement("ul", Object.assign({ className: g, style: o }, this.getDataAttr(h)), s ? f.createElement("span", { className: m }, w) : null, this.renderPrevBtn(), this.renderPageList(), this.renderNextBtn(), this.renderPageSizeSwitch(e), this.renderQuickJump(e)) } render() { const { size: e } = this.props; return f.createElement(Ke, { componentName: "Pagination" }, t => e === "small" ? this.renderSmallPage(t) : this.renderDefaultPage(t)) } } bh.contextType = An; bh.propTypes = { total: c.number, showTotal: c.bool, pageSize: c.number, pageSizeOpts: c.array, size: c.string, currentPage: c.number, defaultCurrentPage: c.number, onPageChange: c.func, onPageSizeChange: c.func, onChange: c.func, prevText: c.node, nextText: c.node, showSizeChanger: c.bool, popoverZIndex: c.number, popoverPosition: c.string, style: c.object, className: c.string, hideOnSinglePage: c.bool, hoverShowPageSelect: c.bool, showQuickJumper: c.bool, disabled: c.bool }; bh.defaultProps = { total: 1, popoverZIndex: Cr.DEFAULT_Z_INDEX, showTotal: !1, pageSize: null, pageSizeOpts: $y.PAGE_SIZE_OPTION, defaultCurrentPage: 1, size: "default", onPageChange: z, onPageSizeChange: z, onChange: z, showSizeChanger: !1, className: "", hideOnSinglePage: !1, showQuickJumper: !1, disabled: !1 }; const aO = { PREFIX: `${G}-popconfirm`, POPOVER: `${G}-popconfirm-popover` }, BZ = { SPACING: 4, DEFAULT_Z_INDEX: 1030 }; class zZ extends ve { init() { } destroy() { } handleCancel(e) { const t = this._adapter.notifyCancel(e); ba(t) ? (this._adapter.updateCancelLoading(!0), t.then(n => { this.handleVisibleChange(!1), this._adapter.updateCancelLoading(!1) }, n => { this._adapter.updateCancelLoading(!1) })) : this.handleVisibleChange(!1) } handleConfirm(e) { const t = this._adapter.notifyConfirm(e); ba(t) ? (this._adapter.updateConfirmLoading(!0), t.then(n => { this._adapter.updateConfirmLoading(!1), this.handleVisibleChange(!1) }, n => { this._adapter.updateConfirmLoading(!1) })) : this.handleVisibleChange(!1) } handleClickOutSide(e) { this._adapter.notifyClickOutSide(e) } handleVisibleChange(e) { this._isControlledComponent("visible") || this._adapter.setVisible(e), e ? this.handleFocusOperateButton() : this._adapter.focusPrevFocusElement(), this._adapter.notifyVisibleChange(e) } handleFocusOperateButton() { const { cancelButtonProps: e, okButtonProps: t } = this._adapter.getProps(); H(e, "autoFocus") && !H(e, "disabled") ? this._adapter.focusCancelButton() : H(t, "autoFocus") && !H(t, "disabled") && this._adapter.focusOkButton() } } var HZ = function (r, e) { var t = {}; for (var n in r) Object.prototype.hasOwnProperty.call(r, n) && e.indexOf(n) < 0 && (t[n] = r[n]); if (r != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, n = Object.getOwnPropertySymbols(r); i < n.length; i++)e.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(r, n[i]) && (t[n[i]] = r[n[i]]); return t }; class Po extends de { constructor(e) { super(e), this.handleCancel = t => this.foundation.handleCancel(t && t.nativeEvent), this.handleConfirm = t => this.foundation.handleConfirm(t && t.nativeEvent), this.handleVisibleChange = t => this.foundation.handleVisibleChange(t), this.handleClickOutSide = t => this.foundation.handleClickOutSide(t), this.stopImmediatePropagation = t => t && t.nativeEvent && t.nativeEvent.stopImmediatePropagation(), this.renderConfirmPopCard = t => { let { initialFocusRef: n } = t; const { content: i, title: s, className: a, style: o, cancelType: l, icon: u, prefixCls: d, showCloseIcon: h } = this.props, { direction: g } = this.context, m = F(d, a, { [`${d}-rtl`]: g === "rtl" }), b = s !== null && typeof s < "u", y = !(i === null || typeof i > "u"), w = f.isValidElement(u), x = F({ [`${d}-body`]: !0, [`${d}-body-withIcon`]: w }); return f.createElement("div", { className: m, onClick: this.stopImmediatePropagation, style: o }, f.createElement("div", { className: `${d}-inner` }, f.createElement("div", { className: `${d}-header` }, w ? f.createElement("i", { className: `${d}-header-icon`, "x-semi-prop": "icon" }, u) : null, f.createElement("div", { className: `${d}-header-body` }, b ? f.createElement("div", { className: `${d}-header-title`, "x-semi-prop": "title" }, s) : null), h ? f.createElement(St, { className: `${d}-btn-close`, icon: f.createElement(ds, null), size: "small", theme: "borderless", type: l, onClick: this.handleCancel }) : null), y ? f.createElement("div", { className: x, "x-semi-prop": "content" }, we(i) ? i({ initialFocusRef: n }) : i) : null, f.createElement("div", { className: `${d}-footer`, ref: this.footerRef }, this.renderControls()))) }, this.state = { cancelLoading: !1, confirmLoading: !1, visible: e.defaultVisible || !1 }, this.foundation = new zZ(this.adapter), this.footerRef = f.createRef(), this.popoverRef = f.createRef() } static getDerivedStateFromProps(e, t) { const n = {}, { hasOwnProperty: i } = Object.prototype; return i.call(e, "visible") && (n.visible = e.visible), n } get adapter() { return Object.assign(Object.assign({}, super.adapter), { setVisible: e => this.setState({ visible: e }), updateConfirmLoading: e => this.setState({ confirmLoading: e }), updateCancelLoading: e => this.setState({ cancelLoading: e }), notifyConfirm: e => this.props.onConfirm(e), notifyCancel: e => this.props.onCancel(e), notifyVisibleChange: e => this.props.onVisibleChange(e), notifyClickOutSide: e => this.props.onClickOutSide(e), focusCancelButton: () => { var e, t; const n = (t = (e = this.footerRef) === null || e === void 0 ? void 0 : e.current) === null || t === void 0 ? void 0 : t.querySelector("[data-type=cancel]"); n == null || n.focus({ preventScroll: !0 }) }, focusOkButton: () => { var e, t; const n = (t = (e = this.footerRef) === null || e === void 0 ? void 0 : e.current) === null || t === void 0 ? void 0 : t.querySelector("[data-type=ok]"); n == null || n.focus({ preventScroll: !0 }) }, focusPrevFocusElement: () => { var e; (e = this.popoverRef.current) === null || e === void 0 || e.focusTrigger() } }) } renderControls() { const { okText: e, cancelText: t, okType: n, cancelType: i, cancelButtonProps: s, okButtonProps: a } = this.props, { cancelLoading: o, confirmLoading: l } = this.state; return f.createElement(Ke, { componentName: "Popconfirm" }, (u, d) => f.createElement(f.Fragment, null, f.createElement(St, Object.assign({ "data-type": "cancel", type: i, onClick: this.handleCancel, loading: o }, Ht(s, "autoFocus")), t || H(u, "cancel")), f.createElement(St, Object.assign({ "data-type": "ok", type: n, theme: "solid", onClick: this.handleConfirm, loading: l }, Ht(a, "autoFocus")), e || H(u, "confirm")))) } render() { const { direction: e } = this.context, t = e === "rtl" ? "bottomRight" : "bottomLeft", n = this.props, { className: i, prefixCls: s, disabled: a, children: o, style: l, position: u = t } = n, d = HZ(n, ["className", "prefixCls", "disabled", "children", "style", "position"]); if (a) return o; const { visible: h } = this.state, g = { onVisibleChange: this.handleVisibleChange, className: aO.POPOVER, onClickOutSide: this.handleClickOutSide }; return this.isControlled("visible") && (g.trigger = "custom"), f.createElement(kn, Object.assign({ ref: this.popoverRef }, d, { content: m => { let { initialFocusRef: b } = m; return this.renderConfirmPopCard({ initialFocusRef: b }) }, visible: h, position: u }, g), o) } } Po.contextType = An; Po.propTypes = { motion: c.oneOfType([c.bool, c.func, c.object]), disabled: c.bool, content: c.oneOfType([c.node, c.func]), title: c.any, prefixCls: c.string, className: c.string, style: c.object, icon: c.node, okText: c.string, okType: c.string, cancelText: c.string, cancelType: c.string, onCancel: c.func, onConfirm: c.func, onClickOutSide: c.func, onVisibleChange: c.func, visible: c.bool, defaultVisible: c.bool, okButtonProps: c.object, cancelButtonProps: c.object, stopPropagation: c.oneOfType([c.bool, c.string]), showCloseIcon: c.bool, zIndex: c.number, trigger: c.string, position: c.string }; Po.__SemiComponentName__ = "Popconfirm"; Po.defaultProps = xn(Po.__SemiComponentName__, { stopPropagation: !0, trigger: "click", onVisibleChange: z, disabled: !1, icon: f.createElement(yc, { size: "extra-large" }), okType: "primary", cancelType: "tertiary", prefixCls: aO.PREFIX, zIndex: BZ.DEFAULT_Z_INDEX, showCloseIcon: !0, onCancel: z, onConfirm: z, onClickOutSide: z }); const KZ = { PREFIX: `${G}-progress` }, or = { types: ["line", "circle"], DEFAULT_TYPE: "line", STROKE_DEFAULT: "var(--semi-color-success)", strokeLineCap: ["square", "round"], DEFAULT_LINECAP: "round", sizes: ["default", "small", "large"], DEFAULT_SIZE: "default", directions: ["vertical", "horizontal"], DEFAULT_DIRECTION: "horizontal" }; function UZ(r, e, t) { try { const n = WZ(r, e, t); if (n.length !== 0) return n } catch { return } } function WZ(r, e, t) { if (r.sort((i, s) => i.percent - s.percent), r[0].percent > e) return or.STROKE_DEFAULT; const n = r[r.length - 1]; if (n.percent < e) return yl(n.color); for (const [i, s] of r.entries()) { if (s.percent === e) return yl(s.color); if (e > s.percent) continue; const a = r[i - 1]; return t ? GZ({ startColor: yl(a.color), endColor: yl(s.color), size: s.percent - a.percent - 1 }, e - a.percent - 1) : yl(a.color) } } function GZ(r, e) { const { startColor: t, endColor: n, size: i } = r, s = t.split(""), a = n.split(""), o = [parseInt(`${s[1]}${s[2]}`, 16), parseInt(`${a[1]}${a[2]}`, 16)], l = [parseInt(`${s[3]}${s[4]}`, 16), parseInt(`${a[3]}${a[4]}`, 16)], u = [parseInt(`${s[5]}${s[6]}`, 16), parseInt(`${a[5]}${a[6]}`, 16)], d = [parseInt(`${s[7]}${s[8]}`, 16), parseInt(`${a[7]}${a[8]}`, 16)], h = (o[0] - o[1]) / (i + 1), g = (l[0] - l[1]) / (i + 1), m = (u[0] - u[1]) / (i + 1), b = (d[0] - d[1]) / (i + 1); function y(x) { const S = Math.round(o[0] - h * (x + 1)).toString(16), C = Math.round(l[0] - g * (x + 1)).toString(16), O = Math.round(u[0] - m * (x + 1)).toString(16), E = `${w(S)}${w(C)}${w(O)}`, v = Math.floor(b * (x + 1) + d[1]).toString(16); return jr.Hex(`#${E}`, v) } function w(x) { return x.length === 1 ? `0${x}` : x.length === 0 ? "00" : x } if (typeof e > "u") { const x = [t]; for (let S = 0; S < i; S += 1)x.push(y(S)); return x } return y(e) } function yl(r) { if (r = r.trim().toLowerCase(), oo.hex.test(r)) return jr.Hex(r, void 0); if (oo.hslA.test(r)) return jr.Hex(jr.HslA(r), void 0); if (oo.rgbA.test(r)) return jr.Hex(jr.RgbA(r), void 0); if (oo.semiDesignTokens.test(r)) return U0.ALONG.indexOf(r) !== -1 ? jr.SemiDesignToken(r) : U0.SEQUENCE.indexOf(r) !== -1 ? jr.SemiDesignToken(`${r}-5`) : jr.SemiDesignToken(`${r}`) } const jr = { Hex(r, e) { return r = r.replace("#", ""), r.length === 8 ? `#${r}` : r.length === 6 ? `#${r}${e || "ff"}` : (r.length === 3 && (r = r.split("").map(t => t + t).join("")), `#${r}${e || "ff"}`) }, SemiDesignToken(r) { if (typeof window > "u") return; const e = getComputedStyle(document.body).getPropertyValue(`--semi-${r}`); if (e === "") return; const t = `rgba(${e}, 1)`; return jr.RgbA(t) }, HslA(r) { const e = oo.hslA.exec(r), t = parseInt(e[2]), n = parseInt(e[3]) / 100, i = parseInt(e[4]) / 100, s = e[5], a = (1 - Math.abs(2 * i - 1)) * n, o = a * (1 - Math.abs(t / 60 % 2 - 1)), l = i - a / 2; let u = 0, d = 0, h = 0; return 0 <= t && t < 60 ? (u = a, d = o, h = 0) : 60 <= t && t < 120 ? (u = o, d = a, h = 0) : 120 <= t && t < 180 ? (u = 0, d = a, h = o) : 180 <= t && t < 240 ? (u = 0, d = o, h = a) : 240 <= t && t < 300 ? (u = o, d = 0, h = a) : 300 <= t && t < 360 && (u = a, d = 0, h = o), u = Math.round((u + l) * 255).toString(16), d = Math.round((d + l) * 255).toString(16), h = Math.round((h + l) * 255).toString(16), jr.utils.pAL(u, d, h, s) }, RgbA(r) { const e = oo.rgbA.exec(r), t = parseInt(e[2], 10).toString(16), n = parseInt(e[3], 10).toString(16), i = parseInt(e[4], 10).toString(16), s = e[5]; return jr.utils.pAL(t, n, i, s) }, utils: { pAL(r, e, t, n) { return r.length == 1 && (r = "0" + r), e.length == 1 && (e = "0" + e), t.length == 1 && (t = "0" + t), typeof n < "u" ? (n = Math.round(parseInt(n) * 255).toString(16), n.length == 1 && (n = "0" + n), "#" + r + e + t + n) : "#" + r + e + t } } }, oo = { hex: /^#([0-9a-fA-F]{3}|[0-9a-fA-F]{6}|[0-9a-fA-F]{8})$/, hslA: /(hsl)a?\(\s*?(\d+),?\s*?(\d+)%,?\s*?(\d+)%,?\s*?\/?(\s*?[\d.]+)?\s*?\)/, rgbA: /(rgb)a?\(\s*?(\d+),?\s*?(\d+),?\s*?(\d+),?\s*?\/?(\s*?[\d.]+)?\s*?\)/, semiDesignTokens: /(\w+)?-?(\w+)-?(\d)?/ }, U0 = { ALONG: ["black", "white"], SEQUENCE: ["amber", "blue", "cyan", "green", "grey", "indigo", "light-blue", "light-green", "lime", "orange", "pink", "purple", "red", "teal", "violet", "yellow"] }; var W0 = function (r, e) { var t = {}; for (var n in r) Object.prototype.hasOwnProperty.call(r, n) && e.indexOf(n) < 0 && (t[n] = r[n]); if (r != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, n = Object.getOwnPropertySymbols(r); i < n.length; i++)e.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(r, n[i]) && (t[n[i]] = r[n[i]]); return t }; const ni = KZ.PREFIX; class Zl extends R.Component { constructor(e) { super(e), this._mounted = !0, this._mounted = !0, this.state = { percentNumber: this.props.percent } } componentDidUpdate(e) { if (isNaN(this.props.percent) || isNaN(e.percent)) throw new Error("[Semi Progress]:percent can not be NaN"); if (e.percent !== this.props.percent) { if (!this.props.motion) { this.setState({ percentNumber: this.props.percent }); return } this.animation && this.animation.destroy && this.animation.destroy(), this.animation = new Jm({ from: { value: e.percent }, to: { value: this.props.percent } }, { easing: "linear", duration: 300 }), this.animation.on("frame", t => { if (this._mounted === !1) return; const n = parseInt(t.value); this.setState({ percentNumber: n }) }), this.animation.on("rest", () => { this._mounted !== !1 && this.setState({ percentNumber: this.props.percent }) }), this.animation.start() } } componentWillUnmount() { this.animation && this.animation.destroy(), this._mounted = !1 } renderCircleProgress() { const e = this.props, { strokeLinecap: t, style: n, className: i, strokeWidth: s, format: a, size: o, stroke: l, strokeGradient: u, showInfo: d, percent: h, orbitStroke: g, id: m } = e, b = W0(e, ["strokeLinecap", "style", "className", "strokeWidth", "format", "size", "stroke", "strokeGradient", "showInfo", "percent", "orbitStroke", "id"]), y = this.props["aria-label"], w = this.props["aria-labelledby"], x = this.props["aria-valuetext"], { percentNumber: S } = this.state, C = { wrapper: F(`${ni}-circle`, i), svg: F(`${ni}-circle-ring`), circle: F(`${ni}-circle-ring-inner`) }, O = this.calcPercent(h), E = this.calcPercent(S); let v; this.props.width ? v = this.props.width : o === or.DEFAULT_SIZE ? v = 72 : v = 24; const T = this.selectStroke(l, h, u), I = v / 2, k = v / 2, P = (v - s) / 2, N = P * 2 * Math.PI, M = (1 - O / 100) * N, B = `${N} ${N}`, K = a(E); return f.createElement("div", Object.assign({ id: m, className: C.wrapper, style: n, role: "progressbar", "aria-valuemin": 0, "aria-valuemax": 100, "aria-valuenow": E, "aria-labelledby": w, "aria-label": y, "aria-valuetext": x }, Xr(b)), f.createElement("svg", { key: o, className: C.svg, height: v, width: v, "aria-hidden": !0 }, f.createElement("circle", { strokeDashoffset: 0, strokeWidth: s, strokeDasharray: B, strokeLinecap: t, fill: "transparent", stroke: g, r: P, cx: k, cy: I, "aria-hidden": !0 }), f.createElement("circle", { className: C.circle, strokeDashoffset: M, strokeWidth: s, strokeDasharray: B, strokeLinecap: t, fill: "transparent", stroke: T, r: P, cx: k, cy: I, "aria-hidden": !0 })), d && o !== "small" ? f.createElement("span", { className: `${ni}-circle-text` }, K) : null) } calcPercent(e) { let t; return e > 100 ? t = 100 : e < 0 ? t = 0 : t = e, t } selectStroke(e, t, n) { if (typeof e == "string") return e; const i = UZ(e, t, n); return typeof i < "u" ? i : or.STROKE_DEFAULT } renderLineProgress() { const e = this.props, { className: t, style: n, stroke: i, strokeGradient: s, direction: a, format: o, showInfo: l, size: u, percent: d, orbitStroke: h, id: g } = e, m = W0(e, ["className", "style", "stroke", "strokeGradient", "direction", "format", "showInfo", "size", "percent", "orbitStroke", "id"]), b = this.props["aria-label"], y = this.props["aria-labelledby"], w = this.props["aria-valuetext"], { percentNumber: x } = this.state, S = F(ni, t, { [`${ni}-horizontal`]: a === or.DEFAULT_DIRECTION, [`${ni}-vertical`]: a !== or.DEFAULT_DIRECTION, [`${ni}-large`]: u === "large" }), C = F({ [`${ni}-track`]: !0 }), O = F(`${ni}-track-inner`), E = this.calcPercent(d), v = this.calcPercent(x), I = { background: this.selectStroke(i, d, s) }; a === or.DEFAULT_DIRECTION ? I.width = `${E}%` : I.height = `${E}%`; const k = o(v); return f.createElement("div", Object.assign({ id: g, className: S, style: n, role: "progressbar", "aria-valuemin": 0, "aria-valuemax": 100, "aria-valuenow": E, "aria-labelledby": y, "aria-label": b, "aria-valuetext": w }, Xr(m)), f.createElement("div", { className: C, style: h ? { backgroundColor: h } : {}, "aria-hidden": !0 }, f.createElement("div", { className: O, style: I, "aria-hidden": !0 })), l ? f.createElement("div", { className: `${ni}-line-text` }, k) : null) } render() { const { type: e } = this.props; return e === "line" ? this.renderLineProgress() : this.renderCircleProgress() } } Zl.propTypes = { "aria-label": c.string, "aria-labelledby": c.string, "aria-valuetext": c.string, className: c.string, direction: c.oneOf(or.directions), format: c.oneOfType([c.func, c.node]), id: c.string, motion: c.oneOfType([c.bool, c.func, c.object]), orbitStroke: c.string, percent: c.number, scale: c.number, showInfo: c.bool, size: c.oneOf(or.sizes), stroke: c.oneOfType([c.string, c.arrayOf(c.shape({ percent: c.number, color: c.string }))]), strokeGradient: c.bool, strokeLinecap: c.oneOf(or.strokeLineCap), strokeWidth: c.number, style: c.object, type: c.oneOf(or.types), width: c.number }; Zl.defaultProps = { className: "", direction: or.DEFAULT_DIRECTION, format: r => `${r}%`, motion: !0, orbitStroke: "var(--semi-color-fill-0)", percent: 0, showInfo: !1, size: or.DEFAULT_SIZE, stroke: or.STROKE_DEFAULT, strokeGradient: !1, strokeLinecap: or.DEFAULT_LINECAP, strokeWidth: 4, style: {}, type: or.DEFAULT_TYPE }; const oO = { PREFIX: `${G}-radio`, INNER: `${G}-radio-inner`, TEXT: `${G}-radio-text`, INPUT: `${G}-radio-input`, CHECKED: `${G}-radio-checked`, DISABLED: `${G}-radio-disabled`, BUTTON: `${G}-radio-button` }, YZ = { PREFIX: `${G}-radioGroup`, INNER: `${G}-radioGroup-inner`, TEXT: `${G}-radioGroup-text`, INPUT: `${G}-radioGroup-input`, CHECKED: `${G}-radioGroup-checked`, DISABLED: `${G}-radioGroup-disabled` }, mn = { DIRECTION_SET: ["horizontal", "vertical"], DEFAULT_DIRECTION: "horizontal", MODE: ["advanced", ""], TYPE_DEFAULT: "default", TYPE_BUTTON: "button", TYPE_CARD: "card", TYPE_PURECARD: "pureCard", BUTTON_SIZE: ["middle", "small", "large"] }; class XZ extends ve { constructor(e) { super(Object.assign({}, e)) } init() { const e = this._getDisplayValue(); this._setValue(e) } _getDisplayValue() { const { value: e, defaultValue: t } = this.getProps(); let n; return "value" in this.getProps() ? n = e : "defaultValue" in this.getProps() && (n = t), n } handleChange(e) { const t = this.getProp("mode"), n = this.getState("value"), { checked: i, value: s } = e.target, a = this._adapter.isInProps("value"), o = Object.assign(Object.assign({}, e), { target: Object.assign(Object.assign({}, e.target), { value: s }) }); t === "advanced" && !i && (o.target.value = void 0), a || (t === "advanced" && !i ? this._setValue(void 0) : this._setValue(s)), (t === "advanced" || n !== s) && this._adapter.notifyChange(o) } handlePropValueChange(e) { this._setValue(e) } _setValue(e) { this._adapter.setValue(e) } destroy() { } } class qZ extends ve { constructor() { super(...arguments), this.handleFocusVisible = e => { const { target: t } = e; try { t.matches(":focus-visible") && this._adapter.setFocusVisible(!0) } catch { Nt(!0, "Warning: [Semi Radio] The current browser does not support the focus-visible") } }, this.handleBlur = () => { this._adapter.setFocusVisible(!1) } } init() { const { children: e, extra: t, extraId: n, addonId: i } = this._adapter.getProps(); e && !i && this._adapter.setAddonId(), t && !n && this._adapter.setExtraId() } setHover(e) { this._adapter.setHover(e) } setChecked(e) { this._adapter.setChecked(e) } } class ZZ extends ve { constructor(e) { super(Object.assign({}, e)) } init() { const e = this._adapter.getProp("checked"), t = this._adapter.getProp("defaultChecked"); this.setChecked(e || t) } setChecked(e) { this._adapter.setNativeControlChecked(e) } getChecked() { return this._adapter.getProp("checked") } handleChange(e) { const t = "checked" in this.getProps(), { checked: n } = e.target, i = () => { e.stopPropagation() }, s = () => { e.preventDefault() }, a = { target: Object.assign(Object.assign({}, this.getProps()), { checked: n }), stopPropagation: i, preventDefault: s }; t ? this._adapter.notifyChange(a) : (this.setChecked(n), this._adapter.notifyChange(a)) } destroy() { } } const My = f.createContext(null); class vh extends de { constructor(e) { super(e), this.state = { checked: !1 }, this.foundation = new ZZ(this.adapter), this.onChange = this.onChange.bind(this) } get adapter() { return Object.assign(Object.assign({}, super.adapter), { setNativeControlChecked: e => { this.setState({ checked: e }) }, notifyChange: e => { this.props.onChange(e) } }) } componentDidMount() { this.foundation.init() } componentDidUpdate(e) { e.checked !== this.props.checked && this.foundation.setChecked(this.props.checked) } componentWillUnmount() { this.foundation.destroy() } blur() { this.inputEntity.blur() } focus() { const { preventScroll: e } = this.props; this.inputEntity.focus({ preventScroll: e }) } onChange(e) { this.foundation.handleChange(e) } render() { const { disabled: e, mode: t, autoFocus: n, name: i, isButtonRadio: s, isPureCardRadioGroup: a, addonId: o, extraId: l, "aria-label": u, focusInner: d, onInputFocus: h, onInputBlur: g } = this.props, { checked: m } = this.state, b = this.props.prefixCls || oO.PREFIX, y = F({ [`${b}-inner`]: !0, [`${b}-inner-checked`]: !!m, [`${b}-inner-buttonRadio`]: s, [`${b}-inner-pureCardRadio`]: a }), w = F({ [`${b}-focus`]: d, [`${b}-focus-border`]: d && !m, [`${b}-inner-display`]: !s }); return f.createElement("span", { className: y }, f.createElement("input", { ref: x => { this.inputEntity = x }, autoFocus: n, type: t === "advanced" ? "checkbox" : "radio", checked: !!m, disabled: e, onChange: this.onChange, name: i, "aria-label": u, "aria-labelledby": o, "aria-describedby": l, onFocus: h, onBlur: g }), f.createElement("span", { className: w }, m ? f.createElement(VH, null) : null)) } } vh.contextType = My; vh.propTypes = { checked: c.bool, disabled: c.bool, isButtonRadio: c.bool, onChange: c.func, mode: c.oneOf(["advanced", ""]), "aria-label": c.string, focusInner: c.bool, onInputFocus: c.func, onInputBlur: c.func, preventScroll: c.bool }; vh.defaultProps = { onChange: z, isButtonRadio: !1 }; var JZ = function (r, e) { var t = {}; for (var n in r) Object.prototype.hasOwnProperty.call(r, n) && e.indexOf(n) < 0 && (t[n] = r[n]); if (r != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, n = Object.getOwnPropertySymbols(r); i < n.length; i++)e.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(r, n[i]) && (t[n[i]] = r[n[i]]); return t }; class Bs extends de { constructor(e) { super(e), this.onChange = t => { const { onChange: n } = this.props; if (this.isInGroup()) { const { radioGroup: i } = this.context; i.onChange && i.onChange(t) } !("checked" in this.props) && this.foundation.setChecked(t.target.checked), n && n(t) }, this.handleMouseEnter = t => { this.props.onMouseEnter(t), this.foundation.setHover(!0) }, this.handleMouseLeave = t => { this.props.onMouseLeave(t), this.foundation.setHover(!1) }, this.handleFocusVisible = t => { this.foundation.handleFocusVisible(t) }, this.handleBlur = t => { this.foundation.handleBlur() }, this.state = { hover: !1, addonId: e.addonId, extraId: e.extraId, checked: e.checked || e.defaultChecked || !1 }, this.foundation = new qZ(this.adapter), this.radioEntity = null } componentDidUpdate(e) { this.props.checked !== e.checked && (st(this.props.checked) ? this.foundation.setChecked(!1) : oy(this.props.checked) && this.foundation.setChecked(this.props.checked)) } get adapter() { return Object.assign(Object.assign({}, super.adapter), { setHover: e => { this.setState({ hover: e }) }, setAddonId: () => { this.setState({ addonId: zi({ prefix: "addon" }) }) }, setChecked: e => { this.setState({ checked: e }) }, setExtraId: () => { this.setState({ extraId: zi({ prefix: "extra" }) }) }, setFocusVisible: e => { this.setState({ focusVisible: e }) } }) } isInGroup() { return this.context && this.context.radioGroup } focus() { this.radioEntity.focus() } blur() { this.radioEntity.blur() } render() { const e = this.props, { addonClassName: t, addonStyle: n, disabled: i, style: s, className: a, prefixCls: o, displayMode: l, children: u, extra: d, mode: h, type: g, value: m, name: b } = e, y = JZ(e, ["addonClassName", "addonStyle", "disabled", "style", "className", "prefixCls", "displayMode", "children", "extra", "mode", "type", "value", "name"]); let w, x, S, C, O, E, v, T, I; const { hover: k, addonId: P, extraId: N, focusVisible: M, checked: B } = this.state, K = { checked: B, disabled: i }; this.isInGroup() ? (w = this.context.radioGroup.value === m, x = i || this.context.radioGroup.disabled, S = this.context.mode, C = this.context.radioGroup.isButtonRadio, O = this.context.radioGroup.isCardRadio, E = this.context.radioGroup.isPureCardRadio, T = this.context.radioGroup.buttonSize, I = o || this.context.radioGroup.prefixCls, K.checked = w, K.disabled = x) : (w = B, x = i, S = h, v = g === "button", I = o, C = g === mn.TYPE_BUTTON, E = g === mn.TYPE_PURECARD, O = g === mn.TYPE_CARD || E); const U = typeof C > "u" ? v : C, W = I || oO.PREFIX, Z = O || E || U, J = F(W, { [`${W}-disabled`]: x, [`${W}-checked`]: w, [`${W}-${l}`]: !!l, [`${W}-buttonRadioComponent`]: v, [`${W}-buttonRadioGroup`]: C, [`${W}-buttonRadioGroup-${T}`]: C && T, [`${W}-cardRadioGroup`]: O, [`${W}-cardRadioGroup_disabled`]: x && O, [`${W}-cardRadioGroup_checked`]: O && w && !x, [`${W}-cardRadioGroup_checked_disabled`]: O && w && x, [`${W}-cardRadioGroup_hover`]: O && !w && k && !x, [a]: !!a, [`${W}-focus`]: M && (O || E) }), ee = this.isInGroup() && this.context.radioGroup.name, $ = F({ [`${W}-addon`]: !U, [`${W}-addon-buttonRadio`]: U, [`${W}-addon-buttonRadio-checked`]: U && w, [`${W}-addon-buttonRadio-disabled`]: U && x, [`${W}-addon-buttonRadio-hover`]: U && !w && !x && k, [`${W}-addon-buttonRadio-${T}`]: U && T, [`${W}-focus`]: M && U }, t), pe = () => !u && !d ? null : f.createElement("div", { className: F([`${W}-content`, { [`${W}-isCardRadioGroup_content`]: O }]) }, u ? f.createElement("span", { className: $, style: n, id: P, "x-semi-prop": "children" }, u) : null, d && !U ? f.createElement("div", { className: `${W}-extra`, id: N, "x-semi-prop": "extra" }, d) : null); return f.createElement("label", Object.assign({ style: s, className: J, onMouseEnter: this.handleMouseEnter, onMouseLeave: this.handleMouseLeave }, this.getDataAttr(y)), f.createElement(vh, Object.assign({}, this.props, K, { mode: S, name: b ?? ee, isButtonRadio: U, isPureCardRadioGroup: E, onChange: this.onChange, ref: re => { this.radioEntity = re }, addonId: u && P, extraId: d && N, focusInner: M && !Z, onInputFocus: this.handleFocusVisible, onInputBlur: this.handleBlur })), pe()) } } Bs.contextType = My; Bs.propTypes = { autoFocus: c.bool, checked: c.bool, defaultChecked: c.bool, value: c.any, style: c.object, className: c.string, disabled: c.bool, prefixCls: c.string, displayMode: c.oneOf(["vertical", ""]), onChange: c.func, onMouseEnter: c.func, onMouseLeave: c.func, mode: c.oneOf(mn.MODE), extra: c.node, addonStyle: c.object, addonClassName: c.string, type: c.oneOf([mn.TYPE_DEFAULT, mn.TYPE_BUTTON, mn.TYPE_CARD, mn.TYPE_PURECARD]), "aria-label": c.string, preventScroll: c.bool }; Bs.defaultProps = { autoFocus: !1, defaultChecked: !1, value: void 0, style: void 0, onMouseEnter: z, onMouseLeave: z, mode: "", type: "default" }; Bs.elementType = "Radio"; var QZ = function (r, e) { var t = {}; for (var n in r) Object.prototype.hasOwnProperty.call(r, n) && e.indexOf(n) < 0 && (t[n] = r[n]); if (r != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, n = Object.getOwnPropertySymbols(r); i < n.length; i++)e.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(r, n[i]) && (t[n[i]] = r[n[i]]); return t }; class jy extends de { constructor(e) { super(e), this.onChange = t => { this.foundation.handleChange(t) }, this.getFormatName = () => this.props.name || "default", this.state = { value: e.value || e.defaultValue }, this.foundation = new XZ(this.adapter) } componentDidMount() { this.foundation.init() } componentDidUpdate(e) { typeof e.value == "number" && isNaN(e.value) && typeof this.props.value == "number" && isNaN(this.props.value) || e.value !== this.props.value && this.foundation.handlePropValueChange(this.props.value) } componentWillUnmount() { this.foundation.destroy() } get adapter() { return Object.assign(Object.assign({}, super.adapter), { setValue: e => { this.setState({ value: e }) }, getProps: () => this.props, isInProps: e => e in this.props, notifyChange: e => { this.props.onChange && this.props.onChange(e) } }) } render() { const e = this.props, { children: t, options: n, mode: i, prefixCls: s, className: a, style: o, direction: l, type: u, buttonSize: d, id: h } = e, g = QZ(e, ["children", "options", "mode", "prefixCls", "className", "style", "direction", "type", "buttonSize", "id"]), m = u === mn.TYPE_BUTTON, b = u === mn.TYPE_PURECARD, y = u === mn.TYPE_CARD || b, w = u === mn.TYPE_DEFAULT, x = s || YZ.PREFIX, S = F(a, { [x]: !0, [`${x}-wrapper`]: !0, [`${x}-${l}`]: l && !m, [`${x}-${l}-default`]: l && w, [`${x}-${l}-card`]: l && y, [`${x}-buttonRadio`]: m }), C = this.state.value; let O; return n ? O = (n || []).map((E, v) => typeof E == "string" ? f.createElement(Bs, { key: v, disabled: this.props.disabled, value: E }, E) : f.createElement(Bs, { key: v, disabled: E.disabled || this.props.disabled, value: E.value, extra: E.extra, className: E.className, style: E.style }, E.label)) : t && (O = f.Children.map(t, (E, v) => f.isValidElement(E) ? f.cloneElement(E, { key: v }) : null)), f.createElement("div", Object.assign({ className: S, style: o, id: h, "aria-label": this.props["aria-label"], "aria-invalid": this.props["aria-invalid"], "aria-errormessage": this.props["aria-errormessage"], "aria-labelledby": this.props["aria-labelledby"], "aria-describedby": this.props["aria-describedby"], "aria-required": this.props["aria-required"] }, this.getDataAttr(g)), f.createElement(My.Provider, { value: { radioGroup: { onChange: this.onChange, value: C, disabled: this.props.disabled, name: this.getFormatName(), isButtonRadio: m, isCardRadio: y, isPureCardRadio: b, buttonSize: d, prefixCls: s }, mode: i } }, O)) } } jy.propTypes = { defaultValue: c.any, disabled: c.bool, name: c.string, options: c.array, buttonSize: c.oneOf(mn.BUTTON_SIZE), type: c.oneOf([mn.TYPE_DEFAULT, mn.TYPE_BUTTON, mn.TYPE_CARD, mn.TYPE_PURECARD]), value: c.any, onChange: c.func, children: c.node, prefixCls: c.string, className: c.string, style: c.object, direction: c.oneOf(mn.DIRECTION_SET), mode: c.oneOf(mn.MODE), "aria-label": c.string, "aria-describedby": c.string, "aria-errormessage": c.string, "aria-invalid": c.bool, "aria-labelledby": c.string, "aria-required": c.bool, id: c.string }; jy.defaultProps = { disabled: !1, onChange: z, direction: mn.DEFAULT_DIRECTION, mode: "", type: mn.TYPE_DEFAULT, buttonSize: "middle" }; const $u = { PREFIX: `${G}-rating` }, lO = { SIZE_SET: ["default", "small"] }; class Vy extends ve { constructor(e) { super(Object.assign(Object.assign({}, Vy.defaultAdapter), e)), this.handleStarFocusVisible = t => { const { target: n } = t; this.getProps(); try { n.matches(":focus-visible") && this._adapter.setEmptyStarFocusVisible(!0) } catch { Nt(!0, "Warning: [Semi Rating] The current browser does not support the focus-visible") } }, this.handleStarBlur = t => { const { emptyStarFocusVisible: n } = this.getStates(); n && this._adapter.setEmptyStarFocusVisible(!1) } } init() { const { autoFocus: e, disabled: t } = this.getProps(); e && !t && this._adapter.focus() } _getScroll(e, t) { let n = t ? e.pageYOffset : e.pageXOffset; const i = t ? "scrollTop" : "scrollLeft"; if (typeof n != "number") { const s = e.document; n = s.documentElement[i], typeof n != "number" && (n = s.body[i]) } return n } _getClientPosition(e) { let t, n; const i = e.ownerDocument, { body: s } = i, a = i && i.documentElement, o = e.getBoundingClientRect(); return t = o.left, n = o.top, t -= a.clientLeft || s.clientLeft || 0, n -= a.clientTop || s.clientTop || 0, { left: t, top: n } } _getOffsetLeft(e) { const t = this._getClientPosition(e), n = e.ownerDocument, i = n.defaultView || n.parentWindow; return t.left += this._getScroll(i), t.left } getStarValue(e, t) { const { allowHalf: n } = this.getProps(), s = this._adapter.getContext("direction") === "rtl"; let a = e + 1; if (n) { const o = this._adapter.getStarDOM(e), l = this._getOffsetLeft(o), u = o.clientWidth; (s && t - l > u / 2 || !s && t - l < u / 2) && (a -= .5) } return a } handleHover(e, t) { const n = this.getStarValue(t, e.pageX), { clearedValue: i, hoverValue: s } = this.getStates(); n !== s && n !== i && this._adapter.notifyHoverChange(n, null) } handleMouseLeave() { this._adapter.notifyHoverChange(void 0, null) } handleClick(e, t) { const { allowClear: n } = this.getProps(), { value: i } = this.getStates(), s = this.getStarValue(t, e.pageX), a = n ? s === i : !1; this._adapter.updateValue(a ? 0 : s), a ? this._adapter.notifyHoverChange(void 0, s) : this._adapter.clearValue(null) } handleFocus(e) { this._adapter.notifyFocus(e) } handleBlur(e) { this._adapter.notifyBlur(e) } handleKeyDown(e, t) { const { key: n } = e, { count: i, allowHalf: s } = this.getProps(), o = this._adapter.getContext("direction") === "rtl", l = s ? .5 : 1; let u, d; n === "ArrowRight" || n === "ArrowUp" ? u = t + (o ? -l : l) : (n === "ArrowLeft" || n === "ArrowDown") && (u = t + (o ? l : -l)), u > i ? d = 0 : u < 0 ? d = i : d = u, ["ArrowRight", "ArrowUp", "ArrowLeft", "ArrowDown"].includes(n) && (this._adapter.notifyKeyDown(e), this._adapter.updateValue(d), this.changeFocusStar(d, e), e.preventDefault(), this._adapter.notifyHoverChange(void 0, null)) } changeFocusStar(e, t) { const { count: n, allowHalf: i, preventScroll: s } = this.getProps(), a = Math.ceil(e) - 1, o = [...t.currentTarget.childNodes].map(l => l.childNodes[0].childNodes); a < 0 ? o[n][0].focus({ preventScroll: s }) : o[a][i ? e * 10 % 10 === 5 ? 0 : 1 : 0].focus({ preventScroll: s }) } } class By extends ve { constructor(e) { super(Object.assign(Object.assign({}, By.defaultAdapter), e)), this.handleFocusVisible = (t, n) => { const { target: i } = t; try { i.matches(":focus-visible") && (n === "first" ? this._adapter.setFirstStarFocus(!0) : this._adapter.setSecondStarFocus(!0)) } catch { Nt(!0, "Warning: [Semi Rating] The current browser does not support the focus-visible") } }, this.handleBlur = (t, n) => { const { firstStarFocus: i, secondStarFocus: s } = this.getStates(); n === "first" ? i && this._adapter.setFirstStarFocus(!1) : s && this._adapter.setSecondStarFocus(!1) } } } class cO extends de { constructor(e) { super(e), this.firstStar = null, this.secondStar = null, this.onHover = t => { const { onHover: n, index: i } = this.props; n(t, i) }, this.onClick = t => { const { onClick: n, index: i } = this.props; n(t, i) }, this.onFocus = (t, n) => { const { onFocus: i } = this.props; i && i(t), this.foundation.handleFocusVisible(t, n) }, this.onBlur = (t, n) => { const { onBlur: i } = this.props; i && i(t), this.foundation.handleBlur(t, n) }, this.onKeyDown = t => { const { onClick: n, index: i } = this.props; t.keyCode === 13 && n(t, i) }, this.starFocus = () => { const { value: t, index: n, preventScroll: i } = this.props; t - n === .5 ? this.firstStar.focus({ preventScroll: i }) : this.secondStar.focus({ preventScroll: i }) }, this.saveFirstStar = t => { this.firstStar = t }, this.saveSecondStar = t => { this.secondStar = t }, this.state = { firstStarFocus: !1, secondStarFocus: !1 }, this.foundation = new By(this.adapter) } get adapter() { return Object.assign(Object.assign({}, super.adapter), { setFirstStarFocus: e => { this.setState({ firstStarFocus: e }) }, setSecondStarFocus: e => { this.setState({ secondStarFocus: e }) } }) } render() { const { index: e, prefixCls: t, character: n, count: i, value: s, disabled: a, allowHalf: o, focused: l, size: u, ariaLabelPrefix: d } = this.props, { firstStarFocus: h, secondStarFocus: g } = this.state, m = e + 1, b = m - s, y = o && b < 1 && b > 0, w = 1 - b, x = m <= s, S = typeof u == "number", C = F(t, { [`${t}-half`]: y, [`${t}-full`]: x, [`${t}-${u}`]: !S }), O = S ? { width: u, height: u, fontSize: u } : {}, E = S ? "inherit" : u === "small" ? "default" : "extra-large", v = n || f.createElement(tK, { size: E, style: { display: "block" } }), T = e === i, I = F(`${t}-wrapper`, { [`${t}-disabled`]: a, [`${$u.PREFIX}-focus`]: (h || g) && s !== 0 }), k = { onClick: a ? null : this.onClick, onKeyDown: a ? null : this.onKeyDown, onMouseMove: a ? null : this.onHover, className: I }, P = o ? i * 2 + 1 : i + 1, N = { ref: this.saveFirstStar, role: "radio", "aria-checked": s === e + .5, "aria-posinset": 2 * e + 1, "aria-setsize": P, "aria-disabled": a, "aria-label": `${e + .5} ${d}s`, "aria-labelledby": this.props["aria-describedby"], "aria-describedby": this.props["aria-describedby"], className: F(`${t}-first`, `${$u.PREFIX}-no-focus`), tabIndex: !a && s === e + .5 ? 0 : -1, onFocus: K => { this.onFocus(K, "first") }, onBlur: K => { this.onBlur(K, "first") } }, M = !a && (s === e + 1 || T && s === 0) ? 0 : -1, B = { ref: this.saveSecondStar, role: "radio", "aria-checked": T ? s === 0 : s === e + 1, "aria-posinset": o ? 2 * (e + 1) : e + 1, "aria-setsize": P, "aria-disabled": a, "aria-label": `${T ? 0 : e + 1} ${d}${e === 0 ? "" : "s"}`, "aria-labelledby": this.props["aria-describedby"], "aria-describedby": this.props["aria-describedby"], className: F(`${t}-second`, `${$u.PREFIX}-no-focus`), tabIndex: M, onFocus: K => { this.onFocus(K, "second") }, onBlur: K => { this.onBlur(K, "second") } }; return f.createElement("li", { className: C, style: Object.assign({}, O), key: e }, f.createElement("div", Object.assign({}, k), o && !T && f.createElement("div", Object.assign({}, N, { style: { width: `${w * 100}%` } }), v), f.createElement("div", Object.assign({}, B, { "x-semi-prop": "character" }), v))) } } cO.propTypes = { value: c.number, index: c.number, prefixCls: c.string, allowHalf: c.bool, onHover: c.func, onClick: c.func, character: c.node, focused: c.bool, disabled: c.bool, count: c.number, ariaLabelPrefix: c.string, size: c.oneOfType([c.oneOf(lO.SIZE_SET), c.number]), "aria-describedby": c.string, onFocus: c.func, onBlur: c.func, preventScroll: c.bool }; var eJ = function (r, e) { var t = {}; for (var n in r) Object.prototype.hasOwnProperty.call(r, n) && e.indexOf(n) < 0 && (t[n] = r[n]); if (r != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, n = Object.getOwnPropertySymbols(r); i < n.length; i++)e.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(r, n[i]) && (t[n[i]] = r[n[i]]); return t }; class xh extends de { constructor(e) { super(e), this.rate = null, this.onHover = (n, i) => { this.foundation.handleHover(n, i) }, this.onMouseLeave = () => { this.foundation.handleMouseLeave() }, this.onClick = (n, i) => { this.foundation.handleClick(n, i) }, this.onFocus = n => { this.foundation.handleFocus(n) }, this.onBlur = n => { this.foundation.handleBlur(n) }, this.onKeyDown = n => { const { value: i } = this.state; this.foundation.handleKeyDown(n, i) }, this.focus = () => { const { disabled: n, preventScroll: i } = this.props; n || this.rate.focus({ preventScroll: i }) }, this.blur = () => { const { disabled: n } = this.props; n || this.rate.blur() }, this.saveRef = n => i => { this.stars[n] = i }, this.saveRate = n => { this.rate = n }, this.handleStarFocusVisible = n => { this.foundation.handleStarFocusVisible(n) }, this.handleStarBlur = n => { this.foundation.handleStarBlur(n) }, this.getAriaLabelPrefix = () => { if (this.props["aria-label"]) return this.props["aria-label"]; let n = "star"; const { character: i } = this.props; return typeof i == "string" && (n = i), n }, this.getItemList = n => { const { count: i, allowHalf: s, prefixCls: a, disabled: o, character: l, size: u, tooltips: d } = this.props, { value: h, hoverValue: g, focused: m } = this.state; return [...Array(i + 1).keys()].map(y => { const w = f.createElement(cO, { ref: this.saveRef(y), index: y, count: i, prefixCls: `${a}-star`, allowHalf: s, value: g === void 0 ? h : g, onClick: o ? Ct : this.onClick, onHover: o ? Ct : this.onHover, key: y, disabled: o, character: l, focused: m, size: y === i ? 0 : u, ariaLabelPrefix: n, onFocus: o || i !== y ? Ct : this.handleStarFocusVisible, onBlur: o || i !== y ? Ct : this.handleStarBlur }); if (d) { const x = d[y] ? d[y] : "", S = g - 1 === y; return f.createElement(ln, { visible: S, trigger: "custom", content: x, key: `${y}-${S}` }, w) } return w }) }; const t = e.value === void 0 ? e.defaultValue : e.value; this.stars = {}, this.state = { value: t, focused: !1, hoverValue: void 0, clearedValue: null, emptyStarFocusVisible: !1 }, this.foundation = new Vy(this.adapter) } static getDerivedStateFromProps(e, t) { return "value" in e && e.value !== void 0 ? Object.assign(Object.assign({}, t), { value: e.value }) : t } get adapter() { return Object.assign(Object.assign({}, super.adapter), { focus: () => { const { disabled: e, count: t } = this.props, { value: n } = this.state; if (!e) { const i = Math.ceil(n) - 1; this.stars[i < 0 ? t : i].starFocus() } }, getStarDOM: e => { const t = this.stars && this.stars[e]; return lr.findDOMNode(t) }, notifyHoverChange: (e, t) => { const { onHoverChange: n } = this.props; this.setState({ hoverValue: e, clearedValue: t }), n(e) }, updateValue: e => { const { onChange: t } = this.props; "value" in this.props || this.setState({ value: e }), t(e) }, clearValue: e => { this.setState({ clearedValue: e }) }, notifyFocus: e => { const { onFocus: t } = this.props; this.setState({ focused: !0 }), t && t(e) }, notifyBlur: e => { const { onBlur: t } = this.props; this.setState({ focused: !1 }), t && t(e) }, notifyKeyDown: e => { const { onKeyDown: t } = this.props; this.setState({ focused: !1 }), t && t(e) }, setEmptyStarFocusVisible: e => { this.setState({ emptyStarFocusVisible: e }) } }) } componentDidMount() { this.foundation.init() } componentWillUnmount() { this.foundation.destroy() } render() { const e = this.props, { style: t, prefixCls: n, disabled: i, className: s, id: a, count: o, tabIndex: l } = e, u = eJ(e, ["style", "prefixCls", "disabled", "className", "id", "count", "tabIndex"]), { value: d, emptyStarFocusVisible: h } = this.state, g = this.getAriaLabelPrefix(), m = `Rating: ${d} of ${o} ${g}${d === 1 ? "" : "s"},`, b = this.getItemList(g), y = F(n, { [`${n}-disabled`]: i, [`${n}-focus`]: h }, s); return f.createElement("ul", Object.assign({ "aria-label": m, "aria-labelledby": this.props["aria-labelledby"], "aria-describedby": this.props["aria-describedby"], className: y, style: t, onMouseLeave: i ? Ct : this.onMouseLeave, tabIndex: i ? -1 : l, onFocus: i ? Ct : this.onFocus, onBlur: i ? Ct : this.onBlur, onKeyDown: i ? Ct : this.onKeyDown, ref: this.saveRate, id: a }, this.getDataAttr(u)), b) } } xh.contextType = An; xh.propTypes = { "aria-describedby": c.string, "aria-errormessage": c.string, "aria-invalid": c.bool, "aria-label": c.string, "aria-labelledby": c.string, "aria-required": c.bool, disabled: c.bool, value: c.number, defaultValue: c.number, count: c.number, allowHalf: c.bool, allowClear: c.bool, style: c.object, prefixCls: c.string, onChange: c.func, onHoverChange: c.func, className: c.string, character: c.node, tabIndex: c.number, onFocus: c.func, onBlur: c.func, onKeyDown: c.func, autoFocus: c.bool, size: c.oneOfType([c.oneOf(lO.SIZE_SET), c.number]), tooltips: c.arrayOf(c.string), id: c.string, preventScroll: c.bool }; xh.defaultProps = { defaultValue: 0, count: 5, allowHalf: !1, allowClear: !0, style: {}, prefixCls: $u.PREFIX, onChange: Ct, onHoverChange: Ct, tabIndex: -1, size: "default" }; const uO = { PREFIX: `${G}-sidesheet`, DIALOG: `${G}-modal` }, Rg = { PLACEMENT: ["top", "right", "bottom", "left"], SIZE: ["small", "medium", "large"], WIDTH: { small: 448, medium: 684, large: 920 }, HEIGHT: 448 }; var G0 = function (r, e) { var t = {}; for (var n in r) Object.prototype.hasOwnProperty.call(r, n) && e.indexOf(n) < 0 && (t[n] = r[n]); if (r != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, n = Object.getOwnPropertySymbols(r); i < n.length; i++)e.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(r, n[i]) && (t[n[i]] = r[n[i]]); return t }; let tJ = 0; const Fr = uO.PREFIX; class zy extends f.PureComponent { constructor() { super(...arguments), this.onMaskClick = e => { e.target === e.currentTarget && this.close(e) }, this.close = e => { const { onClose: t } = this.props; t && t(e) } } componentDidMount() { this.sideSheetId = `sidesheet-${tJ++}` } componentWillUnmount() { clearTimeout(this.timeoutId) } getMaskElement() { var e; const { mask: t, maskStyle: n, maskClosable: i } = this.props; return t ? f.createElement("div", Object.assign({ "aria-hidden": !0, key: "mask", className: F(`${Fr}-mask`, (e = this.props.maskClassName) !== null && e !== void 0 ? e : ""), style: n, onClick: i ? this.onMaskClick : null }, this.props.maskExtraProps)) : null } renderHeader() { const { title: e, closable: t, headerStyle: n, closeIcon: i } = this.props; let s, a; if (e && (s = f.createElement("div", { className: `${Fr}-title`, "x-semi-prop": "title" }, this.props.title)), t) { const o = i || f.createElement(ds, null); a = f.createElement(br, { className: `${Fr}-close`, key: "close-btn", onClick: this.close, type: "tertiary", icon: o, theme: "borderless", size: "small" }) } return f.createElement("div", { className: `${Fr}-header`, role: "heading", "aria-level": 1, style: Object.assign({}, n) }, s, a) } getDialogElement() { var e; const t = G0(this.props, []), n = {}; t.width && (n.width = t.width, t.mask || (n.width = "100%")), t.height && (n.height = t.height); const i = this.renderHeader(); return f.createElement("div", Object.assign({ key: "dialog-element", role: "dialog", tabIndex: -1, className: F(`${Fr}-inner`, `${Fr}-inner-wrap`, (e = this.props.dialogClassName) !== null && e !== void 0 ? e : "", `${Fr}-size-${t.size}`), style: Object.assign(Object.assign({}, t.style), n) }, this.props.wrapperExtraProps), f.createElement("div", { className: `${Fr}-content` }, i, f.createElement("div", { className: `${Fr}-body`, style: t.bodyStyle, "x-semi-prop": "children" }, t.children), t.footer ? f.createElement("div", { className: `${Fr}-footer`, "x-semi-prop": "footer" }, t.footer) : null)) } render() { const e = this.props, { mask: t, className: n, width: i, onClose: s, maskStyle: a, maskClosable: o, maskClassName: l, title: u, closable: d, headerStyle: h, height: g, style: m, size: b, bodyStyle: y, dialogClassName: w, children: x, footer: S, maskExtraProps: C, wrapperExtraProps: O } = e, E = G0(e, ["mask", "className", "width", "onClose", "maskStyle", "maskClosable", "maskClassName", "title", "closable", "headerStyle", "height", "style", "size", "bodyStyle", "dialogClassName", "children", "footer", "maskExtraProps", "wrapperExtraProps"]), v = F(n, { [`${Fr}-fixed`]: !t, [`${Fr}-size-${this.props.size}`]: !t }), T = {}; !t && i && (T.width = i); const I = Xr(E); return f.createElement("div", Object.assign({ className: v, style: T }, I), this.getMaskElement(), this.getDialogElement()) } } zy.propTypes = { onClose: c.func, closeIcon: c.node }; zy.defaultProps = { onClose: z }; class Hy extends ve { constructor(e) { super(Object.assign(Object.assign({}, Hy.defaultAdapter), e)), this.toggleDisplayNone = t => { this._adapter.toggleDisplayNone(t) } } get defaultAdapter() { return { handleCancel: z, beforeShow: z, afterHide: z } } destroy() { this.afterHide() } handleCancel(e) { this._adapter.notifyCancel(e) } beforeShow() { this.getProp("disableScroll") && this._adapter.disabledBodyScroll(), this._adapter.setOnKeyDownListener() } afterHide() { this.getProp("disableScroll") && this._adapter.enabledBodyScroll(), this._adapter.removeKeyDownListener() } handleKeyDown(e) { const { closeOnEsc: t } = this.getProps(); if (t && e.keyCode === Tn.ESC) { e.stopPropagation(), this.handleCancel(e); return } } onVisibleChange(e) { this._adapter.notifyVisibleChange(e) } } var nJ = function (r, e) { var t = {}; for (var n in r) Object.prototype.hasOwnProperty.call(r, n) && e.indexOf(n) < 0 && (t[n] = r[n]); if (r != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, n = Object.getOwnPropertySymbols(r); i < n.length; i++)e.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(r, n[i]) && (t[n[i]] = r[n[i]]); return t }; const Ti = uO.PREFIX, rJ = Rg.HEIGHT; class Jl extends de { constructor(e) { super(e), this.handleCancel = t => { this.foundation.handleCancel(t) }, this.handleKeyDown = t => { this.foundation.handleKeyDown(t) }, this.updateState = () => { this.foundation.toggleDisplayNone(!this.props.visible) }, this.state = { displayNone: !this.props.visible }, this.foundation = new Hy(this.adapter), this.bodyOverflow = "", this.scrollBarWidth = 0, this.originBodyWidth = "100%" } get adapter() { return Object.assign(Object.assign({}, super.adapter), { disabledBodyScroll: () => { const { getPopupContainer: e } = this.props; this.bodyOverflow = document.body.style.overflow || "", !e && this.bodyOverflow !== "hidden" && (document.body.style.overflow = "hidden", document.body.style.width = `calc(${this.originBodyWidth || "100%"} - ${this.scrollBarWidth}px)`) }, enabledBodyScroll: () => { const { getPopupContainer: e } = this.props; !e && this.bodyOverflow !== "hidden" && (document.body.style.overflow = this.bodyOverflow, document.body.style.width = this.originBodyWidth) }, notifyCancel: e => { this.props.onCancel && this.props.onCancel(e) }, notifyVisibleChange: e => { this.props.afterVisibleChange(e) }, setOnKeyDownListener: () => { window && window.addEventListener("keydown", this.handleKeyDown) }, removeKeyDownListener: () => { window && window.removeEventListener("keydown", this.handleKeyDown) }, toggleDisplayNone: e => { e !== this.state.displayNone && this.setState({ displayNone: e }) } }) } static getDerivedStateFromProps(e, t) { const n = {}; return e.visible && t.displayNone && (n.displayNone = !1), !e.visible && !e.motion && !t.displayNone && (n.displayNone = !0), n } componentDidMount() { this.scrollBarWidth = Nm(), this.originBodyWidth = document.body.style.width, this.props.visible && this.foundation.beforeShow() } componentDidUpdate(e, t, n) { !e.visible && this.props.visible && this.foundation.beforeShow(), e.visible && !this.props.visible && this.foundation.afterHide(), t.displayNone !== this.state.displayNone && this.foundation.onVisibleChange(!this.state.displayNone) } componentWillUnmount() { this.props.visible && this.foundation.destroy() } renderContent() { const e = this.props, { placement: t, className: n, children: i, width: s, height: a, motion: o, visible: l, style: u, maskStyle: d, size: h, zIndex: g, getPopupContainer: m, keepDOM: b } = e, y = nJ(e, ["placement", "className", "children", "width", "height", "motion", "visible", "style", "maskStyle", "size", "zIndex", "getPopupContainer", "keepDOM"]); let w = { zIndex: g }; m && (w = { zIndex: g, position: "static" }); const { direction: x } = this.context, S = t === "left" || t === "right", C = t === "top" || t === "bottom", O = C ? a || rJ : "100%", E = F(Ti, n, { [`${Ti}-${t}`]: t, [`${Ti}-popup`]: m, [`${Ti}-horizontal`]: C, [`${Ti}-rtl`]: x === "rtl", [`${Ti}-hidden`]: b && this.state.displayNone }), v = Object.assign(Object.assign(Object.assign({}, S ? s ? { width: s } : {} : { width: "100%" }), y), { visible: l, motion: !1, size: h, className: E, height: O, onClose: this.handleCancel }), T = this.props.visible || this.props.keepDOM || this.props.motion && !this.state.displayNone; return f.createElement(Hi, { motion: this.props.motion, animationState: l ? "enter" : "leave", startClassName: l ? `${Ti}-animation-mask_show` : `${Ti}-animation-mask_hide`, onAnimationEnd: this.updateState }, I => { let { animationClassName: k, animationEventsNeedBind: P } = I; return f.createElement(Hi, { motion: this.props.motion, animationState: l ? "enter" : "leave", startClassName: l ? `${Ti}-animation-content_show_${this.props.placement}` : `${Ti}-animation-content_hide_${this.props.placement}`, onAnimationEnd: this.updateState }, N => { let { animationClassName: M, animationStyle: B, animationEventsNeedBind: K } = N; return T ? f.createElement(Oa, { getPopupContainer: m, style: w }, f.createElement(zy, Object.assign({}, v, { maskExtraProps: P, wrapperExtraProps: K, dialogClassName: M, maskClassName: k, maskStyle: Object.assign({}, d), style: Object.assign(Object.assign({}, B), u) }), i)) : f.createElement(f.Fragment, null) }) }) } render() { return this.props, this.renderContent() } } Jl.contextType = An; Jl.propTypes = { bodyStyle: c.object, headerStyle: c.object, children: c.node, className: c.string, closable: c.bool, disableScroll: c.bool, getPopupContainer: c.func, height: c.oneOfType([c.number, c.string]), mask: c.bool, maskClosable: c.bool, maskStyle: c.object, motion: c.oneOfType([c.bool, c.object, c.func]), onCancel: c.func, placement: c.oneOf(Rg.PLACEMENT), size: c.oneOf(Rg.SIZE), style: c.object, title: c.node, visible: c.bool, width: c.oneOfType([c.number, c.string]), zIndex: c.number, afterVisibleChange: c.func, closeOnEsc: c.bool, footer: c.node, keepDOM: c.bool, "aria-label": c.string }; Jl.__SemiComponentName__ = "SideSheet"; Jl.defaultProps = xn(Jl.__SemiComponentName__, { visible: !1, motion: !0, mask: !0, placement: "right", closable: !0, footer: null, zIndex: 1e3, maskClosable: !0, size: "small", disableScroll: !0, closeOnEsc: !1, afterVisibleChange: z, keepDOM: !1 }); const Yn = { PREFIX: `${G}-slider`, DISABLED: `${G}-slider-disabled`, VERTICAL: `${G}-slider-vertical`, TRACK: `${G}-slider-track`, DOTS: `${G}-slider-dots`, MARKS: `${G}-slider-marks`, HANDLE: `${G}-slider-handle`, HANDLE_DOT: `${G}-slider-handle-dot` }, Y0 = (r, e) => (!globalThis.Touch || !(r instanceof Touch) || ["stopPropagation", "preventDefault"].forEach(n => { let i = e[n]; i && (typeof i == "function" && (i = function () { return e[n](...arguments) }), r[n] ? Nt(!0, `"The key ${n}" exist in Touch.`) : r[n] = i) }), r); class Ky extends ve { constructor(e) { var t; super(Object.assign(Object.assign({}, Ky.defaultAdapter), e)), t = this, this.getMinAndMaxPercent = n => { const { range: i, min: s, max: a } = this._adapter.getProps(), o = i ? (n[0] - s) / (a - s) : (n - s) / (a - s), l = i ? (n[1] - s) / (a - s) : 1; return { min: this._checkValidity(o), max: this._checkValidity(l) } }, this._checkValidity = function (n) { let i = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, s = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1; return n > s ? s : n < i ? i : n }, this.computeHandleVisibleVal = (n, i, s) => { const { focusPos: a, currentValue: o } = this._adapter.getStates(), l = { min: !1, max: !1 }; let u; return i ? u = { min: i(s ? this.outPutValue(o[0]) : this.outPutValue(o)), max: s ? i(this.outPutValue(o[1])) : null } : u = { min: s ? this.outPutValue(o[0]) : this.outPutValue(o), max: s ? this.outPutValue(o[1]) : null }, n ? (l.min = !0, l.max = !0) : typeof n > "u" && i && (a === "min" ? l.min = !0 : a === "max" && (l.max = !0)), { tipVisible: l, tipChildren: u } }, this.valueFormatIsCorrect = n => Array.isArray(n) ? typeof n[0] == "number" && typeof n[0] == "number" : typeof n == "number", this.handleMousePos = (n, i) => { const s = this._adapter.getParentRect(), a = this._adapter.getScrollParentVal(), o = s ? s.left : 0, l = s ? s.top : 0; return { x: n - o + a.scrollLeft, y: i - l + a.scrollTop } }, this.getScrollParent = n => { const i = n, s = /(auto|scroll)/, a = (u, d) => window.getComputedStyle(u, null).getPropertyValue(d), o = u => s.test(a(u, "overflow") + a(u, "overflow-y") + a(u, "overflow-x")), l = u => !u || u === document.body || !(u instanceof Element) ? document.body : o(u) ? u : l(u.parentNode); return l(i) }, this.checkMeetMinMax = n => { const { vertical: i, verticalReverse: s, range: a } = this._adapter.getProps(), o = this._adapter.getState("currentValue"); this.transValueToPos(o); const { sliderX: l, sliderY: u, sliderWidth: d, sliderHeight: h } = this._adapter.getSliderLengths(); this._adapter.getStates(); const g = i ? h : d; let m; i && s ? m = u + g : m = i ? u : l; let b; return i && s ? b = u : b = i ? u + h : l + d, i && s ? n >= m ? n = m : n <= b && (n = b) : n <= m ? n = m : n >= b && (n = b), n }, this.transPosToValue = (n, i) => { const s = this.checkMeetMinMax(n), { min: a, max: o, currentValue: l } = this._adapter.getStates(), { range: u, vertical: d, step: h, verticalReverse: g } = this._adapter.getProps(), { sliderX: m, sliderY: b, sliderWidth: y, sliderHeight: w } = this._adapter.getSliderLengths(), x = d ? b : m, S = d ? w : y; let C; d && g ? C = (x + S - s) / S * (o - a) + a : C = (s - x) / S * (o - a) + a; let O; return u ? O = i ? l[0] : l[1] : O = l, h !== 1 && (C = Math.round(C / h) * h), u && C !== O ? i ? [C, l[1]] : [l[0], C] : !u && C !== O ? C : !1 }, this.transValueToPos = n => { const { min: i, max: s } = this._adapter.getStates(), { vertical: a, range: o, verticalReverse: l } = this._adapter.getProps(), { sliderX: u, sliderY: d, sliderWidth: h, sliderHeight: g } = this._adapter.getSliderLengths(), m = a ? d : u, b = a ? g : h; return o ? [(n[0] - i) * b / (s - i) + m, (n[1] - i) * b / (s - i) + m] : (n - i) * b / (s - i) + m }, this.isMarkActive = n => { const { min: i, max: s, range: a, included: o } = this._adapter.getProps(), l = this._adapter.getState("currentValue"); return typeof (n / 1) == "number" && n >= i && n <= s ? a ? (n > l[1] || n < l[0]) && o ? "unActive" : "active" : n <= l && o ? "active" : "unActive" : !1 }, this.outPutValue = n => { const i = o => { var l, u; return /^\d+(\.\d+)?$/.test(String(o)) && (u = (l = o.toString().split(".")[1]) === null || l === void 0 ? void 0 : l.length) !== null && u !== void 0 ? u : 0 }, s = this._adapter.getProp("step"), a = (() => { const o = i(s), l = Math.pow(10, o); return u => Math.round(u * l) / l })(); if (Array.isArray(n)) { const o = a(n[0]), l = a(n[1]); return o > l ? this.getState("focusPos") === "min" ? [l, l] : [o, o] : [o, l] } else return a(n) }, this.handleDisabledChange = n => { this._adapter.updateDisabled(n) }, this.checkAndUpdateIsInRenderTreeState = () => this._adapter.checkAndUpdateIsInRenderTreeState(), this.calculateOutputValue = (n, i) => { const s = this.transPosToValue(n, i); if (s !== !1) return this.outPutValue(s) }, this.handleValueChange = (n, i) => { const { min: s, max: a } = this._adapter.getStates(); let o = null; const l = {}; this.valueFormatIsCorrect(i) ? (Array.isArray(n) && Array.isArray(i) && (i = [i[0] < s ? s : i[0], i[1] > a ? a : i[1]], o = Object.assign(l, { currentValue: i })), typeof n == "number" && typeof i == "number" && (i > a ? i = a : i = i < s ? s : i, o = Object.assign(l, { currentValue: i }))) : o = l, o && this._adapter.transNewPropsToState(o) }, this.onHandleDown = (n, i) => { this._adapter.onHandleDown(n); const s = this._adapter.getState("disabled"), { vertical: a } = this._adapter.getProps(), { dragging: o } = this._adapter.getOverallVars(); if (s) return !1; this._adapter.setStateVal("isDrag", !0), this._adapter.setStateVal("chooseMovePos", i), i === "min" ? this._adapter.setDragging([!0, o[1]]) : this._adapter.setDragging([o[0], !0]); const l = this.handleMousePos(n.clientX, n.clientY); let u = a ? l.y : l.x; if (!this._adapter.isEventFromHandle(n)) this._dragOffset = 0; else { const d = this._getHandleCenterPosition(a, n.target); this._dragOffset = u - d, u = d } return !0 }, this.onHandleMove = n => { this._adapter.setEventDefault(n); const { disabled: i, chooseMovePos: s } = this._adapter.getStates(), { vertical: a } = this._adapter.getProps(), { dragging: o } = this._adapter.getOverallVars(); if (i) return !1; this.onHandleEnter(s); const l = this.handleMousePos(n.clientX, n.clientY); let u = a ? l.y : l.x; if (u = u - this._dragOffset, s === "min" && o[0] || s === "max" && o[1]) { const d = this.calculateOutputValue(u, s === "min"); if (d === void 0) return !1; this._adapter.notifyChange(d), this._adapter.onHandleMove(u, s === "min", void 0, !1, d) } return !0 }, this.onHandleTouchStart = (n, i) => { const s = this._adapter.getMinHandleEl(), a = this._adapter.getMaxHandleEl(); if (n.target === s || n.target === a) { yn(n); const o = Y0(n.touches[0], n); this.onHandleDown(o, i) } }, this.onHandleTouchMove = n => { const i = this._adapter.getMinHandleEl(), s = this._adapter.getMaxHandleEl(); if (n.target === i || n.target === s) { const a = Y0(n.touches[0], n); this.onHandleMove(a) } }, this.onHandleEnter = n => { const { disabled: i, focusPos: s } = this._adapter.getStates(); i || !s && n !== s && this._adapter.onHandleEnter(n) }, this.onHandleLeave = () => { const n = this._adapter.getState("disabled"), i = this._adapter.getState("isDrag"); !n && !i && this._adapter.onHandleLeave() }, this.onHandleUp = n => { this._adapter.onHandleUpBefore(n); const { disabled: i, chooseMovePos: s } = this._adapter.getStates(), { dragging: a } = this._adapter.getOverallVars(); return i ? !1 : (s === "min" ? this._adapter.setDragging([!1, a[1]]) : this._adapter.setDragging([a[0], !1]), this._adapter.setStateVal("isDrag", !1), this._adapter.onHandleLeave(), this._adapter.onHandleUpAfter(), !0) }, this._handleValueDecreaseWithKeyBoard = (n, i) => { const { min: s, currentValue: a } = this.getStates(), { range: o } = this.getProps(); if (i === "min") if (o) { let l = a[0] - n; return l = l < s ? s : l, [l, a[1]] } else { let l = a - n; return l = l < s ? s : l, l } else { let l = a[1] - n; return l = l < a[0] ? a[0] : l, [a[0], l] } }, this._handleValueIncreaseWithKeyBoard = (n, i) => { const { max: s, currentValue: a } = this.getStates(), { range: o } = this.getProps(); if (i === "min") if (o) { let l = a[0] + n; return l = l > a[1] ? a[1] : l, [l, a[1]] } else { let l = a + n; return l = l > s ? s : l, l } else { let l = a[1] + n; return l = l > s ? s : l, [a[0], l] } }, this._handleHomeKey = n => { const { min: i, currentValue: s } = this.getStates(), { range: a } = this.getProps(); return n === "min" ? a ? [i, s[1]] : i : [s[0], s[0]] }, this._handleEndKey = n => { const { max: i, currentValue: s } = this.getStates(), { range: a } = this.getProps(); return n === "min" ? a ? [s[1], s[1]] : i : [s[0], i] }, this.handleKeyDown = (n, i) => { const { min: s, max: a, currentValue: o } = this.getStates(), { step: l, range: u } = this.getProps(); let d; switch (n.key) { case "ArrowLeft": case "ArrowDown": d = this._handleValueDecreaseWithKeyBoard(l, i); break; case "ArrowRight": case "ArrowUp": d = this._handleValueIncreaseWithKeyBoard(l, i); break; case "PageUp": d = this._handleValueIncreaseWithKeyBoard(10 * l, i); break; case "PageDown": d = this._handleValueDecreaseWithKeyBoard(10 * l, i); break; case "Home": d = this._handleHomeKey(i); break; case "End": d = this._handleEndKey(i); break }if (["ArrowLeft", "ArrowDown", "ArrowRight", "ArrowUp", "PageUp", "PageDown", "Home", "End"].includes(n.key)) { let h = !0; Array.isArray(o) ? h = !(o[0] === d[0] && o[1] === d[1]) : h = o !== d, h && (this._adapter.updateCurrentValue(d), this._adapter.notifyChange(d)), yn(n) } }, this._noTooltip = () => { const { tipFormatter: n, tooltipVisible: i } = this.getProps(); return n === null || i === !1 }, this.onFocus = (n, i) => { if (this._noTooltip()) return; yn(n); const { target: a } = n; try { a.matches(":focus-visible") && (i === "min" ? this._adapter.setStateVal("firstDotFocusVisible", !0) : this._adapter.setStateVal("secondDotFocusVisible", !0)) } catch { Nt(!0, "Warning: [Semi Slider] The current browser does not support the focus-visible") } }, this.onBlur = (n, i) => { if (this._noTooltip()) return; const { firstDotFocusVisible: a, secondDotFocusVisible: o } = this.getStates(); i === "min" ? a && this._adapter.setStateVal("firstDotFocusVisible", !1) : o && this._adapter.setStateVal("secondDotFocusVisible", !1) }, this.handleWrapClick = n => { const { disabled: i, isDrag: s } = this._adapter.getStates(); if (s || i || this._adapter.isEventFromHandle(n)) return; const { vertical: a } = this.getProps(), o = this.handleMousePos(n.clientX, n.clientY), l = a ? o.y : o.x, u = this.checkWhichHandle(l), d = this.calculateOutputValue(l, u); d !== void 0 && (this._adapter.notifyChange(d), !this._isControlledComponent() && this.setHandlePos(l, u, !0, d)) }, this.setHandlePos = function (n, i) { let s = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1, a = arguments.length > 3 ? arguments[3] : void 0; t._adapter.onHandleMove(n, i, () => t._adapter.onHandleUpAfter(), s, a) }, this.checkWhichHandle = n => { const { vertical: i, verticalReverse: s } = this.getProps(), { currentValue: a } = this._adapter.getStates(), o = this.transValueToPos(a); let l = !0; return Array.isArray(o) && (n > o[1] || Math.abs(n - o[0]) > Math.abs(n - o[1])) && (l = !1), i && s && (l = !l), l }, this.handleWrapperEnter = () => { this._adapter.setStateVal("showBoundary", !0) }, this.handleWrapperLeave = () => { this._adapter.setStateVal("showBoundary", !1) } } init() { this._checkCurrentValue(), this._dragOffset = 0 } _checkCurrentValue() { const { currentValue: e, min: t, max: n } = this.getStates(); let i; Array.isArray(e) ? (i = [], i[0] = this._checkValidity(e[0], t, n), i[1] = this._checkValidity(e[1], t, n)) : i = this._checkValidity(e, t, n), this._adapter.updateCurrentValue(i) } destroy() { this._adapter.unSubscribeEventListener() } _getHandleCenterPosition(e, t) { const n = t.getBoundingClientRect(), { x: i, y: s } = this.handleMousePos(n.left + n.width * .5, n.top + n.height * .5); return e ? s : i } } var iJ = function (r, e) { var t = {}; for (var n in r) Object.prototype.hasOwnProperty.call(r, n) && e.indexOf(n) < 0 && (t[n] = r[n]); if (r != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, n = Object.getOwnPropertySymbols(r); i < n.length; i++)e.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(r, n[i]) && (t[n[i]] = r[n[i]]); return t }; const $r = Yn.PREFIX; function sJ(r) { return r ? !!(r.offsetWidth || r.offsetHeight || r.getClientRects().length) : !1 } class wh extends de { constructor(e) { super(e), this.renderHandle = () => { var n, i, s, a, o; const { vertical: l, range: u, tooltipVisible: d, tipFormatter: h, "aria-label": g, "aria-labelledby": m, "aria-valuetext": b, getAriaValueText: y, disabled: w } = this.props, { chooseMovePos: x, isDrag: S, isInRenderTree: C, firstDotFocusVisible: O, secondDotFocusVisible: E } = this.state, v = l ? "top" : "left", T = this.foundation.getMinAndMaxPercent(this.state.currentValue), I = T.min, k = T.max, { tipVisible: P, tipChildren: N } = this.foundation.computeHandleVisibleVal(d && C, h, u), M = F(Yn.HANDLE, { [`${Yn.HANDLE}-clicked`]: x === "min" && S }), B = F(Yn.HANDLE, { [`${Yn.HANDLE}-clicked`]: x === "max" && S }), { min: K, max: U, currentValue: W } = this.state, Z = { "aria-label": g ?? (w ? "Disabled Slider" : void 0), "aria-labelledby": m, "aria-disabled": w }; l && Object.assign(Z, { "aria-orientation": "vertical" }); const J = this.props.handleDot; return u ? f.createElement(f.Fragment, null, f.createElement(ln, { content: N.min, position: "top", trigger: "custom", rePosKey: I, visible: C && (P.min || O), className: `${Yn.HANDLE}-tooltip` }, f.createElement("span", Object.assign({ ref: this.minHanleEl, className: M, style: { [v]: `${I * 100}%`, zIndex: x === "min" ? 2 : 1 }, onMouseDown: $ => { this.foundation.onHandleDown($, "min") }, onMouseEnter: () => { this.foundation.onHandleEnter("min") }, onTouchStart: $ => { this.foundation.onHandleTouchStart($, "min") }, onMouseLeave: () => { this.foundation.onHandleLeave() }, onKeyUp: $ => { this.foundation.onHandleUp($) }, onTouchEnd: $ => { this.foundation.onHandleUp($) }, onKeyDown: $ => { this.foundation.handleKeyDown($, "min") }, onFocus: $ => { this.foundation.onFocus($, "min") }, onBlur: $ => { this.foundation.onBlur($, "min") }, role: "slider", tabIndex: w ? -1 : 0 }, Z, { "aria-valuetext": y ? y(W[0], 0) : b, "aria-valuenow": W[0], "aria-valuemax": W[1], "aria-valuemin": K }), (J == null ? void 0 : J[0]) && f.createElement("div", { className: Yn.HANDLE_DOT, style: Object.assign(Object.assign({}, !((n = J[0]) === null || n === void 0) && n.size ? { width: J[0].size, height: J[0].size } : {}), !((i = J[0]) === null || i === void 0) && i.color ? { backgroundColor: J[0].color } : {}) }))), f.createElement(ln, { content: N.max, position: "top", trigger: "custom", rePosKey: k, visible: C && (P.max || E), className: `${Yn.HANDLE}-tooltip` }, f.createElement("span", Object.assign({ ref: this.maxHanleEl, className: B, style: { [v]: `${k * 100}%`, zIndex: x === "max" ? 2 : 1 }, onMouseDown: $ => { this.foundation.onHandleDown($, "max") }, onMouseEnter: () => { this.foundation.onHandleEnter("max") }, onMouseLeave: () => { this.foundation.onHandleLeave() }, onKeyUp: $ => { this.foundation.onHandleUp($) }, onTouchStart: $ => { this.foundation.onHandleTouchStart($, "max") }, onTouchEnd: $ => { this.foundation.onHandleUp($) }, onKeyDown: $ => { this.foundation.handleKeyDown($, "max") }, onFocus: $ => { this.foundation.onFocus($, "max") }, onBlur: $ => { this.foundation.onBlur($, "max") }, role: "slider", tabIndex: w ? -1 : 0 }, Z, { "aria-valuetext": y ? y(W[1], 1) : b, "aria-valuenow": W[1], "aria-valuemax": U, "aria-valuemin": W[0] }), ((s = this.props.handleDot) === null || s === void 0 ? void 0 : s[1]) && f.createElement("div", { className: Yn.HANDLE_DOT, style: Object.assign(Object.assign({}, !((a = this.props.handleDot[1]) === null || a === void 0) && a.size ? { width: this.props.handleDot[1].size, height: this.props.handleDot[1].size } : {}), !((o = this.props.handleDot[1]) === null || o === void 0) && o.color ? { backgroundColor: this.props.handleDot[1].color } : {}) })))) : f.createElement(ln, { content: N.min, showArrow: this.props.showArrow, position: "top", trigger: "custom", rePosKey: I, visible: C && (P.min || O), className: `${Yn.HANDLE}-tooltip` }, f.createElement("span", Object.assign({ onMouseOver: this.foundation.checkAndUpdateIsInRenderTreeState, ref: this.minHanleEl, className: M, style: { [v]: `${I * 100}%`, zIndex: x === "min" && S ? 2 : 1 }, onMouseDown: $ => { this.foundation.onHandleDown($, "min") }, onMouseEnter: () => { this.foundation.onHandleEnter("min") }, onTouchStart: $ => { this.foundation.onHandleTouchStart($, "min") }, onMouseLeave: () => { this.foundation.onHandleLeave() }, onKeyUp: $ => { this.foundation.onHandleUp($) }, onTouchEnd: $ => { this.foundation.onHandleUp($) }, onKeyDown: $ => { this.foundation.handleKeyDown($, "min") }, onFocus: $ => { this.foundation.onFocus($, "min") }, onBlur: $ => { this.foundation.onBlur($, "min") }, role: "slider", "aria-valuetext": y ? y(W, 0) : b, tabIndex: w ? -1 : 0 }, Z, { "aria-valuenow": W, "aria-valuemax": U, "aria-valuemin": K }), J && f.createElement("div", { className: Yn.HANDLE_DOT, style: Object.assign(Object.assign({}, J != null && J.size ? { width: J.size, height: J.size } : {}), J != null && J.color ? { backgroundColor: J.color } : {}) }))) }, this.renderTrack = () => { const { range: n, included: i, vertical: s } = this.props, a = this.foundation.getMinAndMaxPercent(this.state.currentValue), o = a.min, l = a.max; let u = s ? { height: n ? `${Math.abs(l - o) * 100}%` : `${o * 100}%`, top: n ? `${Math.min(o, l) * 100}%` : 0 } : { width: n ? `${Math.abs(l - o) * 100}%` : `${o * 100}%`, left: n ? `${Math.min(o, l) * 100}%` : 0 }; return u = i ? u : {}, f.createElement("div", { className: Yn.TRACK, style: u, onClick: this.foundation.handleWrapClick }) }, this.renderStepDot = () => { const { min: n, max: i, vertical: s, marks: a } = this.props, o = s ? "top" : "left"; return a && Object.keys(a).length > 0 ? f.createElement("div", { className: Yn.DOTS }, Object.keys(a).map(u => { const d = this.foundation.isMarkActive(Number(u)), h = F(`${$r}-dot`, { [`${$r}-dot-active`]: this.foundation.isMarkActive(Number(u)) === "active" }), g = (Number(u) - n) / (i - n), m = f.createElement("span", { key: u, onClick: this.foundation.handleWrapClick, className: h, style: { [o]: `calc(${g * 100}% - 2px)` } }); return d ? this.props.tooltipOnMark ? f.createElement(ln, { content: a[u] }, m) : m : null })) : null }, this.renderLabel = () => { if (!this.props.showMarkLabel) return null; const { min: n, max: i, vertical: s, marks: a, verticalReverse: o } = this.props, l = s ? "top" : "left"; return a && Object.keys(a).length > 0 ? f.createElement("div", { className: Yn.MARKS + (s && o ? "-reverse" : "") }, Object.keys(a).map(d => { const h = this.foundation.isMarkActive(Number(d)), g = (Number(d) - n) / (i - n); return h ? f.createElement("span", { key: d, className: F(`${$r}-mark${s && o ? "-reverse" : ""}`), style: { [l]: `${g * 100}%` }, onClick: this.foundation.handleWrapClick }, a[d]) : null })) : null }, this._getAriaValueText = (n, i) => { const { getAriaValueText: s } = this.props; return s ? s(n, i) : n }; let { value: t } = this.props; t || (t = this.props.defaultValue), this.state = { currentValue: t || (this.props.range ? [0, 0] : 0), min: this.props.min || 0, max: this.props.max || 0, focusPos: "", onChange: this.props.onChange, disabled: this.props.disabled || !1, chooseMovePos: "", isDrag: !1, clickValue: 0, showBoundary: !1, isInRenderTree: !0, firstDotFocusVisible: !1, secondDotFocusVisible: !1 }, this.sliderEl = f.createRef(), this.minHanleEl = f.createRef(), this.maxHanleEl = f.createRef(), this.dragging = [!1, !1], this.foundation = new Ky(this.adapter), this.eventListenerSet = new Set, this.handleDownEventListenerSet = new Set } get adapter() { var e = this; return Object.assign(Object.assign({}, super.adapter), { getSliderLengths: () => { var t; if (this.sliderEl && this.sliderEl.current) { const n = this.sliderEl.current.getBoundingClientRect(), i = (t = this.sliderEl.current.offsetParent) === null || t === void 0 ? void 0 : t.getBoundingClientRect(), s = { x: i ? n.left - i.left : this.sliderEl.current.offsetLeft, y: i ? n.top - i.top : this.sliderEl.current.offsetTop }; return { sliderX: s.x, sliderY: s.y, sliderWidth: n.width, sliderHeight: n.height } } return { sliderX: 0, sliderY: 0, sliderWidth: 0, sliderHeight: 0 } }, getParentRect: () => { const t = this.sliderEl && this.sliderEl.current && this.sliderEl.current.offsetParent; if (t) return t.getBoundingClientRect() }, getScrollParentVal: () => { const t = this.foundation.getScrollParent(this.sliderEl.current); return { scrollTop: t.scrollTop, scrollLeft: t.scrollLeft } }, isEventFromHandle: t => { const n = [this.minHanleEl, this.maxHanleEl]; let i = !1; return n.forEach(s => { if (!s) return; const a = s && s.current, o = lr.findDOMNode(a); o && o.contains(t.target) && (i = !0) }), i }, getOverallVars: () => ({ dragging: this.dragging }), updateDisabled: t => { this.setState({ disabled: t }) }, transNewPropsToState(t) { let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : z; this.setState(t, n) }, notifyChange: t => { this.props.onChange(Array.isArray(t) ? [...t].sort((n, i) => n - i) : t) }, setDragging: t => { this.dragging = t }, updateCurrentValue: t => { const { currentValue: n } = this.state; t !== n && this.setState({ currentValue: t }) }, setOverallVars: (t, n) => { this[t] = n }, getMinHandleEl: () => this.minHanleEl.current, getMaxHandleEl: () => this.maxHanleEl.current, onHandleDown: t => { this.handleDownEventListenerSet.add(this._addEventListener(document.body, "mousemove", this.foundation.onHandleMove, !1)), this.handleDownEventListenerSet.add(this._addEventListener(window, "mouseup", this.foundation.onHandleUp, !1)), this.handleDownEventListenerSet.add(this._addEventListener(document.body, "touchmove", this.foundation.onHandleTouchMove, !1)) }, onHandleMove: function (t, n) { let i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : z, s = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : !1, a = arguments.length > 4 ? arguments[4] : void 0; if (!e.foundation.checkAndUpdateIsInRenderTreeState()) return; const { value: l } = e.props; let u = a; if (u === void 0) { const h = e.foundation.transPosToValue(t, n); if (h === !1) return; u = e.foundation.outPutValue(h) } const { currentValue: d } = e.state; if (!ke(e.foundation.outPutValue(d), u)) { if (!s && e.foundation.valueFormatIsCorrect(l)) return !1; e.setState({ currentValue: u }, i) } }, setEventDefault: t => { t.stopPropagation(), t.preventDefault() }, setStateVal: (t, n) => { this.setState({ [t]: n }) }, checkAndUpdateIsInRenderTreeState: () => { const t = sJ(this.sliderEl.current); return t !== this.state.isInRenderTree && this.setState({ isInRenderTree: t }), t }, onHandleEnter: t => { this.setState({ focusPos: t }) }, onHandleLeave: () => { this.setState({ focusPos: "" }) }, onHandleUpBefore: t => { var n, i; (i = (n = this.props).onMouseUp) === null || i === void 0 || i.call(n, t), t.stopPropagation(), t.preventDefault(), Array.from(this.handleDownEventListenerSet).forEach(s => s()), this.handleDownEventListenerSet.clear() }, onHandleUpAfter: () => { const { currentValue: t } = this.state, n = this.foundation.outPutValue(t); this.props.onAfterChange(n) }, unSubscribeEventListener: () => { Array.from(this.eventListenerSet).forEach(t => t()) } }) } componentDidMount() { this.foundation.init() } componentDidUpdate(e, t) { const n = !ke(this.props.value, e.value); if (this.props.disabled !== e.disabled && this.foundation.handleDisabledChange(this.props.disabled), n) { const s = this.props.value, a = this.state.currentValue; this.foundation.handleValueChange(a, s), this.props.onAfterChange(this.props.value) } } componentWillUnmount() { this.foundation.destroy() } render() { const { disabled: e, currentValue: t, min: n, max: i } = this.state, s = this.props, { vertical: a, verticalReverse: o, style: l, railStyle: u, range: d, className: h } = s, g = iJ(s, ["vertical", "verticalReverse", "style", "railStyle", "range", "className"]), m = F(`${$r}-wrapper`, { [`${$r}-disabled`]: e, [`${Yn.VERTICAL}-wrapper`]: a, [`${$r}-reverse`]: a && o }, h), b = F(`${$r}-boundary`, { [`${$r}-boundary-show`]: this.props.showBoundary && this.state.showBoundary }), y = F({ [`${$r}`]: !a, [Yn.VERTICAL]: a }), w = Array.isArray(t) ? [...t].sort() : t, x = d ? `Range: ${this._getAriaValueText(w[0], 0)} to ${this._getAriaValueText(w[1], 1)}` : void 0, S = f.createElement("div", Object.assign({ className: m, style: l, ref: this.sliderEl, "aria-label": x, onMouseEnter: () => this.foundation.handleWrapperEnter(), onMouseLeave: () => this.foundation.handleWrapperLeave() }, this.getDataAttr(g)), f.createElement("div", { className: `${$r}-rail`, onClick: this.foundation.handleWrapClick, style: u }), this.renderTrack(), this.renderStepDot(), f.createElement("div", null, this.renderHandle()), this.renderLabel(), f.createElement("div", { className: b }, f.createElement("span", { className: `${$r}-boundary-min` }, n), f.createElement("span", { className: `${$r}-boundary-max` }, i))); return a ? S : f.createElement("div", { className: y }, S) } _addEventListener(e, t, n) { if (e.addEventListener) { for (var i = arguments.length, s = new Array(i > 3 ? i - 3 : 0), a = 3; a < i; a++)s[a - 3] = arguments[a]; e.addEventListener(t, n, ...s); const o = () => { e == null || e.removeEventListener(t, n), Promise.resolve().then(() => { this.eventListenerSet.delete(o) }) }; return this.eventListenerSet.add(o), o } else return z } } wh.propTypes = { defaultValue: c.oneOfType([c.number, c.array]), disabled: c.bool, showMarkLabel: c.bool, included: c.bool, marks: c.object, max: c.number, min: c.number, range: c.bool, step: c.number, tipFormatter: c.func, value: c.oneOfType([c.number, c.array]), vertical: c.bool, onAfterChange: c.func, onChange: c.func, onMouseUp: c.func, tooltipOnMark: c.bool, tooltipVisible: c.bool, showArrow: c.bool, style: c.object, className: c.string, showBoundary: c.bool, railStyle: c.object, verticalReverse: c.bool, getAriaValueText: c.func, handleDot: c.oneOfType([c.shape({ size: c.string, color: c.string }), c.arrayOf(c.shape({ size: c.string, color: c.string }))]) }; wh.defaultProps = { disabled: !1, showMarkLabel: !0, tooltipOnMark: !1, included: !0, max: 100, min: 0, range: !1, showArrow: !0, step: 1, tipFormatter: r => r, vertical: !1, showBoundary: !1, onAfterChange: r => { }, onChange: r => { }, verticalReverse: !1 }; const bl = Qm.PREFIX; class aJ extends de { constructor() { super(...arguments), this.containerRef = f.createRef(), this.mutationObserver = null } componentDidMount() { const e = () => { const t = this.containerRef.current.querySelectorAll("button"), n = t[0], i = t[t.length - 1]; n != null && n.classList.contains(`${bl}-first`) || n == null || n.classList.add(`${bl}-first`), i != null && i.classList.contains(`${bl}-last`) || i == null || i.classList.add(`${bl}-last`) }; if (this.containerRef.current) { e(); const t = new MutationObserver((n, i) => { for (const s of n) (s.type === "attributes" && s.attributeName === "class" || s.type === "childList" && Array.from(s.addedNodes).some(a => a.nodeName === "BUTTON")) && e() }); t.observe(this.containerRef.current, { attributes: !0, childList: !0, subtree: !0 }), this.mutationObserver = t } } componentWillUnmount() { var e; super.componentWillUnmount(), (e = this.mutationObserver) === null || e === void 0 || e.disconnect() } render() { const { children: e, style: t, className: n } = this.props, i = F(`${bl}-split`, n); return f.createElement("div", { ref: this.containerRef, className: i, style: t, role: "group", "aria-label": this.props["aria-label"] }, e) } } aJ.propTypes = { style: c.object, className: c.string, "aria-label": c.string }; class oJ extends ve { constructor(e) { super(Object.assign({}, e)), this.handleFocusVisible = t => { const { target: n } = t; try { n.matches(":focus-visible") && this._adapter.setFocusVisible(!0) } catch { Nt(!0, "Warning: [Semi Switch] The current browser does not support the focus-visible") } }, this.handleBlur = () => { this._adapter.setFocusVisible(!1) } } init() { const { disabled: e } = this.getProps(); this.setDisabled(e) } setChecked(e) { this._adapter.setNativeControlChecked(e) } setDisabled(e) { this._adapter.setNativeControlDisabled(e) } handleChange(e, t) { typeof this.getProps().checked < "u" ? this._adapter.notifyChange(e, t) : (this._adapter.setNativeControlChecked(e), this._adapter.notifyChange(e, t)) } destroy() { } } const Lr = { PREFIX: `${G}-switch`, FOCUS: `${G}-switch-focus`, LARGE: `${G}-switch-large`, SMALL: `${G}-switch-small`, CHECKED: `${G}-switch-checked`, DISABLED: `${G}-switch-disabled`, ACTIVE: `${G}-switch-active`, KNOB: `${G}-switch-knob`, NATIVE_CONTROL: `${G}-switch-native-control`, CHECKED_TEXT: `${G}-switch-checked-text`, UNCHECKED_TEXT: `${G}-switch-unchecked-text`, LOADING_SPIN: `${G}-switch-loading-spin`, LOADING: `${G}-switch-loading` }, lJ = { SIZE_MAP: ["default", "small", "large"] }; var cJ = function (r, e) { var t = {}; for (var n in r) Object.prototype.hasOwnProperty.call(r, n) && e.indexOf(n) < 0 && (t[n] = r[n]); if (r != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, n = Object.getOwnPropertySymbols(r); i < n.length; i++)e.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(r, n[i]) && (t[n[i]] = r[n[i]]); return t }; class Uy extends de { constructor(e) { super(e), this.handleFocusVisible = t => { this.foundation.handleFocusVisible(t) }, this.handleBlur = t => { this.foundation.handleBlur() }, this.state = { nativeControlChecked: e.defaultChecked || e.checked, nativeControlDisabled: !1, focusVisible: !1 }, this.switchRef = f.createRef(), this.foundation = new oJ(this.adapter) } componentDidMount() { this.foundation.init() } componentDidUpdate(e) { this.props.checked !== e.checked && this.foundation.setChecked(this.props.checked), this.props.disabled !== e.disabled && this.foundation.setDisabled(this.props.disabled) } componentWillUnmount() { this.foundation.destroy() } get adapter() { return Object.assign(Object.assign({}, super.adapter), { setNativeControlChecked: e => { this.setState({ nativeControlChecked: e }) }, setNativeControlDisabled: e => { this.setState({ nativeControlDisabled: e }) }, setFocusVisible: e => { this.setState({ focusVisible: e }) }, notifyChange: (e, t) => { this.props.onChange(e, t) } }) } render() { const { nativeControlChecked: e, nativeControlDisabled: t, focusVisible: n } = this.state, i = this.props, { className: s, style: a, onMouseEnter: o, onMouseLeave: l, size: u, checkedText: d, uncheckedText: h, loading: g, id: m } = i, b = cJ(i, ["className", "style", "onMouseEnter", "onMouseLeave", "size", "checkedText", "uncheckedText", "loading", "id"]), y = F(s, { [Lr.PREFIX]: !0, [Lr.CHECKED]: e, [Lr.DISABLED]: t, [Lr.LARGE]: u === "large", [Lr.SMALL]: u === "small", [Lr.LOADING]: g, [Lr.FOCUS]: n }), w = { type: "checkbox", className: Lr.NATIVE_CONTROL, disabled: t || g, checked: e || !1 }, x = d && e && u !== "small", S = h && !e && u !== "small"; return f.createElement("div", Object.assign({ className: y, style: a, onMouseEnter: o, onMouseLeave: l }, this.getDataAttr(b)), g ? f.createElement(yi, { wrapperClassName: Lr.LOADING_SPIN, size: u === "default" ? "middle" : u }) : f.createElement("div", { className: Lr.KNOB, "aria-hidden": !0 }), x ? f.createElement("div", { className: Lr.CHECKED_TEXT, "x-semi-prop": "checkedText" }, d) : null, S ? f.createElement("div", { className: Lr.UNCHECKED_TEXT, "x-semi-prop": "uncheckedText" }, h) : null, f.createElement("input", Object.assign({}, w, { ref: this.switchRef, id: m, role: "switch", "aria-checked": e, "aria-invalid": this.props["aria-invalid"], "aria-errormessage": this.props["aria-errormessage"], "aria-label": this.props["aria-label"], "aria-labelledby": this.props["aria-labelledby"], "aria-describedby": this.props["aria-describedby"], "aria-disabled": this.props.disabled, onChange: C => this.foundation.handleChange(C.target.checked, C), onFocus: C => this.handleFocusVisible(C), onBlur: C => this.handleBlur(C) }))) } } Uy.propTypes = { "aria-label": c.string, "aria-labelledby": c.string, "aria-invalid": c.bool, "aria-errormessage": c.string, "aria-describedby": c.string, className: c.string, checked: c.bool, checkedText: c.node, defaultChecked: c.bool, disabled: c.bool, loading: c.bool, onChange: c.func, onMouseEnter: c.func, onMouseLeave: c.func, style: c.object, size: c.oneOf(lJ.SIZE_MAP), uncheckedText: c.node, id: c.string }; Uy.defaultProps = { disabled: !1, className: "", onChange: z, loading: !1, onMouseEnter: z, onMouseLeave: z, size: "default" }; var uJ = Pm, dJ = 1 / 0; function hJ(r) { var e = r == null ? 0 : r.length; return e ? uJ(r, dJ) : [] } var pJ = hJ; const fJ = _e(pJ); var gJ = Wd; function mJ(r, e) { var t; return gJ(r, function (n, i, s) { return t = e(n, i, s), !t }), !!t } var yJ = mJ, bJ = oS, vJ = Jo, xJ = yJ, wJ = Dn, CJ = Kd; function SJ(r, e, t) { var n = wJ(r) ? bJ : xJ; return t && CJ(r, e, t) && (e = void 0), n(r, vJ(e)) } var EJ = SJ; const Lu = _e(EJ); var _J = Wd; function OJ(r, e) { var t = []; return _J(r, function (n, i, s) { e(n, i, s) && t.push(n) }), t } var TJ = OJ, IJ = U1, PJ = TJ, kJ = Jo, RJ = Dn; function DJ(r, e) { var t = RJ(r) ? IJ : PJ; return t(r, kJ(e)) } var AJ = DJ; const ko = _e(AJ); var NJ = Ud; function FJ(r, e, t) { t = typeof t == "function" ? t : void 0; var n = t ? t(r, e) : void 0; return n === void 0 ? NJ(r, e, void 0, t) : !!n } var $J = FJ; const LJ = _e($J), Qn = { PREFIX: `${G}-table`, TABLE: `${G}-table`, WRAP: `${G}-table-wrapper`, THEAD: `${G}-table-thead`, TR: `${G}-table-row`, TH: `${G}-table-row-head`, TD: `${G}-table-row-cell` }, Te = { SIZE_SMALL: "small", SIZE_MIDDLE: "middle", SIZES: ["small", "default", "middle"], LAYOUTS: ["", "auto", "fixed"], PAGINATION_POSITIONS: ["bottom", "top", "both"], FOOTER_POSITIONS: [!1, !0, "left", "right"], SORT_DIRECTIONS: ["ascend", "descend"], FIXED_SET: [!1, !0, "left", "right"], ALIGNS: ["left", "right", "center"], JUSTIFY_CONTENT: ["flex-start", "flex-end", "center"], SCROLL_HORIZONTAL_POSITIONS: ["left", "middle", "right"], DEFAULT_KEY_COLUMN_SELECTION: "column-selection", DEFAULT_KEY_COLUMN_EXPAND: "column-expand", DEFAULT_KEY_COLUMN_TITLE: "column-title", DEFAULT_KEY_COLUMN_SORTER: "column-sorter", DEFAULT_KEY_COLUMN_FILTER: "column-filter", DEFAULT_KEY_COLUMN_SCROLLBAR: "column-scrollbar", DEFAULT_COMPONENTS: { table: "table", header: { outer: "table", wrapper: "thead", row: "tr", cell: "th" }, body: { outer: "table", wrapper: "tbody", row: "tr", cell: "td" }, footer: { wrapper: "tfoot", row: "tr", cell: "td" } }, EXPAND_RELATED_PROPS: ["expandedRowRender", "dataSource", "hideExpandedColumn", "childrenRecordName", "rowExpandable"] }, Ra = 1, Wy = 0, Gy = 16, Yy = 16, Xy = 12, qy = 12, Zy = 8, Jy = 8, Ch = 20, X0 = Ch + Ra + Wy + Gy + Yy, MJ = Gy + Yy + Ra, q0 = Ch + Ra + Wy + Xy + qy, jJ = Xy + qy + Ra, Z0 = Ch + Ra + Wy + Jy + Zy, VJ = Zy + Jy + Ra, On = { DEFAULT_PAGE_SIZE: 10, DEFAULT_WIDTH_COLUMN_EXPAND: 60, DEFAULT_WIDTH_COLUMN_SELECTION: 60, DEFAULT_INDENT_WIDTH: 20, DEFAULT_CELL_PADDING_LEFT: 16, DEFAULT_CELL_PADDING_RIGHT: 16, DEFAULT_CELL_PADDING_TOP: Gy, DEFAULT_CELL_PADDING_BOTTOM: Yy, DEFAULT_CELL_MIDDLE_PADDING_TOP: Xy, DEFAULT_CELL_MIDDLE_PADDING_BOTTOM: qy, DEFAULT_CELL_SMALL_PADDING_TOP: Zy, DEFAULT_CELL_SMALL_PADDING_BOTTOM: Jy, DEFAULT_CELL_BORDER_WIDTH_LEFT: 1, DEFAULT_CELL_BORDER_WIDTH_RIGHT: 1, DEFAULT_CELL_BORDER_WITH_BOTTOM: Ra, DEFAULT_CELL_LINE_HEIGHT: Ch, DEFAULT_VIRTUALIZED_BODY_HEIGHT: 600, DEFAULT_VIRTUALIZED_SECTION_ROW_HEIGHT: X0, DEFAULT_VIRTUALIZED_ROW_HEIGHT: X0, DEFAULT_VIRTUALIZED_ROW_MIN_HEIGHT: MJ, DEFAULT_VIRTUALIZED_SECTION_ROW_MIDDLE_HEIGHT: q0, DEFAULT_VIRTUALIZED_ROW_MIDDLE_HEIGHT: q0, DEFAULT_VIRTUALIZED_ROW_MIDDLE_MIN_HEIGHT: jJ, DEFAULT_VIRTUALIZED_SECTION_ROW_SMALL_HEIGHT: Z0, DEFAULT_VIRTUALIZED_ROW_SMALL_HEIGHT: Z0, DEFAULT_VIRTUALIZED_ROW_SMALL_MIN_HEIGHT: VJ }; class dO { constructor(e) { this._prefix = e } _isEmpty(e) { return e == null || e === "" } _baseLog() { let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "log"; if (typeof console[e] == "function") { for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), i = 1; i < t; i++)n[i - 1] = arguments[i]; const s = [...n]; this._isEmpty(this._prefix) || s.unshift(this._prefix, ":"), console[e](...s) } } log() { for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)t[n] = arguments[n]; this._baseLog("log", ...t) } warn() { for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)t[n] = arguments[n]; this._baseLog("warn", ...t) } error() { for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)t[n] = arguments[n]; this._baseLog("error", ...t) } info() { for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)t[n] = arguments[n]; this._baseLog("info", ...t) } } function BJ(r, e, t) { return LJ(r, e, function (n, i) { if (typeof n == "function" && typeof i == "function") return Ss(n) === Ss(i) }) } function J0(r, e) { e = Array.isArray(e) ? e : ["key", "dataIndex"]; let t = null; return Vn(e, n => { if (t = H(r, n), t != null) return !1 }), t } function Ro() { let r = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [], e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, t = arguments.length > 2 ? arguments[2] : void 0; e = e < 0 || typeof e != "number" ? 0 : e, t = t > r.length || typeof t != "number" ? r.length : t; let n = 0; return Vn(r, (i, s) => { s >= e && s < t && (n += typeof i == "number" && !isNaN(i) ? i : 0) }), n } function Dg(r, e) { let t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : ["key"]; const n = ko(r, s => s.fixed === !0 || s.fixed === "left"), i = Ur(n, s => t.every(a => s[a] != null && s[a] === e[a])); return n.length > 0 && i === n.length - 1 } function Ag(r, e) { let t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : ["key"]; const n = ko(r, s => s.fixed === "right"), i = Ur(n, s => t.every(a => s[a] != null && s[a] === e[a])); return n.length > 0 && i === 0 } function Mu(r) { return ["left", !0].includes(H(r, "fixed")) } function ju(r) { return ["right"].includes(H(r, "fixed")) } function zJ(r) { return [Te.DEFAULT_KEY_COLUMN_EXPAND, Te.DEFAULT_KEY_COLUMN_SCROLLBAR, Te.DEFAULT_KEY_COLUMN_SELECTION].includes(r) } function hO(r) { return H(r, "key") === Te.DEFAULT_KEY_COLUMN_EXPAND } function HJ(r) { return H(r, "key") === Te.DEFAULT_KEY_COLUMN_SCROLLBAR } function KJ(r) { return H(r, "key") === Te.DEFAULT_KEY_COLUMN_SELECTION } function Qy(r) { let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [Te.DEFAULT_KEY_COLUMN_SCROLLBAR]; return ko(r, t => !e.includes(t.key)) } function Rs(r, e) { return e === void 0 && (e = "key"), typeof e == "function" ? e(r) : H(r, e) } function Ep(r, e) { return e != null && $i(r, e) } function UJ(r, e) { return e !== null && r.has(e) } function WJ(r, e) { return e !== null && r.has(e) } function Q0(r, e, t) { return t === void 0 && (t = "key"), Ui(r, n => e != null && e !== "" && Rs(n, t) === e) } function GJ(r, e) { return e === void 0 && (e = "children"), H(r, e) } function pO() { let r = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "", e = arguments.length > 1 ? arguments[1] : void 0; return e === void 0 && (e = "__expanded_row"), r + e } function YJ() { let r = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "", e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1; const t = {}; return r === "small" ? (t.height = e ? On.DEFAULT_VIRTUALIZED_SECTION_ROW_SMALL_HEIGHT : On.DEFAULT_VIRTUALIZED_ROW_SMALL_HEIGHT, t.minHeight = On.DEFAULT_VIRTUALIZED_ROW_SMALL_MIN_HEIGHT) : r === "middle" ? (t.height = e ? On.DEFAULT_VIRTUALIZED_SECTION_ROW_MIDDLE_HEIGHT : On.DEFAULT_VIRTUALIZED_ROW_MIDDLE_HEIGHT, t.minHeight = On.DEFAULT_VIRTUALIZED_ROW_MIDDLE_MIN_HEIGHT) : (t.height = e ? On.DEFAULT_VIRTUALIZED_SECTION_ROW_HEIGHT : On.DEFAULT_VIRTUALIZED_ROW_HEIGHT, t.minHeight = On.DEFAULT_VIRTUALIZED_ROW_MIN_HEIGHT), t } function go(r) { let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "children"; const t = []; if (Array.isArray(r) && r.length) for (const n of r) Array.isArray(n[e]) && n[e].length ? t.push(...go(n[e], e)) : (ZJ(n), t.push(n)); return t } function gd(r) { let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "children", t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0; const n = []; return Vn(r, (i, s) => { if (i.key == null) { const a = i.dataIndex || s; i.key = `${t}-${a}` } Array.isArray(i[e]) && i[e].length && n.push(...i[e]) }), n.length && gd(n, e, t + 1), r } function fO(r) { let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "children", n = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0; const i = []; return Array.isArray(r) && r.length && n <= e && r.forEach(s => { const a = s[t]; Array.isArray(a) && a.length && n < e ? i.push(...fO(a, e, t, n + 1)) : i.push(s) }), i } function Vu(r, e) { let t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "children", n; return Vn(r, i => { if (i && i.key != null && !n && i.key === e.key && (n = i), i && Array.isArray(i[t]) && !n && (n = Vu(i[t], e, t)), n) return !1 }), n } function XJ(r) { const { expandedRowRender: e, dataSource: t, hideExpandedColumn: n, childrenRecordName: i, rowExpandable: s } = r, a = typeof e == "function"; return n && a || !a && t.some(o => { const l = H(o, i); return !!(Array.isArray(l) && l.length || s(o)) }) } function gO(r) { let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [], t; const n = e.findIndex(i => r.dataIndex === i.dataIndex ? (t = Object.assign(Object.assign({}, i), r), !0) : !1); return n > -1 ? e.splice(n, 1, t) : e.push(t), [...e] } function qJ(r, e) { const t = [...e]; for (const n of r) if (!ze(n.width)) { const i = n.key, s = Ur(t, a => a.key === i); s !== -1 && (t[s].width = H(n, "width")) } return t } function mO(r) { let { dataSource: e, getCheckboxProps: t, childrenRecordName: n, rowKey: i } = r; const s = []; if (Array.isArray(e) && e.length && typeof t == "function") for (const a of e) { const o = t(a), l = typeof i == "function" ? i(a) : H(a, i); o && o.disabled && s.push(l); const u = H(a, n); if (Array.isArray(u) && u.length) { const d = mO({ dataSource: u, getCheckboxProps: t }); s.push(...d) } } return s } function ZJ(r) { if (typeof r == "object" && r !== null) { const { filters: e, sorter: t, dataIndex: n, onFilter: i } = r, s = new dO("[@douyinfe/semi-ui Table]"); (Array.isArray(e) || we(i) || we(t)) && ze(n) && s.warn("The column with sorter or filter must pass the 'dataIndex' prop") } } function JJ(r) { let { dataSource: e, childrenRecordName: t = "children" } = r, n = !1; if (Array.isArray(e)) for (const i of e) { const s = H(i, t); if (Array.isArray(s) && s.length) { n = !0; break } } return n } function yO(r, e) { if (e === "rtl") switch (r) { case "left": return "right"; case "right": return "left"; default: return r }return r } function QJ(r, e) { if (e === "rtl") switch (r) { case "left": return "flex-end"; case "right": return "flex-start"; default: return r } else switch (r) { case "left": return "flex-start"; case "right": return "flex-end"; default: return r } } function eb(r) { return r === !0 || H(r, "showTitle", !0) } class eQ { constructor(e) { this._state = Object.assign({}, e), this._listeners = [] } subscribe(e) { return this._listeners.push(e), () => { const n = this._listeners.indexOf(e); n > -1 && this._listeners.splice(n, 1) } } setState(e) { Object.assign(this._state, Object.assign({}, e)); for (const t of this._listeners) typeof t == "function" && t(this._state) } getState() { return this._state } } function tQ(r, e, t, n) { for (var i = t - 1, s = r.length; ++i < s;)if (n(r[i], e)) return i; return -1 } var nQ = tQ, rQ = Ca, iQ = sy, sQ = nQ, aQ = Ea, oQ = Vd, lQ = Array.prototype, ew = lQ.splice; function cQ(r, e, t, n) { var i = n ? sQ : iQ, s = -1, a = e.length, o = r; for (r === e && (e = oQ(e)), t && (o = rQ(r, aQ(t))); ++s < a;)for (var l = 0, u = e[s], d = t ? t(u) : u; (l = i(o, d, l, n)) > -1;)o !== r && ew.call(o, l, 1), ew.call(r, l, 1); return r } var uQ = cQ, dQ = uQ; function hQ(r, e) { return r && r.length && e && e.length ? dQ(r, e) : r } var pQ = hQ, fQ = Hd, gQ = pQ, mQ = fQ(gQ), yQ = mQ; const bQ = _e(yQ); function vQ(r) { return new Set(r) } function xQ(r, e) { if (r === e && (e = vQ(e)), Ri(r) && r.size && Ri(e) && e.size) { for (const t of e) r.has(t) && r.delete(t); return r } return r } function tw(r, e) { if (r !== null && r.length && e !== null && e.length) { const t = new Set(r), n = new Set(e), i = xQ(t, n); return Array.from(i) } return r } function wQ(r) { let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "ascend"; switch (e) { case "descend": return (t, n) => { const i = Number(r(t, n, e)); return i !== 0 ? -i : i }; case "ascend": default: return (t, n) => r(t, n, e) } } class Ql extends ve { static initColumnsFilteredValueAndSorterOrder(e) { return e.forEach(t => { Ql.initFilteredValue(t), Ql.initSorterOrder(t) }), e } static initFilteredValue(e) { const { defaultFilteredValue: t, filteredValue: n } = e; st(n) && (Array.isArray(t) && t.length ? e.filteredValue = t : e.filteredValue = []) } static initSorterOrder(e) { const { defaultSortOrder: t, sortOrder: n, sorter: i } = e; i && st(n) && (st(t) ? e.sortOrder = !1 : e.sortOrder = t) } constructor(e) { super(Object.assign({}, e)), this.setPage = (i, s) => { i = i || this._adapter.getCurrentPage(); const a = this.getState("pagination"), { dataSource: o, pagination: l, disabledRowKeys: u, allRowKeys: d } = this.getCurrentPageData(null, Object.assign(Object.assign({}, a), { currentPage: i, pageSize: s })); !this._pagerIsControlled() && i > 0 && (this._adapter.setDisabledRowKeys(u), this._adapter.setAllRowKeys(d), this._adapter.setPagination(l), this._adapter.setDataSource(o)), this._notifyChange(l, void 0, void 0, { changeType: "pagination" }) }, this.setCachedFilteredSortedDataSource = i => { this._adapter.setCachedFilteredSortedDataSource(i); const s = this.getAllRowKeys(i); this._adapter.setCachedFilteredSortedRowKeys(s) }, this.isSortOrderValid = i => Te.SORT_DIRECTIONS.includes(i) || i === !1; const t = this._adapter.getHandleColumns(), n = this._adapter.getMergePagination(); this.memoizedWithFnsColumns = oa(t, ke), this.memoizedFilterColumns = oa(Qy), this.memoizedFlattenFnsColumns = oa(go), this.memoizedPagination = oa(n, ke) } init() { const e = [...this.getProp("dataSource")], { queries: t } = this._adapter.getStates(), n = this.getFilteredSortedDataSource(e, t), i = this.getAllDisabledRowKeys(n), s = this.getCurrentPageData(n); this.setAdapterPageData(s), this.initExpandedRowKeys(s), this.initSelectedRowKeys(s), this.setCachedFilteredSortedDataSource(n), this.setAllDisabledRowKeys(i) } initExpandedRowKeys() { let { groups: e } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}; const { defaultExpandAllRows: t, defaultExpandedRowKeys: n = [], expandedRowKeys: i = [], dataSource: s = [], expandAllRows: a, defaultExpandAllGroupRows: o, expandAllGroupRows: l } = this.getProps(), u = []; t || a ? this._addNoDuplicatedItemsToArr(u, this.getAllRowKeys(s), e && Vl(e) && e.size ? Array.from(e.keys()) : []) : o || l ? this._addNoDuplicatedItemsToArr(u, i, e && Vl(e) && e.size ? Array.from(e.keys()) : []) : Array.isArray(n) && n.length ? this._addNoDuplicatedItemsToArr(u, n) : Array.isArray(i) && i.length && this._addNoDuplicatedItemsToArr(u, i), this._adapter.setExpandedRowKeys(u) } initSelectedRowKeys(e) { let { disabledRowKeys: t } = e; const n = this.getProp("rowSelection"), i = []; if (n) { const s = H(n, "selectedRowKeys"), a = H(n, "defaultSelectedRowKeys"); Array.isArray(s) ? this._addNoDuplicatedItemsToArr(i, s) : Array.isArray(a) && this._addNoDuplicatedItemsToArr(i, a), Array.isArray(t) && t.length && bQ(i, ...t), this._adapter.setSelectedRowKeys(i) } } getFilteredSortedDataSource(e, t) { const n = this.filterDataSource(e, t.filter(s => { const a = s.filteredValue ? s.filteredValue : s.defaultFilteredValue; return we(s.onFilter) && Array.isArray(a) && a.length })); return this.sortDataSource(n, t.filter(s => s && we(s.sorter))) } getCurrentPageData(e, t, n) { const i = this._adapter.getCachedFilteredSortedDataSource(); e = e ?? [...i], t = t ?? (this.getState("pagination") && Object.assign({}, this.getState("pagination"))), n = n ?? [...this.getState("queries")]; let s; if (this.getProp("groupBy") != null) { const { groups: u, dataSource: d } = this.groupDataSource(e); e = d, s = u } t = this.normalizePagination(t, e), e = this.limitPageDataSource(e, t); const a = this.getAllDisabledRowKeys(e), o = this.getAllRowKeys(e); return { dataSource: e, groups: s, pagination: t, disabledRowKeys: a, allRowKeys: o, queries: n } } groupDataSource(e, t) { t = t ?? this.getProp("groupBy"); const n = new Map, i = []; return t != null && Vn(e, (s, a) => { const o = typeof t == "function" ? t(s) : H(s, t); if (o != null && o !== "") { const l = this.getRecordKey(s); let u = n.get(o); Ri(u) ? u.add(l) : (u = new Set([l]), n.set(o, u)) } }), n && n.size ? n.forEach((s, a) => { Ri(s) && s.forEach(o => { i.push(this._getRecord(o)) }) }) : i.push(...e), { groups: n, dataSource: i } } sortDataSource(e, t) { return Vn(t, n => { const { sorter: i, sortOrder: s, defaultSortOrder: a, sortChildrenRecord: o } = n, l = this.isSortOrderValid(s) ? s : a; if (we(i) && l && Te.SORT_DIRECTIONS.includes(l)) { if (o) { const u = this.getProp("childrenRecordName"); e = e && e.map(d => { const h = this._getRecordChildren(d); return Array.isArray(h) && h.length ? Object.assign(Object.assign({}, d), { [u]: this.sortDataSource(h, [n]) }) : d }) } return e.sort(wQ(i, l)), !1 } }), e } filterDataSource(e, t) { let n = null, i = !1; const s = this.getProp("childrenRecordName"); return Vn(t, a => { const { onFilter: o, filteredValue: l, filterChildrenRecord: u, defaultFilteredValue: d } = a, h = Array.isArray(l) ? l : d; typeof o == "function" && Array.isArray(h) && h.length && (i = !0, n === null ? n = new Map : (e = Array.from(n && n.values()), n = new Map), Vn(e, g => { Vn(h, m => { const b = H(g, s), y = this.getRecordKey(g); let w; if (Array.isArray(b) && b.length && u && (w = this.filterDataSource(b, [a])), Array.isArray(w) && w.length) { if (y != null) { const x = H(n.get(y), s, []); n.set(y, Object.assign(Object.assign({}, g), { [s]: w.reduce((S, C) => (S.find(O => this.getRecordKey(O) === this.getRecordKey(C)) == null && S.push(C), S), [...x]) })) } } else o(m, g) && n.set(y, g) }) })) }), i && (e = Array.from(n && n.values())), e } limitPageDataSource(e, t) { e = e ?? this.getProp("dataSource"), t = t ?? this.getState("pagination"); let n = e; const i = H(t, "currentPage"); if (this.getProp("pagination") !== !1 && i && e && t && !this._pagerIsControlled()) { const { pageSize: s = On.DEFAULT_PAGE_SIZE } = t, a = (i - 1) * s, o = i * s; n = Nu(e, a, o) } return n } normalizePagination(e, t) { e = e ?? this._getPagination(), t = t ?? this._getDataSource(); const n = this.getProp("pagination"); if (e && (e = typeof e == "object" ? Object.assign({}, e) : {}, e = gc({ total: t && t.length || 0, pageSize: On.DEFAULT_PAGE_SIZE, currentPage: H(n, "defaultCurrentPage", 1), position: Te.PAGINATION_POSITIONS[0] }, e), !this._pagerIsControlled())) { const i = H(n, "total", t.length), { currentPage: s, pageSize: a } = e, o = Math.ceil(i / a); e.total = i, s > o && (e.currentPage = 1) } return e } setAdapterPageData() { let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}; const { pagination: t, dataSource: n, disabledRowKeys: i, allRowKeys: s, groups: a } = e; this._adapter.setDisabledRowKeys(i), this._adapter.setAllRowKeys(s), this._adapter.setPagination(t), this._adapter.setGroups(a), this._adapter.setDataSource(n) } destroy() { } setAllDisabledRowKeys(e) { this._adapter.setAllDisabledRowKeys(e) } handleClick(e) { } handleMouseEnter(e) { } handleMouseLeave(e) { } stopPropagation(e) { this._adapter.stopPropagation(e) } _addNoDuplicatedItemsToArr() { let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : []; for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), i = 1; i < t; i++)n[i - 1] = arguments[i]; for (const s of n) if (Array.isArray(s)) for (const a of s) e.includes(a) || e.push(a); return e } _notifyChange(e, t, n, i) { e = e ?? this._getPagination(), t = t ?? this._getAllFilters(), n = n ?? this._getAllSorters()[0], H(this.getProp("scroll"), "scrollToFirstRowOnChange") && this._adapter.resetScrollY(), this._adapter.notifyChange({ pagination: Object.assign({}, e), filters: [...t], sorter: n, extra: Object.assign({}, i) }) } _rowExpansionIsControlled() { return Array.isArray(this.getProp("expandedRowKeys")) } _pagerIsControlled() { return H(this.getProp("pagination"), "currentPage") != null } _selectionIsControlled() { return Array.isArray(H(this.getProp("rowSelection"), "selectedRowKeys")) } _sorterIsControlled(e) { const t = e && this.getQuery(e, this.getState("flattenColumns")); return !!(t && t.sortOrder != null) } _filterIsControlled(e) { const t = e && this.getQuery(e, this.getState("flattenColumns")); return !!(t && Array.isArray(t.filteredValue)) } _filterShowIsControlled(e) { const t = e && this.getQuery(e, this.getState("flattenColumns")); return !!(t && (t.filterDropdownVisible === !0 || t.filterDropdownVisible === !1)) } _getSelectedRowKeys() { const e = this.getState("rowSelection"); return [...H(e, "selectedRowKeys", [])] } _getSelectedRowKeysSet() { const e = this.getState("rowSelection"); return H(e, "selectedRowKeysSet", new Set) } _getDataSource() { return this.getProp("dataSource") || [] } _getRecord(e) { return Ui(this.getProp("dataSource"), t => e != null && e !== "" && this.getRecordKey(t) === e) } _getRecordChildren(e) { return H(e, this.getProp("childrenRecordName")) } _getPagination() { return this.getState("pagination") || {} } _getAllFilters(e) { e = e || this.getState("queries"); const t = []; return Vn(e, n => { Array.isArray(n.filteredValue) && (n.filteredValue.length || this._filterIsControlled(n.dataIndex)) && t.push(n) }), t } _getAllSorters(e) { return e = e || this.getState("queries"), ko(e, t => t.sorter && t.sortOrder) } _filterQueries(e, t) { let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : ["dataIndex"]; t = t ?? this.getState("queries"); const i = [], s = []; return Vn(t, (a, o) => { Lu(n, u => u && e[u] != null && e[u] === a[u]) && (i.push(a), s.push(o)) }), { filteredQueries: i, filteredIndexes: s } } _mergeToQueries(e, t) { let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : ["dataIndex"]; t = t ?? this.getState("queries"), t = [...t], e = Object.assign({}, e); const { filteredQueries: i, filteredIndexes: s } = this._filterQueries(e, t, n); return Vn(i, (a, o) => { t[s[o]] = Object.assign({}, e) }), t } getRecordKey(e) { if (!e) return; const t = this.getProp("rowKey"); return typeof t == "function" ? t(e) : H(e, t) } isEmpty(e) { return e = e ?? this.getProp("dataSource"), !(Array.isArray(e) && e.length > 0) } handleSelectRow(e, t, n) { if (this.stopPropagation(n), typeof t == "boolean" && e != null) { const i = this._getSelectedRowKeys(); let s = -1; const a = this.getSelectedRows(null, [e])[0]; let o; (s = i.indexOf(e)) > -1 && t === !1 ? (i.splice(s, 1), o = this.getSelectedRows(null, i), this._selectionIsControlled() || this._adapter.setSelectedRowKeys(i), this._adapter.notifySelect(a, t, o, n), this._adapter.notifySelectionChange(i, o)) : i.indexOf(e) === -1 && t === !0 && (i.push(e), o = this.getSelectedRows(null, i), this._selectionIsControlled() || this._adapter.setSelectedRowKeys(i), this._adapter.notifySelect(a, t, o, n), this._adapter.notifySelectionChange(i, o)) } } handleSelectAllRow(e, t) { if (this.stopPropagation(t), typeof e == "boolean") { const n = this._getSelectedRowKeys(); let i = [...n]; const s = this._getSelectedRowKeysSet(); let a = [...this._adapter.getCachedFilteredSortedRowKeys()]; const o = this._adapter.getAllDisabledRowKeys(), l = this._adapter.getAllDisabledRowKeysSet(); let u; if (e) { for (const g of a) !l.has(g) && !s.has(g) && i.push(g); a = tw(a, [...o, ...n]), u = [...a] } else i = tw(i, a), u = [...n]; const d = this.getSelectedRows(null, u || []), h = this.getSelectedRows(null, i || []); this._selectionIsControlled() || this._adapter.setSelectedRowKeys(i), this._adapter.notifySelectAll(e, h, d, t), this._adapter.notifySelectionChange(i, h) } } getSelectedRows(e, t, n) { e = e ?? this._getDataSource(), t = t ?? this._getSelectedRowKeys(), Ri(n) || (n = new Set(t)); const i = this.getProp("childrenRecordName"), s = []; if (Ri(n) && n.size && Array.isArray(e) && e.length && (s.push(...e.filter(a => n.has(this.getRecordKey(a)))), s.length < t.length)) for (const a of e) { const o = H(a, i); if (Array.isArray(o) && o.length) { const l = this.getSelectedRows(o, t, n); s.push(...l) } } return s } getAllDisabledRowKeys(e, t) { e = e ?? this._getDataSource(), t = t ?? H(this.getProp("rowSelection"), "getCheckboxProps"); const n = this.getProp("childrenRecordName"), i = []; if (Array.isArray(e) && e.length && typeof t == "function") for (const s of e) { const a = t(s); a && a.disabled && i.push(this.getRecordKey(s)); const o = H(s, n); if (Array.isArray(o) && o.length) { const l = this.getAllDisabledRowKeys(o, t); i.push(...l) } } return i } getAllRowKeys(e) { e = e ?? this._getDataSource(); const t = this.getProp("childrenRecordName"), n = []; if (Array.isArray(e) && e.length) for (const i of e) { const s = [], a = H(i, t); Array.isArray(a) && a.length && s.push(...this.getAllRowKeys(a)), n.push(this.getRecordKey(i), ...s) } return n } hasRowSelected(e, t) { return !!(Array.isArray(e) && e.length && Ri(t) && t.size && e.filter(n => t.has(n)).length) } handleRowExpanded(e, t, n) { this.stopPropagation(n); const i = [...this.getState("expandedRowKeys")], s = i.indexOf(t), a = typeof t == "string" || typeof t == "number"; a && e && s === -1 ? i.push(t) : a && !e && s > -1 && i.splice(s, 1), this._rowExpansionIsControlled() || this._adapter.setExpandedRowKeys(i); const o = this.getSelectedRows(null, i); let l = this.getSelectedRows(null, [t])[0]; const u = this._getGroups(); if (u) { u.has(t) && (l = { groupKey: t }); for (let d = 0, h = i.length; d < h; d++)u.has(t) && o.push({ groupKey: i[d] }) } this._adapter.notifyExpand(e, l, n), this._adapter.notifyExpandedRowsChange(o) } _getGroups() { return this._adapter.getProp("groupBy") !== null ? this._adapter.getState("groups") : null } allIsSelected(e, t, n) { const i = ko(n, s => s != null && !t.has(s)); if (i && i.length) { for (const s of i) if (s != null && !e.has(s)) return !1; return !0 } else return n.length && n.every(a => e.has(a)) || !1 } allIsNotSelected(e, t) { for (const n of t) if (n != null && Array.isArray(e) && e.includes(n)) return !0; return !1 } formatPaginationInfo() { let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "", n = ""; const i = H(this.getProp("pagination"), "formatPageText"), { total: s, pageSize: a, currentPage: o } = e, l = Math.min((o - 1) * a + 1, s), u = Math.min(o * a, s); return (i || i !== !1 && t && s > 0) && (n = typeof i == "function" ? i({ currentStart: l, currentEnd: u, total: s }) : t.replace("${currentStart}", l).replace("${currentEnd}", u).replace("${total}", s)), n } toggleShowFilter(e, t) { let n = this.getQuery(e); const i = t; n = Object.assign(Object.assign({}, n), { filterDropdownVisible: i }), this._filterShowIsControlled(), this._adapter.notifyFilterDropdownVisibleChange(i, e) } handleFilterSelect(e) { let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, n = this.getQuery(e), i = [...this._adapter.getState("queries")]; const { filteredValue: s } = t; n = Object.assign(Object.assign({}, n), { filteredValue: s }), i = gO(n, i); const a = this._mergeToQueries(n, null), o = this._getAllFilters(a); this._filterIsControlled(e) || (this._adapter.setQueries(i), this.handleClickFilterOrSorter(i)), this._notifyChange(null, o, void 0, { changeType: "filter" }) } handleSort() { let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, t = arguments.length > 1 ? arguments[1] : void 0; this.stopPropagation(t); const { dataIndex: n } = e; let i = this.getState("queries"), s = null; i = [...i], Vn(i, (a, o, l) => { if (a.sorter) { const u = Object.assign({}, a), d = H(u, "sortOrder"), h = H(u, "defaultSortOrder", !1); let g = this.isSortOrderValid(d) ? d : h; n && n === u.dataIndex ? g === Te.SORT_DIRECTIONS[0] ? g = Te.SORT_DIRECTIONS[1] : g === Te.SORT_DIRECTIONS[1] ? g = !1 : g = Te.SORT_DIRECTIONS[0] : g = !1, l[o] = Object.assign(Object.assign({}, u), { sortOrder: g }), n === u.dataIndex && (s = l[o]) } }), this._sorterIsControlled(n) || (this._adapter.setQueries(i), this.handleClickFilterOrSorter(i)), this._notifyChange(null, null, s, { changeType: "sorter" }) } handleClickFilterOrSorter(e) { const t = [...this.getProp("dataSource")], n = this.getFilteredSortedDataSource(t, e), i = this.getAllDisabledRowKeys(n); this.setCachedFilteredSortedDataSource(n), this.setAllDisabledRowKeys(i); const s = this.getCurrentPageData(n); this.setAdapterPageData(s) } getQuery(e, t) { if (t = t || this.getState("queries"), e != null) return Ui(t, n => n.dataIndex === e) } getCellWidths(e, t, n) { return this._adapter.getCellWidths(e, t, n) } setHeadWidths(e, t) { return this._adapter.setHeadWidths(e, t) } getHeadWidths(e) { return this._adapter.getHeadWidths(e) } mergedRowExpandable(e) { return this._adapter.mergedRowExpandable(e) } setBodyHasScrollbar(e) { this._adapter.setBodyHasScrollbar(e) } } const bO = { align: c.oneOf(Te.ALIGNS), className: c.string, colSpan: c.number, dataIndex: c.string, defaultSortOrder: c.oneOf(Te.SORT_DIRECTIONS), filterChildrenRecord: c.bool, filterDropdownProps: c.object, filterDropdown: c.node, filterDropdownVisible: c.bool, filterIcon: c.func, filterMultiple: c.bool, filteredValue: c.arrayOf(c.any), filters: c.array, fixed: c.oneOf(Te.FIXED_SET), onCell: c.func, onFilter: c.func, onFilterDropdownVisibleChange: c.func, onHeaderCell: c.func, onSorterChange: c.func, render: c.func, renderFilterDropdownItem: c.func, sortChildrenRecord: c.bool, sortDirections: c.arrayOf(c.string), sortOrder: c.oneOfType([c.bool, c.string]), sorter: c.oneOfType([c.bool, c.func]), title: c.oneOfType([c.func, c.node]), useFullRender: c.bool, width: c.oneOfType([c.number, c.string]), showSortTip: c.bool }; class Sh extends f.PureComponent { constructor() { let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}; super(e) } render() { return null } } Sh.propTypes = Object.assign({}, bO); Sh.elementType = "Column"; function md(r) { if (r) { const e = []; return f.Children.forEach(r, t => { if (f.isValidElement(t) && (t.type === Sh || H(t, "type.elementType") === "Column")) { const n = Ht(t.props, ["children"]); Array.isArray(t.props.children) && t.props.children.length && (n.children = md(t.props.children)), e.push(Object.assign({ key: t.key }, n)) } }), e } return [] } const Da = f.createContext({ headWidths: [], setHeadWidths: z, handleRowExpanded: z }), CQ = r => { let { children: e, anyColumnFixed: t, flattenedColumns: n, tableWidth: i, headWidths: s, setHeadWidths: a, getHeadWidths: o, getCellWidths: l, handleRowExpanded: u, renderExpandIcon: d, renderSelection: h, getVirtualizedListRef: g, setBodyHasScrollbar: m, direction: b } = r; const y = R.useMemo(() => ({ anyColumnFixed: t, flattenedColumns: n, renderExpandIcon: d, renderSelection: h, setHeadWidths: a, getHeadWidths: o, getCellWidths: l, headWidths: s, tableWidth: i, handleRowExpanded: u, getVirtualizedListRef: g, setBodyHasScrollbar: m, direction: b }), [t, n, d, h, a, o, l, s, i, u, g, m, b]); return f.createElement(Da.Provider, { value: y }, e) }; class SQ extends ve { handleChange(e) { const t = e.target.checked; this._adapter.notifyChange(t, e) } } class yd extends de { get adapter() { var e = this; return Object.assign(Object.assign({}, super.adapter), { notifyChange: function () { return e.props.onChange(...arguments) } }) } constructor(e) { super(e), this.handleChange = t => this.foundation.handleChange(t), this.foundation = new SQ(this.adapter) } render() { const { selected: e, getCheckboxProps: t, indeterminate: n, disabled: i, prefixCls: s, className: a } = this.props, o = this.props["aria-label"]; let l = { onChange: this.handleChange, disabled: i, indeterminate: n, checked: e }; typeof t == "function" && (l = Object.assign(Object.assign({}, l), t())); const u = F(`${s}-selection-wrap`, { [`${s}-selection-disabled`]: i }, a); return f.createElement("span", { className: u }, f.createElement(bi, Object.assign({ "aria-label": o }, l))) } } yd.propTypes = { columnTitle: c.string, getCheckboxProps: c.func, type: c.string, onChange: c.func, selected: c.bool, disabled: c.bool, indeterminate: c.bool, prefixCls: c.string, className: c.string, "aria-label": c.string }; yd.defaultProps = { disabled: !1, onChange: z, prefixCls: Qn.PREFIX }; class tb extends R.PureComponent { render() { const { pagination: e, prefixCls: t, info: n, renderPagination: i } = this.props, s = H(e, "total"), a = i && we(i) ? i(e) : null; return f.createElement("div", { className: `${t}-pagination-outer` }, R.isValidElement(a) ? a : f.createElement(f.Fragment, null, f.createElement("span", { className: `${t}-pagination-info` }, n), f.createElement("span", { className: `${t}-pagination-wrapper` }, s > 0 ? f.createElement(bh, Object.assign({}, e, { key: H(e, "pageSize", "pagination") })) : null))) } } tb.propTypes = { style: c.object, prefixCls: c.string, pagination: c.object, info: c.oneOfType([c.string, c.node]), renderPagination: c.func }; tb.defaultProps = { prefixCls: Qn.PREFIX }; function vO(r) { let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null, t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0; const { filterMultiple: n = !0, filters: i = [], filteredValue: s = [], filterDropdownVisible: a, onSelect: o = z, onFilterDropdownVisibleChange: l = z, trigger: u = "click", position: d = "bottom", renderFilterDropdown: h, renderFilterDropdownItem: g } = r ?? {}, m = cr(r, ["tempFilteredValue", "setTempFilteredValue", "confirm", "clear", "close", "filters"]), b = typeof h == "function" ? h(m) : f.createElement(Jt.Menu, null, Array.isArray(i) && i.map((w, x) => { const S = k => { const P = k && k.nativeEvent; P && (P.stopImmediatePropagation(), P.stopPropagation(), P.preventDefault()); let N = [...s]; const M = N.includes(w.value), B = N.indexOf(w.value); return B > -1 ? N.splice(B, 1) : n ? N.push(w.value) : N = [w.value], o({ value: w.value, filteredValue: N, included: !M, domEvent: P }) }, C = s.includes(w.value), { text: O } = w, { value: E } = w, v = `${t}_${x}`, T = typeof g == "function" ? g({ onChange: S, filterMultiple: n, value: E, text: O, checked: C, filteredValue: s, level: t }) : null; let I = T && f.isValidElement(T) ? f.cloneElement(T, { key: v }) : f.createElement(Jt.Item, { key: v, onClick: S }, n ? f.createElement(bi, { checked: C }, O) : f.createElement(Bs, { checked: C }, O)); if (Array.isArray(w.children) && w.children.length) { const k = Object.assign(Object.assign({}, r), { filters: w.children, trigger: "hover", position: "right" }); delete k.filterDropdownVisible, I = vO(k, I, t + 1) } return I })), y = Object.assign(Object.assign({}, r), { onVisibleChange: w => l(w), trigger: u, position: d, render: b }); return a != null && (y.visible = a), f.createElement(Jt, Object.assign({}, y, { key: `Dropdown_level_${t}`, className: `${Qn.PREFIX}-column-filter-dropdown` }), e) } function EQ() { let r = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}; const { prefixCls: e = Qn.PREFIX, filteredValue: t, filterIcon: n = "filter", filterDropdownProps: i, onSelect: s, filterDropdownVisible: a, renderFilterDropdown: o, onFilterDropdownVisibleChange: l } = r; let { filterDropdown: u = null } = r; const d = typeof a < "u", g = !d && typeof o == "function", [m, b] = R.useState(t), y = g ? !1 : a, [w, x] = R.useState(y); R.useEffect(() => { typeof a < "u" && x(a) }, [a]), R.useEffect(() => { b(t) }, [t]); const S = function () { let P = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}; const N = (P == null ? void 0 : P.filteredValue) || m; ke(N, t) || s({ filteredValue: N }), P.closeDropdown && x(!1) }, C = function () { let P = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}; b([]), s({ filteredValue: [] }), P.closeDropdown && x(!1) }, O = () => { x(!1) }, E = P => { g && x(P), l(P) }, v = { tempFilteredValue: m, setTempFilteredValue: b, confirm: S, clear: C, close: O }, T = F(`${e}-column-filter`, { on: Array.isArray(t) && t.length }); let I; typeof n == "function" ? I = n(Array.isArray(t) && t.length > 0) : R.isValidElement(n) ? I = n : I = f.createElement("div", { className: T }, "​", f.createElement(fH, { role: "button", "aria-label": "Filter data with this column", "aria-haspopup": "listbox", tabIndex: -1, size: "default" })); const k = Object.assign(Object.assign(Object.assign(Object.assign({}, r), i), v), { filterDropdownVisible: d ? a : w, onFilterDropdownVisibleChange: E }); return u = f.isValidElement(u) ? u : vO(k, I), u } var _Q = Tm, OQ = 4; function TQ(r) { return _Q(r, OQ) } var IQ = TQ; const PQ = _e(IQ); let _p, Op; const nw = { position: "absolute", top: "-9999px", width: "50px", height: "50px" }; function kQ() { let r = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "vertical"; if (typeof document > "u" || typeof window > "u") return 0; const e = r === "vertical"; if (e && _p) return _p; if (!e && Op) return Op; const t = document.createElement("div"); Object.keys(nw).forEach(i => { t.style[i] = nw[i] }), e ? t.style.overflowY = "scroll" : t.style.overflowX = "scroll", document.body.appendChild(t); let n = 0; return e ? (n = t.offsetWidth - t.clientWidth, _p = n) : (n = t.offsetHeight - t.clientHeight, Op = n), document.body.removeChild(t), n } function xO(r) { return typeof r == "number" ? r - On.DEFAULT_CELL_PADDING_LEFT - On.DEFAULT_CELL_PADDING_RIGHT - On.DEFAULT_CELL_BORDER_WIDTH_LEFT - On.DEFAULT_CELL_BORDER_WIDTH_RIGHT - kQ("vertical") : void 0 } function rw(r, e) { return gc({}, { table: "table", header: { outer: "table", wrapper: "thead", row: "tr", cell: "th" }, body: e ? { outer: "div", wrapper: "div", row: "div", cell: "div", colgroup: { wrapper: "div", col: "div" } } : { outer: "table", wrapper: "tbody", row: "tr", cell: "td", colgroup: { wrapper: "colgroup", col: "col" } }, footer: { wrapper: "tfoot", row: "tr", cell: "td" } }, r) } const Dl = new dO("[@douyinfe/semi-ui Table]"); function Ng() { let r = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [], e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [], t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null, n = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : !0; const i = [], s = n ? Hr : PQ; return Gl(e, a => { a = Object.assign({}, a); const o = J0(a, t), l = o != null && Ui(r, u => J0(u, t) === o); l ? i.push(s(Object.assign(Object.assign({}, l), a))) : i.push(s(a)) }), i } function wO(r) { switch (r) { case Te.SORT_DIRECTIONS[0]: return Te.SORT_DIRECTIONS[1]; case Te.SORT_DIRECTIONS[1]: return "cancelSort"; default: return Te.SORT_DIRECTIONS[0] } } class nb extends R.PureComponent { render() { const { prefixCls: e, onClick: t, sortOrder: n, style: i, title: s, sortIcon: a, showTooltip: o } = this.props, l = "default", u = F(`${e}-column-sorter-up`, { on: n === Te.SORT_DIRECTIONS[0] }), d = F(`${e}-column-sorter-down`, { on: n === Te.SORT_DIRECTIONS[1] }), h = { "aria-label": `Current sort order is ${n ? `${n}ing` : "none"}`, "aria-roledescription": "Sort data with this column" }, g = () => { if (typeof a == "function") return a({ sortOrder: n }); { const m = f.createElement("div", { style: i, className: `${e}-column-sorter` }, f.createElement("span", { className: `${u}` }, f.createElement(Rz, { size: l })), f.createElement("span", { className: `${d}` }, f.createElement(Pz, { size: l }))); if (o) { let b = wO(n); return f.createElement(Ke, { componentName: "Table" }, (y, w) => f.createElement(ln, { content: y[b] }, m)) } return m } }; return f.createElement("div", Object.assign({ role: "button" }, h, { tabIndex: -1, className: `${e}-column-sorter-wrapper`, onClick: t, onKeyPress: m => Jn(m) && t(m) }), s, g()) } } nb.propTypes = { className: c.string, style: c.object, onClick: c.func, prefixCls: c.string, sortOrder: c.oneOfType([c.string, c.bool]), sortIcon: c.func, showTooltip: c.bool }; nb.defaultProps = { prefixCls: Qn.PREFIX, onClick: z, sortOrder: !1, showTooltip: !1 }; function rb(r) { const { expanded: e, componentType: t, onClick: n = z, onMouseEnter: i = z, onMouseLeave: s = z, expandIcon: a, prefixCls: o = Qn.PREFIX, motion: l = !0 } = r; let u; f.isValidElement(a) ? u = a : typeof a == "function" ? u = a(e) : t === "tree" ? u = e && !l ? f.createElement(YS, { size: "small" }) : f.createElement(oK, { size: "small" }) : u = e && !l ? f.createElement(os, null) : f.createElement(Ms, null); const d = R.useCallback(h => { typeof n == "function" && n(!e, h) }, [e]); if (l) { const h = u; u = f.createElement(Hi, { animationState: e ? "enter" : "leave", startClassName: `${Qn.PREFIX}-expandedIcon-${e ? "show" : "hide"}` }, g => { let { animationClassName: m } = g; return f.cloneElement(h, { className: (h.props.className || "") + " " + m }) }) } return f.createElement("span", { role: "button", "aria-label": "Expand this row", tabIndex: -1, onClick: d, onMouseEnter: i, onMouseLeave: s, className: `${o}-expand-icon`, onKeyPress: h => Jn(h) && d(h) }, u) } rb.propTypes = { expanded: c.bool, componentType: c.oneOf(["tree", "expand"]), onClick: c.func, onMouseEnter: c.func, onMouseLeave: c.func, expandIcon: c.oneOfType([c.node, c.func]), prefixCls: c.string, motion: c.bool }; rb.defaultProps = { componentType: "expand", onClick: z, onMouseEnter: z, onMouseLeave: z, prefixCls: Qn.PREFIX }; class Eh extends f.PureComponent { render() { const { columns: e, className: t, style: n, prefixCls: i, components: s } = this.props, a = H(s, "colgroup.wrapper", "colgroup"), o = H(s, "colgroup.col", "col"), l = go(e).map((d, h) => { const g = {}; return d.width && (g.width = d.width, g.minWidth = g.width), f.createElement(o, { className: F(`${i}-col`, d.className), key: d.key || d.dataIndex || h, style: g }) }), u = F(`${i}-colgroup`, t); return f.createElement(a, { className: u, style: n }, l) } } Eh.propTypes = { columns: c.array, prefixCls: c.string, className: c.string, style: c.object, components: c.object }; Eh.defaultProps = { columns: [], prefixCls: Qn.PREFIX }; var RQ = function (r, e) { var t = {}; for (var n in r) Object.prototype.hasOwnProperty.call(r, n) && e.indexOf(n) < 0 && (t[n] = r[n]); if (r != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, n = Object.getOwnPropertySymbols(r); i < n.length; i++)e.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(r, n[i]) && (t[n[i]] = r[n[i]]); return t }; class _h extends de { get adapter() { return Object.assign({}, super.adapter) } constructor(e) { super(e), this.cacheRef = t => { if (this.headerNode = t, t && this.context.setHeadWidths) { const { prefixCls: n, row: i, index: s } = this.props, a = `.${n}-row-head`, o = t && t.querySelectorAll && t.querySelectorAll(a); this.context.setHeadWidths(Gl(o, (l, u) => { let d = H(i, [u, "column", "width"]); const h = H(i, [u, "column", "key"]); return typeof d != "number" && (d = l && l.getBoundingClientRect().width || 0), { width: d, key: h } }), s) } }, this.headerNode = null } componentDidUpdate(e) { e.columns !== this.props.columns && this.headerNode && this.cacheRef(this.headerNode) } render() { const { components: e, row: t, prefixCls: n, onHeaderRow: i, index: s, style: a, columns: o } = this.props, { getCellWidths: l, direction: u } = this.context, d = u === "rtl", h = fO(o, s), g = l(h), m = H(e, "header.row", "tr"), b = H(e, "header.cell", "th"), y = i(o, s) || {}; yr(y, "className", F(H(y, "className"), `${n}-row`)); const w = Gl(t, (x, S) => { const { column: C } = x, O = RQ(x, ["column"]), E = typeof C.onHeaderCell == "function" ? C.onHeaderCell(C, S, s) : {}; let v = Object.assign({}, E.style); if (C.align) { const U = yO(C.align, u); v = Object.assign(Object.assign({}, v), { textAlign: U }), E.className = F(E.className, C.className, { [`${n}-align-${U}`]: !!U }) } let T, I, k, P; if (d ? (T = ju(C), I = Mu(C), k = Ag(h, C), P = Dg(h, C)) : (T = Mu(C), I = ju(C), k = Dg(h, C), P = Ag(h, C)), E.className = F(`${n}-row-head`, C.className, E.className, { [`${n}-cell-fixed-left`]: T, [`${n}-cell-fixed-left-last`]: k, [`${n}-cell-fixed-right`]: I, [`${n}-cell-fixed-right-first`]: P, [`${n}-row-head-ellipsis`]: C.ellipsis, [`${n}-row-head-clickSort`]: C.clickToSort }), g.length && h.length) { const U = Ur(h, W => W && W.key != null && W.key === C.key); if (U > -1) { if (Mu(C)) { const W = d ? "right" : "left"; v = Object.assign(Object.assign({}, v), { position: "sticky", [W]: Ro(g, 0, U) }) } else if (ju(C)) { const W = d ? "left" : "right"; v = Object.assign(Object.assign({}, v), { position: "sticky", [W]: Ro(g, U + 1) }) } } } Object.assign(O, { resize: C.resize }); const N = Ht(Object.assign(Object.assign({}, O), E), ["colStart", "colEnd", "hasSubColumns", "parents", "level"]), { rowSpan: M, colSpan: B } = N; if (M === 0 || B === 0) return null; typeof C.clickToSort == "function" && (N.onClick ? N.onClick = U => { N.onClick(U), C.clickToSort(U) } : N.onClick = C.clickToSort); const K = f.createElement(b, Object.assign({ role: "columnheader", "aria-colindex": S + 1 }, N, { style: v, key: C.key || C.dataIndex || S })); if (typeof C.clickToSort == "function" && C.showSortTip === !0) { let U = wO(C.sortOrder); return f.createElement(Ke, { componentName: "Table", key: C.key || C.dataIndex || S }, (W, Z) => f.createElement(ln, { content: W[U] }, K)) } return K }); return f.createElement(m, Object.assign({ role: "row", "aria-rowindex": s + 1 }, y, { style: a, ref: this.cacheRef }), w) } } _h.contextType = Da; _h.propTypes = { components: c.object, row: c.array, prefixCls: c.string, onHeaderRow: c.func, index: c.oneOfType([c.string, c.number]), style: c.object, columns: c.array, fixed: c.oneOfType([c.bool, c.string]), selectedRowKeysSet: c.instanceOf(Set).isRequired }; _h.defaultProps = { onHeaderRow: z, prefixCls: Qn.PREFIX, columns: [], components: { header: { wrapper: "thead", row: "tr", cell: "th" } } }; function DQ(r) { const e = []; function t(i, s) { let a = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [], o = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0, l = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 0; e[o] = e[o] || []; let u = s; return i.map(h => { const g = { key: h.key, className: h.className || "", children: we(h.title) ? h.title() : h.title, column: h, colStart: u, level: l, parents: a }; let m = 1; const b = h.children; b && b.length > 0 && (m = t(b, u, [...a, g], o + 1, l + 1).reduce((x, S) => x + S, 0), g.hasSubColumns = !0), "colSpan" in h && ({ colSpan: m } = h), "rowSpan" in h && (g.rowSpan = h.rowSpan), h.key === Te.DEFAULT_KEY_COLUMN_SCROLLBAR && (g["x-type"] = Te.DEFAULT_KEY_COLUMN_SCROLLBAR), g.colSpan = m, g.colEnd = g.colStart + m - 1, e[o].push(g), u += m; const y = h == null ? void 0 : h.ellipsis; return eb(y) && typeof g.children == "string" && (g.title = g.children), m }) } t(r, 0); const n = e.length; for (let i = 0; i < n; i += 1)e[i].forEach(s => { !("rowSpan" in s) && !s.hasSubColumns && (s.rowSpan = n - i) }); return e } class ib extends de { get adapter() { return Object.assign({}, super.adapter) } render() { const { components: e, columns: t, prefixCls: n, fixed: i, onHeaderRow: s, forwardedRef: a, selectedRowKeysSet: o } = this.props, l = DQ(t), u = e.header.wrapper; return f.createElement(u, { className: `${n}-thead`, ref: a }, l.map((d, h) => f.createElement(_h, { prefixCls: n, key: h, index: h, fixed: i, columns: t, row: d, components: e, onHeaderRow: s, selectedRowKeysSet: o }))) } } ib.propTypes = { components: c.any, columns: c.array, columnManager: c.object, prefixCls: c.string, onHeaderRow: c.func, onDidUpdate: c.func, fixed: c.oneOfType([c.bool, c.string]), selectedRowKeysSet: c.instanceOf(Set).isRequired }; ib.defaultProps = { columns: [], prefixCls: Qn.PREFIX, onHeaderRow: z, onDidUpdate: z, components: { header: { wrapper: "thead", row: "tr", cell: "th" } } }; const CO = f.forwardRef((r, e) => f.createElement(ib, Object.assign({}, r, { forwardedRef: e }))); class sb extends f.PureComponent { constructor() { let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : { selectedRowKeysSet: new Set }; super(e) } render() { const { scroll: e, prefixCls: t, fixed: n, forwardedRef: i, handleBodyScroll: s, columns: a, components: o, onDidUpdate: l, showHeader: u, tableLayout: d, bodyHasScrollBar: h, sticky: g } = this.props, m = H(o, "header.outer", "table"), b = H(e, "x"), y = {}, w = {}; b && !n && (w.width = b), h && (y.overflowY = "scroll"); const x = f.createElement(Eh, { columns: a, prefixCls: t }), S = f.createElement(CO, Object.assign({}, this.props, { columns: a, components: o, onDidUpdate: l })), C = F(`${t}-header`, { [`${t}-header-sticky`]: g, [`${t}-header-hidden`]: !u }), O = H(g, "top", 0); return typeof O == "number" && (y.top = O), f.createElement("div", { key: "headTable", style: y, className: C, ref: i, onScroll: s }, f.createElement(m, { style: w, className: F(t, { [`${t}-fixed`]: d === "fixed" }) }, x, S)) } } sb.propTypes = { tableLayout: c.string, bodyHasScrollBar: c.bool, columns: c.array, components: c.object, dataSource: c.array, fixed: c.oneOfType([c.bool, c.string]), handleBodyScroll: c.func, prefixCls: c.string, forwardedRef: c.oneOfType([c.object, c.func]), scroll: c.shape({ x: c.oneOfType([c.number, c.string, c.bool]), y: c.oneOfType([c.number, c.string]) }), selectedRowKeysSet: c.instanceOf(Set).isRequired, showHeader: c.bool, onDidUpdate: c.func, onHeaderRow: c.func }; sb.defaultProps = { handleBodyScroll: z }; const AQ = f.forwardRef((r, e) => f.createElement(sb, Object.assign({}, r, { forwardedRef: e }))); var NQ = V_, FQ = NQ("length"), $Q = FQ, LQ = "\\ud800-\\udfff", MQ = "\\u0300-\\u036f", jQ = "\\ufe20-\\ufe2f", VQ = "\\u20d0-\\u20ff", BQ = MQ + jQ + VQ, zQ = "\\ufe0e\\ufe0f", HQ = "\\u200d", KQ = RegExp("[" + HQ + LQ + BQ + zQ + "]"); function UQ(r) { return KQ.test(r) } var ab = UQ, SO = "\\ud800-\\udfff", WQ = "\\u0300-\\u036f", GQ = "\\ufe20-\\ufe2f", YQ = "\\u20d0-\\u20ff", XQ = WQ + GQ + YQ, qQ = "\\ufe0e\\ufe0f", ZQ = "[" + SO + "]", Fg = "[" + XQ + "]", $g = "\\ud83c[\\udffb-\\udfff]", JQ = "(?:" + Fg + "|" + $g + ")", EO = "[^" + SO + "]", _O = "(?:\\ud83c[\\udde6-\\uddff]){2}", OO = "[\\ud800-\\udbff][\\udc00-\\udfff]", QQ = "\\u200d", TO = JQ + "?", IO = "[" + qQ + "]?", eee = "(?:" + QQ + "(?:" + [EO, _O, OO].join("|") + ")" + IO + TO + ")*", tee = IO + TO + eee, nee = "(?:" + [EO + Fg + "?", Fg, _O, OO, ZQ].join("|") + ")", iw = RegExp($g + "(?=" + $g + ")|" + nee + tee, "g"); function ree(r) { for (var e = iw.lastIndex = 0; iw.test(r);)++e; return e } var iee = ree, see = $Q, aee = ab, oee = iee; function lee(r) { return aee(r) ? oee(r) : see(r) } var cee = lee, uee = Em, dee = Ho, hee = Ei, pee = ym, fee = cee, gee = "[object Map]", mee = "[object Set]"; function yee(r) { if (r == null) return 0; if (hee(r)) return pee(r) ? fee(r) : r.length; var e = dee(r); return e == gee || e == mee ? r.size : uee(r).length } var bee = yee; const uu = _e(bee); var vee = iy, xee = Jo, wee = Go, Cee = Math.max, See = Math.min; function Eee(r, e, t) { var n = r == null ? 0 : r.length; if (!n) return -1; var i = n - 1; return t !== void 0 && (i = wee(t), i = t < 0 ? Cee(n + i, 0) : See(i, n - 1)), vee(r, xee(e), i, !0) } var _ee = Eee; const Oee = _e(_ee); class Tee extends ve { init() { this.initVirtualizedData(), this.initExpandBtnShouldInRow() } destroy() { this.unobserveBodyResize() } initVirtualizedData(e) { this._adapter.setVirtualizedData(this.flattenData(this.getProp("dataSource")), e) } initExpandBtnShouldInRow(e) { const t = this.getProps(), n = XJ(t); this._adapter.setCachedExpandBtnShouldInRow(n), !an(e) && !e && (e = Te.EXPAND_RELATED_PROPS.map(s => H(t, s, void 0))), this._adapter.setCachedExpandRelatedProps(e) } flattenData() { let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [], t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [], i = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : []; const s = [], { rowKey: a, childrenRecordName: o, expandedRowRender: l, expandedRowKeys: u, groups: d } = this.getProps(); return t === 0 && Vl(d) ? d.forEach((h, g) => { const m = e.findIndex(b => h.has(Rs(b, a))); if (m > -1) { const b = Oee(e, w => h.has(Rs(w, a))), y = $i(u, g); s.push({ key: g, level: t, sectionRow: !0, group: h, groupKey: g, expanded: y }), y && s.push(...this.flattenData(e.slice(m, b + 1), t + 1, [...n], [...i])) } }) : e.forEach((h, g) => { const m = Rs(h, a), b = GJ(h, o); t && i.push(m); const y = { key: m, record: h, level: t, parentKeys: [...n], childrenKeys: [...i] }; s.push(y); const w = []; $i(u, m) && (Array.isArray(b) && b.length ? w.push(...this.flattenData(b, t + 1, [...y.parentKeys], [...y.childrenKeys])) : l && w.push({ key: pO(m), level: t, expandedRow: !0, record: h }), s.push(...w)) }), s } observeBodyResize(e) { const { scroll: t } = this.getProps(); if (H(t, "y")) return this._adapter.observeBodyResize(e) } unobserveBodyResize() { return this._adapter.unobserveBodyResize() } } function Iee() { return !0 } var Pee = Iee; const kee = _e(Pee); function Ree(r, e) { if (r === e) return !0; if (!r || !e) return !1; const t = Object.keys(r), n = Object.keys(e), i = t.length; if (n.length !== i) return !1; for (let s = 0; s < i; s++) { const a = t[s]; if (r[a] !== e[a] || !Object.prototype.hasOwnProperty.call(e, a)) return !1 } return !0 } class Dee extends ve { handleClick(e) { const { expanded: t, rowKey: n } = this.getProps(); this._adapter.notifyClick(n, e, t) } handleDoubleClick(e) { this._adapter.notifyDoubleClick(this.getProp("record"), e) } handleMouseEnter(e) { const t = this.getProp("record"); this._adapter.notifyMouseEnter(t, e) } handleMouseLeave(e) { const t = this.getProp("record"); this._adapter.notifyMouseLeave(t, e) } } class Aee extends ve { handleClick(e) { this._adapter.notifyClick(this.getProp("record"), e) } } function sw(r) { return r && !f.isValidElement(r) && Object.prototype.toString.call(r) === "[object Object]" } class ec extends de { get adapter() { var e = this; return Object.assign(Object.assign({}, super.adapter), { notifyClick: function () { const { onClick: t } = e.props; typeof t == "function" && t(...arguments) } }) } constructor(e) { super(e), this.setRef = t => this.ref = t, this.handleClick = t => { this.foundation.handleClick(t); const n = this.adapter.getCache("customCellProps"); n && typeof n.onClick == "function" && n.onClick(t) }, this.ref = R.createRef(), this.foundation = new Aee(this.adapter) } shouldComponentUpdate(e) { const t = this.props, { column: n, expandIcon: i } = t, s = KJ(n), { shouldCellUpdate: a } = n; if (typeof a == "function") return a(e, t); const o = hO(n) || i; if ((s || o) && !ke(e, this.props)) return !0; { const l = ["selected", "expanded", "expandIcon", "disabled"], u = Ht(t, l), d = Ht(e, l); if (!ke(d, u)) return !0 } return !1 } componentDidUpdate() { this.props.onDidUpdate(this.ref) } getTdProps() { const { record: e, index: t, column: n = {}, fixedLeft: i, fixedRight: s, width: a, height: o } = this.props; let l = {}, u = {}; const { direction: d } = this.context, h = d === "rtl"; if (i || typeof i == "number" ? yr(l, h ? "style.right" : "style.left", typeof i == "number" ? i : 0) : (s || typeof s == "number") && yr(l, h ? "style.left" : "style.right", typeof s == "number" ? s : 0), a != null && yr(l, "style.width", a), o != null && yr(l, "style.height", o), n.onCell) { u = n.onCell(e, t), this.adapter.setCache("customCellProps", Object.assign({}, u)), l = Object.assign(Object.assign({}, l), Ht(u, ["style", "className", "onClick"])); const b = H(u, "style") || {}; l.style = Object.assign(Object.assign({}, l.style), b) } if (n.align) { const b = yO(n.align, d), y = QJ(n.align, d); l.style = Object.assign(Object.assign({}, l.style), { textAlign: b, justifyContent: y }) } return { tdProps: l, customCellProps: u } } renderText(e) { const { record: t, indentSize: n, prefixCls: i, indent: s, index: a, expandIcon: o, renderExpandIcon: l, column: u = {} } = this.props, { dataIndex: d, render: h, useFullRender: g } = u; let m, b, y; typeof d == "number" ? m = H(t, d) : !d || d.length === 0 ? m = t : m = H(t, d); const w = s && n ? f.createElement("span", { style: { paddingLeft: `${n * s}px` }, className: `${i}-row-indent indent-level-${s}` }) : null, x = typeof l == "function" ? l(t) : o; if (h) { const S = { expandIcon: x }; if (g) { const { renderSelection: C } = this.context, O = typeof C == "function" ? C(t) : null; Object.assign(S, { selection: O, indentText: w }) } m = h(m, t, a, S), sw(m) && (e = m.props ? gc(e, m.props) : e, b = e.colSpan, y = e.rowSpan, m = m.children) } return { text: m, indentText: w, rowSpan: y, colSpan: b, realExpandIcon: x, tdProps: e } } renderInner(e, t, n) { const { prefixCls: i, isSection: s, expandIcon: a, column: o = {} } = this.props, { tableWidth: l, anyColumnFixed: u } = this.context, { useFullRender: d } = o; let h = null; return d ? h = e : h = [f.createElement(R.Fragment, { key: "indentText" }, t), f.createElement(R.Fragment, { key: "expandIcon" }, a ? n : null), f.createElement(R.Fragment, { key: "text" }, e)], s && (h = f.createElement("div", { className: F(`${i}-section-inner`), style: { width: u ? xO(l) : void 0 } }, h)), h } render() { const { prefixCls: e, column: t = {}, component: n, fixedLeft: i, fixedRight: s, lastFixedLeft: a, firstFixedRight: o, colIndex: l } = this.props, { direction: u } = this.context, d = u === "rtl", { className: h, ellipsis: g } = t, m = i || typeof i == "number", b = s || typeof s == "number", { tdProps: y, customCellProps: w } = this.getTdProps(), x = this.renderText(y); let { text: S } = x; const { indentText: C, rowSpan: O, colSpan: E, realExpandIcon: v, tdProps: T } = x; let I; if (eb(g) && typeof S == "string" && (I = S), O === 0 || E === 0) return null; sw(S) && (S = null); const P = this.renderInner(S, C, v); let N, M, B, K; d ? (N = b, M = o, B = m, K = a) : (N = m, M = a, B = b, K = o); const U = F(h, `${e}-row-cell`, H(w, "className"), { [`${e}-cell-fixed-left`]: N, [`${e}-cell-fixed-left-last`]: M, [`${e}-cell-fixed-right`]: B, [`${e}-cell-fixed-right-first`]: K, [`${e}-row-cell-ellipsis`]: g }); return f.createElement(n, Object.assign({ role: "gridcell", "aria-colindex": l + 1, className: U, onClick: this.handleClick, title: I }, T, { ref: this.setRef }), P) } } ec.contextType = Da; ec.defaultProps = { indent: 0, indentSize: On.DEFAULT_INDENT_WIDTH, onClick: z, prefixCls: Qn.PREFIX, component: "td", onDidUpdate: z, column: {} }; ec.propTypes = { record: c.object, prefixCls: c.string, index: c.number, fixedLeft: c.oneOfType([c.bool, c.number]), lastFixedLeft: c.bool, fixedRight: c.oneOfType([c.bool, c.number]), firstFixedRight: c.bool, indent: c.number, indentSize: c.number, column: c.object, expandIcon: c.any, renderExpandIcon: c.func, hideExpandedColumn: c.bool, component: c.any, onClick: c.func, onDidUpdate: c.func, isSection: c.bool, width: c.oneOfType([c.string, c.number]), height: c.oneOfType([c.string, c.number]), selected: c.bool, expanded: c.bool, colIndex: c.number }; var aw = function (r, e) { var t = {}; for (var n in r) Object.prototype.hasOwnProperty.call(r, n) && e.indexOf(n) < 0 && (t[n] = r[n]); if (r != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, n = Object.getOwnPropertySymbols(r); i < n.length; i++)e.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(r, n[i]) && (t[n[i]] = r[n[i]]); return t }; const PO = { anyColumnFixed: c.bool, cellWidths: c.array.isRequired, className: c.string, columns: c.array.isRequired, components: c.object.isRequired, disabled: c.bool, expandIcon: c.oneOfType([c.bool, c.func, c.node]), expandableRow: c.bool, expanded: c.bool, displayNone: c.bool, expandedRow: c.bool, fixed: c.oneOfType([c.string, c.bool]), height: c.oneOfType([c.string, c.number]), hideExpandedColumn: c.bool, hovered: c.bool.isRequired, indent: c.number, indentSize: c.number, index: c.number, isSection: c.bool, level: c.number, onDidUpdate: c.func, onHover: c.func, onRow: c.func, onRowClick: c.func, onRowContextMenu: c.func, onRowDoubleClick: c.func, onRowMouseEnter: c.func, onRowMouseLeave: c.func, prefixCls: c.string, record: c.object, renderExpandIcon: c.func, replaceClassName: c.string, rowExpandable: c.func, rowKey: c.oneOfType([c.string, c.number]).isRequired, selected: c.bool, store: c.object, style: c.object, virtualized: c.oneOfType([c.object, c.bool]), visible: c.bool.isRequired }; class Mc extends de { get adapter() { var e = this; return Object.assign(Object.assign({}, super.adapter), { notifyClick: function () { return e.props.onRowClick(...arguments) }, notifyDoubleClick: function () { return e.props.onRowDoubleClick(...arguments) }, notifyMouseLeave: function () { e.props.onHover(!1, e.props.rowKey), e.props.onRowMouseEnter(...arguments) }, notifyMouseEnter: function () { e.props.onHover(!0, e.props.rowKey), e.props.onRowMouseEnter(...arguments) } }) } constructor(e) { super(e), this.renderExpandIcon = t => { const { renderExpandIcon: n } = this.props; return n(t, !0) }, this.handleMouseEnter = t => { this.foundation.handleMouseEnter(t); const n = this.adapter.getCache("customRowProps"); typeof (n == null ? void 0 : n.onMouseEnter) == "function" && n.onMouseEnter(t) }, this.handleMouseLeave = t => { this.foundation.handleMouseLeave(t); const n = this.adapter.getCache("customRowProps"); typeof (n == null ? void 0 : n.onMouseLeave) == "function" && n.onMouseLeave(t) }, this.handleClick = t => { this.foundation.handleClick(t); const n = this.adapter.getCache("customRowProps"); n && typeof n.onClick == "function" && n.onClick(t) }, this.foundation = new Dee(this.adapter) } componentDidMount() { const { onRow: e, index: t, record: n } = this.props; if (typeof this.adapter.getCache("customRowProps") > "u") { const s = e(n, t) || {}, a = aw(s, ["className", "style"]); this.adapter.setCache("customRowProps", Object.assign({}, a)) } } shouldComponentUpdate(e) { const t = ["cellWidths"]; return !Ree(Ht(e, t), Ht(this.props, t)) || !ke(cr(e, t), cr(this.props, t)) } renderCells() { const { columns: e, record: t, index: n, prefixCls: i, fixed: s, components: a, expandableRow: o, level: l, expandIcon: u, rowExpandable: d, isSection: h, expandedRow: g, virtualized: m, indentSize: b, hideExpandedColumn: y, cellWidths: w, selected: x, expanded: S, disabled: C, onDidUpdate: O } = this.props, E = H(a, "body.cell", Te.DEFAULT_COMPONENTS.body.cell), v = [], T = d(t); let I = 0; return Vn(e, (k, P) => { const N = H(k, "key"), M = {}; if (s !== "right" && (zJ(N) && I++, o && P === I && (M.renderExpandIcon = this.renderExpandIcon, (y || h) && (M.expandIcon = u ?? !0)), l != null && P === I && (M.indent = l, !o && y && (u !== !1 || !(typeof u == "boolean") && u !== null) && (M.indent = l + 1))), hO(k) && !T) v.push(f.createElement(ec, { key: P, colIndex: P, isSection: h })); else if (!HJ(k)) { const B = {}; E !== Te.DEFAULT_COMPONENTS.body.cell && m && !g && (B.width = H(w, P)), v.push(f.createElement(ec, Object.assign({ colIndex: P }, M, B, { hideExpandedColumn: y, indentSize: b, isSection: h, prefixCls: `${i}`, column: k, key: P, index: n, record: t, component: E, fixedLeft: Mu(k) && Ro(w, 0, P), lastFixedLeft: Dg(e, k), fixedRight: ju(k) && Ro(w, P + 1), firstFixedRight: Ag(e, k), selected: x, expanded: S, disabled: C, onDidUpdate: O }))) } }), v } render() { const { style: e } = this.props, { components: t, prefixCls: n, selected: i, onRow: s, index: a, className: o, replaceClassName: l, record: u, hovered: d, expanded: h, displayNone: g, expandableRow: m, level: b, expandedRow: y, isSection: w, rowKey: x } = this.props, S = t.body.row, C = s(u, a) || {}, { className: O, style: E } = C, v = aw(C, ["className", "style"]); this.adapter.setCache("customRowProps", Object.assign({}, v)); const T = Object.assign(Object.assign({}, e), E), I = typeof l == "string" && l.length ? F(l, O) : F(o, `${n}-row`, { [`${n}-row-selected`]: i, [`${n}-row-expanded`]: h, [`${n}-row-hovered`]: d, [`${n}-row-hidden`]: g }, O), k = {}; return typeof a == "number" && (k["aria-rowindex"] = a + 1), m && (k["aria-expanded"] = h), (h || y) && (k["aria-level"] = 2), typeof b == "number" && (k["aria-level"] = b + 1), w && (k["aria-level"] = 1), f.createElement(S, Object.assign({ role: "row" }, k, v, { style: T, className: I, "data-row-key": x, onMouseEnter: this.handleMouseEnter, onMouseLeave: this.handleMouseLeave, onClick: this.handleClick }), this.renderCells()) } } Mc.propTypes = PO; Mc.defaultProps = { columns: [], rowExpandable: kee, components: { body: { row: "tr", cell: "td" } }, prefixCls: Qn.PREFIX, onRow: z, onRowClick: z, onRowDoubleClick: z, onRowMouseEnter: z, onRowMouseLeave: z, onHover: z, onDidUpdate: z, visible: !0, hovered: !1, selected: !1, disabled: !1 }; var Nee = function (r, e) { var t = {}; for (var n in r) Object.prototype.hasOwnProperty.call(r, n) && e.indexOf(n) < 0 && (t[n] = r[n]); if (r != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, n = Object.getOwnPropertySymbols(r); i < n.length; i++)e.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(r, n[i]) && (t[n[i]] = r[n[i]]); return t }; class Oh extends R.PureComponent { render() { const { record: e, columns: t = [], prefixCls: n, className: i, expanded: s, expandedRowRender: a, renderExpandIcon: o, index: l, store: u, components: d, style: h, virtualized: g, indentSize: m, cellWidths: b, displayNone: y } = this.props, { tableWidth: w, anyColumnFixed: x, getCellWidths: S } = this.context, C = a(e, l, s); let O = null; const E = {}; let v = {}; if (ss(C)) return null; if (R.isValidElement(C)) O = C; else if (C && Object.prototype.toString.call(C) === "[object Object]") { const P = C, { children: N, fixed: M } = P, B = Nee(P, ["children", "fixed"]); O = N, v = Object.assign({}, B) } H(d, "body.cell") !== Te.DEFAULT_COMPONENTS.body.cell ? (g && yr(E, "style.height", "100%"), yr(E, "style.display", "block"), yr(E, "style.width", Ro(b, 0, t.length))) : E.colSpan = Qy(t).length; const T = [Object.assign({ render: () => ({ props: E, children: f.createElement("div", { className: F(`${n}-expand-inner`), style: { width: x ? xO(w) : void 0 } }, O) }) }, v)], I = F(i, `${n}-row-expand`), k = S(T); return f.createElement(Mc, { style: h, components: d, className: I, expandedRow: !0, renderExpandIcon: o, rowKey: `${e.key}-expanded-row`, columns: T, store: u, virtualized: g, indentSize: m, cellWidths: k, displayNone: y }) } } Oh.contextType = Da; Oh.propTypes = { cellWidths: c.array.isRequired, className: c.string, columns: c.array, components: c.object, defaultExpandAllRows: c.bool, defaultExpandedRowKeys: c.array, expandIcon: c.oneOfType([c.object, c.node, c.func]), expandRowByClick: c.bool, expanded: c.bool, expandedRowKeys: c.array, expandedRowRender: c.func, indentSize: c.number, index: c.oneOfType([c.string, c.number]), onExpand: c.func, onExpandedRowsChange: c.func, prefixCls: c.string, record: c.object, renderExpandIcon: c.func, store: c.object, style: c.object, virtualized: c.oneOfType([c.bool, c.object]) }; Oh.defaultProps = { record: {}, prefixCls: Qn.PREFIX }; var Fee = function (r, e) { var t = {}; for (var n in r) Object.prototype.hasOwnProperty.call(r, n) && e.indexOf(n) < 0 && (t[n] = r[n]); if (r != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, n = Object.getOwnPropertySymbols(r); i < n.length; i++)e.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(r, n[i]) && (t[n[i]] = r[n[i]]); return t }; const kO = { record: c.object, index: c.number, columns: c.array, group: c.object.isRequired, groupKey: c.oneOfType([c.string, c.number]).isRequired, data: c.array, renderGroupSection: c.func, onGroupedRow: c.func, clickGroupedRowToExpand: c.bool, components: c.object, expanded: c.bool, prefixCls: c.string, onExpand: c.func, virtualized: c.oneOfType([c.bool, c.object]), style: c.object, renderExpandIcon: c.func, className: c.string, store: c.object, rowKey: c.oneOfType([c.string, c.number, c.func]) }; class Th extends R.PureComponent { constructor() { var e; super(...arguments), e = this, this.onRow = function () { const { onGroupedRow: t, clickGroupedRowToExpand: n, onExpand: i, groupKey: s, expanded: a } = e.props, o = {}; return typeof t == "function" && Object.assign(o, t(...arguments)), Object.assign(Object.assign({}, o), { onClick: l => { typeof i == "function" && n && i(!a, s, l), typeof o.onClick == "function" && o.onClick(l) } }) }, this.collectGroupedData = () => { const { data: t, group: n, rowKey: i } = this.props; return Array.isArray(t) && t.length && Ri(n) ? t.filter(s => { const a = typeof i == "function" ? i(s) : H(s, i); return a != null && a !== "" && n.has(a) }) : [] }, this.renderExpandIcon = t => { const { renderExpandIcon: n, groupKey: i } = this.props; return typeof n == "function" ? n(t, !1, i) : null } } isInnerColumnKey(e) { return e != null ? [Te.DEFAULT_KEY_COLUMN_EXPAND, Te.DEFAULT_KEY_COLUMN_SELECTION].includes(e) : !1 } render() { const { record: e, columns: t = [], prefixCls: n, className: i, expanded: s, renderGroupSection: a, components: o, index: l, store: u, group: d, groupKey: h, virtualized: g, style: m } = this.props, b = {}; let y = {}, w = null; const x = typeof a == "function" ? a(h, [...d]) : null; if (R.isValidElement(x)) w = x; else if (x && Object.prototype.toString.call(x) === "[object Object]") { const v = x, { children: T } = v, I = Fee(v, ["children"]); w = T, y = Object.assign({}, I) } b.colSpan = Qy(t).length; const S = [Object.assign({ render: () => ({ props: b, children: w }) }, y)], C = F(i, `${n}-row-section`, { on: s }), { getCellWidths: O } = this.context, E = O(S, null, !0); return f.createElement(Mc, { components: o, virtualized: g, index: l, onRow: this.onRow, expanded: s, expandIcon: !0, isSection: !0, record: e, replaceClassName: C, expandableRow: !0, renderExpandIcon: this.renderExpandIcon, rowKey: h, columns: S, store: u, style: m, cellWidths: E }) } } Th.contextType = Da; Th.propTypes = kO; Th.defaultProps = { prefixCls: Qn.PREFIX, components: { body: { row: "tr", cell: "td" } } }; var ow = function (r, e) { var t = {}; for (var n in r) Object.prototype.hasOwnProperty.call(r, n) && e.indexOf(n) < 0 && (t[n] = r[n]); if (r != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, n = Object.getOwnPropertySymbols(r); i < n.length; i++)e.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(r, n[i]) && (t[n[i]] = r[n[i]]); return t }; class ob extends de { constructor(e, t) { var n; super(e), n = this, this.forwardRef = a => { const { forwardedRef: o } = this.props; this.ref.current = a, this.foundation.observeBodyResize(a), typeof o == "function" ? o(a) : o && typeof o == "object" && (o.current = a) }, this.setListRef = a => { this.listRef.current = a; const { getVirtualizedListRef: o } = this.context; o && (this.props.virtualized ? o(this.listRef) : console.warn("getVirtualizedListRef only works with virtualized. See https://semi.design/en-US/show/table for more information.")) }, this.itemSize = a => { const { virtualized: o, size: l } = this.props, { virtualizedData: u } = this.state, d = H(u, a), h = YJ(l, d.sectionRow), g = H(o, "itemSize", h.height); let m = g; return typeof g == "function" && (m = g(a, { expandedRow: H(d, "expandedRow", !1), sectionRow: H(d, "sectionRow", !1) })), m < h.minHeight && Dl.warn(`The computed real \`itemSize\` cannot be less than ${h.minHeight}`), m }, this.itemKey = (a, o) => H(o, [a, "key"], a), this.handleRowClick = (a, o, l) => { const { handleRowExpanded: u } = this.context; u(!l, a, o) }, this.handleVirtualizedScroll = function () { let a = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}; const o = H(n.props.virtualized, "onScroll"); typeof o == "function" && o(a) }, this.handleVirtualizedBodyScroll = a => { const { handleBodyScroll: o } = this.props, l = H(a, "nativeEvent.target.scrollLeft"), u = H(a, "nativeEvent.target.scrollTop"); u === this.state.cache.virtualizedScrollTop && this.handleVirtualizedScroll({ horizontalScrolling: !0 }), this.state.cache.virtualizedScrollLeft = l, this.state.cache.virtualizedScrollTop = u, typeof o == "function" && o(a) }, this.getVirtualizedRowWidth = () => { const { getCellWidths: a } = this.context, { columns: o } = this.props, l = a(o); return Ro(l, 0, uu(o)) }, this.renderVirtualizedRow = a => { const { index: o, style: l } = a, { virtualizedData: u, cachedExpandBtnShouldInRow: d } = this.state, { flattenedColumns: h } = this.context, g = H(u, [o], {}), { key: m, parentKeys: b, expandedRow: y, sectionRow: w } = g, x = ow(g, ["key", "parentKeys", "expandedRow", "sectionRow"]), S = this.getVirtualizedRowWidth(), C = d, O = Object.assign(Object.assign(Object.assign(Object.assign({}, this.props), { style: Object.assign(Object.assign({}, l), { width: S }) }), x), { columns: h, index: o, expandBtnShouldInRow: C }); return w ? this.renderSectionRow(O) : y ? this.renderExpandedRow(O) : this.renderBaseRow(O) }, this.renderTbody = f.forwardRef(function () { let a = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, o = arguments.length > 1 ? arguments[1] : void 0; return f.createElement("div", Object.assign({}, a, { onScroll: function () { a.onScroll && a.onScroll(...arguments) }, className: F(a.className, `${n.props.prefixCls}-tbody`), style: Object.assign({}, a.style), ref: o })) }), this.renderOuter = f.forwardRef((a, o) => { const { children: l } = a, u = ow(a, ["children"]), { handleWheel: d, prefixCls: h, emptySlot: g, dataSource: m } = this.props, b = this.getVirtualizedRowWidth(), y = F(`${h}`, `${h}-fixed`); return f.createElement("div", Object.assign({}, u, { ref: o, onWheel: function () { d && d(...arguments), u.onWheel && u.onWheel(...arguments) }, onScroll: function () { n.handleVirtualizedBodyScroll(...arguments), u.onScroll && u.onScroll(...arguments) } }), f.createElement("div", { style: { width: b }, className: y }, l), uu(m) === 0 && g) }), this.onItemsRendered = a => { this.state.cache.virtualizedScrollLeft && this.ref.current && (this.ref.current.scrollLeft = this.state.cache.virtualizedScrollLeft) }, this.renderVirtualizedBody = a => { const { scroll: o, prefixCls: l, virtualized: u, columns: d } = this.props, { virtualizedData: h } = this.state, { getCellWidths: g } = this.context, m = g(d); if (!uu(m)) return null; const b = H(o, "y"), y = typeof b == "number", w = y ? b : 600; y || Dl.warn('You have to specific "scroll.y" which must be a number for table virtualization!'); const x = { width: "100%", height: h != null && h.length ? w : null, overflowX: "auto", overflowY: "auto" }, S = F(`${l}-body`); return f.createElement(E9, Object.assign({}, typeof u == "object" ? u : {}, { initialScrollOffset: this.state.cache.virtualizedScrollTop, onScroll: this.handleVirtualizedScroll, onItemsRendered: this.onItemsRendered, ref: this.setListRef, className: S, outerRef: this.forwardRef, height: h != null && h.length ? w : 0, width: x.width, itemData: h, itemSize: this.itemSize, itemCount: h.length, itemKey: this.itemKey, innerElementType: this.renderTbody, outerElementType: this.renderOuter, style: Object.assign(Object.assign({}, x), { direction: a }), direction: a }), this.renderVirtualizedRow) }, this.renderSectionRow = function () { let a = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : { groupKey: void 0 }; const { dataSource: o, rowKey: l, group: u, groupKey: d, index: h } = a, g = Object.keys(kO), m = cr(a, g), { handleRowExpanded: b } = n.context; return f.createElement(Th, Object.assign({}, m, { record: { groupKey: d, records: [...u].map(y => Q0(o, y, l)) }, index: h, onExpand: b, data: o, key: d || h })) }, this.renderExpandedRow = function () { let a = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : { renderExpandIcon: () => null }; const { style: o, components: l, renderExpandIcon: u, expandedRowRender: d, record: h, columns: g, expanded: m, index: b, rowKey: y, virtualized: w, displayNone: x } = a; let S = Rs(h, y); S == null && (S = b); const { flattenedColumns: C, getCellWidths: O } = n.context; return C !== n.flattenedColumns && (n.flattenedColumns = C, n.cellWidths = O(C)), f.createElement(Oh, { style: o, components: l, renderExpandIcon: u, expandedRowRender: d, record: h, columns: g, expanded: m, index: b, virtualized: w, key: pO(S), cellWidths: n.cellWidths, displayNone: x }) }, this.renderGroupedRows = () => { const { groups: a, dataSource: o, rowKey: l, expandedRowKeys: u, keepDOM: d } = this.props, { flattenedColumns: h } = this.context, g = new Map, m = []; a != null && Array.isArray(o) && o.length && o.forEach(y => { const w = Rs(y, l); a.forEach((x, S) => { if (x.has(w)) return g.has(S) || g.set(S, new Set([])), g.get(S).add(w), !1 }) }); let b = -1; return g.forEach((y, w) => { const x = Ep(u, w); if (m.push(this.renderSectionRow(Object.assign(Object.assign({}, this.props), { columns: h, index: ++b, group: y, groupKey: w, expanded: x }))), x || d) { const S = []; y.forEach(C => { const O = Q0(o, C, l); O != null && S.push(O) }), m.push(this.renderBodyRows(S, void 0, [], !x)) } }), m }, this.renderBody = a => { const { scroll: o, prefixCls: l, columns: u, components: d, fixed: h, handleWheel: g, headerRef: m, handleBodyScroll: b, anyColumnFixed: y, showHeader: w, emptySlot: x, includeHeader: S, dataSource: C, onScroll: O, groups: E, expandedRowRender: v, tableLayout: T } = this.props, I = H(o, "x"), k = H(o, "y"), P = {}, N = {}, M = H(d, "body.outer", "table"), B = H(d, "body.wrapper") || "tbody"; k && (P.maxHeight = k), I && (N.width = I), y && uu(C) && (P.overflow = "auto", P.WebkitTransform = "translate3d (0, 0, 0)"); const K = f.createElement(Eh, { components: H(d, "body"), columns: u, prefixCls: l }), U = `${l}-body`, W = f.createElement("div", { key: "bodyTable", className: U, style: P, ref: this.forwardRef, onWheel: g, onScroll: b }, f.createElement(M, { role: Vl(E) || we(v) || JJ({ dataSource: C }) ? "treegrid" : "grid", "aria-rowcount": C && C.length, "aria-colcount": u && u.length, style: N, className: F(l, { [`${l}-fixed`]: T === "fixed" }) }, K, S && w ? f.createElement(CO, Object.assign({}, this.props, { ref: m, components: d, columns: u })) : null, f.createElement(B, { className: `${l}-tbody`, onScroll: O }, Vl(E) ? this.renderGroupedRows() : this.renderBodyRows(C))), x); return h && u.length ? f.createElement("div", { key: "bodyTable", className: `${l}-body-outer` }, W) : W }, this.ref = f.createRef(), this.state = { virtualizedData: [], cache: { virtualizedScrollTop: null, virtualizedScrollLeft: null }, cachedExpandBtnShouldInRow: null, cachedExpandRelatedProps: [] }, this.listRef = f.createRef(); const { flattenedColumns: i, getCellWidths: s } = t; this.foundation = new Tee(this.adapter), this.flattenedColumns = i, this.cellWidths = s(i), this.observer = null } get adapter() { return Object.assign(Object.assign({}, super.adapter), { setVirtualizedData: (e, t) => this.setState({ virtualizedData: e }, t), setCachedExpandBtnShouldInRow: e => this.setState({ cachedExpandBtnShouldInRow: e }), setCachedExpandRelatedProps: e => this.setState({ cachedExpandRelatedProps: e }), observeBodyResize: e => { const { setBodyHasScrollbar: t } = this.context, n = () => { const i = () => { const { offsetWidth: a, clientWidth: o } = e, l = o < a; t(l) }; (window.requestAnimationFrame || window.setTimeout)(i) }; e && (H(window, "ResizeObserver") ? (this.observer && (this.observer.unobserve(e), this.observer = null), this.observer = new ResizeObserver(n), this.observer.observe(e)) : Dl.warn("The current browser does not support ResizeObserver,and the table may be misaligned after plugging and unplugging the mouse and keyboard.You can try to refresh it.")) }, unobserveBodyResize: () => { const e = this.ref.current; this.observer && (this.observer.unobserve(e), this.observer = null) } }) } componentDidUpdate(e, t) { const { virtualized: n, dataSource: i, expandedRowKeys: s, columns: a, scroll: o } = this.props; n && (e.dataSource !== i || e.expandedRowKeys !== s || e.columns !== a) && this.foundation.initVirtualizedData(); const u = Te.EXPAND_RELATED_PROPS.map(g => H(this.props, g, void 0)); ke(u, t.cachedExpandRelatedProps) || this.foundation.initExpandBtnShouldInRow(u); const d = H(o, "y"), h = this.ref.current; d && d !== H(e, "scroll.y") && this.foundation.observeBodyResize(h) } renderBaseRow() { let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}; const { rowKey: t, columns: n, expandedRowKeys: i, rowExpandable: s, record: a, index: o, level: l, expandBtnShouldInRow: u, selectedRowKeysSet: d, disabledRowKeysSet: h, expandRowByClick: g } = e, m = Object.keys(PO), b = cr(e, m); let y = Rs(a, t); y == null && (y = o); const w = Ep(i, y), x = s && s(a), S = { level: void 0, expanded: w }; (x || u) && (S.level = l, S.expandableRow = x, g && (S.onRowClick = this.handleRowClick)); const C = { selected: UJ(d, y), disabled: WJ(h, y) }, { getCellWidths: O } = this.context, E = O(n, null, !0); return f.createElement(Mc, Object.assign({}, b, S, C, { key: y, rowKey: y, cellWidths: E })) } renderBodyRows() { let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [], t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [], i = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : !1; const { rowKey: s, expandedRowRender: a, expandedRowKeys: o, childrenRecordName: l, rowExpandable: u, keepDOM: d } = this.props, h = typeof a == "function", g = this.state.cachedExpandBtnShouldInRow, { flattenedColumns: m } = this.context; return Vn(e, (b, y) => { let w = Rs(b, s); w == null && (w = y); const x = H(b, l), S = !!(Array.isArray(x) && x.length); n.push(this.renderBaseRow(Object.assign(Object.assign({}, this.props), { columns: m, expandBtnShouldInRow: g, displayNone: i, record: b, key: w, level: t, index: y }))); const C = Ep(o, w), O = C || d; if (h && u && u(b) && O) { const E = this.renderExpandedRow(Object.assign(Object.assign({}, this.props), { columns: m, level: t, index: y, record: b, expanded: C, displayNone: i || !C })); ss(E) || n.push(E) } if (S && O) { const E = this.renderBodyRows(x, t + 1, [], i || !C); n.push(...E) } }), n } render() { const { virtualized: e } = this.props, { direction: t } = this.context; return e ? this.renderVirtualizedBody(t) : this.renderBody(t) } } ob.contextType = Da; ob.propTypes = { anyColumnFixed: c.bool, childrenRecordName: c.string, columns: c.array, components: c.object, dataSource: c.array, disabledRowKeysSet: c.instanceOf(Set).isRequired, emptySlot: c.node, expandRowByClick: c.bool, expandedRowKeys: c.array, expandedRowRender: c.func, fixed: c.oneOfType([c.string, c.bool]), forwardedRef: c.oneOfType([c.object, c.func]), groups: c.instanceOf(Map), handleBodyScroll: c.func, handleWheel: c.func, headerRef: c.oneOfType([c.object, c.func]), includeHeader: c.bool, onScroll: c.func, prefixCls: c.string, renderExpandIcon: c.func, rowExpandable: c.func, rowKey: c.oneOfType([c.string, c.bool, c.func]), scroll: c.object, selectedRowKeysSet: c.instanceOf(Set).isRequired, showHeader: c.bool, size: c.string, store: c.object, virtualized: c.oneOfType([c.bool, c.object]) }; const $ee = f.forwardRef(function (e, t) { return f.createElement(ob, Object.assign({}, e, { forwardedRef: t })) }); var Lee = function (r, e) { var t = {}; for (var n in r) Object.prototype.hasOwnProperty.call(r, n) && e.indexOf(n) < 0 && (t[n] = r[n]); if (r != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, n = Object.getOwnPropertySymbols(r); i < n.length; i++)e.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(r, n[i]) && (t[n[i]] = r[n[i]]); return t }; let nl = class extends de { get adapter() { var e = this; return Object.assign(Object.assign({}, super.adapter), { resetScrollY: () => { this.bodyWrapRef.current && (this.bodyWrapRef.current.scrollTop = 0) }, setSelectedRowKeys: t => { this.setState({ rowSelection: Object.assign(Object.assign({}, this.state.rowSelection), { selectedRowKeys: [...t], selectedRowKeysSet: new Set(t) }) }) }, setDisabledRowKeys: t => { this.setState({ disabledRowKeys: t, disabledRowKeysSet: new Set(t) }) }, setCurrentPage: t => { const { pagination: n } = this.state; typeof n == "object" ? this.setState({ pagination: Object.assign(Object.assign({}, n), { currentPage: t }) }) : this.setState({ pagination: { currentPage: t } }) }, setPagination: t => this.setState({ pagination: t }), setGroups: t => this.setState({ groups: t }), setDataSource: t => this.setState({ dataSource: t }), setExpandedRowKeys: t => this.setState({ expandedRowKeys: [...t] }), setQuery: function () { let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, n = [...e.state.queries]; n = gO(t, n), e.setState({ queries: n }) }, setQueries: t => this.setState({ queries: t }), setFlattenData: t => this.setState({ flattenData: t }), setAllRowKeys: t => this.setState({ allRowKeys: t }), setHoveredRowKey: t => { this.store.setState({ hoveredRowKey: t }) }, setCachedFilteredSortedDataSource: t => { this.cachedFilteredSortedDataSource = t }, setCachedFilteredSortedRowKeys: t => { this.cachedFilteredSortedRowKeys = t, this.cachedFilteredSortedRowKeysSet = new Set(t) }, setAllDisabledRowKeys: t => { const n = new Set(t); this.setState({ allDisabledRowKeys: t, allDisabledRowKeysSet: n }) }, getCurrentPage: () => H(this.state, "pagination.currentPage", 1), getCurrentPageSize: () => H(this.state, "pagination.pageSize", On.DEFAULT_PAGE_SIZE), getCachedFilteredSortedDataSource: () => this.cachedFilteredSortedDataSource, getCachedFilteredSortedRowKeys: () => this.cachedFilteredSortedRowKeys, getCachedFilteredSortedRowKeysSet: () => this.cachedFilteredSortedRowKeysSet, getAllDisabledRowKeys: () => this.state.allDisabledRowKeys, getAllDisabledRowKeysSet: () => this.state.allDisabledRowKeysSet, notifyFilterDropdownVisibleChange: (t, n) => this._invokeColumnFn(n, "onFilterDropdownVisibleChange", t), notifyChange: function () { return e.props.onChange(...arguments) }, notifyExpand: function () { return e.props.onExpand(...arguments) }, notifyExpandedRowsChange: function () { return e.props.onExpandedRowsChange(...arguments) }, notifySelect: function () { for (var t = arguments.length, n = new Array(t), i = 0; i < t; i++)n[i] = arguments[i]; return e._invokeRowSelection("onSelect", ...n) }, notifySelectAll: function () { for (var t = arguments.length, n = new Array(t), i = 0; i < t; i++)n[i] = arguments[i]; return e._invokeRowSelection("onSelectAll", ...n) }, notifySelectInvert: function () { for (var t = arguments.length, n = new Array(t), i = 0; i < t; i++)n[i] = arguments[i]; return e._invokeRowSelection("onSelectInvert", ...n) }, notifySelectionChange: function () { for (var t = arguments.length, n = new Array(t), i = 0; i < t; i++)n[i] = arguments[i]; return e._invokeRowSelection("onChange", ...n) }, isAnyColumnFixed: t => Lu(this.getColumns(t || this.props.columns, this.props.children), n => !!n.fixed), useFixedHeader: () => { const { scroll: t, sticky: n } = this.props; return !!(H(t, "y") || n) }, getTableLayout: () => { let t = !1; const { flattenColumns: n } = this.state; return Array.isArray(n) && (t = n.some(i => !!i.ellipsis || !!i.fixed)), this.adapter.useFixedHeader() && (t = !0), t ? "fixed" : "auto" }, setHeadWidths: function (t) { let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0; BJ(e.state.headWidths[n], t) || e.setState(i => { const s = [...i.headWidths]; return s[n] = [...t], { headWidths: s } }) }, getHeadWidths: function () { let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0; return e.state.headWidths.length && typeof t == "number" ? (e.state.headWidths[t] || []).map(i => i.width) : [] }, getCellWidths: function (t) { let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null, i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1; return Array.isArray(t) && t.length && (n = n == null && e.state.headWidths.length ? fJ(e.state.headWidths) : [], Array.isArray(n) && n.length) ? t.reduce((s, a) => { const o = a.key === Te.DEFAULT_KEY_COLUMN_SCROLLBAR && i ? null : Ui(n, l => l && l.key != null && l.key === a.key); return o && s.push(o.width), s }, []) : [] }, mergedRowExpandable: t => { const { expandedRowRender: n, childrenRecordName: i, rowExpandable: s } = this.props, a = H(t, i), o = typeof n == "function", l = typeof s == "function", u = Array.isArray(a) && a.length, d = l && s(t); return (o || u) && (!l || d) || !(o || u) && d }, isAnyColumnUseFullRender: t => Lu(t, n => !!n.useFullRender), getNormalizeColumns: () => this.normalizeColumns, getHandleColumns: () => this.handleColumns, getMergePagination: () => this.mergePagination, setBodyHasScrollbar: t => { t !== this.state.bodyHasScrollBar && this.setState({ bodyHasScrollBar: t }) }, stopPropagation(t) { t && typeof t == "object" && (typeof t.stopPropagation == "function" && t.stopPropagation(), t.nativeEvent && typeof t.nativeEvent.stopPropagation == "function" ? t.nativeEvent.stopPropagation() : typeof t.stopImmediatePropagation == "function" && t.stopImmediatePropagation()) } }) } constructor(e, t) { var n; super(e), n = this, this._warnIfNoKey = () => { (this.props.rowSelection || this.props.expandedRowRender) && Lu(this.props.dataSource, d => this.foundation.getRecordKey(d) == null) && Dl.error('You must specify a key for each element in the dataSource or use "rowKey" to specify an attribute name as the primary key!') }, this._invokeRowSelection = function (d) { const h = H(n.state, ["rowSelection", d]); if (typeof h == "function") { for (var g = arguments.length, m = new Array(g > 1 ? g - 1 : 0), b = 1; b < g; b++)m[b - 1] = arguments[b]; h(...m) } }, this._invokeColumnFn = function (d, h) { if (d && h) { const y = n.foundation.getQuery(d), w = H(y, h, null); if (typeof w == "function") { for (var g = arguments.length, m = new Array(g > 2 ? g - 2 : 0), b = 2; b < g; b++)m[b - 2] = arguments[b]; w(...m) } } }, this._cacheHeaderRef = d => { this.headerWrapRef.current = d }, this.getCurrentPageData = () => { const d = this.foundation.getCurrentPageData(), h = ["dataSource", "groups"].reduce((g, m) => (d[m] && (g[m] = d[m]), g), {}); return Hr(h) }, this.getColumns = (d, h) => !Array.isArray(d) || !d || !d.length ? md(h) : d, this.getCellWidths = function () { return n.foundation.getCellWidths(...arguments) }, this.setHeadWidths = function () { return n.foundation.setHeadWidths(...arguments) }, this.getHeadWidths = function () { return n.foundation.getHeadWidths(...arguments) }, this.mergedRowExpandable = function () { return n.foundation.mergedRowExpandable(...arguments) }, this.setBodyHasScrollbar = function () { return n.foundation.setBodyHasScrollbar(...arguments) }, this.handleWheel = d => { const { scroll: h = {} } = this.props; if (window.navigator.userAgent.match(/Trident\/7\./) && h.y) { d.preventDefault(); const g = d.deltaY, { target: m } = d, b = this.bodyWrapRef.current; let y = 0; this.lastScrollTop ? y = this.lastScrollTop + g : y = g, b && m !== b && (b.scrollTop = y) } }, this.handleBodyScrollLeft = d => { if (d.currentTarget !== d.target) return; const { target: h } = d, g = this.headerWrapRef.current, m = this.bodyWrapRef.current; h.scrollLeft !== this.lastScrollLeft && (h === m && g ? g.scrollLeft = h.scrollLeft : h === g && m && (m.scrollLeft = h.scrollLeft), this.setScrollPositionClassName()), this.lastScrollLeft = h.scrollLeft }, this.handleWindowResize = () => { this.syncTableWidth(), this.setScrollPositionClassName() }, this.handleBodyScrollTop = d => { const { target: h } = d; if (d.currentTarget !== h) return; const { scroll: g = {} } = this.props, m = this.headerWrapRef.current, b = this.bodyWrapRef.current; if (h.scrollTop !== this.lastScrollTop && g.y && h !== m) { const { scrollTop: y } = h; b && h !== b && (b.scrollTop = y) } this.lastScrollTop = h.scrollTop }, this.handleBodyScroll = d => { this.handleBodyScrollLeft(d), this.handleBodyScrollTop(d) }, this.setScrollPosition = d => { const { prefixCls: h } = this.props, g = [`${h}-scroll-position-both`, `${h}-scroll-position-middle`, `${h}-scroll-position-left`, `${h}-scroll-position-right`]; this.scrollPosition = d; const m = this.wrapRef.current; if (m && m.nodeType) if (d === "both") { const b = [`${h}-scroll-position-left`, `${h}-scroll-position-right`]; m.classList.remove(...Eo(g, b)), m.classList.add(...b) } else { const b = [`${h}-scroll-position-${d}`]; m.classList.remove(...Eo(g, b)), m.classList.add(...b) } }, this.setScrollPositionClassName = () => { const d = this.bodyWrapRef.current; if (d && d.children && d.children.length) { const h = d.scrollLeft === 0, g = Math.abs(d.scrollLeft) + 1 >= d.children[0].getBoundingClientRect().width - d.getBoundingClientRect().width; h && g ? this.setScrollPosition("both") : h ? this.setScrollPosition("left") : g ? this.setScrollPosition("right") : this.scrollPosition !== "middle" && this.setScrollPosition("middle") } }, this.syncTableWidth = () => { this.rootWrapRef && this.rootWrapRef.current && this.setState({ tableWidth: this.rootWrapRef.current.getBoundingClientRect().width }) }, this.renderSelection = function () { let d = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, h = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1, g = arguments.length > 2 ? arguments[2] : void 0; const { rowSelection: m, allDisabledRowKeysSet: b } = n.state; if (m && typeof m == "object") { const { selectedRowKeys: y = [], selectedRowKeysSet: w = new Set, getCheckboxProps: x, disabled: S, renderCell: C } = m, O = n.cachedFilteredSortedRowKeys, E = n.cachedFilteredSortedRowKeysSet, v = n.foundation.allIsSelected(w, b, O), I = n.foundation.hasRowSelected(y, E) && !v; if (h) { const k = H(m, "key", Te.DEFAULT_KEY_COLUMN_SELECTION), P = f.createElement(yd, { "aria-label": `${v ? "Deselect" : "Select"} all rows`, disabled: S, key: k, selected: v, indeterminate: I, onChange: (M, B) => { n.toggleSelectAllRow(M, B) } }), N = (M, B) => n.toggleSelectAllRow(M, B); return we(C) ? C({ selected: v, record: d, originNode: P, inHeader: h, disabled: S, indeterminate: I, selectAll: N }) : P } else { const k = n.foundation.getRecordKey(d), P = w.has(k), N = () => typeof x == "function" ? x(d) : {}, M = f.createElement(yd, { "aria-label": `${P ? "Deselect" : "Select"} this row`, getCheckboxProps: N, selected: P, onChange: (K, U) => n.toggleSelectRow(K, k, U) }), B = (K, U) => n.toggleSelectRow(K, k, U); return we(C) ? C({ selected: P, record: d, index: g, originNode: M, inHeader: !1, disabled: S, indeterminate: I, selectRow: B }) : M } } return null }, this.renderRowSelectionCallback = function (d) { let h = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, g = arguments.length > 2 ? arguments[2] : void 0; return n.renderSelection(h, !1, g) }, this.renderTitleSelectionCallback = () => this.renderSelection(void 0, !0), this.normalizeSelectionColumn = function () { let d = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}; const { rowSelection: h, prefixCls: g } = d; let m = {}; if (h) { const b = ["selectedRowKeys", "selectedRowKeysSet"]; m = { key: Te.DEFAULT_KEY_COLUMN_SELECTION }, an(h) && (m = Object.assign(Object.assign({}, m), Ht(h, b))), m.className = F(m.className, `${g}-column-selection`), m.title = n.renderTitleSelectionCallback, m.render = n.renderRowSelectionCallback } return m }, this.normalizeScrollbarColumn = function () { let d = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}; const { scrollbarWidth: h = 0 } = d; return { key: Te.DEFAULT_KEY_COLUMN_SCROLLBAR, width: h, fixed: "right" } }, this.renderExpandIcon = function () { let d = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, h = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1, g = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null; const { expandedRowKeys: m } = n.state, { expandIcon: b } = n.props, y = typeof g == "string" || typeof g == "number" ? g : n.foundation.getRecordKey(d); return f.createElement(rb, { key: y, componentType: h ? "tree" : "expand", expanded: $i(m, y), expandIcon: b, onClick: (w, x) => n.handleRowExpanded(w, y, x) }) }, this.handleRowExpanded = function () { return n.foundation.handleRowExpanded(...arguments) }, this.normalizeExpandColumn = function () { let d = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, h = null; const { prefixCls: g, expandCellFixed: m, expandIcon: b } = d; return h = { fixed: m, key: Te.DEFAULT_KEY_COLUMN_EXPAND }, h.className = F(h.className, `${g}-column-expand`), h.render = b !== !1 ? function () { let y = arguments.length > 1 ? arguments[1] : void 0; return n.adapter.mergedRowExpandable(y) ? n.renderExpandIcon(y) : null } : () => null, h }, this.addFnsInColumn = function () { let d = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}; const { prefixCls: h } = n.props; if (d && (d.sorter || d.filters || d.onFilter || d.useFullRender)) { let g = typeof d.sorter == "function" || d.sorter === !0, m = Array.isArray(d.filters) && d.filters.length || R.isValidElement(d.filterDropdown) || typeof d.renderFilterDropdown == "function", b = !1; const w = !("sortOrder" in d) && d.showSortTip === !0, { dataIndex: x, title: S, useFullRender: C } = d, O = g && !m && !C, E = n.foundation.getQuery(x), v = {}, T = []; C && (v.selection = n.renderSelection(null, !0)); const I = H(E, "sortOrder"), k = H(E, "defaultSortOrder", !1), P = n.foundation.isSortOrderValid(I) ? I : k, N = eb(d.ellipsis), M = typeof S != "function" && f.createElement("span", { className: `${h}-row-head-title`, key: Te.DEFAULT_KEY_COLUMN_TITLE, title: N && typeof S == "string" ? S : void 0 }, S); if (g) { const Z = f.createElement(nb, { key: Te.DEFAULT_KEY_COLUMN_SORTER, sortOrder: P, sortIcon: d.sortIcon, onClick: C || m ? J => n.foundation.handleSort(d, J) : null, title: M, showTooltip: !O && w }); C && (v.sorter = Z), b = !0, T.push(Z) } else T.push(M); const B = H(E, "filteredValue"), K = H(E, "defaultFilteredValue"), U = B || K; if (m) { const Z = f.createElement(EQ, Object.assign({ key: Te.DEFAULT_KEY_COLUMN_FILTER }, Ht(E, "children"), { filteredValue: U, onFilterDropdownVisibleChange: J => n.foundation.toggleShowFilter(x, J), onSelect: J => n.foundation.handleFilterSelect(x, J) })); C && (v.filter = Z), b = !0, T.push(Z) } const W = typeof S == "function" ? () => S(v) : b ? f.createElement("div", { className: `${h}-operate-wrapper` }, T) : T; d = Object.assign(Object.assign({}, d), { title: W }), O && (d.clickToSort = Z => { n.foundation.handleSort(d, Z) }, d.sortOrder = P, d.showSortTip = w) } return d }, this.toggleSelectRow = (d, h, g) => { this.foundation.handleSelectRow(h, d, g) }, this.toggleSelectAllRow = (d, h) => { this.foundation.handleSelectAllRow(d, h) }, this.renderPagination = (d, h) => { if (!d) return null; const g = this.foundation.memoizedPagination(d); return f.createElement(Ke, { componentName: "Table" }, m => { const b = this.foundation.formatPaginationInfo(g, m.pageText); return f.createElement(tb, { info: b, pagination: g, renderPagination: h }) }) }, this.renderTitle = function () { let d = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, { title: h } = d; const { prefixCls: g, dataSource: m } = d; return typeof h == "function" && (h = h(m)), R.isValidElement(h) || typeof h == "string" ? f.createElement("div", { className: `${g}-title`, "x-semi-prop": "title" }, h) : null }, this.renderEmpty = function () { let d = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}; const { prefixCls: h, empty: g, dataSource: m } = d, b = `${h}-placeholder`; return n.foundation.isEmpty(m) ? f.createElement(Ke, { componentName: "Table", key: "emptyText" }, (w, x) => f.createElement("div", { className: b }, f.createElement("div", { className: `${h}-empty`, "x-semi-prop": "empty" }, g || w.emptyText))) : null }, this.renderFooter = function () { let d = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, { footer: h } = d; const { prefixCls: g, dataSource: m } = d; return typeof h == "function" && (h = h(m)), R.isValidElement(h) || typeof h == "string" ? f.createElement("div", { className: `${g}-footer`, key: "footer", "x-semi-prop": "footer" }, h) : null }, this.renderMainTable = d => { const h = this.adapter.useFixedHeader(), g = this.renderEmpty(d); return [this.renderTable(Object.assign(Object.assign({}, d), { fixed: !1, useFixedHeader: h, headerRef: this._cacheHeaderRef, bodyRef: this.bodyWrapRef, includeHeader: !h, emptySlot: g })), this.renderFooter(d)] }, this.renderTable = d => { const { columns: h, filteredColumns: g, fixed: m, useFixedHeader: b, scroll: y, prefixCls: w, anyColumnFixed: x, includeHeader: S, showHeader: C, components: O, headerRef: E, bodyRef: v, onHeaderRow: T, rowSelection: I, dataSource: k, bodyHasScrollBar: P, disabledRowKeysSet: N, sticky: M } = d, B = H(I, "selectedRowKeysSet", new Set), K = this.adapter.getTableLayout(), U = m || b ? f.createElement(AQ, { key: "head", tableLayout: K, ref: E, columns: g, prefixCls: w, fixed: m, handleBodyScroll: this.handleBodyScrollLeft, components: O, scroll: y, showHeader: C, selectedRowKeysSet: B, onHeaderRow: T, dataSource: k, bodyHasScrollBar: P, sticky: M }) : null, W = f.createElement($ee, Object.assign({}, Ht(d, ["rowSelection", "headWidths"]), { key: "body", ref: v, columns: g, fixed: m, prefixCls: w, handleWheel: this.handleWheel, handleBodyScroll: this.handleBodyScroll, anyColumnFixed: x, tableLayout: K, includeHeader: S, showHeader: C, scroll: y, components: O, store: this.store, selectedRowKeysSet: B, disabledRowKeysSet: N })); return [U, W] }, this.handleColumns = (d, h) => { const { hideExpandedColumn: g, scroll: m, prefixCls: b, expandCellFixed: y, expandIcon: w, rowSelection: x } = this.props, S = "children"; let C = Hr(h); const O = function () { let E = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : []; Array.isArray(E) && E.length && Vn(E, (v, T, I) => { const k = n.addFnsInColumn(v), P = v[S]; if (Array.isArray(P) && P.length) { const N = [...P]; O(N), k[S] = N } I[T] = k }) }; if (O(C), !g) { const E = this.normalizeExpandColumn({ prefixCls: b, expandCellFixed: y, expandIcon: w }), v = Ur(C, T => T.key === Te.DEFAULT_KEY_COLUMN_EXPAND); E && (v > -1 ? C[v] = Object.assign(Object.assign({}, E), C[v]) : E.fixed === "right" ? C = [...C, E] : C = [E, ...C]) } if (x && !H(x, "hidden")) { const E = Ur(C, T => T.key === Te.DEFAULT_KEY_COLUMN_SELECTION), v = this.normalizeSelectionColumn({ rowSelection: x, prefixCls: b }); E > -1 ? C[E] = Object.assign(Object.assign({}, v), C[E]) : v.fixed === "right" ? C = [...C, v] : C = [v, ...C] } return gd(C), C }, this.normalizeColumns = (d, h) => Hr(this.getColumns(d, h)), this.mergePagination = d => Object.assign({ onChange: this.foundation.setPage }, d), this.foundation = new Ql(this.adapter); const i = this.getColumns(e.columns, e.children), s = go(i), a = Ql.initColumnsFilteredValueAndSorterOrder(Hr(s)), o = this.foundation.getFilteredSortedDataSource(this.props.dataSource, a), l = Wu(this.props.pagination) ? this.props.pagination : {}, u = this.foundation.getCurrentPageData(o, l, a); this.state = { cachedColumns: i, cachedChildren: e.children, flattenColumns: s, components: rw(e.components, e.virtualized), queries: a, dataSource: u.dataSource, flattenData: [], expandedRowKeys: [...e.expandedRowKeys || [], ...e.defaultExpandedRowKeys || []], rowSelection: e.rowSelection ? an(e.rowSelection) ? Object.assign({}, e.rowSelection) : {} : null, pagination: u.pagination, groups: null, allRowKeys: [], disabledRowKeys: [], disabledRowKeysSet: new Set, allDisabledRowKeys: [], allDisabledRowKeysSet: new Set, headWidths: [], bodyHasScrollBar: !1, prePropRowSelection: void 0, prePagination: void 0 }, this.rootWrapRef = R.createRef(), this.wrapRef = R.createRef(), this.bodyWrapRef = R.createRef(), this.headerWrapRef = R.createRef(), this.store = new eQ({ hoveredRowKey: null }), this.debouncedWindowResize = $d(this.handleWindowResize, 150), this.cachedFilteredSortedDataSource = [], this.cachedFilteredSortedRowKeys = [], this.cachedFilteredSortedRowKeysSet = new Set } static getDerivedStateFromProps(e, t) { const n = {}, { rowSelection: i, dataSource: s, childrenRecordName: a, rowKey: o, pagination: l } = e; if (e.columns && e.children && Dl.warn("columns should not given by object and children at the same time"), e.columns && e.columns !== t.cachedColumns) { const u = go(e.columns); n.flattenColumns = u, n.queries = Ng(t.queries, u, null, !1), n.cachedColumns = e.columns, n.cachedChildren = null } else if (e.children && e.children !== t.cachedChildren) { const u = md(e.children), d = go(u), h = Ng(t.queries, d, null, !1); n.flattenColumns = d, n.queries = [...h], n.cachedColumns = [...u], n.cachedChildren = e.children } if (i !== t.prePropRowSelection) { let u = {}; an(t.rowSelection) && (u = Object.assign(Object.assign({}, u), t.rowSelection)), an(i) && (u = Object.assign(Object.assign({}, u), i)); const d = H(i, "selectedRowKeys"), h = H(i, "getCheckboxProps"); if (d && Array.isArray(d) && (u.selectedRowKeysSet = new Set(d)), we(h)) { const g = mO({ dataSource: s, getCheckboxProps: h, childrenRecordName: a, rowKey: o }), m = new Set(g); n.disabledRowKeys = g, n.disabledRowKeysSet = m, n.allDisabledRowKeys = g, n.allDisabledRowKeysSet = m } n.rowSelection = u, n.prePropRowSelection = i } if (l !== t.prePagination) { let u = {}; an(t.pagination) && (u = Object.assign(Object.assign({}, u), t.pagination)), an(l) && (u = Object.assign(Object.assign({}, u), l)), n.pagination = u, n.prePagination = l } return n } componentDidMount() { super.componentDidMount(), this.setScrollPosition("left"), (this.adapter.isAnyColumnFixed() || this.props.showHeader && this.adapter.useFixedHeader()) && (this.handleWindowResize(), window.addEventListener("resize", this.debouncedWindowResize)) } componentDidUpdate(e, t) { const { dataSource: n, expandedRowKeys: i, expandAllRows: s, expandAllGroupRows: a, virtualized: o, components: l, pagination: u } = this.props, { pagination: d, queries: h, cachedColumns: g, cachedChildren: m, groups: b } = this.state, y = {}; if (this._warnIfNoKey(), Array.isArray(i) && i !== e.expandedRowKeys && this.setState({ expandedRowKeys: i }), (l !== e.components || o !== e.virtualized) && this.setState({ components: rw(l, o) }), (s !== e.expandAllRows || a !== e.expandAllGroupRows) && this.foundation.initExpandedRowKeys({ groups: b }), n !== e.dataSource || g !== t.cachedColumns || m !== t.cachedChildren) { const w = [...n], x = this.foundation.getFilteredSortedDataSource(w, h), S = this.foundation.getAllDisabledRowKeys(x); this.foundation.setCachedFilteredSortedDataSource(x), this.foundation.setAllDisabledRowKeys(S), y.dataSource = x, this.props.groupBy && (y.groups = null) } if (n !== e.dataSource && (y.pagination = an(d) ? Object.assign(Object.assign({}, d), { currentPage: an(u) && u.currentPage ? u.currentPage : 1 }) : d), Object.keys(y).length) { const { pagination: w = null, queries: x = null, dataSource: S = null } = y, C = this.foundation.getCurrentPageData(S, w, x); this.adapter.setAllRowKeys(C.allRowKeys), this.adapter.setDisabledRowKeys(C.disabledRowKeys), "dataSource" in y && ((this.props.defaultExpandAllRows && C.groups && C.groups.size || this.props.expandAllRows || this.props.expandAllGroupRows) && this.foundation.initExpandedRowKeys(C), y.pagination = C.pagination); const O = Object.keys(y); for (const E of O) this.setState({ [E]: C[E] }) } (this.adapter.isAnyColumnFixed() || this.props.showHeader && this.adapter.useFixedHeader()) && (this.debouncedWindowResize || window.addEventListener("resize", this.debouncedWindowResize)) } componentWillUnmount() { super.componentWillUnmount(), this.debouncedWindowResize && (window.removeEventListener("resize", this.debouncedWindowResize), this.debouncedWindowResize.cancel(), this.debouncedWindowResize = null) } render() { let e = this.props, { scroll: t, prefixCls: n, className: i, style: s = {}, bordered: a, id: o, pagination: l, virtualized: u, size: d, renderPagination: h, getVirtualizedListRef: g, loading: m, hideExpandedColumn: b, rowSelection: y } = e, w = Lee(e, ["scroll", "prefixCls", "className", "style", "bordered", "id", "pagination", "virtualized", "size", "renderPagination", "getVirtualizedListRef", "loading", "hideExpandedColumn", "rowSelection"]), { rowSelection: x, expandedRowKeys: S, headWidths: C, tableWidth: O, pagination: E, dataSource: v, queries: T, cachedColumns: I, bodyHasScrollBar: k } = this.state; s = Object.assign({}, s); let P; if (this.adapter.isAnyColumnUseFullRender(T)) P = this.handleColumns(T, I); else { const re = y && !H(y, "hidden"); P = this.foundation.memoizedWithFnsColumns(T, I, re, b, k) } const N = this.foundation.memoizedFilterColumns(P), M = this.foundation.memoizedFlattenFnsColumns(P), B = this.adapter.isAnyColumnFixed(P), K = Object.assign(Object.assign(Object.assign({}, w), this.state), { virtualized: u, scroll: t, prefixCls: n, size: d, hideExpandedColumn: b, columns: P, anyColumnFixed: B, rowExpandable: this.mergedRowExpandable, pagination: E, dataSource: v, rowSelection: x, expandedRowKeys: S, renderExpandIcon: this.renderExpandIcon, filteredColumns: N }), U = H(t, "x"), W = H(t, "y"); u && typeof s.width != "number" && (s.width = U); const Z = F({ [`${n}-${Te.SIZE_SMALL}`]: d === Te.SIZE_SMALL, [`${n}-${Te.SIZE_MIDDLE}`]: d === Te.SIZE_MIDDLE, [`${n}-virtualized`]: !!u, [`${n}-bordered`]: a, [`${n}-fixed-header`]: !!W, [`${n}-scroll-position-left`]: ["both", "left"].includes(this.position), [`${n}-scroll-position-right`]: ["both", "right"].includes(this.position) }), J = E && l ? this.renderPagination(E, h) : null, ee = H(l, "position", "bottom"), $ = Object.assign(Object.assign({}, this.context), { headWidths: C, tableWidth: O, anyColumnFixed: B, flattenedColumns: M, renderExpandIcon: this.renderExpandIcon, renderSelection: this.renderSelection, setHeadWidths: this.setHeadWidths, getHeadWidths: this.getHeadWidths, getCellWidths: this.getCellWidths, handleRowExpanded: this.handleRowExpanded, getVirtualizedListRef: g, setBodyHasScrollbar: this.setBodyHasScrollbar }), pe = this.getDataAttr(w); return f.createElement("div", Object.assign({ ref: this.rootWrapRef, className: F(i, `${n}-wrapper`, `${n}-wrapper-${K.direction}`), "data-column-fixed": B, style: s, id: o }, pe), f.createElement(CQ, Object.assign({}, $, { direction: K.direction }), f.createElement(yi, { spinning: m, size: "large" }, f.createElement("div", { ref: this.wrapRef, className: Z }, f.createElement(f.Fragment, { key: "pagination-top" }, ["top", "both"].includes(ee) ? J : null), this.renderTitle({ title: K.title, dataSource: K.dataSource, prefixCls: K.prefixCls }), f.createElement("div", { className: `${n}-container` }, this.renderMainTable(Object.assign({}, K))), f.createElement(f.Fragment, { key: "pagination-bottom" }, ["bottom", "both"].includes(ee) ? J : null))))) } }; nl.contextType = Da; nl.propTypes = { className: c.string, style: c.object, prefixCls: c.string, components: c.any, bordered: c.bool, loading: c.bool, size: c.oneOf(Te.SIZES), tableLayout: c.oneOf(Te.LAYOUTS), columns: c.arrayOf(c.shape(bO)), hideExpandedColumn: c.bool, id: c.string, expandIcon: c.oneOfType([c.bool, c.func, c.node]), expandCellFixed: c.oneOf(Te.FIXED_SET), title: c.oneOfType([c.string, c.node, c.func]), onHeaderRow: c.func, showHeader: c.bool, indentSize: c.number, rowKey: c.oneOfType([c.func, c.string, c.number]), onRow: c.func, onExpandedRowsChange: c.func, onExpand: c.func, rowExpandable: c.func, expandedRowRender: c.func, expandedRowKeys: c.array, defaultExpandAllRows: c.bool, expandAllRows: c.bool, defaultExpandAllGroupRows: c.bool, expandAllGroupRows: c.bool, defaultExpandedRowKeys: c.array, pagination: c.oneOfType([c.object, c.bool]), renderPagination: c.func, footer: c.oneOfType([c.func, c.string, c.node]), empty: c.node, dataSource: c.array, childrenRecordName: c.string, rowSelection: c.oneOfType([c.object, c.bool]), onChange: c.func, scroll: c.shape({ x: c.oneOfType([c.number, c.string, c.bool]), y: c.oneOfType([c.number, c.string]) }), groupBy: c.oneOfType([c.string, c.number, c.func]), renderGroupSection: c.oneOfType([c.func]), onGroupedRow: c.func, clickGroupedRowToExpand: c.bool, virtualized: c.oneOfType([c.object, c.bool]), dropdownPrefixCls: c.string, expandRowByClick: c.bool, getVirtualizedListRef: c.func }; nl.defaultProps = { tableLayout: "", dataSource: [], prefixCls: Qn.PREFIX, rowSelection: null, className: "", childrenRecordName: "children", size: "default", loading: !1, bordered: !1, expandCellFixed: !1, hideExpandedColumn: !0, showHeader: !0, indentSize: On.DEFAULT_INDENT_WIDTH, onChange: z, pagination: !0, rowKey: "key", defaultExpandedRowKeys: [], defaultExpandAllRows: !1, defaultExpandAllGroupRows: !1, expandAllRows: !1, expandAllGroupRows: !1, onFilterDropdownVisibleChange: z, onExpand: z, onExpandedRowsChange: z, expandRowByClick: !1 }; var Mee = Im; function jee(r, e, t) { var n = r.length; return t = t === void 0 ? n : t, !e && t >= n ? r : Mee(r, e, t) } var Vee = jee, Bee = Si, zee = Sr, Hee = "[object RegExp]"; function Kee(r) { return zee(r) && Bee(r) == Hee } var Uee = Kee, Wee = Uee, Gee = Ea, lw = dc, cw = lw && lw.isRegExp, Yee = cw ? Gee(cw) : Wee, Xee = Yee; function qee(r) { return r.split("") } var Zee = qee, RO = "\\ud800-\\udfff", Jee = "\\u0300-\\u036f", Qee = "\\ufe20-\\ufe2f", ete = "\\u20d0-\\u20ff", tte = Jee + Qee + ete, nte = "\\ufe0e\\ufe0f", rte = "[" + RO + "]", Lg = "[" + tte + "]", Mg = "\\ud83c[\\udffb-\\udfff]", ite = "(?:" + Lg + "|" + Mg + ")", DO = "[^" + RO + "]", AO = "(?:\\ud83c[\\udde6-\\uddff]){2}", NO = "[\\ud800-\\udbff][\\udc00-\\udfff]", ste = "\\u200d", FO = ite + "?", $O = "[" + nte + "]?", ate = "(?:" + ste + "(?:" + [DO, AO, NO].join("|") + ")" + $O + FO + ")*", ote = $O + FO + ate, lte = "(?:" + [DO + Lg + "?", Lg, AO, NO, rte].join("|") + ")", cte = RegExp(Mg + "(?=" + Mg + ")|" + lte + ote, "g"); function ute(r) { return r.match(cte) || [] } var dte = ute, hte = Zee, pte = ab, fte = dte; function gte(r) { return pte(r) ? fte(r) : hte(r) } var mte = gte, yte = y1, bte = Vee, vte = ab, xte = Kd, wte = Xee, Cte = mte, Ste = Nd, Ete = 4294967295; function _te(r, e, t) { return t && typeof t != "number" && xte(r, e, t) && (e = t = void 0), t = t === void 0 ? Ete : t >>> 0, t ? (r = Ste(r), r && (typeof e == "string" || e != null && !wte(e)) && (e = yte(e), !e && vte(r)) ? bte(Cte(r), 0, t) : r.split(e, t)) : [] } var Ote = _te; const Al = _e(Ote); function Tte(r) { const e = Al(r, /\s+/); for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), i = 1; i < t; i++)n[i - 1] = arguments[i]; const s = ko(n, a => !e.includes(a)); return F(r, ...s) } function Ite(r) { const e = Al(r, /\s+/); for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), i = 1; i < t; i++)n[i - 1] = arguments[i]; return Gl(n, s => { const a = e.indexOf(s); a > -1 && e.splice(a, 1) }), F(...e) } var lb = { exports: {} }, jc = {}, Ih = { exports: {} }, LO = {}; function MO(r) { var e, t, n = ""; if (typeof r == "string" || typeof r == "number") n += r; else if (typeof r == "object") if (Array.isArray(r)) for (e = 0; e < r.length; e++)r[e] && (t = MO(r[e])) && (n && (n += " "), n += t); else for (e in r) r[e] && (n && (n += " "), n += e); return n } function uw() { for (var r, e, t = 0, n = ""; t < arguments.length;)(r = arguments[t++]) && (e = MO(r)) && (n && (n += " "), n += e); return n } const Pte = Object.freeze(Object.defineProperty({ __proto__: null, clsx: uw, default: uw }, Symbol.toStringTag, { value: "Module" })), kte = tP(Pte); var fn = {}, Gi = {}; Object.defineProperty(Gi, "__esModule", { value: !0 }); Gi.dontSetMe = Fte; Gi.findInArray = Rte; Gi.int = Nte; Gi.isFunction = Dte; Gi.isNum = Ate; function Rte(r, e) { for (let t = 0, n = r.length; t < n; t++)if (e.apply(e, [r[t], t, r])) return r[t] } function Dte(r) { return typeof r == "function" || Object.prototype.toString.call(r) === "[object Function]" } function Ate(r) { return typeof r == "number" && !isNaN(r) } function Nte(r) { return parseInt(r, 10) } function Fte(r, e, t) { if (r[e]) return new Error("Invalid prop ".concat(e, " passed to ").concat(t, " - do not set this, set it on the child.")) } var Aa = {}; Object.defineProperty(Aa, "__esModule", { value: !0 }); Aa.browserPrefixToKey = VO; Aa.browserPrefixToStyle = $te; Aa.default = void 0; Aa.getPrefix = jO; const Tp = ["Moz", "Webkit", "O", "ms"]; function jO() { var r; let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "transform"; if (typeof window > "u") return ""; const t = (r = window.document) === null || r === void 0 || (r = r.documentElement) === null || r === void 0 ? void 0 : r.style; if (!t || e in t) return ""; for (let n = 0; n < Tp.length; n++)if (VO(e, Tp[n]) in t) return Tp[n]; return "" } function VO(r, e) { return e ? "".concat(e).concat(Lte(r)) : r } function $te(r, e) { return e ? "-".concat(e.toLowerCase(), "-").concat(r) : r } function Lte(r) { let e = "", t = !0; for (let n = 0; n < r.length; n++)t ? (e += r[n].toUpperCase(), t = !1) : r[n] === "-" ? t = !0 : e += r[n]; return e } Aa.default = jO(); Object.defineProperty(fn, "__esModule", { value: !0 }); fn.addClassName = HO; fn.addEvent = Vte; fn.addUserSelectStyles = Zte; fn.createCSSTransform = Gte; fn.createSVGTransform = Yte; fn.getTouch = Xte; fn.getTouchIdentifier = qte; fn.getTranslation = cb; fn.innerHeight = Kte; fn.innerWidth = Ute; fn.matchesSelector = zO; fn.matchesSelectorAndParentsTo = jte; fn.offsetXYFromParent = Wte; fn.outerHeight = zte; fn.outerWidth = Hte; fn.removeClassName = KO; fn.removeEvent = Bte; fn.removeUserSelectStyles = Jte; var Rr = Gi, dw = Mte(Aa); function BO(r) { if (typeof WeakMap != "function") return null; var e = new WeakMap, t = new WeakMap; return (BO = function (n) { return n ? t : e })(r) } function Mte(r, e) { if (r.__esModule) return r; if (r === null || typeof r != "object" && typeof r != "function") return { default: r }; var t = BO(e); if (t && t.has(r)) return t.get(r); var n = {}, i = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var s in r) if (s !== "default" && Object.prototype.hasOwnProperty.call(r, s)) { var a = i ? Object.getOwnPropertyDescriptor(r, s) : null; a && (a.get || a.set) ? Object.defineProperty(n, s, a) : n[s] = r[s] } return n.default = r, t && t.set(r, n), n } let du = ""; function zO(r, e) { return du || (du = (0, Rr.findInArray)(["matches", "webkitMatchesSelector", "mozMatchesSelector", "msMatchesSelector", "oMatchesSelector"], function (t) { return (0, Rr.isFunction)(r[t]) })), (0, Rr.isFunction)(r[du]) ? r[du](e) : !1 } function jte(r, e, t) { let n = r; do { if (zO(n, e)) return !0; if (n === t) return !1; n = n.parentNode } while (n); return !1 } function Vte(r, e, t, n) { if (!r) return; const i = { capture: !0, ...n }; r.addEventListener ? r.addEventListener(e, t, i) : r.attachEvent ? r.attachEvent("on" + e, t) : r["on" + e] = t } function Bte(r, e, t, n) { if (!r) return; const i = { capture: !0, ...n }; r.removeEventListener ? r.removeEventListener(e, t, i) : r.detachEvent ? r.detachEvent("on" + e, t) : r["on" + e] = null } function zte(r) { let e = r.clientHeight; const t = r.ownerDocument.defaultView.getComputedStyle(r); return e += (0, Rr.int)(t.borderTopWidth), e += (0, Rr.int)(t.borderBottomWidth), e } function Hte(r) { let e = r.clientWidth; const t = r.ownerDocument.defaultView.getComputedStyle(r); return e += (0, Rr.int)(t.borderLeftWidth), e += (0, Rr.int)(t.borderRightWidth), e } function Kte(r) { let e = r.clientHeight; const t = r.ownerDocument.defaultView.getComputedStyle(r); return e -= (0, Rr.int)(t.paddingTop), e -= (0, Rr.int)(t.paddingBottom), e } function Ute(r) { let e = r.clientWidth; const t = r.ownerDocument.defaultView.getComputedStyle(r); return e -= (0, Rr.int)(t.paddingLeft), e -= (0, Rr.int)(t.paddingRight), e } function Wte(r, e, t) { const i = e === e.ownerDocument.body ? { left: 0, top: 0 } : e.getBoundingClientRect(), s = (r.clientX + e.scrollLeft - i.left) / t, a = (r.clientY + e.scrollTop - i.top) / t; return { x: s, y: a } } function Gte(r, e) { const t = cb(r, e, "px"); return { [(0, dw.browserPrefixToKey)("transform", dw.default)]: t } } function Yte(r, e) { return cb(r, e, "") } function cb(r, e, t) { let { x: n, y: i } = r, s = "translate(".concat(n).concat(t, ",").concat(i).concat(t, ")"); if (e) { const a = "".concat(typeof e.x == "string" ? e.x : e.x + t), o = "".concat(typeof e.y == "string" ? e.y : e.y + t); s = "translate(".concat(a, ", ").concat(o, ")") + s } return s } function Xte(r, e) { return r.targetTouches && (0, Rr.findInArray)(r.targetTouches, t => e === t.identifier) || r.changedTouches && (0, Rr.findInArray)(r.changedTouches, t => e === t.identifier) } function qte(r) { if (r.targetTouches && r.targetTouches[0]) return r.targetTouches[0].identifier; if (r.changedTouches && r.changedTouches[0]) return r.changedTouches[0].identifier } function Zte(r) {
  if (!r) return; let e = r.getElementById("react-draggable-style-el"); e || (e = r.createElement("style"), e.type = "text/css", e.id = "react-draggable-style-el", e.innerHTML = `.react-draggable-transparent-selection *::-moz-selection {all: inherit;}
`, e.innerHTML += `.react-draggable-transparent-selection *::selection {all: inherit;}
`, r.getElementsByTagName("head")[0].appendChild(e)), r.body && HO(r.body, "react-draggable-transparent-selection")
} function Jte(r) { if (r) try { if (r.body && KO(r.body, "react-draggable-transparent-selection"), r.selection) r.selection.empty(); else { const e = (r.defaultView || window).getSelection(); e && e.type !== "Caret" && e.removeAllRanges() } } catch { } } function HO(r, e) { r.classList ? r.classList.add(e) : r.className.match(new RegExp("(?:^|\\s)".concat(e, "(?!\\S)"))) || (r.className += " ".concat(e)) } function KO(r, e) { r.classList ? r.classList.remove(e) : r.className = r.className.replace(new RegExp("(?:^|\\s)".concat(e, "(?!\\S)"), "g"), "") } var Yi = {}; Object.defineProperty(Yi, "__esModule", { value: !0 }); Yi.canDragX = tne; Yi.canDragY = nne; Yi.createCoreData = ine; Yi.createDraggableData = sne; Yi.getBoundPosition = Qte; Yi.getControlPosition = rne; Yi.snapToGrid = ene; var Ir = Gi, lo = fn; function Qte(r, e, t) { if (!r.props.bounds) return [e, t]; let { bounds: n } = r.props; n = typeof n == "string" ? n : ane(n); const i = ub(r); if (typeof n == "string") { const { ownerDocument: s } = i, a = s.defaultView; let o; if (n === "parent" ? o = i.parentNode : o = s.querySelector(n), !(o instanceof a.HTMLElement)) throw new Error('Bounds selector "' + n + '" could not find an element.'); const l = o, u = a.getComputedStyle(i), d = a.getComputedStyle(l); n = { left: -i.offsetLeft + (0, Ir.int)(d.paddingLeft) + (0, Ir.int)(u.marginLeft), top: -i.offsetTop + (0, Ir.int)(d.paddingTop) + (0, Ir.int)(u.marginTop), right: (0, lo.innerWidth)(l) - (0, lo.outerWidth)(i) - i.offsetLeft + (0, Ir.int)(d.paddingRight) - (0, Ir.int)(u.marginRight), bottom: (0, lo.innerHeight)(l) - (0, lo.outerHeight)(i) - i.offsetTop + (0, Ir.int)(d.paddingBottom) - (0, Ir.int)(u.marginBottom) } } return (0, Ir.isNum)(n.right) && (e = Math.min(e, n.right)), (0, Ir.isNum)(n.bottom) && (t = Math.min(t, n.bottom)), (0, Ir.isNum)(n.left) && (e = Math.max(e, n.left)), (0, Ir.isNum)(n.top) && (t = Math.max(t, n.top)), [e, t] } function ene(r, e, t) { const n = Math.round(e / r[0]) * r[0], i = Math.round(t / r[1]) * r[1]; return [n, i] } function tne(r) { return r.props.axis === "both" || r.props.axis === "x" } function nne(r) { return r.props.axis === "both" || r.props.axis === "y" } function rne(r, e, t) { const n = typeof e == "number" ? (0, lo.getTouch)(r, e) : null; if (typeof e == "number" && !n) return null; const i = ub(t), s = t.props.offsetParent || i.offsetParent || i.ownerDocument.body; return (0, lo.offsetXYFromParent)(n || r, s, t.props.scale) } function ine(r, e, t) { const n = !(0, Ir.isNum)(r.lastX), i = ub(r); return n ? { node: i, deltaX: 0, deltaY: 0, lastX: e, lastY: t, x: e, y: t } : { node: i, deltaX: e - r.lastX, deltaY: t - r.lastY, lastX: r.lastX, lastY: r.lastY, x: e, y: t } } function sne(r, e) { const t = r.props.scale; return { node: e.node, x: r.state.x + e.deltaX / t, y: r.state.y + e.deltaY / t, deltaX: e.deltaX / t, deltaY: e.deltaY / t, lastX: r.state.x, lastY: r.state.y } } function ane(r) { return { left: r.left, top: r.top, right: r.right, bottom: r.bottom } } function ub(r) { const e = r.findDOMNode(); if (!e) throw new Error("<DraggableCore>: Unmounted during event!"); return e } var Ph = {}, kh = {}; Object.defineProperty(kh, "__esModule", { value: !0 }); kh.default = one; function one() { } Object.defineProperty(Ph, "__esModule", { value: !0 }); Ph.default = void 0; var Ip = cne(R), fr = db(oc), lne = db(di), Gn = fn, xs = Yi, Pp = Gi, vl = db(kh); function db(r) { return r && r.__esModule ? r : { default: r } } function UO(r) { if (typeof WeakMap != "function") return null; var e = new WeakMap, t = new WeakMap; return (UO = function (n) { return n ? t : e })(r) } function cne(r, e) { if (r && r.__esModule) return r; if (r === null || typeof r != "object" && typeof r != "function") return { default: r }; var t = UO(e); if (t && t.has(r)) return t.get(r); var n = {}, i = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var s in r) if (s !== "default" && Object.prototype.hasOwnProperty.call(r, s)) { var a = i ? Object.getOwnPropertyDescriptor(r, s) : null; a && (a.get || a.set) ? Object.defineProperty(n, s, a) : n[s] = r[s] } return n.default = r, t && t.set(r, n), n } function rr(r, e, t) { return e = une(e), e in r ? Object.defineProperty(r, e, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : r[e] = t, r } function une(r) { var e = dne(r, "string"); return typeof e == "symbol" ? e : String(e) } function dne(r, e) { if (typeof r != "object" || r === null) return r; var t = r[Symbol.toPrimitive]; if (t !== void 0) { var n = t.call(r, e || "default"); if (typeof n != "object") return n; throw new TypeError("@@toPrimitive must return a primitive value.") } return (e === "string" ? String : Number)(r) } const li = { touch: { start: "touchstart", move: "touchmove", stop: "touchend" }, mouse: { start: "mousedown", move: "mousemove", stop: "mouseup" } }; let ws = li.mouse, Rh = class extends Ip.Component { constructor() { super(...arguments), rr(this, "dragging", !1), rr(this, "lastX", NaN), rr(this, "lastY", NaN), rr(this, "touchIdentifier", null), rr(this, "mounted", !1), rr(this, "handleDragStart", e => { if (this.props.onMouseDown(e), !this.props.allowAnyClick && typeof e.button == "number" && e.button !== 0) return !1; const t = this.findDOMNode(); if (!t || !t.ownerDocument || !t.ownerDocument.body) throw new Error("<DraggableCore> not mounted on DragStart!"); const { ownerDocument: n } = t; if (this.props.disabled || !(e.target instanceof n.defaultView.Node) || this.props.handle && !(0, Gn.matchesSelectorAndParentsTo)(e.target, this.props.handle, t) || this.props.cancel && (0, Gn.matchesSelectorAndParentsTo)(e.target, this.props.cancel, t)) return; e.type === "touchstart" && e.preventDefault(); const i = (0, Gn.getTouchIdentifier)(e); this.touchIdentifier = i; const s = (0, xs.getControlPosition)(e, i, this); if (s == null) return; const { x: a, y: o } = s, l = (0, xs.createCoreData)(this, a, o); (0, vl.default)("DraggableCore: handleDragStart: %j", l), (0, vl.default)("calling", this.props.onStart), !(this.props.onStart(e, l) === !1 || this.mounted === !1) && (this.props.enableUserSelectHack && (0, Gn.addUserSelectStyles)(n), this.dragging = !0, this.lastX = a, this.lastY = o, (0, Gn.addEvent)(n, ws.move, this.handleDrag), (0, Gn.addEvent)(n, ws.stop, this.handleDragStop)) }), rr(this, "handleDrag", e => { const t = (0, xs.getControlPosition)(e, this.touchIdentifier, this); if (t == null) return; let { x: n, y: i } = t; if (Array.isArray(this.props.grid)) { let o = n - this.lastX, l = i - this.lastY; if ([o, l] = (0, xs.snapToGrid)(this.props.grid, o, l), !o && !l) return; n = this.lastX + o, i = this.lastY + l } const s = (0, xs.createCoreData)(this, n, i); if ((0, vl.default)("DraggableCore: handleDrag: %j", s), this.props.onDrag(e, s) === !1 || this.mounted === !1) { try { this.handleDragStop(new MouseEvent("mouseup")) } catch { const l = document.createEvent("MouseEvents"); l.initMouseEvent("mouseup", !0, !0, window, 0, 0, 0, 0, 0, !1, !1, !1, !1, 0, null), this.handleDragStop(l) } return } this.lastX = n, this.lastY = i }), rr(this, "handleDragStop", e => { if (!this.dragging) return; const t = (0, xs.getControlPosition)(e, this.touchIdentifier, this); if (t == null) return; let { x: n, y: i } = t; if (Array.isArray(this.props.grid)) { let l = n - this.lastX || 0, u = i - this.lastY || 0;[l, u] = (0, xs.snapToGrid)(this.props.grid, l, u), n = this.lastX + l, i = this.lastY + u } const s = (0, xs.createCoreData)(this, n, i); if (this.props.onStop(e, s) === !1 || this.mounted === !1) return !1; const o = this.findDOMNode(); o && this.props.enableUserSelectHack && (0, Gn.removeUserSelectStyles)(o.ownerDocument), (0, vl.default)("DraggableCore: handleDragStop: %j", s), this.dragging = !1, this.lastX = NaN, this.lastY = NaN, o && ((0, vl.default)("DraggableCore: Removing handlers"), (0, Gn.removeEvent)(o.ownerDocument, ws.move, this.handleDrag), (0, Gn.removeEvent)(o.ownerDocument, ws.stop, this.handleDragStop)) }), rr(this, "onMouseDown", e => (ws = li.mouse, this.handleDragStart(e))), rr(this, "onMouseUp", e => (ws = li.mouse, this.handleDragStop(e))), rr(this, "onTouchStart", e => (ws = li.touch, this.handleDragStart(e))), rr(this, "onTouchEnd", e => (ws = li.touch, this.handleDragStop(e))) } componentDidMount() { this.mounted = !0; const e = this.findDOMNode(); e && (0, Gn.addEvent)(e, li.touch.start, this.onTouchStart, { passive: !1 }) } componentWillUnmount() { this.mounted = !1; const e = this.findDOMNode(); if (e) { const { ownerDocument: t } = e; (0, Gn.removeEvent)(t, li.mouse.move, this.handleDrag), (0, Gn.removeEvent)(t, li.touch.move, this.handleDrag), (0, Gn.removeEvent)(t, li.mouse.stop, this.handleDragStop), (0, Gn.removeEvent)(t, li.touch.stop, this.handleDragStop), (0, Gn.removeEvent)(e, li.touch.start, this.onTouchStart, { passive: !1 }), this.props.enableUserSelectHack && (0, Gn.removeUserSelectStyles)(t) } } findDOMNode() { var e, t; return (e = this.props) !== null && e !== void 0 && e.nodeRef ? (t = this.props) === null || t === void 0 || (t = t.nodeRef) === null || t === void 0 ? void 0 : t.current : lne.default.findDOMNode(this) } render() { return Ip.cloneElement(Ip.Children.only(this.props.children), { onMouseDown: this.onMouseDown, onMouseUp: this.onMouseUp, onTouchEnd: this.onTouchEnd }) } }; Ph.default = Rh; rr(Rh, "displayName", "DraggableCore"); rr(Rh, "propTypes", { allowAnyClick: fr.default.bool, children: fr.default.node.isRequired, disabled: fr.default.bool, enableUserSelectHack: fr.default.bool, offsetParent: function (r, e) { if (r[e] && r[e].nodeType !== 1) throw new Error("Draggable's offsetParent must be a DOM Node.") }, grid: fr.default.arrayOf(fr.default.number), handle: fr.default.string, cancel: fr.default.string, nodeRef: fr.default.object, onStart: fr.default.func, onDrag: fr.default.func, onStop: fr.default.func, onMouseDown: fr.default.func, scale: fr.default.number, className: Pp.dontSetMe, style: Pp.dontSetMe, transform: Pp.dontSetMe }); rr(Rh, "defaultProps", { allowAnyClick: !1, disabled: !1, enableUserSelectHack: !0, onStart: function () { }, onDrag: function () { }, onStop: function () { }, onMouseDown: function () { }, scale: 1 }); (function (r) { Object.defineProperty(r, "__esModule", { value: !0 }), Object.defineProperty(r, "DraggableCore", { enumerable: !0, get: function () { return l.default } }), r.default = void 0; var e = g(R), t = d(oc), n = d(di), i = d(kte), s = fn, a = Yi, o = Gi, l = d(Ph), u = d(kh); function d(S) { return S && S.__esModule ? S : { default: S } } function h(S) { if (typeof WeakMap != "function") return null; var C = new WeakMap, O = new WeakMap; return (h = function (E) { return E ? O : C })(S) } function g(S, C) { if (S && S.__esModule) return S; if (S === null || typeof S != "object" && typeof S != "function") return { default: S }; var O = h(C); if (O && O.has(S)) return O.get(S); var E = {}, v = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var T in S) if (T !== "default" && Object.prototype.hasOwnProperty.call(S, T)) { var I = v ? Object.getOwnPropertyDescriptor(S, T) : null; I && (I.get || I.set) ? Object.defineProperty(E, T, I) : E[T] = S[T] } return E.default = S, O && O.set(S, E), E } function m() { return m = Object.assign ? Object.assign.bind() : function (S) { for (var C = 1; C < arguments.length; C++) { var O = arguments[C]; for (var E in O) Object.prototype.hasOwnProperty.call(O, E) && (S[E] = O[E]) } return S }, m.apply(this, arguments) } function b(S, C, O) { return C = y(C), C in S ? Object.defineProperty(S, C, { value: O, enumerable: !0, configurable: !0, writable: !0 }) : S[C] = O, S } function y(S) { var C = w(S, "string"); return typeof C == "symbol" ? C : String(C) } function w(S, C) { if (typeof S != "object" || S === null) return S; var O = S[Symbol.toPrimitive]; if (O !== void 0) { var E = O.call(S, C || "default"); if (typeof E != "object") return E; throw new TypeError("@@toPrimitive must return a primitive value.") } return (C === "string" ? String : Number)(S) } class x extends e.Component { static getDerivedStateFromProps(C, O) { let { position: E } = C, { prevPropsPosition: v } = O; return E && (!v || E.x !== v.x || E.y !== v.y) ? ((0, u.default)("Draggable: getDerivedStateFromProps %j", { position: E, prevPropsPosition: v }), { x: E.x, y: E.y, prevPropsPosition: { ...E } }) : null } constructor(C) { super(C), b(this, "onDragStart", (O, E) => { if ((0, u.default)("Draggable: onDragStart: %j", E), this.props.onStart(O, (0, a.createDraggableData)(this, E)) === !1) return !1; this.setState({ dragging: !0, dragged: !0 }) }), b(this, "onDrag", (O, E) => { if (!this.state.dragging) return !1; (0, u.default)("Draggable: onDrag: %j", E); const v = (0, a.createDraggableData)(this, E), T = { x: v.x, y: v.y, slackX: 0, slackY: 0 }; if (this.props.bounds) { const { x: k, y: P } = T; T.x += this.state.slackX, T.y += this.state.slackY; const [N, M] = (0, a.getBoundPosition)(this, T.x, T.y); T.x = N, T.y = M, T.slackX = this.state.slackX + (k - T.x), T.slackY = this.state.slackY + (P - T.y), v.x = T.x, v.y = T.y, v.deltaX = T.x - this.state.x, v.deltaY = T.y - this.state.y } if (this.props.onDrag(O, v) === !1) return !1; this.setState(T) }), b(this, "onDragStop", (O, E) => { if (!this.state.dragging || this.props.onStop(O, (0, a.createDraggableData)(this, E)) === !1) return !1; (0, u.default)("Draggable: onDragStop: %j", E); const T = { dragging: !1, slackX: 0, slackY: 0 }; if (!!this.props.position) { const { x: k, y: P } = this.props.position; T.x = k, T.y = P } this.setState(T) }), this.state = { dragging: !1, dragged: !1, x: C.position ? C.position.x : C.defaultPosition.x, y: C.position ? C.position.y : C.defaultPosition.y, prevPropsPosition: { ...C.position }, slackX: 0, slackY: 0, isElementSVG: !1 }, C.position && !(C.onDrag || C.onStop) && console.warn("A `position` was applied to this <Draggable>, without drag handlers. This will make this component effectively undraggable. Please attach `onDrag` or `onStop` handlers so you can adjust the `position` of this element.") } componentDidMount() { typeof window.SVGElement < "u" && this.findDOMNode() instanceof window.SVGElement && this.setState({ isElementSVG: !0 }) } componentWillUnmount() { this.setState({ dragging: !1 }) } findDOMNode() { var C, O; return (C = (O = this.props) === null || O === void 0 || (O = O.nodeRef) === null || O === void 0 ? void 0 : O.current) !== null && C !== void 0 ? C : n.default.findDOMNode(this) } render() { const { axis: C, bounds: O, children: E, defaultPosition: v, defaultClassName: T, defaultClassNameDragging: I, defaultClassNameDragged: k, position: P, positionOffset: N, scale: M, ...B } = this.props; let K = {}, U = null; const Z = !!!P || this.state.dragging, J = P || v, ee = { x: (0, a.canDragX)(this) && Z ? this.state.x : J.x, y: (0, a.canDragY)(this) && Z ? this.state.y : J.y }; this.state.isElementSVG ? U = (0, s.createSVGTransform)(ee, N) : K = (0, s.createCSSTransform)(ee, N); const $ = (0, i.default)(E.props.className || "", T, { [I]: this.state.dragging, [k]: this.state.dragged }); return e.createElement(l.default, m({}, B, { onStart: this.onDragStart, onDrag: this.onDrag, onStop: this.onDragStop }), e.cloneElement(e.Children.only(E), { className: $, style: { ...E.props.style, ...K }, transform: U })) } } r.default = x, b(x, "displayName", "Draggable"), b(x, "propTypes", { ...l.default.propTypes, axis: t.default.oneOf(["both", "x", "y", "none"]), bounds: t.default.oneOfType([t.default.shape({ left: t.default.number, right: t.default.number, top: t.default.number, bottom: t.default.number }), t.default.string, t.default.oneOf([!1])]), defaultClassName: t.default.string, defaultClassNameDragging: t.default.string, defaultClassNameDragged: t.default.string, defaultPosition: t.default.shape({ x: t.default.number, y: t.default.number }), positionOffset: t.default.shape({ x: t.default.oneOfType([t.default.number, t.default.string]), y: t.default.oneOfType([t.default.number, t.default.string]) }), position: t.default.shape({ x: t.default.number, y: t.default.number }), className: o.dontSetMe, style: o.dontSetMe, transform: o.dontSetMe }), b(x, "defaultProps", { ...l.default.defaultProps, axis: "both", bounds: !1, defaultClassName: "react-draggable", defaultClassNameDragging: "react-draggable-dragging", defaultClassNameDragged: "react-draggable-dragged", defaultPosition: { x: 0, y: 0 }, scale: 1 }) })(LO); const { default: WO, DraggableCore: hne } = LO; Ih.exports = WO; Ih.exports.default = WO; Ih.exports.DraggableCore = hne; var pne = Ih.exports, hb = {}; hb.__esModule = !0; hb.cloneElement = vne; var fne = gne(R); function gne(r) { return r && r.__esModule ? r : { default: r } } function hw(r, e) { var t = Object.keys(r); if (Object.getOwnPropertySymbols) { var n = Object.getOwnPropertySymbols(r); e && (n = n.filter(function (i) { return Object.getOwnPropertyDescriptor(r, i).enumerable })), t.push.apply(t, n) } return t } function pw(r) { for (var e = 1; e < arguments.length; e++) { var t = arguments[e] != null ? arguments[e] : {}; e % 2 ? hw(Object(t), !0).forEach(function (n) { mne(r, n, t[n]) }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(r, Object.getOwnPropertyDescriptors(t)) : hw(Object(t)).forEach(function (n) { Object.defineProperty(r, n, Object.getOwnPropertyDescriptor(t, n)) }) } return r } function mne(r, e, t) { return e = yne(e), e in r ? Object.defineProperty(r, e, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : r[e] = t, r } function yne(r) { var e = bne(r, "string"); return typeof e == "symbol" ? e : String(e) } function bne(r, e) { if (typeof r != "object" || r === null) return r; var t = r[Symbol.toPrimitive]; if (t !== void 0) { var n = t.call(r, e || "default"); if (typeof n != "object") return n; throw new TypeError("@@toPrimitive must return a primitive value.") } return (e === "string" ? String : Number)(r) } function vne(r, e) { return e.style && r.props.style && (e.style = pw(pw({}, r.props.style), e.style)), e.className && r.props.className && (e.className = r.props.className + " " + e.className), fne.default.cloneElement(r, e) } var Vc = {}; Vc.__esModule = !0; Vc.resizableProps = void 0; var Be = xne(oc); function xne(r) { return r && r.__esModule ? r : { default: r } } var wne = { axis: Be.default.oneOf(["both", "x", "y", "none"]), className: Be.default.string, children: Be.default.element.isRequired, draggableOpts: Be.default.shape({ allowAnyClick: Be.default.bool, cancel: Be.default.string, children: Be.default.node, disabled: Be.default.bool, enableUserSelectHack: Be.default.bool, offsetParent: Be.default.node, grid: Be.default.arrayOf(Be.default.number), handle: Be.default.string, nodeRef: Be.default.object, onStart: Be.default.func, onDrag: Be.default.func, onStop: Be.default.func, onMouseDown: Be.default.func, scale: Be.default.number }), height: function () { for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)t[n] = arguments[n]; var i = t[0]; if (i.axis === "both" || i.axis === "y") { var s; return (s = Be.default.number).isRequired.apply(s, t) } return Be.default.number.apply(Be.default, t) }, handle: Be.default.oneOfType([Be.default.node, Be.default.func]), handleSize: Be.default.arrayOf(Be.default.number), lockAspectRatio: Be.default.bool, maxConstraints: Be.default.arrayOf(Be.default.number), minConstraints: Be.default.arrayOf(Be.default.number), onResizeStop: Be.default.func, onResizeStart: Be.default.func, onResize: Be.default.func, resizeHandles: Be.default.arrayOf(Be.default.oneOf(["s", "w", "e", "n", "sw", "nw", "se", "ne"])), transformScale: Be.default.number, width: function () { for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)t[n] = arguments[n]; var i = t[0]; if (i.axis === "both" || i.axis === "x") { var s; return (s = Be.default.number).isRequired.apply(s, t) } return Be.default.number.apply(Be.default, t) } }; Vc.resizableProps = wne; jc.__esModule = !0; jc.default = void 0; var xl = One(R), Cne = pne, Sne = hb, Ene = Vc, _ne = ["children", "className", "draggableOpts", "width", "height", "handle", "handleSize", "lockAspectRatio", "axis", "minConstraints", "maxConstraints", "onResize", "onResizeStop", "onResizeStart", "resizeHandles", "transformScale"]; function GO(r) { if (typeof WeakMap != "function") return null; var e = new WeakMap, t = new WeakMap; return (GO = function (i) { return i ? t : e })(r) } function One(r, e) { if (r && r.__esModule) return r; if (r === null || typeof r != "object" && typeof r != "function") return { default: r }; var t = GO(e); if (t && t.has(r)) return t.get(r); var n = {}, i = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var s in r) if (s !== "default" && Object.prototype.hasOwnProperty.call(r, s)) { var a = i ? Object.getOwnPropertyDescriptor(r, s) : null; a && (a.get || a.set) ? Object.defineProperty(n, s, a) : n[s] = r[s] } return n.default = r, t && t.set(r, n), n } function jg() { return jg = Object.assign ? Object.assign.bind() : function (r) { for (var e = 1; e < arguments.length; e++) { var t = arguments[e]; for (var n in t) Object.prototype.hasOwnProperty.call(t, n) && (r[n] = t[n]) } return r }, jg.apply(this, arguments) } function Tne(r, e) { if (r == null) return {}; var t = {}, n = Object.keys(r), i, s; for (s = 0; s < n.length; s++)i = n[s], !(e.indexOf(i) >= 0) && (t[i] = r[i]); return t } function fw(r, e) { var t = Object.keys(r); if (Object.getOwnPropertySymbols) { var n = Object.getOwnPropertySymbols(r); e && (n = n.filter(function (i) { return Object.getOwnPropertyDescriptor(r, i).enumerable })), t.push.apply(t, n) } return t } function kp(r) { for (var e = 1; e < arguments.length; e++) { var t = arguments[e] != null ? arguments[e] : {}; e % 2 ? fw(Object(t), !0).forEach(function (n) { Ine(r, n, t[n]) }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(r, Object.getOwnPropertyDescriptors(t)) : fw(Object(t)).forEach(function (n) { Object.defineProperty(r, n, Object.getOwnPropertyDescriptor(t, n)) }) } return r } function Ine(r, e, t) { return e = Pne(e), e in r ? Object.defineProperty(r, e, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : r[e] = t, r } function Pne(r) { var e = kne(r, "string"); return typeof e == "symbol" ? e : String(e) } function kne(r, e) { if (typeof r != "object" || r === null) return r; var t = r[Symbol.toPrimitive]; if (t !== void 0) { var n = t.call(r, e || "default"); if (typeof n != "object") return n; throw new TypeError("@@toPrimitive must return a primitive value.") } return (e === "string" ? String : Number)(r) } function Rne(r, e) { r.prototype = Object.create(e.prototype), r.prototype.constructor = r, Vg(r, e) } function Vg(r, e) { return Vg = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (n, i) { return n.__proto__ = i, n }, Vg(r, e) } var pb = function (r) { Rne(e, r); function e() { for (var n, i = arguments.length, s = new Array(i), a = 0; a < i; a++)s[a] = arguments[a]; return n = r.call.apply(r, [this].concat(s)) || this, n.handleRefs = {}, n.lastHandleRect = null, n.slack = null, n } var t = e.prototype; return t.componentWillUnmount = function () { this.resetData() }, t.resetData = function () { this.lastHandleRect = this.slack = null }, t.runConstraints = function (i, s) { var a = this.props, o = a.minConstraints, l = a.maxConstraints, u = a.lockAspectRatio; if (!o && !l && !u) return [i, s]; if (u) { var d = this.props.width / this.props.height, h = i - this.props.width, g = s - this.props.height; Math.abs(h) > Math.abs(g * d) ? s = i / d : i = s * d } var m = i, b = s, y = this.slack || [0, 0], w = y[0], x = y[1]; return i += w, s += x, o && (i = Math.max(o[0], i), s = Math.max(o[1], s)), l && (i = Math.min(l[0], i), s = Math.min(l[1], s)), this.slack = [w + (m - i), x + (b - s)], [i, s] }, t.resizeHandler = function (i, s) { var a = this; return function (o, l) { var u = l.node, d = l.deltaX, h = l.deltaY; i === "onResizeStart" && a.resetData(); var g = (a.props.axis === "both" || a.props.axis === "x") && s !== "n" && s !== "s", m = (a.props.axis === "both" || a.props.axis === "y") && s !== "e" && s !== "w"; if (!(!g && !m)) { var b = s[0], y = s[s.length - 1], w = u.getBoundingClientRect(); if (a.lastHandleRect != null) { if (y === "w") { var x = w.left - a.lastHandleRect.left; d += x } if (b === "n") { var S = w.top - a.lastHandleRect.top; h += S } } a.lastHandleRect = w, y === "w" && (d = -d), b === "n" && (h = -h); var C = a.props.width + (g ? d / a.props.transformScale : 0), O = a.props.height + (m ? h / a.props.transformScale : 0), E = a.runConstraints(C, O); C = E[0], O = E[1]; var v = C !== a.props.width || O !== a.props.height, T = typeof a.props[i] == "function" ? a.props[i] : null, I = i === "onResize" && !v; T && !I && (o.persist == null || o.persist(), T(o, { node: u, size: { width: C, height: O }, handle: s })), i === "onResizeStop" && a.resetData() } } }, t.renderResizeHandle = function (i, s) { var a = this.props.handle; if (!a) return xl.createElement("span", { className: "react-resizable-handle react-resizable-handle-" + i, ref: s }); if (typeof a == "function") return a(i, s); var o = typeof a.type == "string", l = kp({ ref: s }, o ? {} : { handleAxis: i }); return xl.cloneElement(a, l) }, t.render = function () { var i = this, s = this.props, a = s.children, o = s.className, l = s.draggableOpts; s.width, s.height, s.handle, s.handleSize, s.lockAspectRatio, s.axis, s.minConstraints, s.maxConstraints, s.onResize, s.onResizeStop, s.onResizeStart; var u = s.resizeHandles; s.transformScale; var d = Tne(s, _ne); return (0, Sne.cloneElement)(a, kp(kp({}, d), {}, { className: (o ? o + " " : "") + "react-resizable", children: [].concat(a.props.children, u.map(function (h) { var g, m = (g = i.handleRefs[h]) != null ? g : i.handleRefs[h] = xl.createRef(); return xl.createElement(Cne.DraggableCore, jg({}, l, { nodeRef: m, key: "resizableHandle-" + h, onStop: i.resizeHandler("onResizeStop", h), onStart: i.resizeHandler("onResizeStart", h), onDrag: i.resizeHandler("onResize", h) }), i.renderResizeHandle(h, m)) })) })) }, e }(xl.Component); jc.default = pb; pb.propTypes = Ene.resizableProps; pb.defaultProps = { axis: "both", handleSize: [20, 20], lockAspectRatio: !1, minConstraints: [20, 20], maxConstraints: [1 / 0, 1 / 0], resizeHandles: ["se"], transformScale: 1 }; var Dh = {}; Dh.__esModule = !0; Dh.default = void 0; var Rp = $ne(R), Dne = YO(oc), Ane = YO(jc), Nne = Vc, Fne = ["handle", "handleSize", "onResize", "onResizeStart", "onResizeStop", "draggableOpts", "minConstraints", "maxConstraints", "lockAspectRatio", "axis", "width", "height", "resizeHandles", "style", "transformScale"]; function YO(r) { return r && r.__esModule ? r : { default: r } } function XO(r) { if (typeof WeakMap != "function") return null; var e = new WeakMap, t = new WeakMap; return (XO = function (i) { return i ? t : e })(r) } function $ne(r, e) { if (r && r.__esModule) return r; if (r === null || typeof r != "object" && typeof r != "function") return { default: r }; var t = XO(e); if (t && t.has(r)) return t.get(r); var n = {}, i = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var s in r) if (s !== "default" && Object.prototype.hasOwnProperty.call(r, s)) { var a = i ? Object.getOwnPropertyDescriptor(r, s) : null; a && (a.get || a.set) ? Object.defineProperty(n, s, a) : n[s] = r[s] } return n.default = r, t && t.set(r, n), n } function Bg() { return Bg = Object.assign ? Object.assign.bind() : function (r) { for (var e = 1; e < arguments.length; e++) { var t = arguments[e]; for (var n in t) Object.prototype.hasOwnProperty.call(t, n) && (r[n] = t[n]) } return r }, Bg.apply(this, arguments) } function gw(r, e) { var t = Object.keys(r); if (Object.getOwnPropertySymbols) { var n = Object.getOwnPropertySymbols(r); e && (n = n.filter(function (i) { return Object.getOwnPropertyDescriptor(r, i).enumerable })), t.push.apply(t, n) } return t } function bd(r) { for (var e = 1; e < arguments.length; e++) { var t = arguments[e] != null ? arguments[e] : {}; e % 2 ? gw(Object(t), !0).forEach(function (n) { Lne(r, n, t[n]) }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(r, Object.getOwnPropertyDescriptors(t)) : gw(Object(t)).forEach(function (n) { Object.defineProperty(r, n, Object.getOwnPropertyDescriptor(t, n)) }) } return r } function Lne(r, e, t) { return e = Mne(e), e in r ? Object.defineProperty(r, e, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : r[e] = t, r } function Mne(r) { var e = jne(r, "string"); return typeof e == "symbol" ? e : String(e) } function jne(r, e) { if (typeof r != "object" || r === null) return r; var t = r[Symbol.toPrimitive]; if (t !== void 0) { var n = t.call(r, e || "default"); if (typeof n != "object") return n; throw new TypeError("@@toPrimitive must return a primitive value.") } return (e === "string" ? String : Number)(r) } function Vne(r, e) { if (r == null) return {}; var t = {}, n = Object.keys(r), i, s; for (s = 0; s < n.length; s++)i = n[s], !(e.indexOf(i) >= 0) && (t[i] = r[i]); return t } function Bne(r, e) { r.prototype = Object.create(e.prototype), r.prototype.constructor = r, zg(r, e) } function zg(r, e) { return zg = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (n, i) { return n.__proto__ = i, n }, zg(r, e) } var qO = function (r) { Bne(e, r); function e() { for (var n, i = arguments.length, s = new Array(i), a = 0; a < i; a++)s[a] = arguments[a]; return n = r.call.apply(r, [this].concat(s)) || this, n.state = { width: n.props.width, height: n.props.height, propsWidth: n.props.width, propsHeight: n.props.height }, n.onResize = function (o, l) { var u = l.size; n.props.onResize ? (o.persist == null || o.persist(), n.setState(u, function () { return n.props.onResize && n.props.onResize(o, l) })) : n.setState(u) }, n } e.getDerivedStateFromProps = function (i, s) { return s.propsWidth !== i.width || s.propsHeight !== i.height ? { width: i.width, height: i.height, propsWidth: i.width, propsHeight: i.height } : null }; var t = e.prototype; return t.render = function () { var i = this.props, s = i.handle, a = i.handleSize; i.onResize; var o = i.onResizeStart, l = i.onResizeStop, u = i.draggableOpts, d = i.minConstraints, h = i.maxConstraints, g = i.lockAspectRatio, m = i.axis; i.width, i.height; var b = i.resizeHandles, y = i.style, w = i.transformScale, x = Vne(i, Fne); return Rp.createElement(Ane.default, { axis: m, draggableOpts: u, handle: s, handleSize: a, height: this.state.height, lockAspectRatio: g, maxConstraints: h, minConstraints: d, onResizeStart: o, onResize: this.onResize, onResizeStop: l, resizeHandles: b, transformScale: w, width: this.state.width }, Rp.createElement("div", Bg({}, x, { style: bd(bd({}, y), {}, { width: this.state.width + "px", height: this.state.height + "px" }) }))) }, e }(Rp.Component); Dh.default = qO; qO.propTypes = bd(bd({}, Nne.resizableProps), {}, { children: Dne.default.element }); lb.exports = function () { throw new Error("Don't instantiate Resizable directly! Use require('react-resizable').Resizable") }; var zne = lb.exports.Resizable = jc.default; lb.exports.ResizableBox = Dh.default; var Hne = function (r, e) { var t = {}; for (var n in r) Object.prototype.hasOwnProperty.call(r, n) && e.indexOf(n) < 0 && (t[n] = r[n]); if (r != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, n = Object.getOwnPropertySymbols(r); i < n.length; i++)e.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(r, n[i]) && (t[n[i]] = r[n[i]]); return t }; class Kne extends f.PureComponent { render() { const e = this.props, { onResize: t, onResizeStart: n, onResizeStop: i, width: s, resize: a } = e, o = Hne(e, ["onResize", "onResizeStart", "onResizeStop", "width", "resize"]); if (typeof s != "number" || a === !1) return f.createElement("th", Object.assign({}, o)); let { children: l } = o; return l = f.Children.map(l, (u, d) => f.createElement(f.Fragment, { key: d }, u)), f.createElement(zne, { width: s, height: 0, onResize: t, onResizeStart: n, onResizeStop: i, draggableOpts: { enableUserSelectHack: !1 }, axis: "x" }, f.createElement("th", Object.assign({}, o), l)) } } var Une = function (r, e) { var t = {}; for (var n in r) Object.prototype.hasOwnProperty.call(r, n) && e.indexOf(n) < 0 && (t[n] = r[n]); if (r != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, n = Object.getOwnPropertySymbols(r); i < n.length; i++)e.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(r, n[i]) && (t[n[i]] = r[n[i]]); return t }; const Wne = function () { let r = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, e = arguments.length > 1 ? arguments[1] : void 0; const { components: t, columns: n, resizable: i } = r, s = Une(r, ["components", "columns", "resizable"]), a = "children", o = H(i, "onResize", z), l = H(i, "onResizeStart", z), u = H(i, "onResizeStop", z), d = Array.isArray(n) && n.length ? n : md(r.children), h = gd(Hr(d), a), g = gd(Hr(d), a); typeof r.expandedRowRender == "function" && !r.hideExpandedColumn && !Ui(h, T => T.key === Te.DEFAULT_KEY_COLUMN_EXPAND) && g.unshift({ key: Te.DEFAULT_KEY_COLUMN_EXPAND, width: On.DEFAULT_WIDTH_COLUMN_EXPAND }), r.rowSelection && !H(r.rowSelection, "hidden") && !Ui(h, T => T.key === Te.DEFAULT_KEY_COLUMN_SELECTION) && g.unshift({ width: H(r, "rowSelection.width", On.DEFAULT_WIDTH_COLUMN_SELECTION), key: Te.DEFAULT_KEY_COLUMN_SELECTION }); const [m, b] = R.useState(g); R.useEffect(() => { const T = qJ(m, g); b(Ng(m, T)) }, [n, r.expandedRowRender, r.hideExpandedColumn, r.rowSelection]); const y = R.useMemo(() => gc({ header: { cell: Kne } }, t), [t]), w = H(i, "handlerClassName", "resizing"), x = T => (I, k) => { let { size: P } = k; const N = Hr(m), M = Vu(N, T, a); let B = Object.assign(Object.assign({}, M), { width: P.width }); const K = o(B) || {}; B = Object.assign(Object.assign({}, B), K), Object.assign(M, B), b(N) }, S = T => I => { const k = Hr(m), P = Vu(k, T, a); let N = Object.assign(Object.assign({}, P), { className: Tte(P.className, w) }); const M = l(N) || {}; N = Object.assign(Object.assign({}, N), M), Object.assign(P, N), b(k) }, C = T => I => { const k = Hr(m), P = Vu(k, T, a); let N = Object.assign(Object.assign({}, P), { className: Ite(P.className, w) }); const M = u(N) || {}; N = Object.assign(Object.assign({}, N), M), Object.assign(P, N), b(k) }, O = function (T, I) { let k = arguments.length > 3 ? arguments[3] : void 0; return Object.assign(Object.assign({}, T), { onHeaderCell: P => Object.assign(Object.assign({}, k), { width: P.width, onResize: x(P), onResizeStart: S(P), onResizeStop: C(P) }) }) }, E = function () { let T = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [], I = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0; return Array.isArray(T) && T.length ? T.map((k, P) => { var N, M; const B = (M = (N = k.onHeaderCell) === null || N === void 0 ? void 0 : N.call(k, k, P, I)) !== null && M !== void 0 ? M : {}; Object.assign(k, O(k, P, I, B)); const K = k[a]; return Array.isArray(K) && K.length && (k[a] = E(K, I + 1)), k }) : [] }, v = R.useMemo(() => E(m), [m]); return f.createElement(nl, Object.assign({}, s, { columns: v, components: y, ref: e })) }, Gne = f.forwardRef(Wne); class Na extends f.PureComponent { constructor(e) { super(e), this.getCurrentPageData = () => this.tableRef.current && this.tableRef.current.getCurrentPageData(), this.tableRef = f.createRef() } render() { var e; const t = this.props, n = (e = this.props.direction) !== null && e !== void 0 ? e : this.context.direction; return t.resizable ? f.createElement(Gne, Object.assign({}, t, { ref: this.tableRef, direction: n })) : f.createElement(nl, Object.assign({}, t, { ref: this.tableRef, direction: n })) } } Na.Column = Sh; Na.DEFAULT_KEY_COLUMN_SELECTION = Te.DEFAULT_KEY_COLUMN_SELECTION; Na.DEFAULT_KEY_COLUMN_EXPAND = Te.DEFAULT_KEY_COLUMN_EXPAND; Na.propTypes = Object.assign(Object.assign({}, nl.propTypes), { resizable: c.oneOfType([c.bool, c.object]) }); Na.defaultProps = { hideExpandedColumn: !0 }; Na.contextType = An; const je = { TABS: `${G}-tabs`, TABS_BAR: `${G}-tabs-bar`, TABS_BAR_LINE: `${G}-tabs-bar-line`, TABS_BAR_CARD: `${G}-tabs-bar-card`, TABS_BAR_BUTTON: `${G}-tabs-bar-button`, TABS_BAR_SLASH: `${G}-tabs-bar-slash`, TABS_BAR_EXTRA: `${G}-tabs-bar-extra`, TABS_TAB: `${G}-tabs-tab`, TABS_TAB_ACTIVE: `${G}-tabs-tab-active`, TABS_TAB_DISABLED: `${G}-tabs-tab-disabled`, TABS_CONTENT: `${G}-tabs-content`, TABS_CONTENT_ANIMATED: `${G}-tabs-content-animated`, TABS_CONTENT_NO_ANIMATED: `${G}-tabs-content-no-animated`, TABS_PANE: `${G}-tabs-pane`, TABS_PANE_INACTIVE: `${G}-tabs-pane-inactive`, TABS_PANE_ACTIVE: `${G}-tabs-pane-active`, TABS_PANE_MOTION_OVERLAY: `${G}-tabs-pane-motion-overlay`, TABS_PANE_ANIMATING: `${G}-tabs-pane-animating`, TABS_PANE_ANIMATE_LEFT_SHOW: `${G}-tabs-pane-animate-leftShow`, TABS_PANE_ANIMATE_RIGHT_SHOW: `${G}-tabs-pane-animate-rightShow`, TABS_PANE_ANIMATE_TOP_SHOW: `${G}-tabs-pane-animate-topShow`, TABS_PANE_ANIMATE_BOTTOM_SHOW: `${G}-tabs-pane-animate-bottomShow` }, mo = { TYPE_MAP: ["line", "card", "button", "slash"], SIZE: ["small", "medium", "large"], POSITION_MAP: ["top", "left"] }; class Yne extends ve { constructor(e) { super(Object.assign({}, e)), this.destroy = z, this.handlePrevent = t => { t.stopPropagation(), t.preventDefault() }, this.handleKeyDown = (t, n, i) => { const { preventScroll: s } = this.getProps(), a = [...t.target.parentNode.childNodes].filter(o => H(o, "attributes.data-tabkey.value", "").includes("semiTab") && H(o, "attributes.aria-disabled.value", "") !== "true"); switch (t.key) { case "ArrowLeft": case "ArrowRight": case "ArrowUp": case "ArrowDown": this.determineOrientation(t, a); break; case "Backspace": case "Delete": this.handleDeleteKeyDown(t, a, n, i); break; case "Enter": case " ": this.handleTabClick(n, t), this.handlePrevent(t); break; case "Home": a[0].focus({ preventScroll: s }), this.handlePrevent(t); break; case "End": a[a.length - 1].focus({ preventScroll: s }), this.handlePrevent(t); break } } } init() { this._adapter.collectPane() } _notifyChange(e) { const { activeKey: t } = this.getStates(); t !== e && this._adapter.notifyChange(e) } handleTabClick(e, t) { this._isInProps("activeKey") ? this._notifyChange(e) : (this._notifyChange(e), this.handleNewActiveKey(e)), this._adapter.notifyTabClick(e, t) } handleNewActiveKey(e) { const { activeKey: t } = this.getStates(); t !== e && this._adapter.setNewActiveKey(e) } getDefaultActiveKey() { let e; const t = this.getProps(); return "activeKey" in t ? e = t.activeKey : "defaultActiveKey" in t ? e = t.defaultActiveKey : e = this._adapter.getDefaultActiveKeyFromChildren(), e } handleTabListChange() { this._adapter.collectPane() } handleTabPanesChange() { this._adapter.collectPane(), this._adapter.collectActiveKey() } handleTabDelete(e) { this._adapter.notifyTabDelete(e) } determineOrientation(e, t) { const { tabPosition: n } = this.getProps(); n === "left" ? (e.key === "ArrowUp" || e.key === "ArrowDown") && (this.switchTabOnArrowPress(e, t), this.handlePrevent(e)) : (e.key === "ArrowLeft" || e.key === "ArrowRight") && (this.switchTabOnArrowPress(e, t), this.handlePrevent(e)) } handleDeleteKeyDown(e, t, n, i) { const { preventScroll: s } = this.getProps(); if (i) { this.handleTabDelete(n); const a = t.indexOf(e.target); t.length !== 1 && t[a + 1 >= t.length ? a - 1 : a + 1].focus({ preventScroll: s }) } } switchTabOnArrowPress(e, t) { const { preventScroll: n } = this.getProps(), i = t.indexOf(e.target), s = { ArrowLeft: -1, ArrowUp: -1, ArrowRight: 1, ArrowDown: 1 }; s[e.key] && i !== void 0 && (t[i + s[e.key]] ? t[i + s[e.key]].focus({ preventScroll: n }) : e.key === "ArrowLeft" || e.key === "ArrowUp" ? t[t.length - 1].focus({ preventScroll: n }) : (e.key === "ArrowRight" || e.key == "ArrowDown") && t[0].focus({ preventScroll: n })) } } var Xne = function (r, e) { var t = {}; for (var n in r) Object.prototype.hasOwnProperty.call(r, n) && e.indexOf(n) < 0 && (t[n] = r[n]); if (r != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, n = Object.getOwnPropertySymbols(r); i < n.length; i++)e.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(r, n[i]) && (t[n[i]] = r[n[i]]); return t }; const qne = (r, e) => { const { tab: t, size: n, type: i, icon: s, selected: a, closable: o, disabled: l, itemKey: u, deleteTabItem: d, tabPosition: h, handleKeyDown: g, onClick: m } = r, b = Xne(r, ["tab", "size", "type", "icon", "selected", "closable", "disabled", "itemKey", "deleteTabItem", "tabPosition", "handleKeyDown", "onClick"]), y = R.useMemo(() => o ? f.createElement(ds, { "aria-label": "Close", role: "button", className: `${je.TABS_TAB}-icon-close`, onClick: E => d(u, E) }) : null, [i, o, d, u]), w = R.useCallback(E => f.createElement("span", { className: `${je.TABS_BAR}-icon` }, E), []), x = R.useCallback(E => { g && g(E, u, o) }, [g, u, o]), S = R.useCallback(E => { !l && m && m(u, E) }, [u, l, m]), C = s ? w(s) : null, O = F(je.TABS_TAB, `${je.TABS_TAB}-${i}`, `${je.TABS_TAB}-${h}`, `${je.TABS_TAB}-single`, { [je.TABS_TAB_ACTIVE]: a, [je.TABS_TAB_DISABLED]: l, [`${je.TABS_TAB}-small`]: n === "small", [`${je.TABS_TAB}-medium`]: n === "medium" }); return f.createElement("div", Object.assign({ role: "tab", id: `semiTab${u}`, "data-tabkey": `semiTab${u}`, "aria-controls": `semiTabPanel${u}`, "aria-disabled": l ? "true" : "false", "aria-selected": a ? "true" : "false", tabIndex: a ? 0 : -1, onKeyDown: x, onClick: S, className: O }, b, { ref: e }), C, t, y) }, fb = R.forwardRef(qne); fb.elementType = "Tabs.TabItem"; var Zne = function (r, e) { var t = {}; for (var n in r) Object.prototype.hasOwnProperty.call(r, n) && e.indexOf(n) < 0 && (t[n] = r[n]); if (r != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, n = Object.getOwnPropertySymbols(r); i < n.length; i++)e.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(r, n[i]) && (t[n[i]] = r[n[i]]); return t }; class Hg extends f.Component { constructor(e) { var t; super(e), t = this, this.handleItemClick = (n, i) => { this.props.onTabClick(n, i) }, this.handleKeyDown = (n, i, s) => { this.props.handleKeyDown(n, i, s) }, this.renderTabItem = n => { const { size: i, type: s, deleteTabItem: a, handleKeyDown: o, tabPosition: l } = this.props, u = this._isActive(n.itemKey); return f.createElement(fb, Object.assign({}, cr(n, ["disabled", "icon", "itemKey", "tab", "closable"]), { key: this._getBarItemKeyByItemKey(n.itemKey), selected: u, size: i, type: s, tabPosition: l, handleKeyDown: o, deleteTabItem: a, onClick: this.handleItemClick })) }, this.scrollTabItemIntoViewByKey = function (n) { let i = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "nearest"; const s = document.querySelector(`[data-uuid="${t.state.uuid}"] .${je.TABS_TAB}[data-scrollkey="${n}"]`); s == null || s.scrollIntoView({ behavior: "smooth", block: i, inline: i }) }, this.scrollActiveTabItemIntoView = n => { const i = this._getBarItemKeyByItemKey(this.props.activeKey); this.scrollTabItemIntoViewByKey(i, n) }, this.renderTabComponents = n => n.map(i => this.renderTabItem(i)), this.handleArrowClick = (n, i) => { const s = i === "start" ? n.pop() : n.shift(); if (!s) return; const a = this._getBarItemKeyByItemKey(s.itemKey); this.scrollTabItemIntoViewByKey(a) }, this.renderCollapse = (n, i, s) => { var a; const o = F({ [`${je.TABS_BAR}-arrow-${s}`]: s, [`${je.TABS_BAR}-arrow`]: !0 }); if (kt(n)) return f.createElement("div", { role: "presentation", className: o }, f.createElement(St, { disabled: !0, icon: i, theme: "borderless" })); const { dropdownClassName: l, dropdownStyle: u, showRestInDropdown: d, dropdownProps: h } = this.props, { rePosKey: g } = this.state, m = !n.length, b = f.createElement(Jt.Menu, null, n.map(S => { const { icon: C, tab: O, itemKey: E } = S, v = C ? this.renderIcon(S.icon) : null; return f.createElement(Jt.Item, { key: E, onClick: T => this.handleItemClick(E, T), active: this._isActive(E) }, v, O) })), y = f.createElement("div", { role: "presentation", className: o, onClick: S => this.handleArrowClick(n, s) }, f.createElement(St, { disabled: m, icon: i, theme: "borderless" })), w = F(l, { [`${je.TABS_BAR}-dropdown`]: !0 }), x = (a = h == null ? void 0 : h[s]) !== null && a !== void 0 ? a : {}; return f.createElement(f.Fragment, null, d ? f.createElement(Jt, Object.assign({ className: w, clickToHide: !0, clickTriggerToHide: !0, key: `${g}-${s}`, position: s === "start" ? "bottomLeft" : "bottomRight", render: m ? null : b, showTick: !0, style: u, trigger: "hover", disableFocusListener: !0 }, x), y) : y) }, this.renderOverflow = n => n.map((i, s) => { const a = s === 0 ? "start" : "end", o = s === 0 ? f.createElement(bc, null) : f.createElement(Ms, null), l = this.renderCollapse(i, o, a); return this.props.renderArrow ? this.props.renderArrow(i, a, () => this.handleArrowClick(i, a), l) : l }), this.renderCollapsedTab = () => { const { list: n } = this.props, i = n.map(s => { const { itemKey: a } = s; return Object.assign({ key: this._getBarItemKeyByItemKey(a), active: this._isActive(a) }, s) }); return f.createElement(Io, { items: i, overflowRenderDirection: this.props.arrowPosition, wrapperStyle: this.props.visibleTabsStyle, overflowRenderer: this.renderOverflow, renderMode: "scroll", className: `${je.TABS_BAR}-overflow-list`, visibleItemRenderer: this.renderTabItem, onVisibleStateChange: s => { var a, o; const l = new Map; s.forEach((u, d) => { l.set(this._getItemKeyByBarItemKey(d), u) }), (o = (a = this.props).onVisibleTabsChange) === null || o === void 0 || o.call(a, l) } }) }, this.renderWithMoreTrigger = () => { const { list: n, more: i } = this.props; let s = [], a = f.createElement("div", { className: F({ [`${je.TABS_BAR}-more-trigger`]: !0, [`${je.TABS_BAR}-more-trigger-${this.props.type}`]: !0 }) }, f.createElement(Ke, { componentName: "Tabs" }, (l, u) => f.createElement("div", { className: `${je.TABS_BAR}-more-trigger-content` }, f.createElement("div", null, l.more), f.createElement(os, { className: `${je.TABS_BAR}-more-trigger-content-icon` })))), o; if (typeof i == "number") o = n.length - Math.min(i, n.length), s = n.slice(0, o).map(l => this.renderTabItem(l)); else if (typeof i == "object") o = n.length - Math.min(i.count, n.length), s = n.slice(0, o).map(l => this.renderTabItem(l)), i.render && (a = i.render()); else if (i !== void 0) throw new Error("[Semi Tabs]: invalid tab props format: more"); return f.createElement(f.Fragment, null, s, this.renderMoreDropdown(n.slice(o), i == null ? void 0 : i.dropdownProps, a)) }, this.renderMoreDropdown = (n, i, s) => f.createElement(Jt, Object.assign({ trigger: "hover", showTick: !0, position: "bottomLeft", className: `${je.TABS_BAR}-more-dropdown-${this.props.type}`, clickToHide: !0, menu: n.map(a => ({ node: "item", name: a.tab, icon: a.icon, onClick: o => this.props.onTabClick(a.itemKey, o), active: this.props.activeKey === a.itemKey })) }, i), s), this._isActive = n => n === this.props.activeKey, this._getBarItemKeyByItemKey = n => `${n}-bar`, this._getItemKeyByBarItemKey = n => n.replace(/-bar$/, ""), this.state = { endInd: e.list.length, rePosKey: 0, startInd: 0, uuid: "", currentVisibleItems: [] } } componentDidMount() { this.setState({ uuid: es() }) } componentDidUpdate(e) { e.activeKey !== this.props.activeKey && this.props.collapsible && this.scrollActiveTabItemIntoView() } renderIcon(e) { return f.createElement("span", null, e) } renderExtra() { const { tabBarExtraContent: e, type: t, size: n } = this.props, i = { float: "right" }, s = e && e.props ? e.props.style : {}, a = F(je.TABS_BAR_EXTRA, { [`${je.TABS_BAR}-${t}-extra`]: t, [`${je.TABS_BAR}-${t}-extra-${n}`]: n }); if (e) { const o = Object.assign(Object.assign({}, i), s); return f.createElement("div", { className: a, style: o, "x-semi-prop": "tabBarExtraContent" }, e) } return null } render() { const e = this.props, { type: t, style: n, className: i, list: s, tabPosition: a, more: o, collapsible: l } = e, u = Zne(e, ["type", "style", "className", "list", "tabPosition", "more", "collapsible"]), d = F(i, { [je.TABS_BAR]: !0, [je.TABS_BAR_LINE]: t === "line", [je.TABS_BAR_CARD]: t === "card", [je.TABS_BAR_BUTTON]: t === "button", [je.TABS_BAR_SLASH]: t === "slash", [`${je.TABS_BAR}-${a}`]: a, [`${je.TABS_BAR}-collapse`]: l }), h = this.renderExtra(), g = l ? this.renderCollapsedTab() : o ? this.renderWithMoreTrigger() : this.renderTabComponents(s); return f.createElement("div", Object.assign({ role: "tablist", "aria-orientation": a === "left" ? "vertical" : "horizontal", className: d, style: n }, Xr(u), { "data-uuid": this.state.uuid }), g, h) } } Hg.propTypes = { activeKey: c.string, className: c.string, collapsible: c.bool, list: c.array, onTabClick: c.func, size: c.oneOf(mo.SIZE), style: c.object, tabBarExtraContent: c.node, tabPosition: c.oneOf(mo.POSITION_MAP), type: c.oneOf(mo.TYPE_MAP), closable: c.bool, deleteTabItem: c.func, more: c.oneOfType([c.number, c.object]) }; const ZO = f.createContext({}); var Jne = function (r, e) { var t = {}; for (var n in r) Object.prototype.hasOwnProperty.call(r, n) && e.indexOf(n) < 0 && (t[n] = r[n]); if (r != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, n = Object.getOwnPropertySymbols(r); i < n.length; i++)e.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(r, n[i]) && (t[n[i]] = r[n[i]]); return t }; class Ah extends R.PureComponent { constructor() { super(...arguments), this.ref = R.createRef(), this.getDirection = (e, t, n, i) => { if (t !== null && e !== null && Array.isArray(n) && n.length) { const s = n.findIndex(l => l.itemKey === e), a = n.findIndex(l => l.itemKey === t), o = n.findIndex(l => l.itemKey === i); return s === a ? o > s : a < s } return !1 }, this.shouldRender = () => { const { itemKey: e } = this.props, { activeKey: t, lazyRender: n } = this.context, i = t === e; return this._active = this._active || i, n ? this._active : !0 } } render() { const { tabPaneMotion: e, tabPosition: t, prevActiveKey: n } = this.context, i = this.props, { className: s, style: a, children: o, itemKey: l, tabIndex: u } = i, d = Jne(i, ["className", "style", "children", "itemKey", "tabIndex"]), h = this.context.activeKey === l, g = F(s, { [je.TABS_PANE_INACTIVE]: !h, [je.TABS_PANE_ACTIVE]: h, [je.TABS_PANE]: !0 }), m = this.shouldRender(), b = (() => { const x = this.getDirection(this.context.activeKey, l, this.context.panes, n); return t === "top" ? x ? je.TABS_PANE_ANIMATE_RIGHT_SHOW : je.TABS_PANE_ANIMATE_LEFT_SHOW : x ? je.TABS_PANE_ANIMATE_BOTTOM_SHOW : je.TABS_PANE_ANIMATE_TOP_SHOW })(), y = !this.context.panes.find(x => x.itemKey === n), w = e && h && !y && !this.context.forceDisableMotion; return f.createElement("div", Object.assign({ ref: this.ref, role: "tabpanel", id: `semiTabPanel${l}`, "aria-labelledby": `semiTab${l}`, className: g, style: a, "aria-hidden": h ? "false" : "true", tabIndex: u || 0 }, Xr(d), { "x-semi-prop": "children" }), f.createElement(Hi, { motion: w, animationState: h ? "enter" : "leave", startClassName: b }, x => { let { animationClassName: S, animationEventsNeedBind: C } = x; return f.createElement("div", Object.assign({ className: F(je.TABS_PANE_MOTION_OVERLAY, S), "x-semi-prop": "children" }, C), m ? o : null) })) } } Ah.isTabPane = !0; Ah.contextType = ZO; Ah.propTypes = { className: c.string, style: c.object, children: c.node, disabled: c.bool, itemKey: c.string, tab: c.node, icon: c.node, closable: c.bool }; var Qne = function (r, e) { var t = {}; for (var n in r) Object.prototype.hasOwnProperty.call(r, n) && e.indexOf(n) < 0 && (t[n] = r[n]); if (r != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, n = Object.getOwnPropertySymbols(r); i < n.length; i++)e.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(r, n[i]) && (t[n[i]] = r[n[i]]); return t }; const mw = ["className", "style", "disabled", "itemKey", "tab", "icon"]; class Do extends de { constructor(e) { super(e), this.setContentRef = t => { this.contentRef = { current: t } }, this.getPanes = () => { const { tabList: t, children: n } = this.props; return Array.isArray(t) && t.length ? t : f.Children.map(n, i => { if (i) { const { tab: s, icon: a, disabled: o, itemKey: l, closable: u } = i.props; return { tab: s, icon: a, disabled: o, itemKey: l, closable: u } } }) }, this.onTabClick = (t, n) => { this.foundation.handleTabClick(t, n) }, this.rePosChildren = (t, n) => { const i = [], s = f.Children.toArray(t); return t.length && (i.push(...s.filter(a => a.props && a.props.itemKey === n)), i.push(...s.filter(a => a.props && a.props.itemKey !== n))), i }, this.getActiveItem = () => { const { activeKey: t } = this.state, { children: n, tabList: i } = this.props; return i || !Array.isArray(n) ? n : f.Children.toArray(n).filter(s => R.isValidElement(s) && s.type && s.type.isTabPane ? s.props.itemKey === t : !0) }, this.deleteTabItem = (t, n) => { n.stopPropagation(), this.foundation.handleTabDelete(t) }, this.foundation = new Yne(this.adapter), this.state = { activeKey: this.foundation.getDefaultActiveKey(), panes: this.getPanes(), prevActiveKey: null, forceDisableMotion: !1 }, this.contentRef = R.createRef(), this.contentHeight = "auto" } get adapter() { return Object.assign(Object.assign({}, super.adapter), { collectPane: () => { const e = this.getPanes(); this.setState({ panes: e }) }, collectActiveKey: () => { const { tabList: e, children: t, activeKey: n } = this.props; if (typeof n < "u") return; const { activeKey: i } = this.state, s = this.getPanes(); s.findIndex(a => a.itemKey === i) === -1 && (s.length > 0 ? this.setState({ activeKey: s[0].itemKey }) : this.setState({ activeKey: "" })) }, notifyTabClick: (e, t) => { this.props.onTabClick(e, t) }, notifyChange: e => { this.props.onChange(e) }, setNewActiveKey: e => { this.setState({ activeKey: e }) }, getDefaultActiveKeyFromChildren: () => { const { tabList: e, children: t } = this.props; let n = ""; return (e || f.Children.toArray(t).map(s => R.isValidElement(s) ? s.props : null)).forEach(s => { s && !n && !s.disabled && (n = s.itemKey) }), n }, notifyTabDelete: e => { this.props.onTabClose && this.props.onTabClose(e) } }) } static getDerivedStateFromProps(e, t) { const n = {}; return !ze(e.activeKey) && e.activeKey !== t.activeKey && (t.prevActiveKey = t.activeKey, n.activeKey = e.activeKey), n } componentDidUpdate(e, t) { const n = f.Children.toArray(e.children).map(a => cr(R.isValidElement(a) ? a.props : null, mw)), i = f.Children.toArray(this.props.children).map(a => cr(R.isValidElement(a) ? a.props : null, mw)), s = this.props.tabList || e.tabList; if (ke(this.props.tabList, e.tabList) || this.foundation.handleTabListChange(), t.activeKey !== this.state.activeKey && t.activeKey !== this.state.prevActiveKey && this.setState({ prevActiveKey: t.activeKey }), e.activeKey !== this.props.activeKey) { const a = (() => { const o = new Set(n.map(l => l.itemKey)); return i.map(l => l.itemKey).filter(l => !o.has(l)) })(); this.setState({ forceDisableMotion: a.includes(this.props.activeKey) }) } !ke(n, i) && !s && this.foundation.handleTabPanesChange() } render() { const e = this.props, { children: t, className: n, collapsible: i, contentStyle: s, keepDOM: a, lazyRender: o, renderTabBar: l, showRestInDropdown: u, size: d, style: h, tabBarClassName: g, tabBarExtraContent: m, tabBarStyle: b, tabPaneMotion: y, tabPosition: w, type: x, more: S, onVisibleTabsChange: C, visibleTabsStyle: O, arrowPosition: E, renderArrow: v, dropdownProps: T } = e, I = Qne(e, ["children", "className", "collapsible", "contentStyle", "keepDOM", "lazyRender", "renderTabBar", "showRestInDropdown", "size", "style", "tabBarClassName", "tabBarExtraContent", "tabBarStyle", "tabPaneMotion", "tabPosition", "type", "more", "onVisibleTabsChange", "visibleTabsStyle", "arrowPosition", "renderArrow", "dropdownProps"]), { panes: k, activeKey: P } = this.state, N = F(n, { [je.TABS]: !0, [`${je.TABS}-${w}`]: w }), M = F({ [je.TABS_CONTENT]: !0, [`${je.TABS_CONTENT}-${w}`]: w }), B = { activeKey: P, className: g, collapsible: i, list: k, onTabClick: this.onTabClick, showRestInDropdown: u, size: d, style: b, tabBarExtraContent: m, tabPosition: w, type: x, deleteTabItem: this.deleteTabItem, handleKeyDown: this.foundation.handleKeyDown, more: S, onVisibleTabsChange: C, visibleTabsStyle: O, arrowPosition: E, renderArrow: v, dropdownProps: T }, K = l ? l(B, Hg) : f.createElement(Hg, Object.assign({}, B)), U = a ? t : this.getActiveItem(); return f.createElement("div", Object.assign({ className: N, style: h }, this.getDataAttr(I)), K, f.createElement(ZO.Provider, { value: { activeKey: P, lazyRender: o, panes: k, tabPaneMotion: y, tabPosition: w, prevActiveKey: this.state.prevActiveKey, forceDisableMotion: this.state.forceDisableMotion } }, f.createElement("div", { ref: this.setContentRef, className: M, style: Object.assign({}, s) }, U))) } } Do.TabPane = Ah; Do.TabItem = fb; Do.propTypes = { activeKey: c.string, className: c.string, collapsible: c.bool, contentStyle: c.oneOfType([c.object]), defaultActiveKey: c.string, keepDOM: c.bool, lazyRender: c.bool, onChange: c.func, onTabClick: c.func, renderTabBar: c.func, showRestInDropdown: c.bool, size: c.oneOf(mo.SIZE), style: c.object, tabBarClassName: c.string, tabBarExtraContent: c.node, tabBarStyle: c.object, tabList: c.array, tabPaneMotion: c.bool, tabPosition: c.oneOf(mo.POSITION_MAP), type: c.oneOf(mo.TYPE_MAP), onTabClose: c.func, preventScroll: c.bool, more: c.oneOfType([c.number, c.object]), arrowPosition: c.string, renderArrow: c.func, dropdownProps: c.object }; Do.__SemiComponentName__ = "Tabs"; Do.defaultProps = xn(Do.__SemiComponentName__, { children: [], collapsible: !1, keepDOM: !0, lazyRender: !1, onChange: () => { }, onTabClick: () => { }, size: "large", tabPaneMotion: !0, tabPosition: "top", type: "line", onTabClose: () => { }, showRestInDropdown: !0, arrowPosition: "both" }); const hu = function (r) { let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : hn.DEFAULT_FORMAT, t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : zm; if (r instanceof Date) return r; if (typeof r == "number") return new Date(zr(r)); if (typeof r == "string") { if (r === "") return; let n = new Date; return n = LS(r, e, n, { locale: t }), n } else if (typeof r > "u") return; return new Date }, pu = function (r) { let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : hn.DEFAULT_FORMAT, t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : zm; return mt(r, e, { locale: t }) }, ere = (r, e) => { if (typeof r == "function") { const t = r(); if (Array.isArray(t) && !ze(e) && t.some(n => zr(n) === zr(e))) return !0 } return !1 }, tre = (r, e, t) => { if (typeof r == "function") { const n = r(e); if (Array.isArray(n) && !ze(e) && !ze(t) && n.some(i => zr(i) === zr(t))) return !0 } return !1 }, nre = (r, e, t, n) => { if (typeof r == "function") { const i = r(e, t); if (Array.isArray(i) && !ze(e) && !ze(t) && !ze(n) && i.some(s => zr(s) === zr(n))) return !0 } return !1 }, Dp = r => Array.isArray(r) ? [...r] : [], rre = (r, e) => { let t = !0; const n = "BDEGHKLMOPQRSTXYabcehimopqstuwxyz", i = new RegExp(`[${n}]`, "g"), s = new RegExp(`[^${n}]`, "g"), a = /[H|m|s]{1,2}/, o = e.split(s), l = e.replace(i, ""), u = new RegExp(`[${l}]`, "g"), d = r.split(u); if (o.length !== d.length) t = !1; else for (let h = 0, g = d.length; h < g; h++) { const m = o[h], b = d[h]; if (a.test(m) && b.length < m.length) { t = !1; break } } return t }; let ire = class extends ve { constructor(e) { super(Object.assign({}, e)) } init() { this.initDataFromDefaultValue(), (this._isControlledComponent("open") ? this.getProp("open") : this.getProp("defaultOpen")) && !this._isControlledComponent("open") && this._adapter.registerClickOutSide() } getPosition() { const e = this.getProp("position"), t = this.getProp("type") || hn.DEFAULT_TYPE, i = this.getContext("direction") === "rtl" ? "bottomRight" : ""; return e || i || hn.DEFAULT_POSITION[t] } isDisabledHMS(e) { let { hours: t, minutes: n, seconds: i } = e; const { disabledHours: s, disabledMinutes: a, disabledSeconds: o } = this.getProps(), l = !ze(t) && ere(s, t), u = !ze(t) && !ze(n) && tre(a, t, n), d = !ze(t) && !ze(n) && !ze(i) && nre(o, t, n, i); return l || u || d } isValidTimeZone(e) { return ["string", "number"].includes(typeof e) && e !== "" } getDefaultFormatIfNeed() { return this._isInProps("format") ? this.getProp("format") : this.getProp("use12Hours") ? hn.DEFAULT_FORMAT_A : hn.DEFAULT_FORMAT } initDataFromDefaultValue() { const e = this.getProp("defaultValue"); let t = this.getProp("value"); const n = this.getProp("timeZone"), i = this.getValidFormat(), { rangeSeparator: s, dateFnsLocale: a } = this.getProps(); t = t || e, Array.isArray(t) || (t = t ? [t] : []); const o = []; let l = !1; t.forEach(h => { const g = hu(h, i, a); isNaN(g.getTime()) || o.push(this.isValidTimeZone(n) ? Og(g, n) : g) }); const u = [!0, !1]; o.map((h, g) => { u[g] = xB(h) < 12 }), o.length === t.length ? t = o : (t = [], t.length && (l = !0)); let d = ""; l || (d = t.map(h => pu(h, i, a)).join(s)), this.setState({ isAM: u, value: t, inputValue: d, invalid: l }) } getValidFormat(e) { let t = e; return ze(t) && (t = this.getDefaultFormatIfNeed()), typeof t != "string" && (t = hn.DEFAULT_FORMAT), t } handlePanelChange(e) { let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0; const n = this.getValidFormat(), i = this.getProp("dateFnsLocale"), s = this.getState("value"); let a = this.getState("isAM"); const o = Dp(s); if (a = Dp(a), e) { const l = !!e.isAM, u = hu(e.timeStampValue, n, i); o[t] = u, a[t] = l; const d = this.formatValue(o); if (this.getState("isAM")[t] !== e.isAM && this.setState({ isAM: a }), !this._isControlledComponent("value")) { const h = this.validateDates(o); this.setState({ isAM: a, value: o, inputValue: d, invalid: h }) } this._hasChanged(o, s) && this._notifyChange(o, d) } } refreshProps() { let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}; const { value: t, timeZone: n, __prevTimeZone: i } = e; let s = this.parseValue(t), a = s.some(l => isNaN(Number(l))); a || (this.isValidTimeZone(n) && (s = s.map(l => Og(this.isValidTimeZone(i) ? fo(l, i) : l, n))), a = s.some(l => this.isDisabledHMS({ hours: l.getHours(), minutes: l.getMinutes(), seconds: l.getSeconds() }))); const o = this.formatValue(s); this.setState({ value: s, invalid: a, inputValue: o }) } handleFocus(e) { this.getState("open") || this.handlePanelOpen(), this._adapter.notifyFocus(e) } setPanel(e) { this._adapter.togglePanel(e) } destroy() { this._adapter.unregisterClickOutSide() } handlePanelOpen() { this._isControlledComponent("open") || (this._adapter.registerClickOutSide(), this.setPanel(!0)), this._adapter.notifyOpenChange(!0) } handlePanelClose(e, t) { this._isControlledComponent("open") || (this._adapter.unregisterClickOutSide(), this.setPanel(!1)), this._adapter.notifyOpenChange(!1), this._adapter.notifyBlur(t) } handleVisibleChange(e) { this._isControlledComponent("open") || this._adapter.togglePanel(e), this._adapter.notifyOpenChange(e) } handleInputChange(e) { this._adapter.setInputValue(e); const t = this.getProp("rangeSeparator"), n = Al(e, t), i = this.getValidFormat(); if (e !== "" && n.some(d => !rre(d, i))) return; const s = this.parseInput(e), a = this.validateDates(s), o = { invalid: a }, l = this.getState("value"); let u = Dp(l); a || (o.value = s, u = [...s]), this._isControlledComponent("value") || this.setState(o), this._hasChanged(u, l) && this._notifyChange(u, e) } doValidate(e) { if (typeof e == "string") return this.validateStr(e); if (Array.isArray(e)) return this.validateDates(e) } validateStr() { let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : ""; const t = this.parseInput(e); return this.validateDates(t) } validateDates() { let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [], t = e.some(n => isNaN(Number(n))); return t || (t = e.some(n => this.isDisabledHMS({ hours: n.getHours(), minutes: n.getMinutes(), seconds: n.getSeconds() }))), t } handleInputBlur(e) { const t = this.getState("invalid"), n = this.getState("inputValue"), i = this.getState("value"); n ? t ? this.setState({ inputValue: this.formatValue(i), invalid: !1 }) : this.setState({ inputValue: this.formatValue(i) }) : this.setState({ inputValue: "", value: [], invalid: !1 }) } formatValue(e) { const t = this.getValidFormat(), n = this.getProp("rangeSeparator"), i = this.getProp("dateFnsLocale"); let s = e; if (s && !Array.isArray(s) && (s = s[s]), s && Array.isArray(s)) return s.map(o => { let l; return st(o) ? l = "" : l = pu(o, t, i), l }).join(n) } parseInput(e) { const t = this.getValidFormat(), n = this.getProp("rangeSeparator"), i = this.getProp("dateFnsLocale"); return e && typeof e == "string" ? Al(e, n).map(s => hu(s, t, i)) : [] } parseValue() { let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : []; const t = this.getValidFormat(), n = this.getProp("dateFnsLocale"); let i = e; return Array.isArray(i) || (i = i ? [i] : []), Array.isArray(i) ? i.map(s => hu(s, t, n)) : [] } _notifyChange(e, t) { let n = t, i = e; const s = this.getProp("timeZone"); if (this._adapter.isRangePicker()) { const o = this.getProp("rangeSeparator"); n = Al(t, o) } else i = Array.isArray(i) ? i[0] : i; if (this.isValidTimeZone(s) && i) { const o = this.getValidFormat(); Array.isArray(i) ? (i = i.map(l => fo(l, s)), n = i.map(l => mt(l, o))) : (i = fo(i, s), n = mt(i, o)) } this.getProp("onChangeWithDateFirst") ? this._adapter.notifyChange(i, n) : this._adapter.notifyChange(n, i) } _hasChanged() { let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [], t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : []; const n = this.getValidFormat(), i = this.getProp("dateFnsLocale"); return e.length !== t.length || e.some((s, a) => { const o = t[a]; return !(Kr(s) && Kr(o) && pu(s, n, i) === pu(o, n, i)) }) } }; class sre extends ve { constructor(e) { super(Object.assign({}, e)) } init() { } destroy() { } handleFocus(e) { this.storeCursor(), this._adapter.notifyFocus(e) } handleChange(e) { this.storeCursor(), this._adapter.notifyChange(e) } handleBlur(e) { this.clearCursor(), this._adapter.notifyBlur(e) } storeCursor() { const e = this.getCache("inputNode"); if (e) { const { selectionStart: t } = e; this.setCache("cursorIndex", t) } } restoreCursor() { const e = this.getCache("inputNode"), t = this.getCache("cursorIndex"); e && !ze(t) && (e.selectionStart = t, e.selectionEnd = t) } clearCursor() { this.setCache("cursorIndex", null), this.setCache("beforeStr", null), this.setCache("afterStr", null) } } var are = function (r, e) { var t = {}; for (var n in r) Object.prototype.hasOwnProperty.call(r, n) && e.indexOf(n) < 0 && (t[n] = r[n]); if (r != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, n = Object.getOwnPropertySymbols(r); i < n.length; i++)e.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(r, n[i]) && (t[n[i]] = r[n[i]]); return t }; class gb extends de { constructor(e) { super(e), this.setRef = t => this.adapter.setCache("inputNode", t), this.handleClick = t => this.props.onClick(t), this.handleFocus = t => this.foundation.handleFocus(t), this.handleBlur = t => this.foundation.handleBlur(t), this.handleChange = t => this.foundation.handleChange(t), this.foundation = new sre(this.adapter), this.state = {} } componentDidMount() { super.componentDidMount(); const { focusOnOpen: e, preventScroll: t } = this.props; e && (window.requestAnimationFrame || window.setTimeout)(() => { const i = this.adapter.getCache("inputNode"); i && (i.focus({ preventScroll: t }), i.select()) }) } componentDidUpdate(e) { const { timeStampValue: t } = this.props; this.isControlled("timeStampValue") && t !== this.state.timeStampValue && this.foundation.restoreCursor(), this.props.value !== e.value && this.foundation.restoreCursor() } get adapter() { var e = this; return Object.assign(Object.assign({}, super.adapter), { notifyChange: function () { return e.props.onChange(...arguments) }, notifyFocus: function () { return e.props.onFocus(...arguments) }, notifyBlur: function () { return e.props.onBlur(...arguments) } }) } getInput() { const e = this.props, { prefixCls: t, placeholder: n, inputReadOnly: i, onFocus: s, disabled: a, type: o, locale: l, localeCode: u, insetLabel: d, validateStatus: h, value: g, onChange: m, invalid: b, format: y, clearText: w, disabledHours: x, disabledMinutes: S, disabledSeconds: C, onEsc: O, defaultOpenValue: E, currentSelectPanel: v, focusOnOpen: T, timeStampValue: I, timeZone: k, defaultOpen: P, dateFnsLocale: N } = e, M = are(e, ["prefixCls", "placeholder", "inputReadOnly", "onFocus", "disabled", "type", "locale", "localeCode", "insetLabel", "validateStatus", "value", "onChange", "invalid", "format", "clearText", "disabledHours", "disabledMinutes", "disabledSeconds", "onEsc", "defaultOpenValue", "currentSelectPanel", "focusOnOpen", "timeStampValue", "timeZone", "defaultOpen", "dateFnsLocale"]), B = F(`${t}-input`, { [`${t}-input-invalid`]: b, [`${t}-input-readonly`]: i }), K = b ? "error" : h; return f.createElement(xr, Object.assign({}, M, { hideSuffix: !0, className: B, ref: this.setRef, value: g, placeholder: n || l.placeholder[o], readonly: !!i, onChange: this.handleChange, onFocus: this.handleFocus, onBlur: this.handleBlur, suffix: f.createElement(HS, { onClick: this.handleClick }), validateStatus: K, disabled: a, insetLabel: d })) } render() { const { prefixCls: e } = this.props; return f.createElement("div", { className: `${e}-input-wrap` }, this.getInput()) } } gb.propTypes = { borderless: c.bool, format: c.string, prefixCls: c.string, placeholder: c.string, clearText: c.string, inputReadOnly: c.bool, hourOptions: c.array, minuteOptions: c.array, secondOptions: c.array, disabledHours: c.func, disabledMinutes: c.func, disabledSeconds: c.func, onChange: c.func, onFocus: c.func, onBlur: c.func, onEsc: c.func, onClick: c.func, defaultOpenValue: c.object, currentSelectPanel: c.string, focusOnOpen: c.bool, timeStampValue: c.any, locale: c.object, localeCode: c.string, insetLabel: c.node, validateStatus: c.string, preventScroll: c.bool }; gb.defaultProps = { borderless: !1, inputReadOnly: !1, onChange: z, onBlur: z, onFocus: z, onClick: z, disabledHours: z, disabledMinutes: z, disabledSeconds: z, format: hn.DEFAULT_FORMAT }; const yw = { panelHeader: c.oneOfType([c.node, c.string]), panelFooter: c.oneOfType([c.node, c.string]) }, ore = {}, lre = [c.string, c.number, c.instanceOf(Date)], bw = c.oneOfType([...lre, c.arrayOf(c.string), c.arrayOf(c.number), c.arrayOf(c.instanceOf(Date))]); var cre = function (r, e) { var t = {}; for (var n in r) Object.prototype.hasOwnProperty.call(r, n) && e.indexOf(n) < 0 && (t[n] = r[n]); if (r != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, n = Object.getOwnPropertySymbols(r); i < n.length; i++)e.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(r, n[i]) && (t[n[i]] = r[n[i]]); return t }; class rl extends de { constructor(e) { var t; super(e), t = this, this.onCurrentSelectPanelChange = i => { this.setState({ currentSelectPanel: i }) }, this.handlePanelChange = (i, s) => this.foundation.handlePanelChange(i, s), this.handleInput = i => this.foundation.handleInputChange(i), this.createPanelProps = function () { let i = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0; const { panels: s, panelFooter: a, panelHeader: o, locale: l } = t.props, u = { panelHeader: o, panelFooter: a }; if (t.adapter.isRangePicker()) { const d = { 0: l.begin, 1: l.end }; u.panelHeader = H(s, i, ze(o) ? H(d, i, null) : Array.isArray(o) ? o[i] : o), u.panelFooter = H(s, i, Array.isArray(a) ? a[i] : a) } return u }, this.handlePanelVisibleChange = i => this.foundation.handleVisibleChange(i), this.openPanel = () => { this.foundation.handlePanelOpen() }, this.handleFocus = i => { this.foundation.handleFocus(i) }, this.handleBlur = i => this.foundation.handleInputBlur(i), this.setTimePickerRef = i => this.timePickerRef.current = i; const { format: n = hn.DEFAULT_FORMAT } = e; this.state = { open: e.open || e.defaultOpen || !1, value: [], inputValue: "", currentSelectPanel: 0, isAM: [!0, !1], showHour: !!n.match(/HH|hh|H|h/g), showMinute: !!n.match(/mm/g), showSecond: !!n.match(/ss/g), invalid: void 0 }, this.foundation = new ire(this.adapter), this.timePickerRef = f.createRef(), this.savePanelRef = f.createRef(), this.useCustomTrigger = typeof this.props.triggerRender == "function" } get adapter() { var e = this; return Object.assign(Object.assign({}, super.adapter), { togglePanel: t => { this.setState({ open: t }) }, registerClickOutSide: () => { this.clickOutSideHandler && this.adapter.unregisterClickOutSide(), this.clickOutSideHandler = t => { const n = this.savePanelRef && this.savePanelRef.current, i = this.timePickerRef && this.timePickerRef.current, s = t.target, a = t.composedPath && t.composedPath() || [s]; !(n && n.contains(s)) && !(i && i.contains(s)) && !(a.includes(i) || a.includes(n)) && this.foundation.handlePanelClose(!0, t) }, document.addEventListener("mousedown", this.clickOutSideHandler) }, setInputValue: (t, n) => this.setState({ inputValue: t }, n), unregisterClickOutSide: () => { this.clickOutSideHandler && (document.removeEventListener("mousedown", this.clickOutSideHandler), this.clickOutSideHandler = null) }, notifyOpenChange: function () { return e.props.onOpenChange(...arguments) }, notifyChange: (t, n) => this.props.onChange && this.props.onChange(t, n), notifyFocus: function () { return e.props.onFocus && e.props.onFocus(...arguments) }, notifyBlur: function () { return e.props.onBlur && e.props.onBlur(...arguments) }, isRangePicker: () => this.props.type === hn.TYPE_TIME_RANGE_PICKER }) } static getDerivedStateFromProps(e, t) { return "open" in e && e.open !== t.open ? { open: e.open } : null } componentDidUpdate(e) { this.isControlled("value") && this.props.value !== e.value ? this.foundation.refreshProps(Object.assign({}, this.props)) : this.props.timeZone !== e.timeZone && this.foundation.refreshProps({ timeZone: this.props.timeZone, __prevTimeZone: e.timeZone, value: this.state.value }) } getPanelElement() { const { prefixCls: e, type: t } = this.props, { isAM: n, value: i } = this.state, s = this.foundation.getDefaultFormatIfNeed(), a = [f.createElement(Yl, Object.assign({}, this.props, { key: 0, format: s, isAM: n[0], timeStampValue: i[0], prefixCls: `${e}-panel`, onChange: l => this.handlePanelChange(l, 0), onCurrentSelectPanelChange: this.onCurrentSelectPanelChange }, this.createPanelProps(0)))]; t === hn.TYPE_TIME_RANGE_PICKER && a.push(f.createElement(Yl, Object.assign({}, this.props, { key: 1, format: s, isAM: n[1], timeStampValue: i[1], prefixCls: `${e}-panel`, onChange: l => this.handlePanelChange(l, 1), onCurrentSelectPanelChange: this.onCurrentSelectPanelChange }, this.createPanelProps(1)))); const o = F({ [Ig.RANGE_PANEL_LISTS]: this.adapter.isRangePicker() }); return f.createElement("div", { ref: this.savePanelRef, className: o }, a.map(l => l)) } getPopupClassName() { const { use12Hours: e, prefixCls: t, popupClassName: n } = this.props, { showHour: i, showMinute: s, showSecond: a } = this.state; let o = 0; return i && (o += 1), s && (o += 1), a && (o += 1), e && (o += 1), F(`${t}-panel`, n, { [`${t}-panel-narrow`]: (!i || !s || !a) && !e, [Ig.RANGE_PICKER]: this.adapter.isRangePicker() }, `${t}-panel-column-${o}`) } focus() { } blur() { } render() { const e = this.props, { prefixCls: t, placeholder: n, disabled: i, defaultValue: s, dropdownMargin: a, className: o, popupStyle: l, size: u, style: d, locale: h, localeCode: g, zIndex: m, getPopupContainer: b, insetLabel: y, insetLabelId: w, inputStyle: x, showClear: S, panelHeader: C, panelFooter: O, rangeSeparator: E, onOpenChange: v, onChangeWithDateFirst: T, popupClassName: I, hideDisabledOptions: k, use12Hours: P, minuteStep: N, hourStep: M, secondStep: B, scrollItemProps: K, triggerRender: U, motion: W, autoAdjustOverflow: Z, stopPropagation: J } = e, ee = cre(e, ["prefixCls", "placeholder", "disabled", "defaultValue", "dropdownMargin", "className", "popupStyle", "size", "style", "locale", "localeCode", "zIndex", "getPopupContainer", "insetLabel", "insetLabelId", "inputStyle", "showClear", "panelHeader", "panelFooter", "rangeSeparator", "onOpenChange", "onChangeWithDateFirst", "popupClassName", "hideDisabledOptions", "use12Hours", "minuteStep", "hourStep", "secondStep", "scrollItemProps", "triggerRender", "motion", "autoAdjustOverflow", "stopPropagation"]), $ = this.foundation.getDefaultFormatIfNeed(), pe = this.foundation.getPosition(), { open: re, inputValue: j, invalid: ae, value: be } = this.state, fe = this.getPopupClassName(), Ce = F({ [`${t}-header`]: !0 }), ue = F({ [`${t}-panel`]: !0, [`${t}-panel-${u}`]: u }), te = Object.assign(Object.assign({}, ee), { disabled: i, prefixCls: t, size: u, showClear: i ? !1 : S, style: x, value: j, onFocus: this.handleFocus, insetLabel: y, insetLabelId: w, format: $, locale: h, localeCode: g, invalid: ae, placeholder: n, onChange: this.handleInput, onBlur: this.handleBlur }), le = {}; return this.useCustomTrigger && (le.onClick = this.openPanel), f.createElement("div", Object.assign({ ref: this.setTimePickerRef, className: F({ [t]: !0 }, o), style: d }, le), f.createElement(kn, { getPopupContainer: b, zIndex: m, prefixCls: ue, contentClassName: fe, style: l, content: this.getPanelElement(), trigger: "custom", position: pe, visible: i ? !1 : !!re, motion: W, margin: a, autoAdjustOverflow: Z, stopPropagation: J }, this.useCustomTrigger ? f.createElement(Ia, { triggerRender: U, disabled: i, value: be, inputValue: j, onChange: this.handleInput, placeholder: n, componentName: "TimePicker", componentProps: Object.assign({}, this.props) }) : f.createElement("span", { className: Ce }, f.createElement(gb, Object.assign({}, te))))) } } rl.contextType = An; rl.propTypes = Object.assign(Object.assign({ "aria-labelledby": c.string, "aria-invalid": c.bool, "aria-errormessage": c.string, "aria-describedby": c.string, "aria-required": c.bool, prefixCls: c.string, borderless: c.bool, clearText: c.string, clearIcon: c.node, value: bw, inputReadOnly: c.bool, disabled: c.bool, showClear: c.bool, defaultValue: bw, open: c.bool, defaultOpen: c.bool, onOpenChange: c.func, position: c.any, getPopupContainer: c.func, placeholder: c.string, format: c.string, style: c.object, className: c.string, popupClassName: c.string, popupStyle: c.object, disabledHours: c.func, disabledMinutes: c.func, disabledSeconds: c.func, dropdownMargin: c.oneOfType([c.number, c.object]), hideDisabledOptions: c.bool, onChange: c.func, use12Hours: c.bool, hourStep: c.number, minuteStep: c.number, secondStep: c.number, focusOnOpen: c.bool, autoFocus: c.bool, size: c.oneOf(hn.SIZE), stopPropagation: c.bool, panels: c.arrayOf(c.shape(yw)), onFocus: c.func, onBlur: c.func, locale: c.object, localeCode: c.string, dateFnsLocale: c.object, zIndex: c.oneOfType([c.number, c.string]), insetLabel: c.node, insetLabelId: c.string, validateStatus: c.oneOf(hn.STATUS), type: c.oneOf(hn.TYPES), rangeSeparator: c.string, triggerRender: c.func, timeZone: c.oneOfType([c.string, c.number]), scrollItemProps: c.object, motion: c.oneOfType([c.bool, c.func, c.object]), autoAdjustOverflow: c.bool }, yw), { inputStyle: c.object, preventScroll: c.bool }); rl.defaultProps = Object.assign({ autoAdjustOverflow: !0, borderless: !1, getPopupContainer: () => document.body, showClear: !0, zIndex: Cr.DEFAULT_Z_INDEX, rangeSeparator: hn.DEFAULT_RANGE_SEPARATOR, onOpenChange: z, clearText: "clear", prefixCls: Ig.PREFIX, inputReadOnly: !1, style: {}, stopPropagation: !0, className: "", popupClassName: "", popupStyle: { left: "0px", top: "0px" }, disabledHours: () => [], disabledMinutes: () => [], disabledSeconds: () => [], hideDisabledOptions: !1, onFocus: z, onBlur: z, onChange: z, onChangeWithDateFirst: !0, use12Hours: !1, focusOnOpen: !1, onKeyDown: z, size: "default", type: hn.DEFAULT_TYPE, motion: !0 }, ore); class tc extends f.PureComponent { render() { const { type: e } = this.props; return f.createElement(An.Consumer, null, t => { let { timeZone: n } = t; return f.createElement(Ke, { componentName: "TimePicker" }, (i, s, a) => f.createElement(rl, Object.assign({ timeZone: n, placeholder: H(i, ["placeholder", e]) }, this.props, { locale: i, localeCode: s, dateFnsLocale: a }))) }) } } tc.propTypes = rl.propTypes; tc.__SemiComponentName__ = "TimePicker"; tc.defaultProps = xn(tc.__SemiComponentName__, rl.defaultProps); class mb extends ve { constructor(e) { super(Object.assign(Object.assign({}, mb.defaultAdapter), e)), this.handleMouseInSideChange = t => { this._adapter.handleMouseInSideChange(t) }, this.getInputWrapperRect = () => this._adapter.getInputWrapperRect() } hasToast(e) { return this._adapter.getState("list").map(n => { let { id: i } = n; return i }).includes(e) } addToast(e) { const t = this._adapter.getState("list"); t.push(e), this._adapter.updateToast(t, [], []) } updateToast(e, t) { let n = this._adapter.getState("list"); n = n.map(s => s.id === e ? Object.assign(Object.assign({}, s), t) : s); const i = n.filter(s => s.id === e); this._adapter.updateToast(n, [], i) } removeToast(e) { let t = this._adapter.getState("list"); const n = []; t = t.filter(i => i.id === e ? (n.push(i), !1) : !0), this._adapter.updateToast(t, n, []) } destroyAll() { const e = this._adapter.getState("list"); e.length > 0 && this._adapter.updateToast([], e, []) } } const Ap = `${G}-toast`, to = { PREFIX: Ap, WRAPPER: `${Ap}-wrapper`, LIST: `${Ap}-list` }, Nl = { types: ["warning", "success", "info", "error", "default"], themes: ["normal", "light"], directions: ["ltr", "rtl"] }, ure = { duration: 3 }; class yb extends ve { constructor(e) { super(Object.assign(Object.assign({}, yb.defaultAdapter), e)), this._timer = null, this._id = null } init() { this.startCloseTimer_(), this._id = this._adapter.getProp("id") } destroy() { this.clearCloseTimer_() } startCloseTimer_() { const e = this._adapter.getProp("duration"); e && Zt(e) && (this._timer = setTimeout(() => { this.close() }, e * 1e3)) } close(e) { e && e.stopPropagation(), this._adapter.notifyWrapperToRemove(this._id), this._adapter.notifyClose() } clearCloseTimer_() { this._timer && (clearTimeout(this._timer), this._timer = null) } restartCloseTimer() { this.clearCloseTimer_(), this.startCloseTimer_() } } const ri = to.PREFIX; let va = class extends de { constructor(e) { super(e), this.toastEle = f.createRef(), this.clearCloseTimer = () => { this.foundation.clearCloseTimer_() }, this.startCloseTimer = () => { this.foundation.startCloseTimer_() }, this.restartCloseTimer = () => { this.foundation.restartCloseTimer() }, this.state = {}, this.foundation = new yb(this.adapter) } get adapter() { return Object.assign(Object.assign({}, super.adapter), { notifyWrapperToRemove: e => { this.props.close(e) }, notifyClose: () => { this.props.onClose() } }) } componentDidMount() { this.foundation.init() } componentWillUnmount() { this.foundation.destroy() } close(e) { this.foundation.close(e) } renderIcon() { const { type: e, icon: t } = this.props, i = { warning: f.createElement(yc, null), success: f.createElement(Km, null), info: f.createElement(Hm, null), error: f.createElement(Co, null) }[e], s = "large", a = F(`${ri}-icon`, `${ri}-icon-${e}`); return t ? Bn(t) ? f.cloneElement(t, { size: s, className: `${ri}-icon` }) : t : e && i ? f.cloneElement(i, { size: s, className: a }) : null } render() { const { content: e, type: t, theme: n, showClose: i, textMaxWidth: s, className: a, style: o } = this.props, l = this.props.direction || this.context.direction, u = F(ri, a, { [`${ri}-${t}`]: !0, [`${ri}-${n}`]: n === "light", [`${ri}-rtl`]: l === "rtl" }), d = {}; d.maxWidth = s; const h = "borderless", g = "small", m = this.props.positionInList ? this.props.positionInList.length - this.props.positionInList.index - 1 : 0, b = f.createElement("div", { ref: this.toastEle, role: "alert", "aria-label": `${t || "default"} type`, className: u, style: Object.assign(Object.assign({}, o), { transform: `translate3d(0,0,${m * -10}px)` }), onMouseEnter: this.clearCloseTimer, onMouseLeave: this.startCloseTimer, onAnimationStart: this.props.onAnimationStart, onAnimationEnd: this.props.onAnimationEnd }, f.createElement("div", { className: `${ri}-content` }, this.renderIcon(), f.createElement("span", { className: `${ri}-content-text`, style: d, "x-semi-prop": "content" }, e), i && f.createElement("div", { className: `${ri}-close-button` }, f.createElement(br, { onClick: y => this.close(y), type: "tertiary", icon: f.createElement(ds, { "x-semi-prop": "icon" }), theme: h, size: g })))); if (this.props.stack) { const y = this.props.stackExpanded && this.toastEle.current && getComputedStyle(this.toastEle.current).height || 0; return f.createElement("div", { className: `${ri}-zero-height-wrapper`, style: { height: y } }, b) } else return b } }; va.contextType = An; va.propTypes = { onClose: c.func, content: c.node, close: c.func, duration: c.number, theme: c.oneOf(Nl.themes), type: c.oneOf(Nl.types), textMaxWidth: c.oneOfType([c.string, c.number]), style: c.object, className: c.string, showClose: c.bool, stack: c.bool, stackExpanded: c.bool, icon: c.node, direction: c.oneOf(Nl.directions) }; va.__SemiComponentName__ = "Toast"; va.defaultProps = xn(va.__SemiComponentName__, { onClose: z, content: "", close: z, duration: ure.duration, textMaxWidth: 450, showClose: !0, stack: !1, stackExpanded: !1, theme: "normal" }); var dre = function (r, e) { var t = {}; for (var n in r) Object.prototype.hasOwnProperty.call(r, n) && e.indexOf(n) < 0 && (t[n] = r[n]); if (r != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, n = Object.getOwnPropertySymbols(r); i < n.length; i++)e.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(r, n[i]) && (t[n[i]] = r[n[i]]); return t }; const hre = (r, e) => { var { afterClose: t } = r, n = dre(r, ["afterClose"]); const [i, s] = R.useState(!0), a = () => { s(!1) }; return f.useImperativeHandle(e, () => ({ close: () => { s(!1) } })), R.useEffect(() => { i || t(n.id) }, [i]), i ? f.createElement(va, Object.assign({}, n, { close: a })) : null }, pre = f.forwardRef(hre), wl = { motion: !0, zIndex: 1010, duration: 3 }; function fre() { const [r, e] = f.useState([]); function t(n, i) { return e(s => [{ element: n, config: i }, ...s]), s => { e(a => a.filter(o => { let { config: l } = o; return l.id !== s })) } } return [r, t] } function gre() { const [r, e] = fre(), t = R.useRef(new Map), n = s => { const a = Xu("semi_toast_"), o = Object.assign(Object.assign({}, s), { id: a }); let l; const u = f.createElement(pre, Object.assign({}, o, { key: a, afterClose: d => l(d), ref: d => { var h; t.current.set(a, { close: (h = d == null ? void 0 : d.close) !== null && h !== void 0 ? h : z }) } })); return l = e(u, Object.assign({}, o)), a }, i = s => { var a; const { close: o } = (a = t.current.get(s)) !== null && a !== void 0 ? a : {}; o == null || o() }; return [{ success: s => n(Object.assign(Object.assign(Object.assign({}, wl), s), { type: "success" })), info: s => n(Object.assign(Object.assign(Object.assign({}, wl), s), { type: "info" })), error: s => n(Object.assign(Object.assign(Object.assign({}, wl), s), { type: "error" })), warning: s => n(Object.assign(Object.assign(Object.assign({}, wl), s), { type: "warning" })), open: s => n(Object.assign(Object.assign(Object.assign({}, wl), s), { type: "default" })), close: s => i(s) }, f.createElement(f.Fragment, null, Array.isArray(r) && r.length ? f.createElement(f.Fragment, null, r.map(s => s.element)) : null)] } const mre = () => { var r; return r = class wt extends de { constructor(t) { super(t), this.stack = !1, this.innerWrapperRef = f.createRef(), this.handleMouseEnter = n => { this.stack && this.foundation.handleMouseInSideChange(!0) }, this.handleMouseLeave = n => { var i; this.stack && (!((i = this.foundation.getInputWrapperRect()) === null || i === void 0) && i.height) && this.foundation.handleMouseInSideChange(!1) }, this.state = { list: [], removedItems: [], updatedItems: [], mouseInSide: !1 }, this.foundation = new mb(this.adapter) } get adapter() { return Object.assign(Object.assign({}, super.adapter), { updateToast: (t, n, i) => { this.setState({ list: t, removedItems: n, updatedItems: i }) }, handleMouseInSideChange: t => { this.setState({ mouseInSide: t }) }, getInputWrapperRect: () => { var t; return (t = this.innerWrapperRef.current) === null || t === void 0 ? void 0 : t.getBoundingClientRect() } }) } static create(t) { var n; const i = (n = t.id) !== null && n !== void 0 ? n : Xu("toast"); if (wt.ref) { const s = document.querySelector(`#${this.wrapperId}`);["top", "left", "bottom", "right"].map(a => { a in t && (s.style[a] = typeof t[a] == "number" ? `${t[a]}px` : t[a]) }), !!t.stack !== wt.ref.stack && (wt.ref.stack = !!t.stack), wt.ref.has(i) ? wt.ref.update(i, Object.assign(Object.assign({}, t), { id: i })) : wt.ref.add(Object.assign(Object.assign({}, t), { id: i })) } else { const s = document.createElement("div"); this.wrapperId || (this.wrapperId = Xu("toast-wrapper").slice(0, 26)), s.className = to.WRAPPER, s.id = this.wrapperId, s.style.zIndex = String(typeof t.zIndex == "number" ? t.zIndex : wt.defaultOpts.zIndex), ["top", "left", "bottom", "right"].map(a => { if (a in wt.defaultOpts || a in t) { const o = t[a] ? t[a] : wt.defaultOpts[a]; s.style[a] = typeof o == "number" ? `${o}px` : o } }), wt.defaultOpts.getPopupContainer ? wt.defaultOpts.getPopupContainer().appendChild(s) : document.body.appendChild(s), lr.render(f.createElement(wt, { ref: a => wt.ref = a }), s, () => { wt.ref.add(Object.assign(Object.assign({}, t), { id: i })), wt.ref.stack = !!t.stack }) } return i } static close(t) { wt.ref && wt.ref.remove(t) } static destroyAll() { if (wt.ref) { wt.ref.destroyAll(); const t = document.querySelector(`#${this.wrapperId}`); lr.unmountComponentAtNode(t), t && t.parentNode.removeChild(t), wt.ref = null, this.wrapperId = null } } static getWrapperId() { return this.wrapperId } static info(t) { return typeof t == "string" && (t = { content: t }), this.create(Object.assign(Object.assign(Object.assign({}, wt.defaultOpts), t), { type: "info" })) } static warning(t) { return typeof t == "string" && (t = { content: t }), this.create(Object.assign(Object.assign(Object.assign({}, wt.defaultOpts), t), { type: "warning" })) } static error(t) { return typeof t == "string" && (t = { content: t }), this.create(Object.assign(Object.assign(Object.assign({}, wt.defaultOpts), t), { type: "error" })) } static success(t) { return typeof t == "string" && (t = { content: t }), this.create(Object.assign(Object.assign(Object.assign({}, wt.defaultOpts), t), { type: "success" })) } static config(t) { ["top", "left", "bottom", "right"].forEach(n => { n in t && (wt.defaultOpts[n] = t[n]) }), typeof t.theme == "string" && Nl.themes.includes(t.theme) && (wt.defaultOpts.theme = t.theme), typeof t.zIndex == "number" && (wt.defaultOpts.zIndex = t.zIndex), typeof t.duration == "number" && (wt.defaultOpts.duration = t.duration), typeof t.getPopupContainer == "function" && (wt.defaultOpts.getPopupContainer = t.getPopupContainer) } has(t) { return this.foundation.hasToast(t) } add(t) { return this.foundation.addToast(t) } update(t, n) { return this.foundation.updateToast(t, n) } remove(t) { return this.foundation.removeToast(t) } destroyAll() { return this.foundation.destroyAll() } render() { let { list: t } = this.state; const { removedItems: n, updatedItems: i } = this.state; t = Array.from(new Set([...t, ...n])); const s = i.map(o => { let { id: l } = o; return l }), a = o => { var l; !((l = o == null ? void 0 : o.foundation) === null || l === void 0) && l._id && s.includes(o.foundation._id) && o.foundation.restartCloseTimer() }; return f.createElement(f.Fragment, null, f.createElement("div", { className: F({ [`${to.PREFIX}-innerWrapper`]: !0, [`${to.PREFIX}-innerWrapper-hover`]: this.state.mouseInSide }), ref: this.innerWrapperRef, onMouseEnter: this.handleMouseEnter, onMouseLeave: this.handleMouseLeave }, t.map((o, l) => { const u = n.find(d => d.id === o.id) !== void 0; return f.createElement(Hi, { key: o.id, motion: o.motion, animationState: u ? "leave" : "enter", startClassName: u ? `${to.PREFIX}-animation-hide` : `${to.PREFIX}-animation-show` }, d => { let { animationClassName: h, animationEventsNeedBind: g, isAnimating: m } = d; return u && !m ? null : f.createElement(va, Object.assign({}, o, { stack: this.stack, stackExpanded: this.state.mouseInSide, positionInList: { length: t.length, index: l }, className: F({ [o.className]: !!o.className, [h]: !0 }) }, g, { style: Object.assign({}, o.style), close: b => this.remove(b), ref: a })) }) }))) } }, r.defaultOpts = { motion: !0, zIndex: 1010, content: "" }, r.propTypes = { content: c.node, duration: c.number, onClose: c.func, icon: c.node, direction: c.oneOf(Nl.directions), stack: c.bool }, r.defaultProps = {}, r }; class yre { static create(e) { const t = mre(); return t.useToast = gre, e && t.config(e), t } } const bre = yre.create(); function Np(r) { return fS(r, e => { if (Wu(e) && !e._innerDataTag || f.isValidElement(e)) return e }) } const vre = bE.PREFIX; class bb extends R.PureComponent { constructor(e) { super(e), this._onResize = t => { const n = t && t[1] && t[1].target; if (n) { const i = H(n, "offsetHeight") || 0, s = window.getComputedStyle(n) || {}, a = parseInt(H(s, "paddingTop"), 10) || 0, o = parseInt(H(s, "paddingBottom"), 10) || 0, l = i - a - o; this.state.height !== l && this.setState({ height: i - a - o }) } }, this.state = { height: this.props.defaultHeight || 0 } } componentDidMount() { const { height: e } = this.state } render() { const { children: e, defaultWidth: t, defaultHeight: n } = this.props, { height: i } = this.state; let s = !1; return (i === 0 || typeof i != "number") && (s = !0), f.createElement(As, { observeParent: !0, onResize: this._onResize }, f.createElement("div", { style: { height: n, overflow: "visible" }, className: `${vre}-auto-wrapper` }, !s && e({ height: i, width: t }))) } } bb.propTypes = { defaultHeight: c.oneOfType([c.number, c.string]), defaultWidth: c.oneOfType([c.number, c.string]) }; bb.defaultProps = { defaultHeight: "100%", defaultWidth: "100%" }; const vb = f.createContext(null), xre = r => { let { prefixcls: e, level: t, isEnd: n, showLine: i } = r; const s = `${e}-indent-unit`, a = []; for (let o = 0; o < t; o += 1)a.push(R.createElement("span", { key: o, className: F(s, { [`${s}-end`]: n[o] }) })); return R.createElement("span", { "aria-hidden": "true", className: F(`${e}-indent`, { [`${e}-indent-show-line`]: i }) }, a) }, wre = R.memo(xre); var Cre = function (r, e) { var t = {}; for (var n in r) Object.prototype.hasOwnProperty.call(r, n) && e.indexOf(n) < 0 && (t[n] = r[n]); if (r != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, n = Object.getOwnPropertySymbols(r); i < n.length; i++)e.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(r, n[i]) && (t[n[i]] = r[n[i]]); return t }; const gt = bE.PREFIX_OPTION; class yo extends R.PureComponent { constructor(e) { super(e), this.onSelect = t => { const { onNodeSelect: n } = this.context; n(t, this.props) }, this.onExpand = t => { const { onNodeExpand: n } = this.context; t && t.stopPropagation(), t.nativeEvent.stopImmediatePropagation(), n(t, this.props) }, this.onCheck = t => { var n, i; if (this.isDisabled()) return; const { onNodeCheck: s } = this.context; t.stopPropagation(), (i = (n = t.nativeEvent) === null || n === void 0 ? void 0 : n.stopImmediatePropagation) === null || i === void 0 || i.call(n), s(t, this.props) }, this.handleCheckEnterPress = t => { Jn(t) && this.onCheck(t) }, this.onContextMenu = t => { const { onNodeRightClick: n } = this.context; n(t, this.props) }, this.onClick = t => { const { expandAction: n } = this.context; if (n === "doubleClick") { this.debounceSelect(t); return } this.onSelect(t), n === "click" && this.onExpand(t) }, this.handleliEnterPress = t => { Jn(t) && this.onClick(t) }, this.onDoubleClick = t => { const { expandAction: n, onNodeDoubleClick: i } = this.context; t.stopPropagation(), t.nativeEvent.stopImmediatePropagation(), we(i) && i(t, this.props), n === "doubleClick" && this.onExpand(t) }, this.onDragStart = t => { const { onNodeDragStart: n } = this.context; t.stopPropagation(), n(t, Object.assign(Object.assign({}, this.props), { nodeInstance: this.refNode })); try { t.dataTransfer.setData("text/plain", "") } catch { } }, this.onDragEnter = t => { const { onNodeDragEnter: n } = this.context; t.preventDefault(), t.stopPropagation(), n(t, Object.assign(Object.assign({}, this.props), { nodeInstance: this.refNode })) }, this.onDragOver = t => { const { onNodeDragOver: n } = this.context; t.preventDefault(), t.stopPropagation(), n(t, Object.assign(Object.assign({}, this.props), { nodeInstance: this.refNode })) }, this.onDragLeave = t => { const { onNodeDragLeave: n } = this.context; t.stopPropagation(), n(t, Object.assign(Object.assign({}, this.props), { nodeInstance: this.refNode })) }, this.onDragEnd = t => { const { onNodeDragEnd: n } = this.context; t.stopPropagation(), n(t, Object.assign(Object.assign({}, this.props), { nodeInstance: this.refNode })) }, this.onDrop = t => { const { onNodeDrop: n } = this.context; t.preventDefault(), t.stopPropagation(), n(t, Object.assign(Object.assign({}, this.props), { nodeInstance: this.refNode })) }, this.getNodeChildren = () => { const { children: t } = this.props; return t || [] }, this.isLeaf = () => { const { isLeaf: t, loaded: n } = this.props, { loadData: i } = this.context, s = this.getNodeChildren().length !== 0; return t === !1 ? !1 : t || !i && !s || i && n && !s }, this.isDisabled = () => { const { disabled: t } = this.props, { treeDisabled: n } = this.context; return t === !1 ? !1 : !!(n || t) }, this.renderSwitcher = () => this.isLeaf() ? f.createElement("span", { className: F(`${gt}-switcher`) }, f.createElement("span", { className: `${gt}-switcher-leaf-line` })) : null, this.renderRealLabel = () => { const { renderLabel: t } = this.context, { label: n, keyword: i, data: s, filtered: a, treeNodeFilterProp: o } = this.props; return we(t) ? t(n, s, i) : Fe(n) && a && i ? f.createElement(vc, { highlightClassName: `${gt}-highlight`, component: "span", sourceString: n, searchWords: [i] }) : n }, this.setRef = t => { this.refNode = t }, this.state = {}, this.debounceSelect = $d(this.onSelect, 500, { leading: !0, trailing: !1 }) } renderArrow() { const e = !this.isLeaf(), { loading: t, expanded: n, showLine: i } = this.props; return t ? f.createElement(yi, { wrapperClassName: `${gt}-spin-icon` }) : e ? f.createElement(YS, { role: "button", "aria-label": `${n ? "Expand" : "Collapse"} the tree item`, className: `${gt}-expand-icon`, size: "small", onClick: this.onExpand }) : i ? this.renderSwitcher() : f.createElement("span", { className: `${gt}-empty-icon` }) } renderCheckbox() { const { checked: e, halfChecked: t, eventKey: n } = this.props, i = this.isDisabled(); return f.createElement("div", { role: "none", onClick: this.onCheck, onKeyPress: this.handleCheckEnterPress }, f.createElement(bi, { "aria-label": "Toggle the checked state of checkbox", value: n, indeterminate: t, checked: e, disabled: !!i })) } renderIcon() { const { directory: e, treeIcon: t } = this.context, { expanded: n, icon: i, data: s } = this.props; return i || (t ? typeof t == "function" ? t(this.props) : t : e ? this.isLeaf() ? f.createElement(Sf, { className: `${gt}-item-icon` }) : n ? f.createElement(bH, { className: `${gt}-item-icon` }) : f.createElement(mH, { className: `${gt}-item-icon` }) : null) } renderEmptyNode() { const { emptyContent: e } = this.props, t = F(gt, { [`${gt}-empty`]: !0 }); return f.createElement("ul", { className: t }, f.createElement("li", { className: `${gt}-label ${gt}-label-empty`, "x-semi-prop": "emptyContent" }, e)) } render() { const e = this.props, { eventKey: t, expanded: n, selected: i, checked: s, halfChecked: a, loading: o, active: l, level: u, empty: d, filtered: h, treeNodeFilterProp: g, display: m, style: b, isEnd: y, showLine: w } = e, x = Cre(e, ["eventKey", "expanded", "selected", "checked", "halfChecked", "loading", "active", "level", "empty", "filtered", "treeNodeFilterProp", "display", "style", "isEnd", "showLine"]); if (d) return this.renderEmptyNode(); const { multiple: S, draggable: C, renderFullLabel: O, dragOverNodeKey: E, dropPosition: v, labelEllipsis: T } = this.context, I = y[y.length - 1], k = this.isDisabled(), P = E === t && v === 0, N = E === t && v === -1, M = E === t && v === 1, B = F(gt, { [`${gt}-level-${u + 1}`]: !0, [`${gt}-fullLabel-level-${u + 1}`]: O, [`${gt}-collapsed`]: !n, [`${gt}-disabled`]: !!k, [`${gt}-selected`]: i, [`${gt}-active`]: !S && l, [`${gt}-ellipsis`]: T, [`${gt}-drag-over`]: !k && P, [`${gt}-draggable`]: !k && C && !O, [`${gt}-fullLabel-draggable`]: !k && C && O, [`${gt}-fullLabel-drag-over-gap-top`]: !k && N && O, [`${gt}-fullLabel-drag-over-gap-bottom`]: !k && M && O, [`${gt}-tree-node-last-leaf`]: I }), K = { onClick: this.onClick, onContextMenu: this.onContextMenu, onDoubleClick: this.onDoubleClick, className: B, onExpand: this.onExpand, data: x.data, level: u, onCheck: this.onCheck, style: b, expandIcon: this.renderArrow(), checkStatus: { checked: s, halfChecked: a }, expandStatus: { expanded: n, loading: o }, filtered: h, searchWord: x.keyword }, U = { onDoubleClick: this.onDoubleClick, onDragStart: C ? this.onDragStart : void 0, onDragEnter: C ? this.onDragEnter : void 0, onDragOver: C ? this.onDragOver : void 0, onDragLeave: C ? this.onDragLeave : void 0, onDrop: C ? this.onDrop : void 0, onDragEnd: C ? this.onDragEnd : void 0, draggable: !k && C || void 0 }; if (O) { const ee = O(Object.assign({}, K)); return C ? f.cloneElement(ee, Object.assign({ ref: this.setRef }, U)) : kt(b) ? ee : f.cloneElement(ee, { style: Object.assign(Object.assign({}, H(ee, ["props", "style"])), b) }) } const W = F(`${gt}-label`, { [`${gt}-drag-over-gap-top`]: !k && N, [`${gt}-drag-over-gap-bottom`]: !k && M }), Z = H(x, ["data", "children", "length"]), J = Fe(x.pos) ? Number(x.pos.split("-")[u + 1]) + 1 : 1; return f.createElement("li", Object.assign({ className: B, role: "treeitem", "aria-disabled": k, "aria-checked": s, "aria-selected": i, "aria-setsize": Z, "aria-posinset": J, "aria-expanded": n, "aria-level": u + 1, "data-key": t, onClick: this.onClick, onKeyPress: this.handleliEnterPress, onContextMenu: this.onContextMenu, onDoubleClick: this.onDoubleClick, ref: this.setRef, style: b }, U), f.createElement(wre, { showLine: w, prefixcls: gt, level: u, isEnd: y }), this.renderArrow(), f.createElement("span", { className: W }, S ? this.renderCheckbox() : null, this.renderIcon(), f.createElement("span", { className: `${gt}-label-text` }, this.renderRealLabel()))) } } yo.contextType = vb; yo.propTypes = { expanded: c.bool, selected: c.bool, checked: c.bool, halfChecked: c.bool, active: c.bool, disabled: c.bool, loaded: c.bool, loading: c.bool, isLeaf: c.bool, pos: c.string, children: c.oneOfType([c.array, c.object]), icon: c.node, directory: c.bool, keyword: c.string, treeNodeFilterProp: c.string, selectedKey: c.string, motionKey: c.oneOfType([c.string, c.arrayOf(c.string)]), isEnd: c.arrayOf(c.bool), showLine: c.bool }; yo.defaultProps = { selectedKey: "", motionKey: "" }; var Sre = function (r, e) { var t = {}; for (var n in r) Object.prototype.hasOwnProperty.call(r, n) && e.indexOf(n) < 0 && (t[n] = r[n]); if (r != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, n = Object.getOwnPropertySymbols(r); i < n.length; i++)e.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(r, n[i]) && (t[n[i]] = r[n[i]]); return t }; function Ere(r) { const { open: e, children: t } = r, n = Sre(r, ["open", "children"]), [i, s] = R.useState(r.open); return R.useEffect(() => { setTimeout(() => { s(!r.open) }, 0) }, []), f.createElement(ls, Object.assign({}, n, { isOpen: i }), t) } const vw = r => r.key; class JO extends R.PureComponent { constructor(e) { super(e), this.onMotionEnd = () => { typeof this.props.onMotionEnd == "function" && this.props.onMotionEnd(), this.setState({ transitionNodes: [] }) }, this.state = { transitionNodes: [] } } static getDerivedStateFromProps(e, t) { const { flattenNodes: n = [], motionKeys: i, motionType: s, flattenList: a = [] } = e, o = !ke(t.cachedMotionKeys, i) || !ke(t.cachedData.map(b => b.key), n.map(b => b.key)), l = [...i]; if (!o || !l.length) return null; const u = [], d = []; let h = 0, g = {}; return (s === "hide" && a ? a : n).forEach((b, y) => { const w = vw(b); i.has(w) ? (d.push(b), w === l[0] && (h = y)) : u.push(b) }), u.splice(h, 0, d), g = { transitionNodes: u, cachedData: n, cachedMotionKeys: i, cachedMotionType: s }, g } render() { const { flattenNodes: e, motionType: t, searchTargetIsDeep: n, renderTreeNode: i } = this.props, { transitionNodes: s } = this.state; return (s.length && !n ? s : e).map(l => { const u = Array.isArray(l); if (u && !l.length) return null; if (u && l.length) { const d = vw(l[0]); return f.createElement(Ere, { open: t === "hide", duration: 200, motion: !!t, key: `motion-${d}`, onMotionEnd: this.onMotionEnd }, l.map(h => i(h))) } return i(l) }) } } JO.contextType = vb; const QO = { PREFIX: `${G}-tree-select`, PREFIX_TREE: `${G}-tree`, PREFIX_OPTION: `${G}-tree-select-option` }, ar = { SIZE_SET: ["small", "large", "default"], SEARCH_POSITION_DROPDOWN: "dropdown", SEARCH_POSITION_TRIGGER: "trigger", STATUS: Vo }; class _re extends ve { constructor(e) { super(Object.assign({}, e)), this.handleKeyDown = t => { t.key === qS && this.getState("isOpen") && this.close(t) }, this._registerClickOutsideHandler = () => { this._adapter.registerClickOutsideHandler(t => { this.handlerTriggerBlur(t), this.close(t) }) }, this.clearInputValue = () => { const { inputValue: t } = this.getStates(); t && this._adapter.updateInputValue("") }, this.onClickSingleTriggerSearchItem = t => { this.focusInput(!0) } } init() { const { searchAutoFocus: e, searchPosition: t, filterTreeNode: n } = this.getProps(), i = t === ar.SEARCH_POSITION_TRIGGER && n, s = e && i; this._setDropdownWidth(); const a = !this._isDisabled(); (this.getProp("defaultOpen") || s) && a && (this.open(), this._registerClickOutsideHandler()), s && a && this.handleTriggerFocus(null) } destroy() { this._adapter.unregisterClickOutsideHandler() } _setDropdownWidth() { const { style: e, dropdownMatchSelectWidth: t } = this.getProps(); let n; t && (e && Zt(e.width) || e && Fe(e.width) && !e.width.includes("%") ? n = e.width : n = this._adapter.getTriggerWidth(), this._adapter.setOptionWrapperWidth(n)) } _isMultiple() { return this.getProp("multiple") } _isAnimated() { return this.getProp("motionExpand") } _isDisabled() { let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}; return this.getProp("disabled") || e.disabled } _isExpandControlled() { return this.getProp("expandedKeys") } _isSelectToClose() { return !this.getProp("expandAction") } _isLoadControlled() { return this.getProp("loadedKeys") } _showFilteredOnly() { const { inputValue: e } = this.getStates(), { showFilteredOnly: t } = this.getProps(); return !!e && t } findDataForValue(e) { const { value: t, defaultValue: n, keyMaps: i } = this.getProps(), s = H(i, "value", "value"), a = H(i, "key", "key"); let o = []; return t ? o = Array.isArray(t) ? t : [t] : n && (o = Array.isArray(n) ? n : [n]), o.find(l => l[s] === e || l[a] === e) } constructDataForValue(e) { const { treeNodeLabelProp: t, keyMaps: n } = this.getProps(), i = H(n, "key", "key"), s = H(n, "label", t); return { [i]: e, [s]: e } } getDataForKeyNotInKeyEntities(e) { const { onChangeWithObject: t } = this.getProps(); return t ? this.findDataForValue(e) : this.constructDataForValue(e) } getTreeNodeProps(e) { const { expandedKeys: t = new Set([]), selectedKeys: n = [], checkedKeys: i = new Set([]), halfCheckedKeys: s = new Set([]), realCheckedKeys: a = new Set([]), keyEntities: o = {}, filteredKeys: l = new Set([]), inputValue: u = "", loadedKeys: d, loadingKeys: h, filteredExpandedKeys: g = new Set([]), disabledKeys: m = new Set([]) } = this.getStates(), { treeNodeFilterProp: b, checkRelation: y } = this.getProps(), w = o[e]; if (!w) return null; let S = !1, C = !1; y === "related" ? (S = i.has(e), C = s.has(e)) : y === "unRelated" && (S = a.has(e), C = !1); const E = { eventKey: e, expanded: !!u ? g.has(e) : t.has(e), selected: n.includes(e), checked: S, halfChecked: C, pos: String(w ? w.pos : ""), level: w.level, filtered: l.has(e), keyword: u, treeNodeFilterProp: b, loading: h.has(e) && !d.has(e), loaded: d.has(e) }; return this.getProp("disableStrictly") && m.has(e) && (E.disabled = !0), E } handleNodeLoad(e, t, n, i) { const { loadData: s } = this.getProps(), { key: a } = n; return !s || e.has(a) || t.has(a) ? {} : (s(n).then(() => { const o = new Set(this.getState("loadedKeys")), l = new Set(this.getState("loadingKeys")), u = o.add(a), d = new Set([...l]); d.delete(a), this._adapter.notifyLoad(u, n), this._isLoadControlled() || this._adapter.updateState({ loadedKeys: u }), this._adapter.setState({ loadingKeys: d }), i() }), { loadingKeys: t.add(a) }) } focusInput(e) { this._adapter.updateInputFocus(e) } _notifyMultipleChange(e, t) { const { keyEntities: n } = this.getStates(), { leafOnly: i, checkRelation: s, keyMaps: a, autoMergeValue: o } = this.getProps(); let l = []; s === "related" ? l = o ? hi(e, n, i, !0) : e : s === "unRelated" && (l = e); const u = l.map(d => n[d] && n[d].key === d ? n[d].data : this.getDataForKeyNotInKeyEntities(d)); if (this.getProp("onChangeWithObject")) this._adapter.notifyChangeWithObject(u, t); else { const d = sd(u, a); this._adapter.notifyChange(d, u, t) } } _notifyChange(e, t) { const { keyEntities: n } = this.getStates(), { keyMaps: i } = this.getProps(); if (this._isMultiple() && Array.isArray(e)) this._notifyMultipleChange(e, t); else { const s = st(e) ? e : n[e].data, a = st(e) ? e : sd(s, i); this.getProp("onChangeWithObject") ? this._adapter.notifyChangeWithObject(s, t) : this._adapter.notifyChange(a, s, t) } } _notifyFocus(e) { this._adapter.notifyFocus(e) } handleTriggerFocus(e) { this._adapter.updateIsFocus(!0), this._notifyFocus(e), this._registerClickOutsideHandler() } _notifyBlur(e) { this._adapter.notifyBlur(e) } handlerTriggerBlur(e) { this.getState("isFocus") && (this._adapter.updateIsFocus(!1), this._notifyBlur(e), this._adapter.unregisterClickOutsideHandler()) } toggleHoverState(e) { this._adapter.toggleHovering(e) } open() { this._adapter.openMenu(), this._setDropdownWidth() } close(e) { this._adapter.closeMenu(), this.getProp("motionExpand") && this._adapter.updateState({ motionKeys: new Set([]) }) } handleClick(e) { const t = this._isDisabled(), { isOpen: n, inputValue: i, isFocus: s } = this.getStates(), { searchPosition: a, clickTriggerToHide: o } = this.getProps(); if (!t) if (s || this.handleTriggerFocus(e), n) { if (a === "trigger" && i) return; o && this.close(e) } else this.open() } handleSelectionEnterPress(e) { Jn(e) && this.handleClick(e) } handleClear(e) { const { searchPosition: t, filterTreeNode: n } = this.getProps(), { inputValue: i, selectedKeys: s } = this.getStates(), a = this._isMultiple(), o = this._isControlledComponent(), l = a ? [] : void 0; this._notifyChange(l, e), o || (this._adapter.rePositionDropdown(), this._adapter.updateState({ selectedKeys: [], checkedKeys: new Set, halfCheckedKeys: new Set, realCheckedKeys: new Set([]) })), n && t === ar.SEARCH_POSITION_TRIGGER && i !== "" && (kt(s) ? this.handleInputChange("") : this.clearInput()), this._adapter.notifyClear(e) } handleClearEnterPress(e) { Jn(e) && this.handleClear(e) } removeTag(e) { const { disableStrictly: t, checkRelation: n, keyMaps: i } = this.getProps(), { keyEntities: s, disabledKeys: a, realCheckedKeys: o } = this.getStates(), l = s[e] && s[e].key === e ? s[e].data : this.getDataForKeyNotInKeyEntities(e), u = H(i, "disabled", "disabled"); if (!(l[u] || t && a.has(e))) { if (n === "unRelated") { const d = new Set(o); d.delete(e), this._notifyChange([...d], null), this._isControlledComponent() || (this._adapter.updateState({ realCheckedKeys: d }), this._adapter.rePositionDropdown()) } else if (n === "related") { const { checkedKeys: d, halfCheckedKeys: h } = this.calcCheckedKeys(e, !1); this._notifyChange([...d], null), this._isControlledComponent() || (this._adapter.updateState({ checkedKeys: d, halfCheckedKeys: h }), this._adapter.rePositionDropdown()) } this._adapter.notifySelect(e, !1, l), this._adapter.rePositionDropdown() } } clearInput() { const { flattenNodes: e, expandedKeys: t, selectedKeys: n, keyEntities: i, treeData: s } = this.getStates(), { keyMaps: a } = this.getProps(), o = new Set(t); this._isExpandControlled(); const l = ji(n, i, !1); l.forEach(d => o.add(d)); const u = Ts(s, o, a); this._adapter.updateState({ expandedKeys: o, flattenNodes: u, inputValue: "", motionKeys: new Set([]), filteredKeys: new Set([]), filteredExpandedKeys: new Set(l), filteredShownKeys: new Set([]) }), this._adapter.rePositionDropdown() } handleInputChange(e) { this._adapter.updateInputValue(e); const { flattenNodes: t, expandedKeys: n, selectedKeys: i, keyEntities: s, treeData: a } = this.getStates(), { showFilteredOnly: o, filterTreeNode: l, treeNodeFilterProp: u, keyMaps: d } = this.getProps(), h = u !== "label" ? u : H(d, "label", "label"), g = new Set(n); let m = [], b = [], y = [], w = [], x = new Set([]); if (!e) y = ji(i, s, !1), y.forEach(C => g.add(C)), w = Ts(a, g, d); else { const C = Object.values(s).filter(E => { const { data: v } = E; return xE(e, v, l, h) }); m = C.map(E => E.data), b = C.map(E => E.key), y = ji(b, s, !1); const O = Mi(b, s, !0); x = new Set([...O, ...y]), w = Ts(a, new Set(y), d, o && x) } const S = new Set(y); this._adapter.notifySearch(e, Array.from(S), m), this._adapter.updateState({ expandedKeys: g, flattenNodes: w, motionKeys: new Set([]), filteredKeys: new Set(b), filteredExpandedKeys: S, filteredShownKeys: x }), this._adapter.rePositionDropdown() } handleNodeSelect(e, t) { this._isDisabled(t) || (this._isMultiple() ? this.handleMultipleSelect(e, t) : this.handleSingleSelect(e, t)) } handleSingleSelect(e, t) { let n = [...this.getState("selectedKeys")]; const { clickToHide: i } = this.getProps(), { selected: s, eventKey: a, data: o } = t; this._adapter.notifySelect(a, !0, o), !n.includes(a) && !s && (n = [a], this._notifyChange(a, e), this._isControlledComponent() || this._adapter.updateState({ selectedKeys: n })), i && (this._isSelectToClose() || !o.children) && (this.close(e), this.handlerTriggerBlur(e)) } calcCheckedKeys(e, t) { const { keyEntities: n } = this.getStates(), i = new Set(this.getState("checkedKeys")), s = new Set(this.getState("halfCheckedKeys")); return t ? wE(e, n, i, s) : CE(e, n, i, s) } handleMultipleSelect(e, t) { const { searchPosition: n, disableStrictly: i, checkRelation: s } = this.getProps(), { inputValue: a, realCheckedKeys: o } = this.getStates(), { checked: l, eventKey: u, data: d } = t; if (s === "related") { const h = i ? this.calcCheckedStatus(!l, u) : !l, { checkedKeys: g, halfCheckedKeys: m } = i ? this.calcNonDisabledCheckedKeys(u, h) : this.calcCheckedKeys(u, h); this._adapter.notifySelect(u, h, d), this._notifyChange([...g], e), this._isControlledComponent() || (this._adapter.updateState({ checkedKeys: g, halfCheckedKeys: m }), this._adapter.rePositionDropdown()) } else if (s === "unRelated") { const h = new Set(o); let g; o.has(u) ? (h.delete(u), g = !1) : (h.add(u), g = !0), this._adapter.notifySelect(u, g, d), this._notifyChange([...h], e), this._isControlledComponent() || (this._adapter.updateState({ realCheckedKeys: h }), this._adapter.rePositionDropdown()) } n === ar.SEARCH_POSITION_TRIGGER && a !== "" && this._adapter.updateState({ inputValue: "" }) } calcNonDisabledCheckedKeys(e, t) { const { keyEntities: n, disabledKeys: i } = this.getStates(), s = new Set(this.getState("checkedKeys")), a = hi(Mi([e], n, !1), n, !0); if (!a.some(d => i.has(d))) return this.calcCheckedKeys(e, t); const l = a.filter(d => !i.has(d)), u = t ? [...l, ...s] : Eo(hi([...s], n, !0, !0), l); return Sc(u, n) } calcCheckedStatus(e, t) { if (!e) return e; const { checkedKeys: n, keyEntities: i, disabledKeys: s } = this.getStates(), a = hi(Mi([t], i, !1), i, !0); return a.some(d => s.has(d)) ? !a.filter(d => !s.has(d)).every(d => n.has(d)) : e } handleNodeExpandInSearch(e, t) { const { treeData: n, filteredShownKeys: i, keyEntities: s } = this.getStates(), { keyMaps: a } = this.getProps(), o = this._showFilteredOnly(), l = new Set(this.getState("filteredExpandedKeys")); let u = "show"; const { eventKey: d, expanded: h, data: g } = t; if (h ? l.has(d) && (l.delete(d), u = "hide") : l.add(d), this._adapter.cacheFlattenNodes(u === "hide" && this._isAnimated()), !this._isExpandControlled()) { const m = Ts(n, l, a, o && i), b = this._isAnimated() ? Ix(d, l, s) : [], y = { filteredExpandedKeys: l, flattenNodes: m, motionKeys: new Set(b), motionType: u }; this._adapter.updateState(y) } this._adapter.notifyExpand(l, { expanded: !h, node: g }) } handleNodeExpand(e, t) { const { loadData: n, keyMaps: i } = this.getProps(), { inputValue: s, keyEntities: a } = this.getStates(), o = !!s; if (!n && (!t.children || !t.children.length)) return; const l = this._isExpandControlled(); if (o) { this.handleNodeExpandInSearch(e, t); return } const { treeData: u } = this.getStates(), d = new Set(this.getState("expandedKeys")); let h = "show"; const { eventKey: g, expanded: m, data: b } = t; if (m ? d.has(g) && (d.delete(g), h = "hide") : d.add(g), this._adapter.cacheFlattenNodes(h === "hide" && this._isAnimated()), !l) { const y = Ts(u, d, i), w = this._isAnimated() ? Ix(g, d, a) : [], x = { expandedKeys: d, flattenNodes: y, motionKeys: new Set(w), motionType: h }; this._adapter.updateState(x) } this._adapter.notifyExpand(d, { expanded: !m, node: b }) } getRenderTextInSingle() { const { renderSelectedItem: e, treeNodeLabelProp: t, keyMaps: n } = this.getProps(), { selectedKeys: i, keyEntities: s } = this.getStates(), a = H(n, "label", t), o = we(e) ? e : d => H(d, a, null); let l; if (i.length) { const d = i[0]; l = s[d] && s[d].key === d ? s[d].data : this.getDataForKeyNotInKeyEntities(d) } return l ? o(l) : null } handleInputTriggerBlur() { this._adapter.updateState({ inputTriggerFocus: !1 }) } handleInputTriggerFocus() { this.clearInput(), this._adapter.updateState({ inputTriggerFocus: !0 }) } setLoadKeys(e, t) { this._adapter.updateLoadKeys(e, t) } handlePopoverVisibleChange(e) { const { filterTreeNode: t, searchAutoFocus: n, searchPosition: i } = this.getProps(); e === !1 && t && this.clearInputValue(), t && i === ar.SEARCH_POSITION_DROPDOWN && e && n && this.focusInput(!0) } handleAfterClose() { const { filterTreeNode: e } = this.getProps(); e && this.clearInput() } } var Ore = function (r, e) { var t = {}; for (var n in r) Object.prototype.hasOwnProperty.call(r, n) && e.indexOf(n) < 0 && (t[n] = r[n]); if (r != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, n = Object.getOwnPropertySymbols(r); i < n.length; i++)e.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(r, n[i]) && (t[n[i]] = r[n[i]]); return t }; const We = QO.PREFIX, qs = QO.PREFIX_TREE, Tre = 0; class Nh extends de { constructor(e) { super(e), this.renderSuffix = () => { const { suffix: t } = this.props, n = F({ [`${We}-suffix`]: !0, [`${We}-suffix-text`]: t && Fe(t), [`${We}-suffix-icon`]: Bn(t) }); return f.createElement("div", { className: n, "x-semi-prop": "suffix" }, t) }, this.renderPrefix = () => { const { prefix: t, insetLabel: n, insetLabelId: i } = this.props, s = t || n, a = F({ [`${We}-prefix`]: !0, [`${We}-inset-label`]: n, [`${We}-prefix-text`]: s && Fe(s), [`${We}-prefix-icon`]: Bn(s) }); return f.createElement("div", { className: a, id: i, "x-semi-prop": "prefix,insetLabel" }, s) }, this.renderContent = () => { const { dropdownMinWidth: t } = this.state, { dropdownStyle: n, dropdownClassName: i } = this.props, s = Object.assign({ minWidth: t }, n), a = F(i, `${We}-popover`); return f.createElement("div", { className: a, style: s, onKeyDown: this.foundation.handleKeyDown }, this.renderTree()) }, this.removeTag = t => { this.foundation.removeTag(t) }, this.handleClick = t => { this.foundation.handleClick(t) }, this.getDataForKeyNotInKeyEntities = t => this.foundation.getDataForKeyNotInKeyEntities(t), this.handleSelectionEnterPress = t => { this.foundation.handleSelectionEnterPress(t) }, this.hasValue = () => { const { multiple: t, checkRelation: n } = this.props, { realCheckedKeys: i, checkedKeys: s, selectedKeys: a } = this.state; let o = !1; return t ? n === "related" ? o = !!s.size : n === "unRelated" && (o = !!i.size) : o = !!a.length, o }, this.showClearBtn = () => { const { showClear: t, disabled: n, searchPosition: i } = this.props, { inputValue: s, isOpen: a, isHovering: o } = this.state, l = i === ar.SEARCH_POSITION_TRIGGER && s; return t && (this.hasValue() || l) && !n && (a || o) }, this.renderTagList = t => { const { keyEntities: n, disabledKeys: i } = this.state, { treeNodeLabelProp: s, leafOnly: a, disabled: o, disableStrictly: l, size: u, renderSelectedItem: d, keyMaps: h } = this.props, g = H(h, "label", s), m = we(d) ? d : y => ({ isRenderInTag: !0, content: H(y, g, null) }), b = []; return t.forEach((y, w) => { const x = n[y] && n[y].key === y ? n[y].data : this.getDataForKeyNotInKeyEntities(y), S = (T, I) => { I && typeof I.preventDefault == "function" && I.preventDefault(), this.removeTag(y) }, { content: C, isRenderInTag: O } = x ? m(x, { index: w, onClose: S }) : {}; if (ss(C) || st(C)) return; const v = { closable: !(o || x.disabled || l && i.has(x.key)), color: "white", visible: !0, onClose: S, key: `tag-${y}-${w}`, size: u === "small" ? "small" : "large" }; O ? b.push(f.createElement(wr, Object.assign({}, v), C)) : b.push(C) }), b }, this.renderSingleTriggerSearchItem = () => { const { placeholder: t, disabled: n } = this.props, { inputTriggerFocus: i } = this.state, s = this.foundation.getRenderTextInSingle(), a = F(`${We}-selection-TriggerSearchItem`, { [`${We}-selection-TriggerSearchItem-placeholder`]: (i || !s) && !n, [`${We}-selection-TriggerSearchItem-disabled`]: n }); return f.createElement("span", { className: a, onClick: this.foundation.onClickSingleTriggerSearchItem }, s || t) }, this.renderSingleTriggerSearch = () => { const { inputValue: t } = this.state; return f.createElement(f.Fragment, null, this.renderInput(), !t && this.renderSingleTriggerSearchItem()) }, this.renderSelectContent = t => { const { multiple: n, placeholder: i, maxTagCount: s, searchPosition: a, filterTreeNode: o, showRestTagsPopover: l, restTagsPopoverProps: u } = this.props; if (o && a === ar.SEARCH_POSITION_TRIGGER) return n ? this.renderTagInput(t) : this.renderSingleTriggerSearch(); if (!n || !this.hasValue()) { const g = this.foundation.getRenderTextInSingle(), m = F(`${We}-selection-content`, { [`${We}-selection-placeholder`]: !g }); return f.createElement("span", { className: m }, g || i) } const h = this.renderTagList(t); return f.createElement(ql, { maxTagCount: s, tagList: h, size: "large", mode: "custom", showPopover: l, popoverProps: u }) }, this.handleClear = t => { t && t.stopPropagation(), this.foundation.handleClear(t) }, this.handleClearEnterPress = t => { t && t.stopPropagation(), this.foundation.handleClearEnterPress(t) }, this.handleMouseOver = t => { this.foundation.toggleHoverState(!0) }, this.handleMouseLeave = t => { this.foundation.toggleHoverState(!1) }, this.search = t => { const { isOpen: n } = this.state; n || this.foundation.open(), this.foundation.handleInputChange(t) }, this.close = () => { this.foundation.close(null) }, this.renderArrow = () => { const t = this.showClearBtn(), { arrowIcon: n } = this.props; return t ? null : n ? f.createElement("div", { className: F(`${We}-arrow`), "x-semi-prop": "arrowIcon" }, n) : null }, this.renderClearBtn = () => { const t = this.showClearBtn(), { clearIcon: n } = this.props, i = F(`${We}-clearbtn`); return t ? f.createElement("div", { role: "button", tabIndex: 0, "aria-label": "Clear TreeSelect value", className: i, onClick: this.handleClear, onKeyPress: this.handleClearEnterPress }, n || f.createElement(us, null)) : null }, this.renderSelection = () => { const t = this.props, { disabled: n, multiple: i, filterTreeNode: s, validateStatus: a, prefix: o, suffix: l, style: u, size: d, insetLabel: h, className: g, placeholder: m, showClear: b, leafOnly: y, searchPosition: w, triggerRender: x, borderless: S, autoMergeValue: C, checkRelation: O } = t, E = Ore(t, ["disabled", "multiple", "filterTreeNode", "validateStatus", "prefix", "suffix", "style", "size", "insetLabel", "className", "placeholder", "showClear", "leafOnly", "searchPosition", "triggerRender", "borderless", "autoMergeValue", "checkRelation"]), { inputValue: v, selectedKeys: T, checkedKeys: I, keyEntities: k, isFocus: P, realCheckedKeys: N } = this.state, M = !!s, B = typeof x == "function", K = b ? { onMouseEnter: re => this.handleMouseOver(re), onMouseLeave: re => this.handleMouseLeave(re) } : {}, U = w === ar.SEARCH_POSITION_TRIGGER && M, W = U && kt(I), Z = U && !kt(I), J = B ? F(g) : F(We, { [`${We}-borderless`]: S, [`${We}-focus`]: P, [`${We}-disabled`]: n, [`${We}-single`]: !i, [`${We}-multiple`]: i, [`${We}-multiple-tagInput-empty`]: i && W, [`${We}-multiple-tagInput-notEmpty`]: i && Z, [`${We}-filterable`]: M, [`${We}-error`]: a === "error", [`${We}-warning`]: a === "warning", [`${We}-small`]: d === "small", [`${We}-large`]: d === "large", [`${We}-with-prefix`]: o || h, [`${We}-with-suffix`]: l, [`${We}-with-suffix`]: l }, g); let ee, $ = []; i ? C ? O === "related" ? $ = hi([...I], k, y, !0) : O === "unRelated" && ($ = [...N]) : $ = [...I] : $ = T, B ? ee = f.createElement(Ia, { inputValue: v, value: $.map(re => H(k, [re, "data"])), disabled: n, placeholder: m, onClear: this.handleClear, componentName: "TreeSelect", triggerRender: x, componentProps: Object.assign({}, this.props), onSearch: this.search, onRemove: this.removeTag }) : ee = [f.createElement(R.Fragment, { key: "prefix" }, o || h ? this.renderPrefix() : null), f.createElement(R.Fragment, { key: "selection" }, f.createElement("div", { className: `${We}-selection` }, this.renderSelectContent($))), f.createElement(R.Fragment, { key: "suffix" }, l ? this.renderSuffix() : null), f.createElement(R.Fragment, { key: "clearBtn" }, b || U && v ? this.renderClearBtn() : null), f.createElement(R.Fragment, { key: "arrow" }, this.renderArrow())]; const pe = n ? null : 0; return f.createElement("div", Object.assign({ role: "combobox", "aria-disabled": n, "aria-haspopup": "tree", tabIndex: pe, className: J, style: u, ref: this.triggerRef, onClick: this.handleClick, onKeyPress: this.handleSelectionEnterPress, onKeyDown: this.foundation.handleKeyDown, "aria-invalid": this.props["aria-invalid"], "aria-errormessage": this.props["aria-errormessage"], "aria-label": this.props["aria-label"], "aria-labelledby": this.props["aria-labelledby"], "aria-describedby": this.props["aria-describedby"], "aria-required": this.props["aria-required"] }, K, this.getDataAttr(E)), ee) }, this.renderTagItem = (t, n) => { const { keyEntities: i, disabledKeys: s } = this.state, { size: a, leafOnly: o, disabled: l, disableStrictly: u, renderSelectedItem: d, treeNodeLabelProp: h, keyMaps: g } = this.props, m = H(g, "label", h), y = hi([t], i, o, !0).map(k => i[t] && i[t].key === t ? i[t].data : this.getDataForKeyNotInKeyEntities(t)), w = sd(y, g), x = F(`${We}-selection-tag`, { [`${We}-selection-tag-disabled`]: l }), S = !kt(y) && !kt(y[0]), C = u && S && s.has(y[0].key), O = S && !y[0].disabled && !l && !C, E = (k, P) => { P.preventDefault(), this.removeTag(t) }, v = { size: a === "small" ? "small" : "large", key: `tag-${w}-${n}`, color: "white", className: x, closable: O, onClose: E }, T = y[0], I = we(d) ? d : k => ({ isRenderInTag: !0, content: H(k, m, null) }); if (we(I)) { const { content: k, isRenderInTag: P } = T ? I(T, { index: n, onClose: E }) : {}; return P ? f.createElement(wr, Object.assign({}, v), k) : k } return f.createElement(wr, Object.assign({}, v), w) }, this.renderTagInput = t => { const { disabled: n, size: i, searchAutoFocus: s, placeholder: a, maxTagCount: o, showRestTagsPopover: l, restTagsPopoverProps: u, searchPosition: d, filterTreeNode: h, preventScroll: g } = this.props, { inputValue: m } = this.state, b = h && d === ar.SEARCH_POSITION_TRIGGER ? s : void 0; return f.createElement(Pc, { maxTagCount: o, disabled: n, onInputChange: y => this.search(y), ref: this.tagInputRef, placeholder: a, value: t, inputValue: m, size: i, showRestTagsPopover: l, restTagsPopoverProps: u, autoFocus: b, renderTagItem: (y, w) => this.renderTagItem(y, w), onRemove: y => this.removeTag(y), expandRestTagsOnClick: !1, preventScroll: g }) }, this.renderInput = () => { const { searchPlaceholder: t, searchRender: n, showSearchClear: i, searchPosition: s, searchAutoFocus: a, multiple: o, disabled: l, preventScroll: u } = this.props, { inputValue: d, inputTriggerFocus: h } = this.state, g = s === ar.SEARCH_POSITION_DROPDOWN, m = F({ [`${qs}-input`]: g, [`${We}-inputTrigger`]: !g }), b = { value: d, className: m, preventScroll: u, onChange: O => this.search(O) }, x = g ? { showClear: i, prefix: f.createElement(GS, null) } : { autofocus: a, onFocus: O => this.foundation.handleInputTriggerFocus(), onBlur: O => this.foundation.handleInputTriggerBlur(), disabled: l }, S = F({ [`${qs}-search-wrapper`]: g, [`${We}-triggerSingleSearch-wrapper`]: !g && !o, [`${We}-triggerSingleSearch-upper`]: !g && h }), C = typeof n == "function" || typeof n == "boolean"; return C && !n ? null : f.createElement("div", { className: S }, f.createElement(Ke, { componentName: "TreeSelect" }, O => { const E = g ? t || O.searchPlaceholder : ""; return C ? n(Object.assign(Object.assign(Object.assign({}, x), b), { placeholder: E })) : f.createElement(xr, Object.assign({ "aria-label": "Filter TreeSelect item", ref: this.inputRef, placeholder: E }, b, x)) })) }, this.renderEmpty = () => { const { emptyContent: t } = this.props; return t === null ? null : t ? f.createElement(yo, { empty: !0, emptyContent: this.props.emptyContent }) : f.createElement(Ke, { componentName: "Tree" }, n => f.createElement(yo, { empty: !0, emptyContent: n.emptyText })) }, this.onNodeLoad = t => new Promise(n => this.foundation.setLoadKeys(t, n)), this.onNodeSelect = (t, n) => { this.foundation.handleNodeSelect(t, n) }, this.onNodeCheck = (t, n) => { this.foundation.handleNodeSelect(t, n) }, this.onNodeExpand = (t, n) => { this.foundation.handleNodeExpand(t, n) }, this.getTreeNodeRequiredProps = () => { const { expandedKeys: t, selectedKeys: n, checkedKeys: i, halfCheckedKeys: s, keyEntities: a, filteredKeys: o } = this.state; return { expandedKeys: t || new Set, selectedKeys: n || [], checkedKeys: i || new Set, halfCheckedKeys: s || new Set, filteredKeys: o || new Set, keyEntities: a } }, this.getTreeNodeKey = t => { const { data: n } = t, { key: i } = n; return i }, this.handlePopoverVisibleChange = t => { this.foundation.handlePopoverVisibleChange(t) }, this.afterClose = () => { this.foundation.handleAfterClose() }, this.renderTreeNode = (t, n, i) => { const { data: s, key: a } = t, o = this.foundation.getTreeNodeProps(a), { showLine: l } = this.props; if (!o) return null; const u = cr(t, ["key", "label", "disabled", "isLeaf", "icon", "isEnd"]), { keyMaps: d } = this.props, h = s[H(d, "children", "children")]; return !st(h) && (u.children = h), f.createElement(yo, Object.assign({}, o, s, u, { data: s, style: i, showLine: l })) }, this.itemKey = (t, n) => { const { visibleOptions: i } = n; return i[t].key }, this.renderNodeList = () => { const { flattenNodes: t, cachedFlattenNodes: n, motionKeys: i, motionType: s, filteredKeys: a } = this.state, { direction: o } = this.context, { virtualize: l, motionExpand: u } = this.props, d = "expandedKeys" in this.props; if (!l || kt(l)) return f.createElement(JO, { flattenNodes: t, flattenList: n, motionKeys: u ? i : new Set([]), motionType: s, searchTargetIsDeep: d && u && kt(i) && !kt(a), onMotionEnd: this.onMotionEnd, renderTreeNode: this.renderTreeNode }); const h = { visibleOptions: t, renderOption: this.renderTreeNode }; return f.createElement(bb, { defaultHeight: l.height, defaultWidth: l.width }, g => { let { height: m, width: b } = g; return f.createElement(eh, { itemCount: t.length, itemSize: l.itemSize, height: m, width: b, itemKey: this.itemKey, itemData: h, className: `${qs}-virtual-list`, style: { direction: o } }, sO) }) }, this.renderTree = () => { const { keyEntities: t, motionKeys: n, motionType: i, inputValue: s, filteredKeys: a, flattenNodes: o, checkedKeys: l, realCheckedKeys: u } = this.state, { loadData: d, filterTreeNode: h, disabled: g, multiple: m, showFilteredOnly: b, motionExpand: y, outerBottomSlot: w, outerTopSlot: x, expandAction: S, labelEllipsis: C, virtualize: O, optionListStyle: E, searchPosition: v, renderLabel: T, renderFullLabel: I, checkRelation: k, emptyContent: P } = this.props, N = F(`${qs}-wrapper`), M = !!s && !a.size, B = kt(o) || b && M, K = v === ar.SEARCH_POSITION_DROPDOWN, U = F(`${qs}-option-list ${qs}-option-list-block`, { [`${qs}-option-list-hidden`]: P === null && B }); return f.createElement(vb.Provider, { value: { loadData: d, treeDisabled: g, motion: y, motionKeys: n, motionType: i, expandAction: S, filterTreeNode: h, keyEntities: t, onNodeClick: this.onNodeClick, onNodeDoubleClick: this.onNodeDoubleClick, onNodeRightClick: z, onNodeExpand: this.onNodeExpand, onNodeSelect: this.onNodeSelect, onNodeCheck: this.onNodeCheck, renderTreeNode: this.renderTreeNode, multiple: m, showFilteredOnly: b, isSearching: !!s, renderLabel: T, renderFullLabel: I, labelEllipsis: typeof C > "u" ? O : C } }, f.createElement("div", { className: N }, x, !x && h && K && this.renderInput(), f.createElement("div", { className: U, role: "tree", "aria-multiselectable": !!m, style: E }, B ? this.renderEmpty() : m ? f.createElement(Ec, { value: Array.from(k === "related" ? l : u) }, this.renderNodeList()) : this.renderNodeList()), w)) }, this.state = { inputTriggerFocus: !1, isOpen: !1, isFocus: !1, rePosKey: Tre, dropdownMinWidth: null, inputValue: "", keyEntities: {}, treeData: [], flattenNodes: [], cachedFlattenNodes: void 0, selectedKeys: [], checkedKeys: new Set, halfCheckedKeys: new Set, realCheckedKeys: new Set([]), disabledKeys: new Set, motionKeys: new Set([]), motionType: "hide", expandedKeys: new Set(e.expandedKeys), filteredKeys: new Set, filteredExpandedKeys: new Set, filteredShownKeys: new Set, prevProps: null, isHovering: !1, cachedKeyValuePairs: {}, loadedKeys: new Set, loadingKeys: new Set }, this.inputRef = f.createRef(), this.tagInputRef = f.createRef(), this.triggerRef = f.createRef(), this.optionsRef = f.createRef(), this.clickOutsideHandler = null, this.foundation = new _re(this.adapter), this.treeSelectID = Math.random().toString(36).slice(2), this.onMotionEnd = () => { this.adapter.rePositionDropdown() } } static getDerivedStateFromProps(e, t) { const { prevProps: n, rePosKey: i } = t, { keyMaps: s } = e, a = x => !n && x in e || n && !ke(n[x], e[x]); let o; const l = e.onChangeWithObject; let u = t.keyEntities || {}, d = t.cachedKeyValuePairs || {}; const h = { prevProps: e }, g = a("treeData"), m = a("expandedKeys"), b = !!(e.filterTreeNode && t.inputValue && t.inputValue.length); if (g) { o = e.treeData, h.treeData = o; const x = YW(o, s); h.keyEntities = Object.assign({}, x.keyEntities), u = h.keyEntities, h.cachedKeyValuePairs = Object.assign({}, x.valueEntities), d = h.cachedKeyValuePairs } o && e.motion && !ke(Object.keys(h.keyEntities), Object.keys(t.keyEntities)) && n && e.motion && (h.motionKeys = new Set([]), h.motionType = null); const y = g && e.expandAll; if (b) { let x; if (o && (x = ZW({ treeData: o, inputValue: t.inputValue, filterTreeNode: e.filterTreeNode, filterProps: e.treeNodeFilterProp, showFilteredOnly: e.showFilteredOnly, keyEntities: h.keyEntities, prevExpandedKeys: [...t.filteredExpandedKeys], keyMaps: s }), h.flattenNodes = x.flattenNodes, h.motionKeys = new Set([]), h.filteredKeys = x.filteredKeys, h.filteredShownKeys = x.filteredShownKeys, h.filteredExpandedKeys = x.filteredExpandedKeys), e.expandedKeys) { if (h.filteredExpandedKeys = ap(e.expandedKeys, u, e.autoExpandParent || !n), n && e.motion) { const S = t ? t.filteredExpandedKeys : new Set([]); if (!o) { const C = Tx(S, h.filteredExpandedKeys, u); let { motionKeys: O } = C; const { motionType: E } = C; e.showFilteredOnly && (O = O.filter(v => t.filteredShownKeys.has(v))), E === "hide" && (h.cachedFlattenNodes = Np(t.flattenNodes)), h.motionKeys = new Set(O), h.motionType = E } } h.flattenNodes = Ts(o || t.treeData, h.filteredExpandedKeys || t.filteredExpandedKeys, s, e.showFilteredOnly && t.filteredShownKeys) } } else { if (m || n && a("autoExpandParent")) { if (h.expandedKeys = ap(e.expandedKeys, u, e.autoExpandParent || !n), n && e.motion && !o) { const { motionKeys: x, motionType: S } = Tx(t.expandedKeys, h.expandedKeys, u); h.motionKeys = new Set(x), h.motionType = S, S === "hide" && (h.cachedFlattenNodes = Np(t.flattenNodes)) } } else !n && (e.defaultExpandAll || e.expandAll) || y ? h.expandedKeys = new Set(Object.keys(u)) : !n && e.defaultExpandedKeys ? h.expandedKeys = ap(e.defaultExpandedKeys, u) : !n && e.defaultValue ? h.expandedKeys = Ox(bs(e.defaultValue, l, s), u, e.multiple, d) : !n && e.value && (h.expandedKeys = Ox(bs(e.value, l, s), u, e.multiple, d)); if (h.expandedKeys || delete h.expandedKeys, o || h.expandedKeys) { const x = Ts(o || t.treeData, h.expandedKeys || t.expandedKeys, s); h.flattenNodes = x } } const w = e.multiple; if (!w) a("value") ? h.selectedKeys = ra(bs(e.value, l, s), d, w) : !n && e.defaultValue ? h.selectedKeys = ra(bs(e.defaultValue, l, s), d, w) : o && (e.value ? h.selectedKeys = ra(bs(e.value, l, s) || "", d, w) : h.selectedKeys = Px(t.selectedKeys, u)); else { let x; if (a("value") ? x = ra(bs(e.value, l, s), d, w) : !n && e.defaultValue ? x = ra(bs(e.defaultValue, l, s), d, w) : o && (e.value ? x = ra(bs(e.value, l, s) || [], d, w) : x = Px(e.checkRelation === "related" ? t.checkedKeys : t.realCheckedKeys, u)), x) { if (e.checkRelation === "unRelated") h.realCheckedKeys = new Set(x); else if (e.checkRelation === "related") { const { checkedKeys: S, halfCheckedKeys: C } = Sc(x, u); h.checkedKeys = S, h.halfCheckedKeys = C } } } return a("loadedKeys") && (h.loadedKeys = new Set(e.loadedKeys)), (g || a("value")) && (h.rePosKey = i + 1), o && e.disableStrictly && e.checkRelation === "related" && (h.disabledKeys = SE(u, s)), h } get adapter() { var e = this; const t = { updateInputValue: s => { this.setState({ inputValue: s }) } }, n = { registerClickOutsideHandler: s => { this.adapter.unregisterClickOutsideHandler(); const a = o => { const l = this.optionsRef && this.optionsRef.current, u = this.triggerRef && this.triggerRef.current, d = lr.findDOMNode(l), h = o.target, g = o.composedPath && o.composedPath() || [h]; d && (!d.contains(h) || !d.contains(h.parentNode)) && u && !u.contains(h) && !(g.includes(u) || g.includes(d)) && s(o) }; this.clickOutsideHandler = a, document.addEventListener("mousedown", a, !1) }, unregisterClickOutsideHandler: () => { this.clickOutsideHandler && (document.removeEventListener("mousedown", this.clickOutsideHandler, !1), this.clickOutsideHandler = null) }, rePositionDropdown: () => { let { rePosKey: s } = this.state; s = s + 1, this.setState({ rePosKey: s }) } }, i = { updateState: s => { this.setState(Object.assign({}, s)) }, notifySelect: (s, a, o) => { this.props.onSelect && this.props.onSelect(s, a, o) }, notifySearch: (s, a, o) => { this.props.onSearch && this.props.onSearch(s, a, o) }, cacheFlattenNodes: s => { this.setState({ cachedFlattenNodes: s ? Np(this.state.flattenNodes) : void 0 }) }, notifyLoad: (s, a) => { const { onLoad: o } = this.props; we(o) && o(s, a) }, notifyClear: s => { this.props.onClear && this.props.onClear(s) } }; return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, super.adapter), t), n), i), { updateLoadKeys: (s, a) => { this.setState(o => { let { loadedKeys: l, loadingKeys: u } = o; return this.foundation.handleNodeLoad(l, u, s, a) }) }, updateState: s => { this.setState(Object.assign({}, s)) }, openMenu: () => { this.setState({ isOpen: !0 }, () => { this.props.onVisibleChange(!0) }) }, closeMenu: s => { this.setState({ isOpen: !1 }, () => { s && s(), this.props.onVisibleChange(!1) }) }, getTriggerWidth: () => { const s = this.triggerRef.current; return s && s.getBoundingClientRect().width }, setOptionWrapperWidth: s => { this.setState({ dropdownMinWidth: s }) }, notifyChange: (s, a, o) => { this.props.onChange && this.props.onChange(s, a, o) }, notifyChangeWithObject: (s, a) => { this.props.onChange && this.props.onChange(s, a) }, notifyExpand: (s, a) => { let { expanded: o, node: l } = a; this.props.onExpand && this.props.onExpand([...s], { expanded: o, node: l }), o && this.props.loadData && this.onNodeLoad(l) }, notifyFocus: function () { e.props.onFocus && e.props.onFocus(...arguments) }, notifyBlur: function () { e.props.onBlur && e.props.onBlur(...arguments) }, toggleHovering: s => { this.setState({ isHovering: s }) }, updateInputFocus: s => { if (s) { if (this.inputRef && this.inputRef.current) { const { preventScroll: a } = this.props; this.inputRef.current.focus({ preventScroll: a }) } this.tagInputRef && this.tagInputRef.current && this.tagInputRef.current.focus() } else this.inputRef && this.inputRef.current && this.inputRef.current.blur(), this.tagInputRef && this.tagInputRef.current && this.tagInputRef.current.blur() }, updateIsFocus: s => { this.setState({ isFocus: s }) } }) } componentDidMount() { this.foundation.init() } componentWillUnmount() { this.foundation.destroy() } render() { const e = this.renderContent(), { motion: t, zIndex: n, mouseLeaveDelay: i, mouseEnterDelay: s, autoAdjustOverflow: a, stopPropagation: o, getPopupContainer: l, dropdownMargin: u, position: d } = this.props, { isOpen: h, rePosKey: g } = this.state, m = this.renderSelection(), b = d || "bottomLeft"; return f.createElement(kn, { stopPropagation: o, getPopupContainer: l, zIndex: n, motion: t, margin: u, ref: this.optionsRef, content: e, visible: h, trigger: "custom", rePosKey: g, position: b, autoAdjustOverflow: a, mouseLeaveDelay: i, mouseEnterDelay: s, onVisibleChange: this.handlePopoverVisibleChange, afterClose: this.afterClose }, m) } } Nh.contextType = An; Nh.propTypes = { "aria-describedby": c.string, "aria-errormessage": c.string, "aria-invalid": c.bool, "aria-labelledby": c.string, "aria-required": c.bool, borderless: c.bool, loadedKeys: c.arrayOf(c.string), loadData: c.func, onLoad: c.func, arrowIcon: c.node, clearIcon: c.node, defaultOpen: c.bool, defaultValue: c.oneOfType([c.string, c.array, c.object]), defaultExpandAll: c.bool, defaultExpandedKeys: c.array, expandAll: c.bool, disabled: c.bool, disableStrictly: c.bool, filterTreeNode: c.oneOfType([c.func, c.bool]), multiple: c.bool, searchPlaceholder: c.string, searchAutoFocus: c.bool, virtualize: c.object, treeNodeFilterProp: c.string, onChange: c.func, onClear: c.func, onSearch: c.func, onSelect: c.func, onExpand: c.func, onChangeWithObject: c.bool, onBlur: c.func, onFocus: c.func, value: c.oneOfType([c.string, c.number, c.array, c.object]), expandedKeys: c.array, autoExpandParent: c.bool, showClear: c.bool, showSearchClear: c.bool, autoAdjustOverflow: c.bool, showFilteredOnly: c.bool, showLine: c.bool, motionExpand: c.bool, emptyContent: c.node, keyMaps: c.object, leafOnly: c.bool, treeData: c.arrayOf(c.shape({ key: c.string, value: c.oneOfType([c.string, c.number]), label: c.any })), dropdownClassName: c.string, dropdownStyle: c.object, dropdownMargin: c.oneOfType([c.number, c.object]), motion: c.bool, placeholder: c.string, maxTagCount: c.number, size: c.oneOf(ar.SIZE_SET), className: c.string, style: c.object, treeNodeLabelProp: c.string, suffix: c.node, prefix: c.node, insetLabel: c.node, insetLabelId: c.string, zIndex: c.number, getPopupContainer: c.func, dropdownMatchSelectWidth: c.bool, validateStatus: c.oneOf(ar.STATUS), mouseEnterDelay: c.number, mouseLeaveDelay: c.number, triggerRender: c.func, stopPropagation: c.oneOfType([c.bool, c.string]), outerBottomSlot: c.node, outerTopSlot: c.node, onVisibleChange: c.func, expandAction: c.oneOf(["click", "doubleClick", !1]), searchPosition: c.oneOf([ar.SEARCH_POSITION_DROPDOWN, ar.SEARCH_POSITION_TRIGGER]), clickToHide: c.bool, renderLabel: c.func, renderFullLabel: c.func, labelEllipsis: c.bool, optionListStyle: c.object, searchRender: c.oneOfType([c.func, c.bool]), renderSelectedItem: c.func, checkRelation: c.string, "aria-label": c.string, showRestTagsPopover: c.bool, restTagsPopoverProps: c.object, preventScroll: c.bool, clickTriggerToHide: c.bool, autoMergeValue: c.bool }; Nh.defaultProps = { borderless: !1, searchPosition: ar.SEARCH_POSITION_DROPDOWN, arrowIcon: f.createElement(os, null), autoExpandParent: !1, autoAdjustOverflow: !0, stopPropagation: !0, motion: !0, motionExpand: !0, expandAll: !1, zIndex: Cr.DEFAULT_Z_INDEX, disableStrictly: !1, multiple: !1, filterTreeNode: !1, size: "default", treeNodeFilterProp: "label", onChangeWithObject: !1, treeNodeLabelProp: "label", dropdownMatchSelectWidth: !0, defaultOpen: !1, showSearchClear: !0, showClear: !1, onVisibleChange: z, expandAction: !1, clickToHide: !0, searchAutoFocus: !1, checkRelation: "related", "aria-label": "TreeSelect", showRestTagsPopover: !1, restTagsPopoverProps: {}, clickTriggerToHide: !0, autoMergeValue: !0 }; const xw = `${G}-upload`, ww = "picture", Cw = "list", Ire = .95, eT = { PREFIX: xw, LIST: `${xw}-list` }, Sw = "auto", Ew = "custom", et = { FILE_STATUS_UPLOADING: "uploading", FILE_STATUS_SUCCESS: "success", FILE_STATUS_UPLOAD_FAIL: "uploadFail", FILE_STATUS_VALIDATING: "validating", FILE_STATUS_VALID_FAIL: "validateFail", FILE_STATUS_WAIT_UPLOAD: "wait", FILE_LIST_PIC: ww, FILE_LIST_DEFAULT: Cw, LIST_TYPE: [ww, Cw], imageTypes: ["image", "webp", "png", "svg", "gif", "jpg", "jpeg", "bmp", "dpg"], DRAG_AREA_DEFAULT: "default", DRAG_AREA_LEGAL: "legal", DRAG_AREA_ILLEGAL: "illegal", TRIGGER_AUTO: Sw, TRIGGER_CUSTOM: Ew, UPLOAD_TRIGGER: [Sw, Ew], VALIDATE_STATUS: Vo, PROMPT_POSITION: ["left", "right", "bottom"] }, Pre = { PROGRESS_COEFFICIENT: Ire }; var Kg = function (r, e, t, n) { function i(s) { return s instanceof t ? s : new t(function (a) { a(s) }) } return new (t || (t = Promise))(function (s, a) { function o(d) { try { u(n.next(d)) } catch (h) { a(h) } } function l(d) { try { u(n.throw(d)) } catch (h) { a(h) } } function u(d) { d.done ? s(d.value) : i(d.value).then(o, l) } u((n = n.apply(r, e || [])).next()) }) }; const co = 1024, Fp = 1048576; function Ug(r) { if (r < co) return `${(r / co).toFixed(2)}KB`; if (r >= co && r < Fp) return `${(r / co).toFixed(1)}KB`; if (r >= Fp) return `${(r / Fp).toFixed(1)}MB` } function kre(r, e) { return r.indexOf(e, r.length - e.length) !== -1 } function Rre(r) { return Kg(this, void 0, void 0, function* () { return new Promise((e, t) => { const n = r.createReader(); let i = []; function s() { n.readEntries(a => { const o = Array.prototype.slice.apply(a); i = i.concat(o), !o.length ? e(i) : s() }, t) } s() }) }) } function Dre(r) { return Kg(this, void 0, void 0, function* () { const e = [], t = (n, i) => Kg(this, void 0, void 0, function* () { if (i = i || "", n.path = i, n.isFile) e.push(new Promise((s, a) => { n.file(o => { n.fullPath && !o.webkitRelativePath && (Object.defineProperties(o, { webkitRelativePath: { writable: !0 } }), o.webkitRelativePath = n.fullPath.replace(/^\//, ""), Object.defineProperties(o, { webkitRelativePath: { writable: !1 } })), s(o) }, a) })); else if (n.isDirectory) { const s = yield Rre(n); for (let a = 0; a < s.length; a++) { const o = s[a]; yield t(o, `${i}${n.name}/`) } } }); try { const n = r.map(s => t(s.webkitGetAsEntry())); return yield Promise.all(n), yield Promise.all(e) } catch (n) { return console.warn("Captured error while loop directory."), console.error(n), [] } }) } var Are = function (r, e, t, n) { function i(s) { return s instanceof t ? s : new t(function (a) { a(s) }) } return new (t || (t = Promise))(function (s, a) { function o(d) { try { u(n.next(d)) } catch (h) { a(h) } } function l(d) { try { u(n.throw(d)) } catch (h) { a(h) } } function u(d) { d.done ? s(d.value) : i(d.value).then(o, l) } u((n = n.apply(r, e || [])).next()) }) }; const { FILE_STATUS_UPLOADING: _w, FILE_STATUS_SUCCESS: Nre, FILE_STATUS_UPLOAD_FAIL: Fre, FILE_STATUS_VALID_FAIL: $p, FILE_STATUS_WAIT_UPLOAD: Ow, DRAG_AREA_DEFAULT: Lp, DRAG_AREA_LEGAL: $re, TRIGGER_AUTO: fu } = et; class Lre extends ve { constructor(e) { super(Object.assign({}, e)), this.destroyState = !1 } init() { this.destroyState = !1; const { disabled: e, addOnPasting: t } = this.getProps(); t && !e && this.bindPastingHandler() } destroy() { const { disabled: e, addOnPasting: t } = this.getProps(); this.releaseMemory(), e || this.unbindPastingHandler(), this.destroyState = !0 } getError(e) { let { action: t, xhr: n, message: i, fileName: s } = e; const a = n ? n.status : 0, o = i || `cannot post ${s} to ${t}, xhr status: ${a}'`, l = new Error(o); return l.status = a, l.method = "post", l.url = t, l } getBody(e) { if (!e) return; const t = e.responseText || e.response; if (!t) return t; try { return JSON.parse(t) } catch { return t } } checkFileSize(e) { const { size: t } = e, { maxSize: n, minSize: i } = this.getProps(); let s = !1; return (t > n * co || t < i * co) && (s = !0), s } handleChange(e) { const t = [], { limit: n, transformFile: i, accept: s } = this.getProps(), { fileList: a } = this.getStates(); let o = Array.from(e); if (typeof s < "u" && (o = o.filter(u => { const d = this.checkFileFormat(s, u); return d || t.push(u), d }), t.length !== 0 && this._adapter.notifyAcceptInvalid(t), o.length === 0)) return; o = o.map(u => (i && (u = i(u)), u.uid || (u.uid = es()), this.checkFileSize(u) && (u._sizeInvalid = !0, u.status = $p, this._adapter.notifySizeError(u, a)), u)); const l = a.length + o.length; if (typeof n < "u" && l > n) { if (this._adapter.notifyExceed(o), n === 1) { o = o.slice(-1), this._adapter.notifyFileSelect(o), this._adapter.resetInput(), this.replaceFileList(o); return } const u = n - a.length; o = o.slice(0, u) } this._adapter.notifyFileSelect(o), this._adapter.resetInput(), this.addFilesToList(o) } handleReplaceChange(e) { if (e.length === 0) return; const { transformFile: t, uploadTrigger: n, accept: i } = this.getProps(), { replaceIdx: s, fileList: a } = this.getStates(); let o = Array.from(e).pop(); if (typeof i < "u" && !this.checkFileFormat(i, o)) { this._adapter.notifyAcceptInvalid([o]); return } t && (o = t(o)), o.uid || (o.uid = es()), this.checkFileSize(o) && (o._sizeInvalid = !0, o.status = $p, this._adapter.notifySizeError(o, a)), this._adapter.notifyFileSelect([o]); const l = this.buildFileItem(o, n), u = [...a]; u.splice(s, 1, l), this._adapter.notifyChange({ currentFile: l, fileList: u }), this._adapter.updateFileList(u, () => { this._adapter.resetReplaceInput(), l._sizeInvalid || this.upload(l) }) } buildFileItem(e, t) { const { _sizeInvalid: n, status: i } = e; try { delete e._sizeInvalid, delete e.status } catch { } const s = { status: i || (t === fu ? _w : Ow), name: e.name, size: Ug(e.size), uid: e.uid, percent: 0, fileInstance: e, url: this._createURL(e) }; return n && (s._sizeInvalid = !0), this.isImage(e) && (s.preview = !0), s } replaceFileList(e) { const { uploadTrigger: t } = this.getProps(), n = e.map(i => this.buildFileItem(i, t)); this._adapter.notifyChange({ fileList: n, currentFile: n[0] }), this._adapter.updateFileList(n, () => { t === fu && this.startUpload(n) }) } addFilesToList(e) { const t = this.getState("fileList").slice(), { uploadTrigger: n } = this.getProps(), i = e.map(s => this.buildFileItem(s, n)); i.forEach(s => { const a = t.findIndex(o => o.uid === s.uid); a !== -1 ? t[a] = s : (t.push(s), this._adapter.notifyChange({ fileList: t, currentFile: s })) }), this._adapter.updateFileList(t, () => { n === fu && this.startUpload(i) }) } insertFileToList(e, t) { const { limit: n, transformFile: i, accept: s, uploadTrigger: a } = this.getProps(), { fileList: o } = this.getStates(), l = []; let u = Array.from(e); if (typeof s < "u" && (u = u.filter(m => { const b = this.checkFileFormat(s, m); return b || l.push(m), b }), l.length !== 0 && this._adapter.notifyAcceptInvalid(l), u.length === 0)) return; u = u.map(m => (m.uid || (m.uid = es()), this.checkFileSize(m) && (m._sizeInvalid = !0, m.status = $p, this._adapter.notifySizeError(m, o)), i && (m = i(m)), m)); const d = o.length + u.length; if (typeof n < "u" && d > n) { if (n === 1) { u = u.slice(-1), this._adapter.notifyFileSelect(u), this._adapter.resetInput(), this.replaceFileList(u); return } const m = n - o.length; u = u.slice(0, m), this._adapter.notifyExceed(u) } const h = u.map(m => this.buildFileItem(m, a)), g = o.slice(); typeof t < "u" ? g.splice(t, 0, ...h) : g.push(...h), this._adapter.notifyFileSelect(u), this._adapter.notifyChange({ fileList: g, currentFile: null }), this._adapter.updateFileList(g, () => { a === fu && this.startUpload(h) }) } manualUpload() { const e = this.getState("fileList").filter(t => t.status === Ow); this.startUpload(e) } startUpload(e) { e.forEach(t => { t._sizeInvalid || this.upload(t) }) } upload(e) { const { beforeUpload: t } = this.getProps(); if (typeof t > "u") { this.post(e); return } if (typeof t == "function") { const { fileList: n } = this.getStates(), i = this._adapter.notifyBeforeUpload({ file: e, fileList: n }); switch (!0) { case i === !0: { this.post(e); break } case i === !1: { const s = { shouldUpload: !1, status: et.FILE_STATUS_VALID_FAIL }; this.handleBeforeUploadResultInObject(s, e); break } case (i && ba(i)): { Promise.resolve(i).then(s => { let a = { shouldUpload: !0 }; Object.prototype.toString.call(s).slice(8, -1) === "Object" && (a = Object.assign(Object.assign({}, a), s)), this.handleBeforeUploadResultInObject(a, e) }, s => { let a = { shouldUpload: !1, status: et.FILE_STATUS_VALID_FAIL }; Object.prototype.toString.call(s).slice(8, -1) === "Object" && (a = Object.assign(Object.assign({}, a), s)), this.handleBeforeUploadResultInObject(a, e) }); break } case typeof i == "object": this.handleBeforeUploadResultInObject(i, e); break } } } handleBeforeUploadResultInObject(e, t) { const { shouldUpload: n, status: i, autoRemove: s, validateMessage: a, fileInstance: o } = e; let l = this.getState("fileList").slice(); if (s) l = l.filter(u => u.uid !== t.uid); else { const u = this._getFileIndex(t, l); if (u < 0) return; i && (l[u].status = i), a && (l[u].validateMessage = a), o && (o.uid = t.uid, l[u].fileInstance = o, l[u].size = Ug(o.size), l[u].name = o.name, l[u].url = this._createURL(o)), l[u].shouldUpload = n } this._adapter.updateFileList(l), this._adapter.notifyChange({ fileList: l, currentFile: t }), n && this.post(t) } post(e) { const { fileInstance: t } = e, n = this.getProps(); if (typeof XMLHttpRequest > "u") return; const i = new XMLHttpRequest, s = new FormData, { action: a } = n; let { data: o } = n; o && (typeof o == "function" && (o = o(t)), Object.keys(o).forEach(d => { s.append(d, o[d]) })); const l = n.name || n.fileName || t.name; if (n.customRequest) return n.customRequest({ fileName: l, data: o, file: e, fileInstance: t, onProgress: d => this.handleProgress({ e: d, fileInstance: t }), onError: (d, h) => this.handleError({ e: h, xhr: d, fileInstance: t }), onSuccess: (d, h) => this.handleSuccess({ response: d, fileInstance: t, e: h, isCustomRequest: !0 }), withCredentials: n.withCredentials, action: n.action }); s.append(l, t), i.open("post", a, !0), n.withCredentials && "withCredentials" in i && (i.withCredentials = !0), i.upload && (i.upload.onprogress = d => { this.destroyState ? i.abort() : this.handleProgress({ e: d, fileInstance: t }) }), i.onload = d => { this.destroyState || this.handleOnLoad({ e: d, xhr: i, fileInstance: t }) }, i.onerror = d => { this.destroyState || this.handleError({ e: d, xhr: i, fileInstance: t }) }; let u = n.headers || {}; typeof u == "function" && (u = u(t)); for (const d in u) Object.prototype.hasOwnProperty.call(u, d) && u[d] !== null && i.setRequestHeader(d, u[d]); i.send(s) } handleProgress(e) { let { e: t, fileInstance: n } = e; const { fileList: i } = this.getStates(), s = i.slice(); let a = 0; t.total > 0 && (a = Number((t.loaded / t.total * 100 * Pre.PROGRESS_COEFFICIENT).toFixed(0)) || 0); const o = this._getFileIndex(n, s); o < 0 || (s[o].percent = a, s[o].status = _w, this._adapter.notifyProgress(a, n, s), this._adapter.updateFileList(s), this._adapter.notifyChange({ fileList: s, currentFile: s[o] })) } handleOnLoad(e) { let { e: t, xhr: n, fileInstance: i } = e; const { fileList: s } = this.getStates(), a = this._getFileIndex(i, s); a < 0 || (n.status < 200 || n.status >= 300 ? this.handleError({ e: t, xhr: n, fileInstance: i }) : this.handleSuccess({ e: t, xhr: n, fileInstance: i, index: a })) } handleSuccess(e) { let { e: t, fileInstance: n, isCustomRequest: i = !1, xhr: s, response: a } = e; const { fileList: o } = this.getStates(); let l = null; const u = this._getFileIndex(n, o); if (u < 0) return; i ? l = a : l = this.getBody(s); const d = o.slice(), { afterUpload: h } = this.getProps(); if (d[u].status = Nre, d[u].percent = 100, this._adapter.notifyProgress(100, n, d), d[u].response = l, t && (d[u].event = t), h && typeof h == "function") { const { autoRemove: g, status: m, validateMessage: b, name: y, url: w } = this._adapter.notifyAfterUpload({ response: l, file: d[u], fileList: d }) || {}; m && (d[u].status = m), b && (d[u].validateMessage = b), y && (d[u].name = y), w && (d[u].url = w), g && d.splice(u, 1) } this._adapter.notifySuccess(l, n, d), this._adapter.notifyChange({ fileList: d, currentFile: d[u] }), this._adapter.updateFileList(d) } _getFileIndex(e, t) { return t.findIndex(n => n.uid === e.uid) } handleRemove(e) { const { disabled: t } = this.getProps(); if (t) return; const { fileList: n } = this.getStates(); Promise.resolve(this._adapter.notifyBeforeRemove(e, n)).then(i => { if (i === !1) return; const s = n.slice(), a = this._getFileIndex(e, n); a < 0 || (s.splice(a, 1), this._adapter.notifyRemove(e.fileInstance, s, e), this._adapter.updateFileList(s), this._adapter.notifyChange({ fileList: s, currentFile: e })) }) } handleError(e) { let { e: t, xhr: n, fileInstance: i } = e; const { fileList: s } = this.getStates(), a = this._getFileIndex(i, s); if (a < 0) return; const { action: o } = this.getProps(), l = s.slice(), u = this.getError({ action: o, xhr: n, fileName: i.name }); l[a].status = Fre, l[a].response = u, l[a].event = t, this._adapter.notifyError(u, i, l, n), this._adapter.updateFileList(l), this._adapter.notifyChange({ currentFile: l[a], fileList: l }) } handleClear() { const { disabled: e } = this.getProps(), { fileList: t } = this.getStates(); e || Promise.resolve(this._adapter.notifyBeforeClear(t)).then(n => { n !== !1 && (this._adapter.updateFileList([]), this._adapter.notifyClear(), this._adapter.notifyChange({ fileList: [] })) }).catch(n => { }) } _createURL(e) { const t = URL.createObjectURL(e), { localUrls: n } = this.getStates(), i = n.slice(); return i.push(t), this._adapter.updateLocalUrls(i), t } releaseMemory() { const { localUrls: e } = this.getStates(); e.forEach(t => { this._releaseBlob(t) }) } _releaseBlob(e) { try { URL.revokeObjectURL(e) } catch (t) { console.log(t) } } isImage(e) { return /(webp|svg|png|gif|jpg|jpeg|bmp|dpg)$/i.test(e.type) } isMultiple() { return !!this.getProp("multiple") } handleDragEnter(e) { e.preventDefault(), e.stopPropagation(), this._dragEnterTarget = e.currentTarget; const { disabled: t } = this.getProps(); t || this._adapter.updateDragAreaStatus($re) } handleDirectoryDrop(e) { return Are(this, void 0, void 0, function* () { const t = this.getState("fileList").slice(), n = [].slice.call(e.dataTransfer.items), i = yield Dre(n); this.handleChange(i), this._adapter.updateDragAreaStatus(Lp), this._adapter.notifyDrop(e, i, t) }) } handleDrop(e) { e.preventDefault(), e.stopPropagation(); const { disabled: t, directory: n } = this.getProps(), i = this.getState("fileList").slice(); if (!t) { if (n) { this.handleDirectoryDrop(e); return } const s = Array.from(e.dataTransfer.files); this.handleChange(s), this._adapter.updateDragAreaStatus(Lp), this._adapter.notifyDrop(e, s, i) } } handleDragOver(e) { e.preventDefault(), e.stopPropagation() } handleDragLeave(e) { e.preventDefault(), e.stopPropagation(), this._dragEnterTarget === e.target && this._adapter.updateDragAreaStatus(Lp) } checkFileFormat(e, t) { const n = e.split(",").map(a => a.trim()).filter(a => a), i = t.type || "", s = i.replace(/\/.*$/, ""); return n.some(a => { if (a.charAt(0) === ".") { const o = t.name || "", l = a.split(".").pop().toLowerCase(); return kre(o.toLowerCase(), l) } if (/\/\*$/.test(a)) { const o = a.replace(/\/.*$/, ""); return s === o } return /^[^\/]+\/[^\/]+$/.test(a) ? i === a : !1 }) } retry(e) { const { onRetry: t } = this.getProps(); t && typeof t == "function" && t(e), this.post(e) } handlePreviewClick(e) { this._adapter.notifyPreviewClick(e) } readFileFromClipboard(e) { for (const t of e) for (const n of t.types) n.startsWith("image") && t.getType(n).then(i => i.arrayBuffer()).then(i => { const s = n.split("/")[1], a = new File([i], `upload.${s}`, { type: n }); this.handleChange([a]) }) } handlePasting(e) { const n = this._adapter.isMac() ? e.metaKey : e.ctrlKey, { addOnPasting: i } = this.getProps(); i && n && e.code === "KeyV" && navigator.permissions.query({ name: "clipboard-read" }).then(a => { a.state === "granted" || a.state === "prompt" ? navigator.clipboard.read().then(o => { this.readFileFromClipboard(o) }) : this._adapter.notifyPastingError(a) }).catch(a => { this._adapter.notifyPastingError(a) }) } bindPastingHandler() { this._adapter.registerPastingHandler(e => this.handlePasting(e)) } unbindPastingHandler() { this._adapter.unRegisterPastingHandler() } } class Mre extends ve { constructor(e) { super(Object.assign({}, e)) } handleImageError(e) { this._adapter.updateFallbackPreview(!0) } } const At = eT.PREFIX, jre = function () { let r = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}; return f.createElement("svg", Object.assign({ focusable: !1, "aria-hidden": !0, width: "16", height: "16", viewBox: "0 0 16 16", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, r), f.createElement("circle", { cx: "7.99992", cy: "7.99992", r: "6.66667", fill: "white" }), f.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M15.3332 8.00008C15.3332 12.0502 12.0499 15.3334 7.99984 15.3334C3.94975 15.3334 0.666504 12.0502 0.666504 8.00008C0.666504 3.94999 3.94975 0.666748 7.99984 0.666748C12.0499 0.666748 15.3332 3.94999 15.3332 8.00008ZM8.99984 11.6667C8.99984 11.1145 8.55212 10.6667 7.99984 10.6667C7.44755 10.6667 6.99984 11.1145 6.99984 11.6667C6.99984 12.219 7.44755 12.6667 7.99984 12.6667C8.55212 12.6667 8.99984 12.219 8.99984 11.6667ZM7.99984 3.33341C7.27573 3.33341 6.7003 3.94171 6.74046 4.66469L6.94437 8.33495C6.97549 8.89513 7.4388 9.33341 7.99984 9.33341C8.56087 9.33341 9.02419 8.89513 9.05531 8.33495L9.25921 4.66469C9.29938 3.94171 8.72394 3.33341 7.99984 3.33341Z", fill: "#F93920" })) }, Vre = function () { let r = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}; return f.createElement("svg", Object.assign({ focusable: !1, "aria-hidden": !0, width: "28", height: "28", viewBox: "0 0 28 28", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, r), f.createElement("circle", { cx: "14", cy: "14", r: "14", fill: "#16161A", fillOpacity: "0.6" }), f.createElement("path", { d: "M9 10.25V18.25L10.25 13.25H17.875V11.75C17.875 11.4739 17.6511 11.25 17.375 11.25H14L12.75 9.75H9.5C9.22386 9.75 9 9.97386 9 10.25Z", stroke: "currentColor", strokeLinecap: "round", strokeLinejoin: "round" }), f.createElement("path", { d: "M18 18.25L19 13.25H10.2031L9 18.25H18Z", stroke: "currentColor", strokeLinecap: "round", strokeLinejoin: "round" })) }, Bre = function () { let r = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}; return f.createElement("svg", Object.assign({ focusable: !1, "aria-hidden": !0, width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, r), f.createElement("path", { d: "M6 17V7.58824C6 7.26336 6.26863 7 6.6 7H10.5L12 8.76471H16.05C16.3814 8.76471 16.65 9.02806 16.65 9.35294V11.1176H7.5L6 17ZM6 17L7.44375 11.1176H18L16.8 17L6 17Z", stroke: "currentColor", strokeWidth: "1.5", strokeLinecap: "round", strokeLinejoin: "round" })) }; class Fh extends de { constructor(e) { super(e), this.state = { fallbackPreview: !1 }, this.foundation = new Mre(this.adapter) } get adapter() { return Object.assign(Object.assign({}, super.adapter), { updateFallbackPreview: e => this.setState({ fallbackPreview: e }) }) } transSize(e) { return typeof e == "number" ? Ug(e) : e } renderValidateMessage() { const { status: e, validateMessage: t } = this.props; let n = null; switch (!0) { case (typeof t == "string" && e === et.FILE_STATUS_VALIDATING): n = f.createElement(f.Fragment, null, f.createElement(yi, { size: "small", wrapperClassName: `${At}-file-card-icon-loading` }), t); break; case typeof t == "string": n = f.createElement(f.Fragment, null, f.createElement(Co, { className: `${At}-file-card-icon-error` }), t); break; case vf(t): n = t; break }return n } renderPicValidateMsg() { const { status: e, validateMessage: t } = this.props; let n = null; switch (!0) { case (t && e === et.FILE_STATUS_VALIDATING): n = f.createElement(yi, { size: "small", wrapperClassName: `${At}-picture-file-card-icon-loading` }); break; case (t && (e === et.FILE_STATUS_VALID_FAIL || e === et.FILE_STATUS_UPLOAD_FAIL)): n = f.createElement("div", { className: `${At}-picture-file-card-icon-error` }, f.createElement(jre, null)); break }return n ? f.createElement(ln, { content: t, trigger: "hover", position: "bottom" }, n) : null } renderPic(e) { const { fallbackPreview: t } = this.state, { url: n, percent: i, status: s, disabled: a, style: o, onPreviewClick: l, showPicInfo: u, renderPicInfo: d, renderPicPreviewIcon: h, renderThumbnail: g, name: m, index: b, picHeight: y, picWidth: w } = this.props, x = s === et.FILE_STATUS_UPLOADING && i !== 100, S = s === et.FILE_STATUS_UPLOAD_FAIL && this.props.showRetry, C = s === et.FILE_STATUS_SUCCESS && this.props.showReplace, O = s === et.FILE_STATUS_SUCCESS && !this.props.showReplace, E = typeof g == "function", v = F({ [`${At}-picture-file-card`]: !0, [`${At}-picture-file-card-preview-fallback`]: t, [`${At}-picture-file-card-disabled`]: a, [`${At}-picture-file-card-show-pointer`]: typeof l < "u", [`${At}-picture-file-card-error`]: s === et.FILE_STATUS_UPLOAD_FAIL, [`${At}-picture-file-card-uploading`]: x, [`${At}-picture-file-card-custom-thumbnail`]: E && y && w }), T = f.createElement("div", { role: "button", tabIndex: 0, className: `${At}-picture-file-card-retry`, onClick: W => this.onRetry(W) }, f.createElement(WH, { className: `${At}-picture-file-card-icon-retry` })), I = f.createElement(ln, { trigger: "hover", position: "top", content: e.replace, showArrow: !1, spacing: 4 }, f.createElement("div", { role: "button", tabIndex: 0, className: `${At}-picture-file-card-replace`, onClick: W => this.onReplace(W) }, f.createElement(Vre, { className: `${At}-picture-file-card-icon-replace` }))), k = f.createElement("div", { className: `${At}-picture-file-card-preview` }, typeof h == "function" ? h(this.props) : null), P = f.createElement("div", { role: "button", tabIndex: 0, className: `${At}-picture-file-card-close`, onClick: W => this.onRemove(W) }, f.createElement(us, { className: `${At}-picture-file-card-icon-close` })), N = typeof d == "function" ? d(this.props) : f.createElement("div", { className: `${At}-picture-file-card-pic-info` }, b + 1); let M = {}, B = o ? Object.assign({}, o) : {}; y && (B.height = y, M.height = y), w && (B.width = w, M.width = w); const U = E ? g(this.props) : t ? f.createElement(Sf, { size: "large" }) : f.createElement("img", { src: n, alt: m, onError: W => this.foundation.handleImageError(W), style: M }); return f.createElement("div", { role: "listitem", className: v, style: B, onClick: l }, U, x ? f.createElement(Zl, { percent: i, type: "circle", size: "small", orbitStroke: "#FFF", "aria-label": "uploading file progress" }) : null, S ? T : null, C && I, O && k, u && N, !a && P, this.renderPicValidateMsg()) } renderFile(e) { const { name: t, size: n, percent: i, url: s, showRetry: a, showReplace: o, preview: l, previewFile: u, status: d, style: h, onPreviewClick: g, renderFileOperation: m } = this.props, { fallbackPreview: b } = this.state, y = F({ [`${At}-file-card`]: !0, [`${At}-file-card-fail`]: d === et.FILE_STATUS_VALID_FAIL || d === et.FILE_STATUS_UPLOAD_FAIL, [`${At}-file-card-show-pointer`]: typeof g < "u" }), w = F({ [`${At}-file-card-preview`]: !0, [`${At}-file-card-preview-placeholder`]: !l || u || b }), x = `${At}-file-card-info`, S = `${At}-file-card-close`, C = `${At}-file-card-replace`, O = !(i === 100 || typeof i > "u") && d === et.FILE_STATUS_UPLOADING, E = d === et.FILE_STATUS_UPLOAD_FAIL && a, v = d === et.FILE_STATUS_SUCCESS && o, T = this.transSize(n); let I = l && !b ? f.createElement("img", { src: s, alt: t, onError: P => this.foundation.handleImageError(P) }) : f.createElement(Sf, { size: "large" }); u && (I = u(this.props)); const k = typeof m == "function" ? m(this.props) : f.createElement(St, { onClick: P => this.onRemove(P), type: "tertiary", icon: f.createElement(ds, null), theme: "borderless", size: "small", className: S }); return f.createElement("div", { role: "listitem", className: y, style: h, onClick: g }, f.createElement("div", { className: w }, I), f.createElement("div", { className: `${x}-main` }, f.createElement("div", { className: `${x}-main-text` }, f.createElement("span", { className: `${x}-name` }, t), f.createElement("span", null, f.createElement("span", { className: `${x}-size` }, T), v && f.createElement(ln, { trigger: "hover", position: "top", showArrow: !1, content: e.replace }, f.createElement(St, { onClick: P => this.onReplace(P), type: "tertiary", theme: "borderless", size: "small", icon: f.createElement(Bre, null), className: C })))), O ? f.createElement(Zl, { percent: i, style: { width: "100%" }, "aria-label": "uploading file progress" }) : null, f.createElement("div", { className: `${x}-main-control` }, f.createElement("span", { className: `${x}-validate-message` }, this.renderValidateMessage()), E ? f.createElement("span", { role: "button", tabIndex: 0, className: `${x}-retry`, onClick: P => this.onRetry(P) }, e.retry) : null)), k) } onRemove(e) { e.stopPropagation(), this.props.onRemove() } onReplace(e) { e.stopPropagation(), this.props.onReplace() } onRetry(e) { e.stopPropagation(), this.props.onRetry() } render() { const { listType: e } = this.props; return e === et.FILE_LIST_PIC ? f.createElement(Ke, { componentName: "Upload" }, t => this.renderPic(t)) : e === et.FILE_LIST_DEFAULT ? f.createElement(Ke, { componentName: "Upload" }, t => this.renderFile(t)) : null } } Fh.propTypes = { className: c.string, disabled: c.bool, listType: c.string, name: c.string, onPreviewClick: c.func, onRemove: c.func, onReplace: c.func, onRetry: c.func, percent: c.number, preview: c.bool, previewFile: c.func, picWidth: c.oneOfType([c.number, c.string]), picHeight: c.oneOfType([c.number, c.string]), showReplace: c.bool, showRetry: c.bool, size: c.oneOfType([c.number, c.string]), status: c.string, style: c.object, url: c.string, validateMessage: c.node, index: c.number }; Fh.defaultProps = { listType: et.FILE_LIST_DEFAULT, name: "", onRemove: () => { }, onRetry: () => { }, preview: !1, size: "" }; var zre = function (r, e) { var t = {}; for (var n in r) Object.prototype.hasOwnProperty.call(r, n) && e.indexOf(n) < 0 && (t[n] = r[n]); if (r != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, n = Object.getOwnPropertySymbols(r); i < n.length; i++)e.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(r, n[i]) && (t[n[i]] = r[n[i]]); return t }; const rn = eT.PREFIX; class Bc extends de { constructor(e) { super(e), this.inputRef = null, this.replaceInputRef = null, this.onClick = () => { const { inputRef: t, props: n } = this, { onOpenFileDialog: i } = n; this.props.disabled || !t || !t.current || (t.current.click(), i && i()) }, this.onChange = t => { const { files: n } = t.target; this.foundation.handleChange(n) }, this.replace = t => { this.setState({ replaceIdx: t }, () => { this.replaceInputRef.current.click() }) }, this.onReplaceChange = t => { const { files: n } = t.target; this.foundation.handleReplaceChange(n) }, this.clear = () => { this.foundation.handleClear() }, this.remove = t => { this.foundation.handleRemove(t) }, this.insert = (t, n) => this.foundation.insertFileToList(t, n), this.upload = () => { this.foundation.manualUpload() }, this.openFileDialog = () => { this.onClick() }, this.renderFile = (t, n, i) => { const { name: s, status: a, validateMessage: o, _sizeInvalid: l, uid: u } = t, { previewFile: d, listType: h, itemStyle: g, showPicInfo: m, renderPicInfo: b, renderPicPreviewIcon: y, renderFileOperation: w, renderFileItem: x, renderThumbnail: S, disabled: C, onPreviewClick: O, picWidth: E, picHeight: v } = this.props, T = () => this.remove(t), I = () => { this.foundation.retry(t) }, k = () => { this.replace(n) }, P = Object.assign(Object.assign(Object.assign({}, cr(this.props, ["showRetry", "showReplace", ""])), t), { previewFile: d, listType: h, onRemove: T, onRetry: I, index: n, key: u || `${s}${n}`, style: g, disabled: C, showPicInfo: m, renderPicInfo: b, renderPicPreviewIcon: y, renderFileOperation: w, renderThumbnail: S, onReplace: k, onPreviewClick: typeof O < "u" ? () => this.foundation.handlePreviewClick(t) : void 0, picWidth: E, picHeight: v }); return a === et.FILE_STATUS_UPLOAD_FAIL && !o && (P.validateMessage = i.fail), l && !o && (P.validateMessage = i.illegalSize), typeof x > "u" ? f.createElement(Fh, Object.assign({}, P)) : x(P) }, this.renderFileList = () => { const { listType: t } = this.props; return t === et.FILE_LIST_PIC ? this.renderFileListPic() : t === et.FILE_LIST_DEFAULT ? this.renderFileListDefault() : null }, this.renderFileListPic = () => { const { showUploadList: t, limit: n, disabled: i, children: s, draggable: a, hotSpotLocation: o, picHeight: l, picWidth: u } = this.props, { fileList: d, dragAreaStatus: h } = this.state, g = this.props.fileList || d, m = n ? n > g.length : !0, b = `${rn}-drag-area`, y = F(`${rn}-add`, { [`${rn}-picture-add`]: !0, [`${rn}-picture-add-disabled`]: i }), w = F(`${rn}-file-list`, { [`${rn}-picture-file-list`]: !0 }), x = F({ [`${b}-legal`]: h === et.DRAG_AREA_LEGAL, [`${b}-illegal`]: h === et.DRAG_AREA_ILLEGAL }), S = `${rn}-file-list-main`, C = { role: "button", className: y, onClick: this.onClick, style: { height: l, width: u } }, O = { className: w }, E = { onDrop: this.onDrop, onDragOver: this.onDragOver, onDragLeave: this.onDragLeave, onDragEnter: this.onDragEnter }; a && Object.assign(C, E, { className: F(y, x) }); const v = f.createElement("div", Object.assign({}, C, { "x-semi-prop": "children" }), s); return !t || !g.length ? m ? v : null : f.createElement(Ke, { componentName: "Upload" }, T => f.createElement("div", Object.assign({}, O), f.createElement("div", { className: S, role: "list", "aria-label": "picture list" }, m && o === "start" ? v : null, g.map((I, k) => this.renderFile(I, k, T)), m && o === "end" ? v : null))) }, this.renderFileListDefault = () => { const { showUploadList: t, limit: n, disabled: i } = this.props, { fileList: s } = this.state, a = this.props.fileList || s, o = F(`${rn}-file-list`), l = `${rn}-file-list-title`, u = `${rn}-file-list-main`, d = n !== 1 && a.length, h = this.props.showClear && !i, g = { className: o }; return !t || !a.length ? null : f.createElement(Ke, { componentName: "Upload" }, m => f.createElement("div", Object.assign({}, g), d ? f.createElement("div", { className: l }, f.createElement("span", { className: `${l}-choosen` }, m.selectedFiles), h ? f.createElement("span", { role: "button", tabIndex: 0, onClick: this.clear, className: `${l}-clear` }, m.clear) : null) : null, f.createElement("div", { className: u, role: "list", "aria-label": "file list" }, a.map((b, y) => this.renderFile(b, y, m))))) }, this.onDrop = t => { this.foundation.handleDrop(t) }, this.onDragOver = t => { this.foundation.handleDragOver(t) }, this.onDragLeave = t => { this.foundation.handleDragLeave(t) }, this.onDragEnter = t => { this.foundation.handleDragEnter(t) }, this.renderAddContent = () => { const { draggable: t, children: n, listType: i, disabled: s } = this.props, a = F(`${rn}-add`); return i === et.FILE_LIST_PIC ? null : t ? this.renderDragArea() : f.createElement("div", { role: "button", tabIndex: 0, "aria-disabled": s, className: a, onClick: this.onClick }, n) }, this.renderDragArea = () => { const { dragAreaStatus: t } = this.state, { children: n, dragIcon: i, dragMainText: s, dragSubText: a, disabled: o } = this.props, l = `${rn}-drag-area`, u = F(l, { [`${l}-legal`]: t === et.DRAG_AREA_LEGAL, [`${l}-illegal`]: t === et.DRAG_AREA_ILLEGAL, [`${l}-custom`]: n }); return f.createElement(Ke, { componentName: "Upload" }, d => f.createElement("div", { role: "button", tabIndex: 0, "aria-disabled": o, className: u, onDrop: this.onDrop, onDragOver: this.onDragOver, onDragLeave: this.onDragLeave, onDragEnter: this.onDragEnter, onClick: this.onClick }, n || f.createElement(f.Fragment, null, f.createElement("div", { className: `${l}-icon`, "x-semi-prop": "dragIcon" }, i || f.createElement(cK, { size: "extra-large" })), f.createElement("div", { className: `${l}-text` }, f.createElement("div", { className: `${l}-main-text`, "x-semi-prop": "dragMainText" }, s || d.mainText), f.createElement("div", { className: `${l}-sub-text`, "x-semi-prop": "dragSubText" }, a), f.createElement("div", { className: `${l}-tips` }, t === et.DRAG_AREA_LEGAL && f.createElement("span", { className: `${l}-tips-legal` }, d.legalTips), t === et.DRAG_AREA_ILLEGAL && f.createElement("span", { className: `${l}-tips-illegal` }, d.illegalTips)))))) }, this.state = { fileList: e.defaultFileList || [], replaceIdx: -1, inputKey: Math.random(), replaceInputKey: Math.random(), dragAreaStatus: "default", localUrls: [] }, this.foundation = new Lre(this.adapter), this.inputRef = f.createRef(), this.replaceInputRef = f.createRef() } static getDerivedStateFromProps(e) { const { fileList: t } = e; return "fileList" in e ? { fileList: t || [] } : null } get adapter() { return Object.assign(Object.assign({}, super.adapter), { notifyFileSelect: e => this.props.onFileChange(e), notifyError: (e, t, n, i) => this.props.onError(e, t, n, i), notifySuccess: (e, t, n) => this.props.onSuccess(e, t, n), notifyProgress: (e, t, n) => this.props.onProgress(e, t, n), notifyRemove: (e, t, n) => this.props.onRemove(e, t, n), notifySizeError: (e, t) => this.props.onSizeError(e, t), notifyExceed: e => this.props.onExceed(e), updateFileList: (e, t) => { typeof t == "function" ? this.setState({ fileList: e }, t) : this.setState({ fileList: e }) }, notifyBeforeUpload: e => { let { file: t, fileList: n } = e; return this.props.beforeUpload({ file: t, fileList: n }) }, notifyAfterUpload: e => { let { response: t, file: n, fileList: i } = e; return this.props.afterUpload({ response: t, file: n, fileList: i }) }, resetInput: () => { this.setState(e => ({ inputKey: Math.random() })) }, resetReplaceInput: () => { this.setState(e => ({ replaceInputKey: Math.random() })) }, isMac: () => navigator.platform.toUpperCase().indexOf("MAC") >= 0, registerPastingHandler: e => { document.body.addEventListener("keydown", e), this.pastingCb = e }, unRegisterPastingHandler: () => { this.pastingCb && document.body.removeEventListener("keydown", this.pastingCb) }, notifyPastingError: e => this.props.onPastingError(e), updateDragAreaStatus: e => this.setState({ dragAreaStatus: e }), notifyChange: e => { let { currentFile: t, fileList: n } = e; return this.props.onChange({ currentFile: t, fileList: n }) }, updateLocalUrls: e => this.setState({ localUrls: e }), notifyClear: () => this.props.onClear(), notifyPreviewClick: e => this.props.onPreviewClick(e), notifyDrop: (e, t, n) => this.props.onDrop(e, t, n), notifyAcceptInvalid: e => this.props.onAcceptInvalid(e), notifyBeforeRemove: (e, t) => this.props.beforeRemove(e, t), notifyBeforeClear: e => this.props.beforeClear(e) }) } componentDidMount() { this.foundation.init() } componentWillUnmount() { this.foundation.destroy() } render() { const e = this.props, { style: t, className: n, multiple: i, accept: s, disabled: a, children: o, capture: l, listType: u, prompt: d, promptPosition: h, draggable: g, validateMessage: m, validateStatus: b, directory: y } = e, w = zre(e, ["style", "className", "multiple", "accept", "disabled", "children", "capture", "listType", "prompt", "promptPosition", "draggable", "validateMessage", "validateStatus", "directory"]), x = F(rn, { [`${rn}-picture`]: u === et.FILE_LIST_PIC, [`${rn}-disabled`]: a, [`${rn}-default`]: b === "default", [`${rn}-error`]: b === "error", [`${rn}-warning`]: b === "warning", [`${rn}-success`]: b === "success" }, n), S = F(`${rn}-hidden-input`), C = F(`${rn}-hidden-input-replace`), O = F(`${rn}-prompt`), E = F(`${rn}-validate-message`), v = y ? { directory: "directory", webkitdirectory: "webkitdirectory" } : {}; return f.createElement("div", Object.assign({ className: x, style: t, "x-prompt-pos": h }, this.getDataAttr(w)), f.createElement("input", Object.assign({ key: this.state.inputKey, capture: l, multiple: i, accept: s, onChange: this.onChange, type: "file", autoComplete: "off", tabIndex: -1, className: S, ref: this.inputRef }, v)), f.createElement("input", { key: this.state.replaceInputKey, multiple: !1, accept: s, onChange: this.onReplaceChange, type: "file", autoComplete: "off", tabIndex: -1, className: C, ref: this.replaceInputRef }), this.renderAddContent(), d ? f.createElement("div", { className: O, "x-semi-prop": "prompt" }, d) : null, m ? f.createElement("div", { className: E, "x-semi-prop": "validateMessage" }, m) : null, this.renderFileList()) } } Bc.propTypes = { accept: c.string, action: c.string.isRequired, addOnPasting: c.bool, afterUpload: c.func, beforeClear: c.func, beforeRemove: c.func, beforeUpload: c.func, children: c.node, className: c.string, customRequest: c.func, data: c.oneOfType([c.object, c.func]), defaultFileList: c.array, directory: c.bool, disabled: c.bool, dragIcon: c.node, dragMainText: c.node, dragSubText: c.node, draggable: c.bool, fileList: c.array, fileName: c.string, headers: c.oneOfType([c.object, c.func]), hotSpotLocation: c.oneOf(["start", "end"]), itemStyle: c.object, limit: c.number, listType: c.oneOf(et.LIST_TYPE), maxSize: c.number, minSize: c.number, multiple: c.bool, name: c.string, onAcceptInvalid: c.func, onChange: c.func, onClear: c.func, onDrop: c.func, onError: c.func, onExceed: c.func, onFileChange: c.func, onOpenFileDialog: c.func, onPreviewClick: c.func, onProgress: c.func, onRemove: c.func, onRetry: c.func, onSizeError: c.func, onSuccess: c.func, onPastingError: c.func, previewFile: c.func, prompt: c.node, promptPosition: c.oneOf(et.PROMPT_POSITION), picWidth: c.oneOfType([c.number, c.string]), picHeight: c.oneOfType([c.number, c.string]), renderFileItem: c.func, renderPicPreviewIcon: c.func, renderFileOperation: c.func, renderPicInfo: c.func, renderThumbnail: c.func, showClear: c.bool, showPicInfo: c.bool, showReplace: c.bool, showRetry: c.bool, showUploadList: c.bool, style: c.object, timeout: c.number, transformFile: c.func, uploadTrigger: c.oneOf(et.UPLOAD_TRIGGER), validateMessage: c.node, validateStatus: c.oneOf(et.VALIDATE_STATUS), withCredentials: c.bool }; Bc.defaultProps = { defaultFileList: [], disabled: !1, listType: "list", hotSpotLocation: "end", multiple: !1, onAcceptInvalid: z, onChange: z, beforeRemove: () => !0, beforeClear: () => !0, onClear: z, onDrop: z, onError: z, onExceed: z, onFileChange: z, onOpenFileDialog: z, onProgress: z, onRemove: z, onRetry: z, onSizeError: z, onSuccess: z, onPastingError: z, promptPosition: "right", showClear: !0, showPicInfo: !1, showReplace: !1, showRetry: !0, showUploadList: !0, uploadTrigger: "auto", withCredentials: !1 }; Bc.FileCard = Fh; function ua() { return ua = Object.assign || function (r) { for (var e = 1; e < arguments.length; e++) { var t = arguments[e]; for (var n in t) Object.prototype.hasOwnProperty.call(t, n) && (r[n] = t[n]) } return r }, ua.apply(this, arguments) } function Hre(r, e) { r.prototype = Object.create(e.prototype), r.prototype.constructor = r, nc(r, e) } function Wg(r) { return Wg = Object.setPrototypeOf ? Object.getPrototypeOf : function (t) { return t.__proto__ || Object.getPrototypeOf(t) }, Wg(r) } function nc(r, e) { return nc = Object.setPrototypeOf || function (n, i) { return n.__proto__ = i, n }, nc(r, e) } function Kre() { if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham) return !1; if (typeof Proxy == "function") return !0; try { return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () { })), !0 } catch { return !1 } } function Bu(r, e, t) { return Kre() ? Bu = Reflect.construct : Bu = function (i, s, a) { var o = [null]; o.push.apply(o, s); var l = Function.bind.apply(i, o), u = new l; return a && nc(u, a.prototype), u }, Bu.apply(null, arguments) } function Ure(r) { return Function.toString.call(r).indexOf("[native code]") !== -1 } function Gg(r) { var e = typeof Map == "function" ? new Map : void 0; return Gg = function (n) { if (n === null || !Ure(n)) return n; if (typeof n != "function") throw new TypeError("Super expression must either be null or a function"); if (typeof e < "u") { if (e.has(n)) return e.get(n); e.set(n, i) } function i() { return Bu(n, arguments, Wg(this).constructor) } return i.prototype = Object.create(n.prototype, { constructor: { value: i, enumerable: !1, writable: !0, configurable: !0 } }), nc(i, n) }, Gg(r) } var Wre = /%[sdj%]/g, Gre = function () { }; function Yg(r) { if (!r || !r.length) return null; var e = {}; return r.forEach(function (t) { var n = t.field; e[n] = e[n] || [], e[n].push(t) }), e } function kr() { for (var r = arguments.length, e = new Array(r), t = 0; t < r; t++)e[t] = arguments[t]; var n = 1, i = e[0], s = e.length; if (typeof i == "function") return i.apply(null, e.slice(1)); if (typeof i == "string") { var a = String(i).replace(Wre, function (o) { if (o === "%%") return "%"; if (n >= s) return o; switch (o) { case "%s": return String(e[n++]); case "%d": return Number(e[n++]); case "%j": try { return JSON.stringify(e[n++]) } catch { return "[Circular]" } break; default: return o } }); return a } return i } function Yre(r) { return r === "string" || r === "url" || r === "hex" || r === "email" || r === "date" || r === "pattern" } function Rn(r, e) { return !!(r == null || e === "array" && Array.isArray(r) && !r.length || Yre(e) && typeof r == "string" && !r) } function Xre(r, e, t) { var n = [], i = 0, s = r.length; function a(o) { n.push.apply(n, o), i++, i === s && t(n) } r.forEach(function (o) { e(o, a) }) } function Tw(r, e, t) { var n = 0, i = r.length; function s(a) { if (a && a.length) { t(a); return } var o = n; n = n + 1, o < i ? e(r[o], s) : t([]) } s([]) } function qre(r) { var e = []; return Object.keys(r).forEach(function (t) { e.push.apply(e, r[t]) }), e } var Iw = function (r) { Hre(e, r); function e(t, n) { var i; return i = r.call(this, "Async Validation Error") || this, i.errors = t, i.fields = n, i } return e }(Gg(Error)); function Zre(r, e, t, n) { if (e.first) { var i = new Promise(function (h, g) { var m = function (w) { return n(w), w.length ? g(new Iw(w, Yg(w))) : h() }, b = qre(r); Tw(b, t, m) }); return i.catch(function (h) { return h }), i } var s = e.firstFields || []; s === !0 && (s = Object.keys(r)); var a = Object.keys(r), o = a.length, l = 0, u = [], d = new Promise(function (h, g) { var m = function (y) { if (u.push.apply(u, y), l++, l === o) return n(u), u.length ? g(new Iw(u, Yg(u))) : h() }; a.length || (n(u), h()), a.forEach(function (b) { var y = r[b]; s.indexOf(b) !== -1 ? Tw(y, t, m) : Xre(y, t, m) }) }); return d.catch(function (h) { return h }), d } function Pw(r) { return function (e) { return e && e.message ? (e.field = e.field || r.fullField, e) : { message: typeof e == "function" ? e() : e, field: e.field || r.fullField } } } function kw(r, e) { if (e) { for (var t in e) if (e.hasOwnProperty(t)) { var n = e[t]; typeof n == "object" && typeof r[t] == "object" ? r[t] = ua({}, r[t], n) : r[t] = n } } return r } function tT(r, e, t, n, i, s) { r.required && (!t.hasOwnProperty(r.field) || Rn(e, s || r.type)) && n.push(kr(i.messages.required, r.fullField)) } function Jre(r, e, t, n, i) { (/^\s+$/.test(e) || e === "") && n.push(kr(i.messages.whitespace, r.fullField)) } var Mp = { email: /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/, url: new RegExp("^(?!mailto:)(?:(?:http|https|ftp)://|//)(?:\\S+(?::\\S*)?@)?(?:(?:(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[0-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(?:(?:[a-z\\u00a1-\\uffff0-9]+-*)*[a-z\\u00a1-\\uffff0-9]+)(?:\\.(?:[a-z\\u00a1-\\uffff0-9]+-*)*[a-z\\u00a1-\\uffff0-9]+)*(?:\\.(?:[a-z\\u00a1-\\uffff]{2,})))|localhost)(?::\\d{2,5})?(?:(/|\\?|#)[^\\s]*)?$", "i"), hex: /^#?([a-f0-9]{6}|[a-f0-9]{3})$/i }, Il = { integer: function (e) { return Il.number(e) && parseInt(e, 10) === e }, float: function (e) { return Il.number(e) && !Il.integer(e) }, array: function (e) { return Array.isArray(e) }, regexp: function (e) { if (e instanceof RegExp) return !0; try { return !!new RegExp(e) } catch { return !1 } }, date: function (e) { return typeof e.getTime == "function" && typeof e.getMonth == "function" && typeof e.getYear == "function" && !isNaN(e.getTime()) }, number: function (e) { return isNaN(e) ? !1 : typeof e == "number" }, object: function (e) { return typeof e == "object" && !Il.array(e) }, method: function (e) { return typeof e == "function" }, email: function (e) { return typeof e == "string" && !!e.match(Mp.email) && e.length < 255 }, url: function (e) { return typeof e == "string" && !!e.match(Mp.url) }, hex: function (e) { return typeof e == "string" && !!e.match(Mp.hex) } }; function Qre(r, e, t, n, i) { if (r.required && e === void 0) { tT(r, e, t, n, i); return } var s = ["integer", "float", "array", "regexp", "object", "method", "email", "number", "date", "url", "hex"], a = r.type; s.indexOf(a) > -1 ? Il[a](e) || n.push(kr(i.messages.types[a], r.fullField, r.type)) : a && typeof e !== r.type && n.push(kr(i.messages.types[a], r.fullField, r.type)) } function eie(r, e, t, n, i) { var s = typeof r.len == "number", a = typeof r.min == "number", o = typeof r.max == "number", l = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g, u = e, d = null, h = typeof e == "number", g = typeof e == "string", m = Array.isArray(e); if (h ? d = "number" : g ? d = "string" : m && (d = "array"), !d) return !1; m && (u = e.length), g && (u = e.replace(l, "_").length), s ? u !== r.len && n.push(kr(i.messages[d].len, r.fullField, r.len)) : a && !o && u < r.min ? n.push(kr(i.messages[d].min, r.fullField, r.min)) : o && !a && u > r.max ? n.push(kr(i.messages[d].max, r.fullField, r.max)) : a && o && (u < r.min || u > r.max) && n.push(kr(i.messages[d].range, r.fullField, r.min, r.max)) } var Xa = "enum"; function tie(r, e, t, n, i) { r[Xa] = Array.isArray(r[Xa]) ? r[Xa] : [], r[Xa].indexOf(e) === -1 && n.push(kr(i.messages[Xa], r.fullField, r[Xa].join(", "))) } function nie(r, e, t, n, i) { if (r.pattern) { if (r.pattern instanceof RegExp) r.pattern.lastIndex = 0, r.pattern.test(e) || n.push(kr(i.messages.pattern.mismatch, r.fullField, e, r.pattern)); else if (typeof r.pattern == "string") { var s = new RegExp(r.pattern); s.test(e) || n.push(kr(i.messages.pattern.mismatch, r.fullField, e, r.pattern)) } } } var Xe = { required: tT, whitespace: Jre, type: Qre, range: eie, enum: tie, pattern: nie }; function rie(r, e, t, n, i) { var s = [], a = r.required || !r.required && n.hasOwnProperty(r.field); if (a) { if (Rn(e, "string") && !r.required) return t(); Xe.required(r, e, n, s, i, "string"), Rn(e, "string") || (Xe.type(r, e, n, s, i), Xe.range(r, e, n, s, i), Xe.pattern(r, e, n, s, i), r.whitespace === !0 && Xe.whitespace(r, e, n, s, i)) } t(s) } function iie(r, e, t, n, i) { var s = [], a = r.required || !r.required && n.hasOwnProperty(r.field); if (a) { if (Rn(e) && !r.required) return t(); Xe.required(r, e, n, s, i), e !== void 0 && Xe.type(r, e, n, s, i) } t(s) } function sie(r, e, t, n, i) { var s = [], a = r.required || !r.required && n.hasOwnProperty(r.field); if (a) { if (e === "" && (e = void 0), Rn(e) && !r.required) return t(); Xe.required(r, e, n, s, i), e !== void 0 && (Xe.type(r, e, n, s, i), Xe.range(r, e, n, s, i)) } t(s) } function aie(r, e, t, n, i) { var s = [], a = r.required || !r.required && n.hasOwnProperty(r.field); if (a) { if (Rn(e) && !r.required) return t(); Xe.required(r, e, n, s, i), e !== void 0 && Xe.type(r, e, n, s, i) } t(s) } function oie(r, e, t, n, i) { var s = [], a = r.required || !r.required && n.hasOwnProperty(r.field); if (a) { if (Rn(e) && !r.required) return t(); Xe.required(r, e, n, s, i), Rn(e) || Xe.type(r, e, n, s, i) } t(s) } function lie(r, e, t, n, i) { var s = [], a = r.required || !r.required && n.hasOwnProperty(r.field); if (a) { if (Rn(e) && !r.required) return t(); Xe.required(r, e, n, s, i), e !== void 0 && (Xe.type(r, e, n, s, i), Xe.range(r, e, n, s, i)) } t(s) } function cie(r, e, t, n, i) { var s = [], a = r.required || !r.required && n.hasOwnProperty(r.field); if (a) { if (Rn(e) && !r.required) return t(); Xe.required(r, e, n, s, i), e !== void 0 && (Xe.type(r, e, n, s, i), Xe.range(r, e, n, s, i)) } t(s) } function uie(r, e, t, n, i) { var s = [], a = r.required || !r.required && n.hasOwnProperty(r.field); if (a) { if (e == null && !r.required) return t(); Xe.required(r, e, n, s, i, "array"), e != null && (Xe.type(r, e, n, s, i), Xe.range(r, e, n, s, i)) } t(s) } function die(r, e, t, n, i) { var s = [], a = r.required || !r.required && n.hasOwnProperty(r.field); if (a) { if (Rn(e) && !r.required) return t(); Xe.required(r, e, n, s, i), e !== void 0 && Xe.type(r, e, n, s, i) } t(s) } var hie = "enum"; function pie(r, e, t, n, i) { var s = [], a = r.required || !r.required && n.hasOwnProperty(r.field); if (a) { if (Rn(e) && !r.required) return t(); Xe.required(r, e, n, s, i), e !== void 0 && Xe[hie](r, e, n, s, i) } t(s) } function fie(r, e, t, n, i) { var s = [], a = r.required || !r.required && n.hasOwnProperty(r.field); if (a) { if (Rn(e, "string") && !r.required) return t(); Xe.required(r, e, n, s, i), Rn(e, "string") || Xe.pattern(r, e, n, s, i) } t(s) } function gie(r, e, t, n, i) { var s = [], a = r.required || !r.required && n.hasOwnProperty(r.field); if (a) { if (Rn(e, "date") && !r.required) return t(); if (Xe.required(r, e, n, s, i), !Rn(e, "date")) { var o; e instanceof Date ? o = e : o = new Date(e), Xe.type(r, o, n, s, i), o && Xe.range(r, o.getTime(), n, s, i) } } t(s) } function mie(r, e, t, n, i) { var s = [], a = Array.isArray(e) ? "array" : typeof e; Xe.required(r, e, n, s, i, a), t(s) } function jp(r, e, t, n, i) { var s = r.type, a = [], o = r.required || !r.required && n.hasOwnProperty(r.field); if (o) { if (Rn(e, s) && !r.required) return t(); Xe.required(r, e, n, a, i, s), Rn(e, s) || Xe.type(r, e, n, a, i) } t(a) } function yie(r, e, t, n, i) { var s = [], a = r.required || !r.required && n.hasOwnProperty(r.field); if (a) { if (Rn(e) && !r.required) return t(); Xe.required(r, e, n, s, i) } t(s) } var Fl = { string: rie, method: iie, number: sie, boolean: aie, regexp: oie, integer: lie, float: cie, array: uie, object: die, enum: pie, pattern: fie, date: gie, url: jp, hex: jp, email: jp, required: mie, any: yie }; function Xg() { return { default: "Validation error on field %s", required: "%s is required", enum: "%s must be one of %s", whitespace: "%s cannot be empty", date: { format: "%s date %s is invalid for format %s", parse: "%s date could not be parsed, %s is invalid ", invalid: "%s date %s is invalid" }, types: { string: "%s is not a %s", method: "%s is not a %s (function)", array: "%s is not an %s", object: "%s is not an %s", number: "%s is not a %s", date: "%s is not a %s", boolean: "%s is not a %s", integer: "%s is not an %s", float: "%s is not a %s", regexp: "%s is not a valid %s", email: "%s is not a valid %s", url: "%s is not a valid %s", hex: "%s is not a valid %s" }, string: { len: "%s must be exactly %s characters", min: "%s must be at least %s characters", max: "%s cannot be longer than %s characters", range: "%s must be between %s and %s characters" }, number: { len: "%s must equal %s", min: "%s cannot be less than %s", max: "%s cannot be greater than %s", range: "%s must be between %s and %s" }, array: { len: "%s must be exactly %s in length", min: "%s cannot be less than %s in length", max: "%s cannot be greater than %s in length", range: "%s must be between %s and %s in length" }, pattern: { mismatch: "%s value %s does not match pattern %s" }, clone: function () { var e = JSON.parse(JSON.stringify(this)); return e.clone = this.clone, e } } } var xb = Xg(); function $s(r) { this.rules = null, this._messages = xb, this.define(r) } $s.prototype = { messages: function (e) { return e && (this._messages = kw(Xg(), e)), this._messages }, define: function (e) { if (!e) throw new Error("Cannot configure a schema with no rules"); if (typeof e != "object" || Array.isArray(e)) throw new Error("Rules must be an object"); this.rules = {}; var t, n; for (t in e) e.hasOwnProperty(t) && (n = e[t], this.rules[t] = Array.isArray(n) ? n : [n]) }, validate: function (e, t, n) { var i = this; t === void 0 && (t = {}), n === void 0 && (n = function () { }); var s = e, a = t, o = n; if (typeof a == "function" && (o = a, a = {}), !this.rules || Object.keys(this.rules).length === 0) return o && o(), Promise.resolve(); function l(y) { var w, x = [], S = {}; function C(O) { if (Array.isArray(O)) { var E; x = (E = x).concat.apply(E, O) } else x.push(O) } for (w = 0; w < y.length; w++)C(y[w]); x.length ? S = Yg(x) : (x = null, S = null), o(x, S) } if (a.messages) { var u = this.messages(); u === xb && (u = Xg()), kw(u, a.messages), a.messages = u } else a.messages = this.messages(); var d, h, g = {}, m = a.keys || Object.keys(this.rules); m.forEach(function (y) { d = i.rules[y], h = s[y], d.forEach(function (w) { var x = w; typeof x.transform == "function" && (s === e && (s = ua({}, s)), h = s[y] = x.transform(h)), typeof x == "function" ? x = { validator: x } : x = ua({}, x), x.validator = i.getValidationMethod(x), x.field = y, x.fullField = x.fullField || y, x.type = i.getType(x), x.validator && (g[y] = g[y] || [], g[y].push({ rule: x, value: h, source: s, field: y })) }) }); var b = {}; return Zre(g, a, function (y, w) { var x = y.rule, S = (x.type === "object" || x.type === "array") && (typeof x.fields == "object" || typeof x.defaultField == "object"); S = S && (x.required || !x.required && y.value), x.field = y.field; function C(v, T) { return ua({}, T, { fullField: x.fullField + "." + v }) } function O(v) { v === void 0 && (v = []); var T = v; if (Array.isArray(T) || (T = [T]), !a.suppressWarning && T.length && $s.warning("async-validator:", T), T.length && x.message !== void 0 && (T = [].concat(x.message)), T = T.map(Pw(x)), a.first && T.length) return b[x.field] = 1, w(T); if (!S) w(T); else { if (x.required && !y.value) return x.message !== void 0 ? T = [].concat(x.message).map(Pw(x)) : a.error && (T = [a.error(x, kr(a.messages.required, x.field))]), w(T); var I = {}; if (x.defaultField) for (var k in y.value) y.value.hasOwnProperty(k) && (I[k] = x.defaultField); I = ua({}, I, y.rule.fields); for (var P in I) if (I.hasOwnProperty(P)) { var N = Array.isArray(I[P]) ? I[P] : [I[P]]; I[P] = N.map(C.bind(null, P)) } var M = new $s(I); M.messages(a.messages), y.rule.options && (y.rule.options.messages = a.messages, y.rule.options.error = a.error), M.validate(y.value, y.rule.options || a, function (B) { var K = []; T && T.length && K.push.apply(K, T), B && B.length && K.push.apply(K, B), w(K.length ? K : null) }) } } var E; x.asyncValidator ? E = x.asyncValidator(x, y.value, O, y.source, a) : x.validator && (E = x.validator(x, y.value, O, y.source, a), E === !0 ? O() : E === !1 ? O(x.message || x.field + " fails") : E instanceof Array ? O(E) : E instanceof Error && O(E.message)), E && E.then && E.then(function () { return O() }, function (v) { return O(v) }) }, function (y) { l(y) }) }, getType: function (e) { if (e.type === void 0 && e.pattern instanceof RegExp && (e.type = "pattern"), typeof e.validator != "function" && e.type && !Fl.hasOwnProperty(e.type)) throw new Error(kr("Unknown rule type %s", e.type)); return e.type || "string" }, getValidationMethod: function (e) { if (typeof e.validator == "function") return e.validator; var t = Object.keys(e), n = t.indexOf("message"); return n !== -1 && t.splice(n, 1), t.length === 1 && t[0] === "required" ? Fl.required : Fl[this.getType(e)] || !1 } }; $s.register = function (e, t) { if (typeof t != "function") throw new Error("Cannot register a validator by type, validator is not a function"); Fl[e] = t }; $s.warning = Gre; $s.messages = xb; $s.validators = Fl; var bie = function (r, e) { var t = {}; for (var n in r) Object.prototype.hasOwnProperty.call(r, n) && e.indexOf(n) < 0 && (t[n] = r[n]); if (r != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, n = Object.getOwnPropertySymbols(r); i < n.length; i++)e.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(r, n[i]) && (t[n[i]] = r[n[i]]); return t }; function vie(r) { const e = r.displayName || r.name; return e ? `SemiField${e}` : "SemiField" } function xie(r) { let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : []; const t = {}; return t[r] = e, new $s(t) } function wie() { let r = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [], e = !1; return typeof r == "object" && "required" in r ? e = r.required : Array.isArray(r) && r.length && r.forEach(t => { t.required && (e = !0) }), e } function da(r) { let e = !0; return typeof r == "string" && r.length ? e = !1 : Array.isArray(r) && r.length ? e = r.every(t => da(t)) : typeof r == "boolean" ? e = r : r && typeof r.$$typeof == "symbol" && r.$$typeof.toString() === "Symbol(react.element)" && (e = !1), e } function Cie(r, e) { let t = [], n = []; return st(r) ? st(e) ? t = Tl.DEFAULT_TRIGGER : t = e : t = r, Array.isArray(t) && (n = t), typeof t == "string" && (n[0] = t), n } function Sie(r, e) { let t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1; return st(r) ? st(e) ? t : e : r } function Eie(r, e) { const n = Object.assign(Object.assign({}, { valueKey: "value", onKeyChangeFnName: "onChange", valuePath: "", maintainCursor: !1, shouldInject: !0, shouldMemo: !0 }), r), i = "field" in e ? !0 : n.shouldInject; return { options: n, shouldInject: i } } function _ie(r) { let t = Object.assign(Object.assign({}, { allowEmptyString: !1, allowEmpty: !1, emptyValue: "", noLabel: !1, noErrorMessage: !1, isInInputGroup: !1 }), r), { field: n, label: i, labelPosition: s, labelWidth: a, labelAlign: o, labelCol: l, wrapperCol: u, initValue: d, validate: h, validateStatus: g, trigger: m, allowEmptyString: b, allowEmpty: y, emptyValue: w, rules: x, onChange: S, keepState: C, transform: O, name: E, fieldClassName: v, fieldStyle: T, noLabel: I, noErrorMessage: k, isInInputGroup: P, stopValidateWithError: N, convert: M, showValidateIcon: B, helpText: K, extraText: U, extraTextPosition: W, pure: Z, id: J } = t, ee = bie(t, ["field", "label", "labelPosition", "labelWidth", "labelAlign", "labelCol", "wrapperCol", "initValue", "validate", "validateStatus", "trigger", "allowEmptyString", "allowEmpty", "emptyValue", "rules", "onChange", "keepState", "transform", "name", "fieldClassName", "fieldStyle", "noLabel", "noErrorMessage", "isInInputGroup", "stopValidateWithError", "convert", "showValidateIcon", "helpText", "extraText", "extraTextPosition", "pure", "id"]); delete ee.defaultChecked, delete ee.defaultValue, delete ee.checked, typeof d < "u" && (d = cs(d)); const $ = wie(x); return w = typeof w < "u" ? w : "", { field: n, label: i, labelPosition: s, labelWidth: a, labelAlign: o, labelCol: l, wrapperCol: u, noLabel: I, noErrorMessage: k, isInInputGroup: P, initValue: d, validate: h, validateStatus: g, trigger: m, allowEmptyString: b, allowEmpty: y, emptyValue: w, rules: x, required: $, keepState: C, transform: O, name: E, fieldClassName: v, fieldStyle: T, convert: M, stopValidateWithError: N, showValidateIcon: B, helpText: K, extraText: U, extraTextPosition: W, pure: Z, rest: ee, id: J } } class Oie extends ve { constructor(e) { super(Object.assign({}, e)); let { initValues: t } = this._adapter.getProps(); t = this._adapter.cloneDeep(t), this.data = { values: t || {}, errors: {}, touched: {} }, this.fields = new Map, this.registered = {}, this.registeredArrayField = new Map, this.register = this.register.bind(this), this.unRegister = this.unRegister.bind(this), this.registerArrayField = this.registerArrayField.bind(this), this.unRegisterArrayField = this.unRegisterArrayField.bind(this), this.getArrayField = this.getArrayField.bind(this), this.updateArrayField = this.updateArrayField.bind(this), this.getField = this.getField.bind(this), this.setValues = this.setValues.bind(this), this.updateStateValue = this.updateStateValue.bind(this), this.updateStateError = this.updateStateError.bind(this), this.updateStateTouched = this.updateStateTouched.bind(this), this.getFormState = this.getFormState.bind(this), this.getValue = this.getValue.bind(this), this.getError = this.getError.bind(this), this.getTouched = this.getTouched.bind(this), this.getInitValues = this.getInitValues.bind(this), this.getInitValue = this.getInitValue.bind(this), this.getFormProps = this.getFormProps.bind(this), this.getFieldExist = this.getFieldExist.bind(this), this.scrollToField = this.scrollToField.bind(this), this.scrollToError = this.scrollToError.bind(this) } init() { this._adapter.initFormId() } getField(e) { return this.fields.get(e) } register(e, t, n) { if (this.registered[e], this.registered[e] = !0, this.fields.set(e, n), !n.keepState) { const i = n.allowEmpty || !1, s = { notNotify: !0, notUpdate: !1, allowEmpty: i }; let a = t.value; !i && a === "" && (a = void 0), this.updateStateValue(e, a, s), t.error && this.updateStateError(e, t.error, s) } } unRegister(e) { const t = this.fields.get(e); try { t.keepState || (ku(this.data.values, e), ku(this.data.errors, e), ku(this.data.touched, e)) } catch { console.error(`some thing wrong when unregister field:${e}`) } this.fields.delete(e), this._adapter.notifyChange(this.data), this._adapter.forceUpdate() } registerArrayField(e, t) { this.updateArrayField(e, { updateKey: new Date().valueOf(), initValue: t }) } unRegisterArrayField(e) { this.registeredArrayField.delete(e) } getArrayField(e) { return this.registeredArrayField.get(e) } updateArrayField(e, t) { const n = Object.assign(Object.assign({}, this.registeredArrayField.get(e)), t); this.registeredArrayField.set(e, n) } validate(e) { const { validateFields: t } = this.getProps(); return t && we(t) ? this._formValidate() : this._fieldsValidate(e) } _formValidate() { const { values: e } = this.data, { validateFields: t } = this.getProps(); return new Promise((n, i) => { let s; try { s = t(e) } catch (a) { s = a } if (s) ba(s) ? s.then(a => { if (a) this.data.errors = a, this._adapter.notifyChange(this.data), this.injectErrorToField(a), this._adapter.forceUpdate(), this._autoScroll(100), i(a); else { const o = this._adapter.cloneDeep(e); n(o), this.injectErrorToField({}) } }, a => { this._autoScroll(100), i(a) }) : (this.data.errors = s, this.injectErrorToField(s), this._adapter.notifyChange(this.data), this._adapter.forceUpdate(), this._autoScroll(100), i(s)); else { const a = this._adapter.cloneDeep(e); n(a), this.injectErrorToField({}) } }) } _fieldsValidate(e) { const { values: t } = this.data; return new Promise((n, i) => { let s = []; const a = this._getOperateFieldMap(e); a.forEach((o, l) => { const u = this.getValue(l), d = { notNotify: !0, notUpdate: !0 }, h = o.fieldApi.validate(u, d); s.push(h), o.fieldApi.setTouched(!0, d) }), Promise.all(s).then(() => { this._adapter.notifyChange(this.data), this._adapter.forceUpdate(); const o = this.getError(); if (this._isValid(a)) { const l = this._adapter.cloneDeep(t); n(l) } else this._autoScroll(), i(o) }) }) } submit(e) { const { values: t } = this.data; this.validate().then(n => { const i = this._adapter.cloneDeep(n); this._adapter.notifySubmit(i, e) }).catch(n => { const i = this._adapter.cloneDeep(n), s = this._adapter.cloneDeep(t); this._adapter.notifySubmitFail(i, s, e) }) } _getNestedField(e) { const t = this.fields, n = [...t].map(s => s[0]); let i = new Map; return n.forEach(s => { let a = Wl(s), o = Wl(e); if (o.every((l, u) => o[u] === a[u])) { const l = t.get(s); i.set(s, l) } }), i } _getOperateFieldMap(e) { let t = new Map; return st(e) ? t = this.fields : e.forEach(n => { const i = this.fields.get(n); if (st(i)) { const s = this._getNestedField(n); t = new Map([...t, ...s]) } else t.set(n, i) }), t } reset(e) { this._getOperateFieldMap(e).forEach(n => { n.fieldApi.reset() }), this.registeredArrayField.size && this._resetArrayField(), this._adapter.notifyChange(this.data), this._adapter.forceUpdate(), this._adapter.notifyReset() } _resetArrayField() { [...this.registeredArrayField.keys()].forEach(t => { const i = this.registeredArrayField.get(t).initValue; this.updateStateValue(t, i, { notNotify: !0, notUpdate: !0 }), this.updateArrayField(t, { updateKey: new Date().valueOf() }) }) } injectErrorToField(e) { this.fields.forEach(t => { const n = ir(e, t.field), i = { notNotify: !0, notUpdate: !0 }; t.fieldApi.setError(n, i) }) } getValue(e, t) { const n = typeof e > "u", i = t && t.needClone; let s, a; switch (!0) { case (!n && !i): s = ir(this.data.values, e); break; case (!n && i): a = ir(this.data.values, e), s = this._adapter.cloneDeep(a); break; case (n && !i): s = Object.assign({}, this.data.values); break; case (n && i): s = this._adapter.cloneDeep(this.data.values); break }return s } setValues(e, t) { let { isOverride: n = !1 } = t; const i = this._adapter.cloneDeep(e); this.fields.forEach(s => { const a = ir(i, s.field), o = { notNotify: !0, notUpdate: !0 }; s.fieldApi.setValue(a, o) }), this.registeredArrayField.size && [...this.registeredArrayField.keys()].forEach(a => { this.updateArrayField(a, { updateKey: new Date().valueOf() }) }), n && (this.data.values = i), this._adapter.notifyChange(this.data), this._adapter.notifyValueChange(this.data.values, Object.assign({}, e)), this._adapter.forceUpdate() } updateStateValue(e, t, n, i) { const s = n && n.notNotify, a = n && n.notUpdate, o = n && n.fieldAllowEmpty, l = this.getProp("allowEmpty"), u = o || l; pp(this.data.values, e, t, u), s || (this._adapter.notifyChange(this.data), this._adapter.notifyValueChange(this.data.values, { [e]: t })), a || this._adapter.forceUpdate(i) } getTouched(e) { return typeof e > "u" ? this.data.touched : ir(this.data.touched, e) } updateStateTouched(e, t, n, i) { const s = n && n.notNotify, a = n && n.notUpdate; pp(this.data.touched, e, t), s || this._adapter.notifyChange(this.data), a || this._adapter.forceUpdate(i) } getError(e) { return typeof e > "u" ? this.data.errors : ir(this.data.errors, e) } updateStateError(e, t, n, i) { const s = n && n.notNotify, a = n && n.notUpdate; pp(this.data.errors, e, t), s || this._adapter.notifyChange(this.data), this._adapter.notifyErrorChange(this.data.errors, { [e]: t }), a || this._adapter.forceUpdate(i) } getFieldSetterApi() { return { setValue: (i, s, a) => { const o = this.fields.get(i) ? this.fields.get(i).fieldApi : void 0, l = this._adapter.cloneDeep(s); o ? o.setValue(l, a) : (this.updateStateValue(i, l, a, () => { let u = this._getNestedField(i); u.size && u.forEach(d => { let h = d.field, g = ir(this.data.values, h), m = { notNotify: !0, notUpdate: !0 }; d.fieldApi.setValue(g, m) }) }), this.getArrayField(i) && this.updateArrayField(i, { updateKey: new Date().valueOf() })) }, setError: (i, s, a) => { const o = this.fields.get(i) ? this.fields.get(i).fieldApi : void 0, l = this._adapter.cloneDeep(s); o ? o.setError(l, a) : (this.updateStateError(i, l, a, () => { let u = this._getNestedField(i); u.size && u.forEach(d => { let h = d.field, g = ir(this.data.errors, h), m = { notNotify: !0, notUpdate: !0 }; d.fieldApi.setError(g, m) }) }), this.getArrayField(i) && this.updateArrayField(i, { updateKey: new Date().valueOf() })) }, setTouched: (i, s, a) => { const o = this.fields.get(i) ? this.fields.get(i).fieldApi : void 0; o ? o.setTouched(s, a) : (this.updateStateTouched(i, s, a, () => { let l = this._getNestedField(i); l.size && l.forEach(u => { let d = u.field, h = ir(this.data.touched, d), g = { notNotify: !0, notUpdate: !0 }; u.fieldApi.setTouched(h, g) }) }), this.getArrayField(i) && this.updateArrayField(i, { updateKey: new Date().valueOf() })) } } } getModifyFormStateApi() { return { register: this.register, unRegister: this.unRegister, updateStateValue: this.updateStateValue, updateStateError: this.updateStateError, updateStateTouched: this.updateStateTouched, getValue: this.getValue, getError: this.getError, getTouched: this.getTouched, getInitValues: this.getInitValues, getInitValue: this.getInitValue, getFormProps: this.getFormProps, getField: this.getField, registerArrayField: this.registerArrayField, unRegisterArrayField: this.unRegisterArrayField, getArrayField: this.getArrayField, updateArrayField: this.updateArrayField } } getFormApi() { const e = this.getFieldSetterApi(); return Object.assign(Object.assign({}, e), { reset: t => this.reset(t), validate: t => this.validate(t), getValue: t => this.getValue(t, { needClone: !0 }), getValues: () => this.getValue(void 0, { needClone: !0 }), getFormState: () => this.getFormState(!0), getFormProps: t => this.getFormProps(t), getInitValue: t => this.getInitValue(t), getInitValues: () => this.getInitValues(), getTouched: t => this.getTouched(t), getError: t => this.getError(t), setValues: (t, n) => this.setValues(t, n || { isOverride: !1 }), submitForm: () => this.submit(), getFieldExist: t => this.getFieldExist(t), scrollToField: (t, n) => this.scrollToField(t, n), scrollToError: t => this.scrollToError(t) }) } getFormState() { return (arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !1) ? this._adapter.cloneDeep(this.data) : Object.assign({}, this.data) } _isValid(e) { let t = !0; return e ? [...e.keys()].forEach(i => { const s = ir(this.data.errors, i); da(s) || (t = !1) }) : t = !!K8(this.data.errors), t } getInitValues() { return this._adapter.getInitValues() } getInitValue(e) { return typeof e > "u" ? this._adapter.getInitValues() : ir(this._adapter.getInitValues(), e) } getFormProps(e) { return this._adapter.getFormProps(e) } getFieldExist(e) { return !!this.fields.has(e) } _autoScroll(e) { const { autoScrollToError: t } = this.getFormProps(); if (!t) return; let n = { behavior: "smooth", block: "start" }; typeof t == "object" && (n = t), e ? setTimeout(() => this._getErrorFieldAndScroll(n), 100) : this._getErrorFieldAndScroll(n) } _getErrorFieldAndScroll(e) { const t = this._adapter.getAllErrorDOM(); if (t && t.length) try { const n = t[0].parentNode.parentNode; Gh(n, e) } catch { } } scrollToField(e) { let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : { behavior: "smooth", block: "start" }; if (this.getFieldExist(e)) { const n = this._adapter.getFieldDOM(e); Gh(n, t) } } scrollToError(e) { let t = e && e.scrollOpts ? e.scrollOpts : { behavior: "smooth", block: "start" }, n = e && e.field, i = e && e.index, s, a; if (typeof i == "number") { let l = this._adapter.getAllErrorDOM()[i]; l && (s = l.parentNode.parentNode) } else if (n) a = this._adapter.getFieldErrorDOM(n), a && (s = a.parentNode.parentNode); else if (typeof n > "u") { let o = this._adapter.getAllErrorDOM(); o && o.length && (s = o[0].parentNode.parentNode) } s && Gh(s, t) } } const wb = f.createContext({}); wb.displayName = "FormState"; const nT = f.createContext({}); nT.displayName = "FormApi"; const zc = f.createContext({}); zc.displayName = "FormUpdater"; const Tie = f.createContext({ shouldUseInitValue: !0 }), Vp = pi.PREFIX; class Hc extends R.PureComponent { generatorText(e) { const { helpTextId: t, errorMessageId: n } = this.props, i = this.props.error; let s = n; if (i || (s = t), typeof e == "string") return f.createElement("span", { id: s }, e); if (Array.isArray(e)) { const a = e.filter(o => o); return a.length ? f.createElement("span", { id: s }, a.join(", ")) : null } else if (f.isValidElement(e)) return e; return null } render() { const { error: e, className: t, style: n, validateStatus: i, helpText: s, showValidateIcon: a, isInInputGroup: o } = this.props, l = F({ [Vp + "-field-error-message"]: !!e, [Vp + "-field-help-text"]: !!s }, t); if (!e && !s) return null; const u = { warning: f.createElement(yc, null), error: f.createElement(Co, null) }, d = e ? this.generatorText(e) : this.generatorText(s), h = `${Vp}-field-validate-status-icon`; let g = null; return o ? g = f.createElement(Co, { className: h }) : u[i] && (g = f.cloneElement(u[i], { className: h })), f.createElement("div", { className: l, style: n }, a && d ? g : null, d) } } Hc.propTypes = { error: c.oneOfType([c.bool, c.string, c.array, c.node]), className: c.string, style: c.object, validateStatus: c.string, showValidateIcon: c.bool, helpText: c.node, isInInputGroup: c.bool, errorMessageId: c.string, helpTextId: c.string }; var Iie = function (r, e) { var t = {}; for (var n in r) Object.prototype.hasOwnProperty.call(r, n) && e.indexOf(n) < 0 && (t[n] = r[n]); if (r != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, n = Object.getOwnPropertySymbols(r); i < n.length; i++)e.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(r, n[i]) && (t[n[i]] = r[n[i]]); return t }; const Cl = pi.PREFIX, Pie = r => { let e, t, n, i, s, a = "top"; try { const O = R.useContext(zc).getFormProps(["labelPosition", "labelWidth", "labelAlign", "labelCol", "wrapperCol"]); e = O.labelCol, t = O.wrapperCol, n = O.labelWidth, i = O.labelAlign, a = O.labelPosition ? O.labelPosition : a } catch { } r.labelPosition && (a = r.labelPosition); let { children: o, label: l, className: u, style: d, error: h, noLabel: g } = r; Iie(r, ["children", "label", "className", "style", "error", "noLabel"]); const m = e && t, b = F({ [`${Cl}-field`]: !0, [`${Cl}-slot`]: !0 }, u), y = F({ [`${Cl}-col-${i}`]: !0 }); switch (!0) { case (an(l) && !f.isValidElement(l)): break; case (Fe(l) || Zt(l)): l = { text: l }; break; case f.isValidElement(l): l = { text: l }; break }let w = null; if (typeof h !== void 0) { let C = {}; switch (!0) { case (an(h) && !f.isValidElement(h)): C = h; break; case (Fe(h) || Zt(h)): C = { error: h }; break; case f.isValidElement(h): C = { error: h }; break }w = f.createElement(Hc, Object.assign({}, C)) } let x = Object.assign({ align: i, width: n }, l), S = F({ [`${Cl}-field-main`]: !0, [`${Cl}-slot-main`]: !0 }); switch (!0) { case (!m && !g): s = f.createElement(f.Fragment, null, f.createElement(Vi, Object.assign({}, x)), f.createElement("div", { className: S }, o, w)); break; case (!m && g): s = f.createElement(f.Fragment, null, f.createElement("div", { className: S }, o, w)); break; case (m && a === "top"): s = f.createElement(f.Fragment, null, f.createElement("div", { style: { overflow: "hidden" } }, f.createElement(vr, Object.assign({}, e, { className: y }), f.createElement(Vi, Object.assign({}, x)))), f.createElement(vr, null, o, w)); break; case (m && a !== "top"): s = f.createElement(f.Fragment, null, f.createElement(vr, Object.assign({}, e, { className: y }), f.createElement(Vi, Object.assign({}, x))), f.createElement(vr, null, o, w)); break }return f.createElement("div", { className: b, "x-label-pos": a, style: d }, s) }, Rw = pi.PREFIX; class rT extends R.PureComponent { render() { const { text: e, className: t, style: n, children: i } = this.props, s = F({ [Rw + "-section"]: !0 }, t), a = Rw + "-section-text"; return f.createElement("section", { className: s, style: n }, f.createElement("h5", { className: a }, e), i) } } rT.propTypes = { text: c.node, className: c.string, style: c.object, children: c.node }; function iT() { return R.useContext(wb) } function kie() { return R.useContext(zc) } function Bp(r) { const e = R.useRef(), [t, n] = R.useState(r); return e.current = t, [t, a => { e.current = a, n(a) }, () => e.current] } function Rie() { return R.useContext(Tie) } var Die = function (r, e) { var t = {}; for (var n in r) Object.prototype.hasOwnProperty.call(r, n) && e.indexOf(n) < 0 && (t[n] = r[n]); if (r != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, n = Object.getOwnPropertySymbols(r); i < n.length; i++)e.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(r, n[i]) && (t[n[i]] = r[n[i]]); return t }; const qa = pi.PREFIX, Aie = r => { const { fieldSet: e } = r, t = iT(), n = e.map(i => ir(t.errors, i)); return da(n) ? null : f.createElement(Hc, { error: n, showValidateIcon: r.showValidateIcon, isInInputGroup: r.isInInputGroup }) }; class sT extends R.Component { renderLabel(e, t) { return e ? Fe(e) ? f.createElement(Vi, { width: t.labelWidth, text: e }) : f.createElement(Vi, Object.assign({ width: t.labelWidth }, e)) : null } render() { const e = this.props, { children: t, label: n, extraText: i, extraTextPosition: s } = e, a = Die(e, ["children", "label", "extraText", "extraTextPosition"]), l = this.context.getFormProps(["labelPosition", "labelWidth", "labelAlign", "showValidateIcon", "wrapperCol", "labelCol", "disabled"]), u = this.props.labelPosition || l.labelPosition, d = [], h = f.Children.map(t, I => I && I.props && I.props.field ? (d.push(I.props.field), f.cloneElement(I, { isInInputGroup: !0 })) : null), g = F({ [`${qa}-field-group`]: !0 }), m = l.labelCol, b = l.wrapperCol, y = l.labelAlign, w = m && b, x = m ? `${qa}-col-${y}` : "", S = this.renderLabel(n, l), C = f.createElement(Dy, Object.assign({ disabled: l.disabled }, a), h), O = f.createElement(Aie, { fieldSet: d, showValidateIcon: l.showValidateIcon, isInInputGroup: !0 }), E = F(`${qa}-field-extra`, { [`${qa}-field-extra-string`]: typeof i == "string", [`${qa}-field-extra-middle`]: s === "middle", [`${qa}-field-extra-bottom`]: s === "bottom" }), v = i ? f.createElement("div", { className: E, "x-semi-prop": "extraText" }, i) : null; let T; switch (!0) { case !w: T = f.createElement(f.Fragment, null, S, f.createElement("div", null, s === "middle" ? v : null, C, s === "bottom" ? v : null, O)); break; case (w && u === "top"): T = f.createElement(f.Fragment, null, f.createElement("div", { style: { overflow: "hidden" } }, f.createElement(vr, Object.assign({}, m, { className: x }), S)), f.createElement(vr, Object.assign({}, b), s === "middle" ? v : null, C, s === "bottom" ? v : null, O)); break; case (w && u !== "top"): T = f.createElement(f.Fragment, null, f.createElement(vr, Object.assign({}, m, { className: x }), S), f.createElement(vr, Object.assign({}, b), s === "middle" ? v : null, C, s === "bottom" ? v : null, O)); break }return f.createElement("div", { "x-label-pos": u, className: g }, T) } } sT.contextType = zc; const Ii = pi.PREFIX, zp = typeof window < "u" ? R.useLayoutEffect : R.useEffect; function Mn(r, e) { let t = (n, i) => { let { field: s, label: a, labelPosition: o, labelWidth: l, labelAlign: u, labelCol: d, wrapperCol: h, noLabel: g, noErrorMessage: m, isInInputGroup: b, initValue: y, validate: w, validateStatus: x, trigger: S, allowEmptyString: C, allowEmpty: O, emptyValue: E, rules: v, required: T, keepState: I, transform: k, name: P, fieldClassName: N, fieldStyle: M, convert: B, stopValidateWithError: K, helpText: U, extraText: W, extraTextPosition: Z, pure: J, id: ee, rest: $ } = _ie(n), { options: pe, shouldInject: re } = Eie(e, n); if (Nt(typeof s > "u" && pe.shouldInject, "[Semi Form]: 'field' is required, please check your props of Field Component"), !re) return f.createElement(r, Object.assign({}, $, { ref: i })); iT(); const j = kie(); if (!j.getFormProps) return Nt(!0, "[Semi Form]: Field Component must be use inside the Form, please check your dom declaration"), null; let ae = j.getFormProps(["labelPosition", "labelWidth", "labelAlign", "labelCol", "wrapperCol", "disabled", "showValidateIcon", "extraTextPosition", "stopValidateWithError", "trigger"]), be = o || ae.labelPosition, fe = l || ae.labelWidth, Ce = u || ae.labelAlign, ue = d || ae.labelCol, te = h || ae.wrapperCol, le = Z || ae.extraTextPosition || "bottom", Re = Sie(K, ae.stopValidateWithError, !1), at = Cie(S, ae.trigger), yt = typeof s < "u" ? j.getValue(s) : void 0, ht = typeof y < "u" ? y : yt, Ft; try { Ft = Rie(), Ft && (ht = Ft.shouldUseInitValue && typeof y < "u" ? y : yt) } catch { } const [qe, $t, gn] = Bp(typeof ht !== void 0 ? ht : null), Hn = at.includes("mount"); O = O || j.getFormProps().allowEmpty; const [ot, Ut, Wt] = Bp(), [wn, Ze] = R.useState(), [hr, X, Q] = Bp(0), [L, Oe] = R.useState(x), De = R.useRef(!1), ie = R.useRef(v), un = R.useRef(w), Qt = R.useRef(null), jn = (Pe, Je) => { Ze(Pe), j.updateStateTouched(s, Pe, Je) }, Et = (Pe, Je) => { De.current || Pe !== Wt() && (Ut(Pe), j.updateStateError(s, Pe, Je), da(Pe) ? Oe("success") : Oe("error")) }, _t = (Pe, Je) => { $t(Pe); let Bt = Object.assign(Object.assign({}, Je), { allowEmpty: O }); j.updateStateValue(s, Pe, Bt) }, Nn = () => { let Pe = { notNotify: !0, notUpdate: !0 }; _t(ht !== null ? ht : void 0, Pe), Et(void 0, Pe), jn(void 0, Pe), Oe("default") }, Cn = (Pe, Je) => { let Bt = ie.current || []; const lt = xie(s, Bt), Yt = { [s]: Pe }, Ot = new Promise((Rt, $a) => { lt.validate(Yt, { first: Re }, (Qr, ei) => { }).then(Qr => { De.current || Qt.current !== Ot || (Oe("success"), Et(void 0, Je), Rt({})) }).catch(Qr => { if (De.current || Qt.current !== Ot) return; let { errors: ei, fields: La } = Qr; if (ei && La) { let qi = ei.map(fs => fs.message); qi.length === 1 && (qi = qi[0]), Et(qi, Je), da(qi) || (Oe("error"), Rt(ei)) } else throw Oe("error"), Et(Qr.message, Je), Rt(Qr.message), Qr }) }); return Qt.current = Ot, Ot }, Ar = (Pe, Je, Bt) => { const lt = new Promise(Yt => { let Ot; try { Ot = un.current(Pe, Je) } catch (Rt) { Ot = Rt } Ot === void 0 ? (Yt({}), Et(void 0, Bt)) : ba(Ot) ? Ot.then(Rt => { De.current || Qt.current !== lt || (da(Rt) ? (Et(void 0, Bt), Yt(null)) : (Et(Rt, Bt), Yt(Rt))) }) : da(Ot) ? (Et(void 0, Bt), Yt(null)) : (Et(Ot, Bt), Yt(Ot)) }); return Qt.current = lt, lt }, en = (Pe, Je) => { let Bt = Pe, lt = ie.current; return k && (Bt = k(Pe)), un.current ? Ar(Bt, j.getValue(), Je) : lt ? Cn(Bt, Je) : null }, Sn = function (Pe, Je) { if (pe.onKeyChangeFnName in n && typeof n[pe.onKeyChangeFnName] == "function") { for (var lt = arguments.length, Yt = new Array(lt > 2 ? lt - 2 : 0), Ot = 2; Ot < lt; Ot++)Yt[Ot - 2] = arguments[Ot]; n[pe.onKeyChangeFnName](Pe, Je, ...Yt) } let Rt; pe.valuePath ? Rt = ir(Pe, pe.valuePath) : Rt = Pe, typeof B == "function" && (Rt = B(Rt)), C || O || Rt === E && (Rt = void 0); try { Je && Je.target && Je.target.selectionStart && X(Je.target.selectionStart) } catch { } jn(!0, { notNotify: !0, notUpdate: !0 }), _t(Rt), at.includes("change") && en(Rt) }, Ie = function () { if (n.onBlur && n.onBlur(...arguments), wn || jn(!0), at.includes("blur")) { let Pe = gn(); en(Pe) } }, Dt = { setValue: _t, setTouched: jn, setError: Et, reset: Nn, validate: en }, me = { value: qe, error: ot, touched: wn, status: L }; zp(() => { ie.current = v, un.current = w }, [v, w]), zp(() => (De.current = !1, Hn && en(qe), () => { De.current = !0 }), []), zp(() => { if (typeof s > "u") return () => { }; const Pe = gn(); return j.register(s, { value: Pe, error: ot, touched: wn, status: L }, { field: s, fieldApi: Dt, keepState: I, allowEmpty: O || C }), () => { j.unRegister(s) } }, [s]); const tn = ee || s, Gt = `${tn}-label`, nn = `${tn}-helpText`, En = `${tn}-extraText`, Fn = `${tn}-errormessage`, dn = () => { let Pe = x || L; const Je = F(`${Ii}-field-extra`, { [`${Ii}-field-extra-string`]: typeof W == "string", [`${Ii}-field-extra-middle`]: le === "middle", [`${Ii}-field-extra-bottom`]: le === "bottom" }), Bt = W ? f.createElement("div", { className: Je, id: En, "x-semi-prop": "extraText" }, W) : null; let lt = Object.assign(Object.assign({ id: tn, disabled: ae.disabled }, $), { ref: i, onBlur: Ie, [pe.onKeyChangeFnName]: Sn, [pe.valueKey]: qe, validateStatus: Pe, "aria-required": T, "aria-labelledby": Gt }); P && (lt.name = P), U && (lt["aria-describedby"] = W ? `${nn} ${En}` : nn), W && (lt["aria-describedby"] = U ? `${nn} ${En}` : En), L === "error" && (lt["aria-errormessage"] = Fn, lt["aria-invalid"] = !0); const Yt = F({ [`${Ii}-field`]: !0, [`${Ii}-field-${P}`]: !!P, [N]: !!N }), Ot = F({ [`${Ii}-field-main`]: !0 }); be === "inset" && !g && (lt.insetLabel = a || s, lt.insetLabelId = Gt, typeof a == "object" && !vf(a) && (lt.insetLabel = a.text, lt.insetLabelId = Gt)); const Rt = f.createElement(r, Object.assign({}, lt)); if (b) return Rt; if (J) { let fs = F($.className, { [`${Ii}-field-pure`]: !0, [`${Ii}-field-${P}`]: !!P, [N]: !!N }); return lt.className = fs, f.createElement(r, Object.assign({}, lt)) } let $a = ue && te; const Qr = Ce ? `${Ii}-col-${Ce}` : ""; let ei = null; if (!g && be !== "inset") { let fs = typeof a == "object" && !vf(a) ? a : {}; ei = f.createElement(Vi, Object.assign({ text: a || s, id: Gt, required: T, name: tn || P || s, width: fe, align: Ce }, fs)) } const La = f.createElement("div", { className: Ot }, le === "middle" ? Bt : null, Rt, m ? null : f.createElement(Hc, { error: ot, validateStatus: Pe, helpText: U, helpTextId: nn, errorMessageId: Fn, showValidateIcon: ae.showValidateIcon }), le === "bottom" ? Bt : null), qi = f.createElement(f.Fragment, null, be === "top" ? f.createElement("div", { style: { overflow: "hidden" } }, f.createElement(vr, Object.assign({}, ue, { className: Qr }), ei)) : f.createElement(vr, Object.assign({}, ue, { className: Qr }), ei), f.createElement(vr, Object.assign({}, te), La)); return f.createElement("div", { className: Yt, style: M, "x-label-pos": be, "x-field-id": s, "x-extra-pos": le }, $a ? qi : f.createElement(f.Fragment, null, ei, La)) }, Kn = [...Object.values(me), ...Object.values(n), s, be, Ce, ae.disabled]; return pe.shouldMemo ? R.useMemo(dn, [...Kn]) : dn() }; return t = R.forwardRef(t), t.displayName = vie(r), t } const Nie = Mn(xr, { maintainCursor: !0 }), Fie = Mn(nO, { maintainCursor: !0 }), $ie = Mn(tO, { maintainCursor: !0 }), Cb = Mn(Zr); Cb.Option = Zr.Option; Cb.OptGroup = Zr.OptGroup; const Lie = Mn(Ec), Mie = Mn(bi, { valueKey: "checked", valuePath: "target.checked", shouldInject: !1 }), jie = Mn(jy, { valuePath: "target.value" }), Vie = Mn(Bs, { valueKey: "checked", valuePath: "target.checked", shouldInject: !1 }), Bie = Mn(xq), zie = Mn(Uy, { valueKey: "checked" }), Hie = Mn(wh), Kie = Mn(tc), Uie = Mn(Nh), Wie = Mn(_o), Gie = Mn(xh), Yie = Mn(So, { valueKey: "value", onKeyChangeFnName: "onChange" }), Xie = Mn(Bc, { valueKey: "fileList", valuePath: "fileList", onKeyChangeFnName: "onChange" }), qie = Mn(Pc); var Zie = function (r, e) { var t = {}; for (var n in r) Object.prototype.hasOwnProperty.call(r, n) && e.indexOf(n) < 0 && (t[n] = r[n]); if (r != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, n = Object.getOwnPropertySymbols(r); i < n.length; i++)e.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(r, n[i]) && (t[n[i]] = r[n[i]]); return t }; const Hp = pi.PREFIX; class Kt extends de { constructor(e) { super(e), this.state = { formId: "" }, Nt(!!(e.component && e.render), "[Semi Form] You should not use <Form component> and <Form render> in ths same time; <Form render> will be ignored"), Nt(e.component && e.children && !rx(e.children), "[Semi Form] You should not use <Form component> and <Form>{children}</Form> in ths same time; <Form>{children}</Form> will be ignored"), Nt(e.render && e.children && !rx(e.children), "[Semi Form] You should not use <Form render> and <Form>{children}</Form> in ths same time; <Form>{children}</Form> will be ignored"), this.submit = this.submit.bind(this), this.reset = this.reset.bind(this), this.foundation = new Oie(this.adapter), this.formApi = this.foundation.getFormApi(), this.props.getFormApi && this.props.getFormApi(this.formApi) } componentDidMount() { this.foundation.init() } componentWillUnmount() { this.foundation.destroy() } get adapter() { return Object.assign(Object.assign({}, super.adapter), { cloneDeep: Hr, notifySubmit: (e, t) => { this.props.onSubmit(e, t) }, notifySubmitFail: (e, t, n) => { this.props.onSubmitFail(e, t, n) }, forceUpdate: e => { this.forceUpdate(e) }, notifyChange: e => { this.props.onChange(e) }, notifyValueChange: (e, t) => { this.props.onValueChange(e, t) }, notifyErrorChange: (e, t) => { this.props.onErrorChange(e, t) }, notifyReset: () => { this.props.onReset() }, initFormId: () => { this.setState({ formId: es() }) }, getInitValues: () => this.props.initValues, getFormProps: e => { if (typeof e > "u") return this.props; if (typeof e == "string") return this.props[e]; { const t = {}; return e.forEach(n => { t[n] = this.props[n] }), t } }, getAllErrorDOM: () => { const { formId: e } = this.state, { id: t } = this.props, n = t || e; return document.querySelectorAll(`form[x-form-id="${n}"] .${pi.PREFIX}-field-error-message`) }, getFieldDOM: e => document.querySelector(`.${pi.PREFIX}-field[x-field-id="${e}"]`), getFieldErrorDOM: e => { const { formId: t } = this.state, { id: n } = this.props; let s = `form[x-form-id="${n || t}"] .${pi.PREFIX}-field[x-field-id="${e}"] .${pi.PREFIX}-field-error-message`; return document.querySelector(s) } }) } get content() { const { children: e, component: t, render: n } = this.props, i = this.foundation.getFormState(), s = { formState: i, formApi: this.foundation.getFormApi(), values: i.values }; return t ? f.createElement(t, s) : n ? n(s) : typeof e == "function" ? e(s) : e } submit(e) { e.preventDefault(), this.props.stopPropagation && this.props.stopPropagation.submit && e.stopPropagation(), this.foundation.submit(e) } reset(e) { e.preventDefault(), this.props.stopPropagation && this.props.stopPropagation.reset && e.stopPropagation(), this.foundation.reset() } render() { const t = this.foundation.getFormState(!1), n = this.foundation.getModifyFormStateApi(), { formId: i } = this.state, s = this.props, { children: a, getFormApi: o, onChange: l, onSubmit: u, onSubmitFail: d, onErrorChange: h, onValueChange: g, component: m, render: b, validateFields: y, initValues: w, layout: x, style: S, className: C, labelPosition: O, labelWidth: E, labelAlign: v, labelCol: T, wrapperCol: I, allowEmpty: k, autoScrollToError: P, showValidateIcon: N, stopValidateWithError: M, extraTextPosition: B, id: K, trigger: U } = s, W = Zie(s, ["children", "getFormApi", "onChange", "onSubmit", "onSubmitFail", "onErrorChange", "onValueChange", "component", "render", "validateFields", "initValues", "layout", "style", "className", "labelPosition", "labelWidth", "labelAlign", "labelCol", "wrapperCol", "allowEmpty", "autoScrollToError", "showValidateIcon", "stopValidateWithError", "extraTextPosition", "id", "trigger"]), Z = F(Hp, C, { [Hp + "-vertical"]: x === "vertical", [Hp + "-horizontal"]: x === "horizontal" }), J = I && T, ee = f.createElement("form", Object.assign({ style: S }, W, { onReset: this.reset, onSubmit: this.submit, className: Z, id: K || i, "x-form-id": K || i }), this.content), $ = f.createElement(gh, null, ee); return f.createElement(zc.Provider, { value: n }, f.createElement(nT.Provider, { value: this.formApi }, f.createElement(wb.Provider, { value: t }, J ? $ : ee))) } } Kt.propTypes = { "aria-label": c.string, onSubmit: c.func, onSubmitFail: c.func, onChange: c.func, onReset: c.func, onValueChange: c.func, autoScrollToError: c.oneOfType([c.bool, c.object]), allowEmpty: c.bool, className: c.string, component: c.oneOfType([c.node, c.func]), disabled: c.bool, extraTextPosition: c.oneOf(Tl.EXTRA_POS), getFormApi: c.func, initValues: c.object, validateFields: c.func, layout: c.oneOf(Tl.LAYOUT), labelPosition: c.oneOf(Tl.LABEL_POS), labelWidth: c.oneOfType([c.number, c.string]), labelAlign: c.oneOf(Tl.LABEL_ALIGN), labelCol: c.object, render: c.func, style: c.object, showValidateIcon: c.bool, stopValidateWithError: c.bool, stopPropagation: c.shape({ submit: c.bool, reset: c.bool }), id: c.string, wrapperCol: c.object, trigger: c.oneOfType([c.oneOf(["blur", "change", "custom", "mount"]), c.arrayOf(c.oneOf(["blur", "change", "custom", "mount"]))]) }; Kt.defaultProps = { onChange: z, onSubmitFail: z, onSubmit: z, onReset: z, onValueChange: z, onErrorChange: z, layout: "vertical", labelPosition: "top", allowEmpty: !1, autoScrollToError: !1, showValidateIcon: !0 }; Kt.Input = Nie; Kt.TextArea = $ie; Kt.InputNumber = Fie; Kt.Select = Cb; Kt.Checkbox = Mie; Kt.CheckboxGroup = Lie; Kt.Radio = Vie; Kt.RadioGroup = jie; Kt.DatePicker = Bie; Kt.TimePicker = Kie; Kt.Switch = zie; Kt.Slider = Hie; Kt.TreeSelect = Uie; Kt.Cascader = Wie; Kt.Rating = Gie; Kt.AutoComplete = Yie; Kt.Upload = Xie; Kt.TagInput = qie; Kt.Slot = Pie; Kt.ErrorMessage = Hc; Kt.InputGroup = sT; Kt.Label = Vi; Kt.Section = rT; const il = { PREFIX: `${G}-image` }, Jie = { DEFAULT_Z_INDEX: 1070 }, $h = R.createContext({}), Kp = `${il.PREFIX}-preview-header`, Qie = R.forwardRef((r, e) => { let { onClose: t, titleStyle: n, className: i, renderHeader: s, closable: a } = r; return f.createElement($h.Consumer, null, o => { let { currentIndex: l, titles: u } = o, d; return u && typeof l == "number" && (d = u[l]), f.createElement("section", { ref: e, className: F(Kp, i) }, f.createElement("section", { className: `${Kp}-title`, style: n }, s ? s(d) : d), a && f.createElement("section", { className: `${Kp}-close`, onMouseUp: t }, f.createElement(ds, null))) }) }); class ese extends ve { constructor() { super(...arguments), this.changeSliderValue = e => { const { zoom: t, step: n, min: i, max: s } = this.getProps(); let a = e === "plus" ? t + n : t - n; a > s ? a = s : a < i && (a = i), this.handleValueChange(a) }, this.handleValueChange = e => { const { onZoomIn: t, onZoomOut: n, zoom: i } = this.getProps(); e > i ? t(Number((e / 100).toFixed(2))) : n(Number((e / 100).toFixed(2))) }, this.handleRatioClick = () => { const { ratio: e, onAdjustRatio: t } = this.getProps(); t(e === "adaptation" ? "realSize" : "adaptation") }, this.handleRotate = e => { const { onRotate: t } = this.getProps(); t && t(e) } } } const ii = `${il.PREFIX}-preview-footer`; class Sb extends de { get adapter() { return Object.assign({}, super.adapter) } constructor(e) { super(e), this.changeSliderValue = t => { this.foundation.changeSliderValue(t) }, this.handleMinusClick = () => { this.changeSliderValue("minus") }, this.handlePlusClick = () => { this.changeSliderValue("plus") }, this.handleRotateLeft = () => { this.foundation.handleRotate("left") }, this.handleRotateRight = () => { this.foundation.handleRotate("right") }, this.handleSlideChange = xo(t => { this.foundation.handleValueChange(t) }, 50), this.handleRatioClick = () => { this.foundation.handleRatioClick() }, this.customRenderViewMenu = () => { const { min: t, max: n, step: i, curPage: s, totalNum: a, ratio: o, zoom: l, disabledPrev: u, disabledNext: d, disableDownload: h, onNext: g, onPrev: m, onDownload: b, renderPreviewMenu: y } = this.props, w = { min: t, max: n, step: i, curPage: s, totalNum: a, ratio: o, zoom: l, disabledPrev: u, disabledNext: d, disableDownload: h, onNext: g, onPrev: m, onDownload: b, onRotateLeft: this.handleRotateLeft, onRotateRight: this.handleRotateRight, disabledZoomIn: l === n, disabledZoomOut: l === t, onRatioClick: this.handleRatioClick, onZoomIn: this.handlePlusClick, onZoomOut: this.handleMinusClick, menuItems: this.getMenu() }; return y(w) }, this.getFinalIconElement = (t, n, i) => { const { showTooltip: s, zIndex: a } = this.props; return s ? f.createElement(ln, { content: n, key: `tooltip-${i}`, zIndex: a + 1 }, t) : t }, this.getLocalTextByKey = t => f.createElement(Ke, { componentName: "Image" }, n => n[t]), this.getIconChevronLeft = () => { const { disabledPrev: t, onPrev: n, prevTip: i } = this.props, s = f.createElement(bc, { key: "chevron-left", size: "large", className: t ? `${ii}-disabled` : "", onClick: t ? void 0 : n }), a = i ?? this.getLocalTextByKey("prevTip"); return this.getFinalIconElement(s, a, "chevron-left") }, this.getIconChevronRight = () => { const { disabledNext: t, onNext: n, nextTip: i } = this.props, s = f.createElement(Ms, { key: "chevron-right", size: "large", className: t ? `${ii}-disabled` : "", onClick: t ? void 0 : n }), a = i ?? this.getLocalTextByKey("nextTip"); return this.getFinalIconElement(s, a, "chevron-right") }, this.getIconMinus = () => { const { zoomOutTip: t, zoom: n, min: i } = this.props, s = n === i, a = f.createElement($H, { key: "minus", size: "large", onClick: s ? void 0 : this.handleMinusClick, className: s ? `${ii}-disabled` : "" }), o = t ?? this.getLocalTextByKey("zoomOutTip"); return this.getFinalIconElement(a, o, "minus") }, this.getIconPlus = () => { const { zoomInTip: t, zoom: n, max: i } = this.props, s = n === i, a = f.createElement(MH, { key: "plus", size: "large", onClick: s ? void 0 : this.handlePlusClick, className: s ? `${ii}-disabled` : "" }), o = t ?? this.getLocalTextByKey("zoomInTip"); return this.getFinalIconElement(a, o, "plus") }, this.getIconRatio = () => { const { ratio: t, originTip: n, adaptiveTip: i } = this.props, s = { key: "ratio", size: "large", className: F(`${ii}-gap`), onClick: this.handleRatioClick }, a = t === "adaptation" ? f.createElement(zH, Object.assign({}, s)) : f.createElement(fK, Object.assign({}, s)); let o; return t === "adaptation" ? o = n ?? this.getLocalTextByKey("originTip") : o = i ?? this.getLocalTextByKey("adaptiveTip"), this.getFinalIconElement(a, o, "ratio") }, this.getIconRotate = () => { const { rotateTip: t } = this.props, n = f.createElement(YH, { key: "rotate", size: "large", onClick: this.handleRotateLeft }), i = t ?? this.getLocalTextByKey("rotateTip"); return this.getFinalIconElement(n, i, "rotate") }, this.getIconDownload = () => { const { downloadTip: t, onDownload: n, disableDownload: i } = this.props, s = f.createElement(lH, { key: "download", size: "large", onClick: i ? void 0 : n, className: F(`${ii}-gap`, { [`${ii}-disabled`]: i }) }), a = t ?? this.getLocalTextByKey("downloadTip"); return this.getFinalIconElement(s, a, "download") }, this.getNumberInfo = () => { const { curPage: t, totalNum: n } = this.props; return f.createElement("div", { className: `${ii}-page`, key: "info" }, t, "/", n) }, this.getSlider = () => { const { zoom: t, min: n, max: i, step: s, showTooltip: a } = this.props; return f.createElement(wh, { key: "slider", value: t, min: n, max: i, step: s, tipFormatter: o => `${o}%`, tooltipVisible: a ? void 0 : !1, onChange: this.handleSlideChange }) }, this.getMenu = () => [this.getIconChevronLeft(), this.getNumberInfo(), this.getIconChevronRight(), this.getIconMinus(), this.getSlider(), this.getIconPlus(), this.getIconRatio(), this.getIconRotate(), this.getIconDownload()], this.getFooterMenu = () => { const t = this.getMenu(); return t.splice(3, 0, f.createElement(Pg, { layout: "vertical", key: "divider-first" })), t.splice(8, 0, f.createElement(Pg, { layout: "vertical", key: "divider-second" })), t }, this.foundation = new ese(this.adapter) } render() { const { className: e, renderPreviewMenu: t, forwardRef: n } = this.props, i = F(ii, `${ii}-wrapper`, e, { [`${ii}-content`]: !t }); return f.createElement("section", { className: i, ref: n }, t ? this.customRenderViewMenu() : this.getFooterMenu()) } } Sb.propTypes = { curPage: c.number, totalNum: c.number, disabledPrev: c.bool, disabledNext: c.bool, disableDownload: c.bool, className: c.string, zoom: c.number, ratio: c.string, prevTip: c.string, nextTip: c.string, zoomInTip: c.string, zoomOutTip: c.string, rotateTip: c.string, downloadTip: c.string, adaptiveTip: c.string, originTip: c.string, showTooltip: c.bool, onZoomIn: c.func, onZoomOut: c.func, onPrev: c.func, onNext: c.func, onAdjustRatio: c.func, onRotateLeft: c.func, onDownload: c.func }; Sb.defaultProps = { min: 10, max: 500, step: 10, showTooltip: !1, disableDownload: !1 }; class tse extends ve { constructor(e) { var t; super(Object.assign({}, e)), t = this, this.startMouseClientPosition = { x: 0, y: 0 }, this.originImageWidth = null, this.originImageHeight = null, this.containerWidth = 0, this.containerHeight = 0, this._isImageVertical = () => this.getProp("rotation") % 180 !== 0, this._getContainerBoundingRectSize = () => { const n = this._adapter.getContainer(); n && (this.containerWidth = n.clientWidth, this.containerHeight = n.clientHeight) }, this._getAdaptationZoom = () => { let n = 1; if (this._adapter.getContainer() && this.originImageWidth && this.originImageHeight) { const { rotation: s } = this.getProps(), { width: a, height: o } = this.calcBoundingRectSize(this.originImageWidth, this.originImageHeight, s), l = this.containerWidth - 80, u = this.containerHeight - 80; n = Number(Math.min(l / a, u / o).toFixed(2)) } return n }, this._getInitialZoom = () => { const { ratio: n } = this.getProps(); let i = 1; return n === "adaptation" && (i = this._getAdaptationZoom()), i }, this.setLoading = n => { this._adapter.setLoading(n) }, this.handleWindowResize = () => { this._getContainerBoundingRectSize(), this.initializeImage() }, this.handleLoad = n => { if (n.target) { const { naturalWidth: a, naturalHeight: o } = n.target; this.originImageHeight = o, this.originImageWidth = a, this.setState({ loading: !1 }), this.initializeImage(!1) } const { src: i, onLoad: s } = this.getProps(); s && s(i) }, this.handleError = n => { const { onError: i, src: s } = this.getProps(); this.setState({ loading: !1 }), i && i(s) }, this.handleRatioChange = () => { this.initializeImage() }, this.initializeImageZoom = function () { let n = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !0; const { currZoom: i } = t.getStates(), { onZoom: s } = t.getProps(), a = t._getInitialZoom(); i !== a ? s(a, n) : t.changeZoom(a) }, this.initializeTranslate = () => { this.setState({ translate: { x: 0, y: 0 } }) }, this.initializeImage = function () { let n = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !0; t.initializeImageZoom(n), t.initializeTranslate() }, this.handleRightClickImage = n => { const { disableDownload: i } = this.getProps(); return i ? (n.preventDefault(), n.stopPropagation(), !1) : !0 }, this.getCanDragDirection = (n, i) => { let s = n > this.containerWidth; return { canDragVertical: i > this.containerHeight, canDragHorizontal: s } }, this.changeZoom = (n, i) => { const s = this._adapter.getImage(), { currZoom: a, translate: o, width: l, height: u } = this.getStates(), { rotation: d } = this.getProps(), h = n / (a || 1), g = Math.floor(this.originImageWidth * n), m = Math.floor(this.originImageHeight * n); let b = Math.floor(o.x * h), y = Math.floor(o.y * h); const w = this.calcBoundingRectSize(l, u, d), x = { width: w.width * h, height: w.height * h }; if (i && s && i.target === s) { let C = d % 360; switch (C < 0 && (C = 360 + C), C) { case 0: b = (i.offsetX - .5 * l) * (1 - n / a) + o.x, y = (i.offsetY - .5 * u) * (1 - n / a) + o.y; break; case 90: b = (.5 * u - i.offsetY) * (1 - n / a) + o.x, y = (i.offsetX - .5 * l) * (1 - n / a) + o.y; break; case 180: b = (.5 * l - i.offsetX) * (1 - n / a) + o.x, y = (.5 * u - i.offsetY) * (1 - n / a) + o.y; break; case 270: b = (i.offsetY - .5 * u) * (1 - n / a) + o.x, y = (.5 * l - i.offsetX) * (1 - n / a) + o.y; break } } const S = this.getSafeTranslate(x.width, x.height, b, y); if (this.setState({ translate: S, width: g, height: m, currZoom: n }), s) { const { canDragVertical: C, canDragHorizontal: O } = this.getCanDragDirection(x.width, x.height), E = C || O; this._adapter.setImageCursor(E) } }, this.getExtremeTranslate = (n, i) => ({ x: (n - this.containerWidth) / 2, y: (i - this.containerHeight) / 2 }), this.getSafeTranslate = (n, i, s, a) => { const { x: o, y: l } = this.getExtremeTranslate(n, i), { canDragVertical: u, canDragHorizontal: d } = this.getCanDragDirection(n, i); let h = 0, g = 0; return d && (h = s > 0 ? Math.min(s, o) : Math.max(s, -o)), u && (g = a > 0 ? Math.min(a, l) : Math.max(a, -l)), { x: h, y: g } }, this.handleImageMove = n => { n.buttons === 1 && this.moveImage(n) }, this.moveImage = n => { const { clientX: i, clientY: s } = n, { width: a, height: o, translate: l } = this.getStates(), { rotation: u } = this.getProps(), d = this.calcBoundingRectSize(a, o, u), { canDragVertical: h, canDragHorizontal: g } = this.getCanDragDirection(d.width, d.height); if (h || g) { let m = g ? l.x + i - this.startMouseClientPosition.x : l.x, b = h ? l.y + s - this.startMouseClientPosition.y : l.y; const y = this.getSafeTranslate(d.width, d.height, m, b); this.setState({ translate: y }), this.startMouseClientPosition = { x: i, y: s } } }, this.handleImageMouseDown = n => { this.startMouseClientPosition = { x: n.clientX, y: n.clientY } }, this.calcBoundingRectMouseOffset = n => { const { width: i, height: s, offset: a, rotation: o = 0 } = n; let l = o % 360; l = l >= 0 ? l : 360 + l; let u = 0, d = 0; switch (l) { case 0: u = a.x, d = a.y; break; case 90: u = s - a.y, d = a.x; break; case 180: u = i - a.x, d = s - a.y; break; case 270: u = a.y, d = i - a.x; break }return { x: u, y: d } } } init() { this._getContainerBoundingRectSize() } calcBoundingRectSize() { let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0, t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0; const i = (arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0) * Math.PI / 180, s = Math.abs(Math.sin(i)), a = Math.abs(Math.cos(i)), o = e * a + t * s, l = e * s + t * a; return { width: o, height: l } } } const nse = il.PREFIX, Up = `${nse}-preview-image`; class Eb extends de { get adapter() { return Object.assign(Object.assign({}, super.adapter), { getContainer: () => this.containerRef.current, getImage: () => this.imageRef.current, setLoading: e => { this.setState({ loading: e }) }, setImageCursor: e => { this.imageRef.current.style.cursor = e ? "grab" : "default" } }) } constructor(e) { super(e), this.onWindowResize = () => { this.foundation.handleWindowResize() }, this.handleRightClickImage = t => { this.foundation.handleRightClickImage(t) }, this.handleLoad = t => { this.foundation.handleLoad(t) }, this.handleError = t => { this.foundation.handleError(t) }, this.handleImageMove = t => { this.foundation.handleImageMove(t) }, this.handleMouseDown = t => { this.foundation.handleImageMouseDown(t) }, this.state = { width: 0, height: 0, loading: !0, translate: { x: 0, y: 0 }, currZoom: this.props.zoom }, this.containerRef = f.createRef(), this.imageRef = f.createRef(), this.foundation = new tse(this.adapter) } componentDidMount() { this.foundation.init(), window.addEventListener("resize", this.onWindowResize) } componentWillUnmount() { window.removeEventListener("resize", this.onWindowResize) } componentDidUpdate(e, t) { const n = "zoom" in this.props && this.props.zoom !== this.state.currZoom, i = this.props.src && this.props.src !== e.src; i && this.foundation.setLoading(!0), !n && !i && e && ("ratio" in this.props && this.props.ratio !== e.ratio && this.foundation.handleRatioChange(), "rotation" in this.props && this.props.rotation !== e.rotation && this.onWindowResize()) } render() { const { src: e, rotation: t, crossOrigin: n } = this.props, { loading: i, width: s, height: a, translate: o } = this.state, l = { position: "absolute", visibility: i ? "hidden" : "visible", transform: `translate(${o.x}px, ${o.y}px) rotate(${t}deg)`, width: s, height: a }; return f.createElement("div", { className: `${Up}`, ref: this.containerRef }, f.createElement("img", { ref: this.imageRef, src: e, alt: "previewImag", className: `${Up}-img`, key: e, onMouseMove: this.handleImageMove, onMouseDown: this.handleMouseDown, onContextMenu: this.handleRightClickImage, onDragStart: u => u.preventDefault(), onLoad: this.handleLoad, onError: this.handleError, style: l, crossOrigin: n }), i && f.createElement(yi, { size: "large", wrapperClassName: `${Up}-spin` })) } } Eb.propTypes = { src: c.string, rotation: c.number, style: c.object, zoom: c.number, ratio: c.string, disableDownload: c.bool, clickZoom: c.number, setRatio: c.func, onZoom: c.func, onLoad: c.func, onError: c.func }; Eb.defaultProps = { zoom: void 0 }; var rse = function (r, e, t, n) { function i(s) { return s instanceof t ? s : new t(function (a) { a(s) }) } return new (t || (t = Promise))(function (s, a) { function o(d) { try { u(n.next(d)) } catch (h) { a(h) } } function l(d) { try { u(n.throw(d)) } catch (h) { a(h) } } function u(d) { d.done ? s(d.value) : i(d.value).then(o, l) } u((n = n.apply(r, e || [])).next()) }) }; const ise = (r, e) => { const t = r == null ? void 0 : r.composedPath(); return t == null ? void 0 : t.slice(0, t.length - 4).some(i => i.className && typeof i.className == "string" ? e.some(s => i.className.includes(s)) : !1) }, sse = (r, e, t) => rse(void 0, void 0, void 0, function* () { try { const n = yield fetch(r); if (n.ok) { const i = yield n.blob(), s = URL.createObjectURL(i), a = document.createElement("a"); a.href = s, a.download = e, a.click(), URL.revokeObjectURL(s), a.remove() } else t(r) } catch { t(r) } }), ase = function () { let r = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [], e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [], t = []; const n = r.length, i = e.length, s = n <= i ? n : i; return new Array(s).fill(0).forEach((a, o) => { t.push(e[o]), t.push(r[o]) }), n > i ? t = t.concat(r.slice(i, n)) : n < i && (t = t.concat(e.slice(n, i))), t }, ose = (r, e, t, n) => { const i = e - t, s = e + t, a = r.length; let o = [], l = []; t >= Math.floor(a / 2) ? n ? (o = r.concat(r).slice(i + a < 0 ? 0 : i + a, e + a), l = r.concat(r).slice(e + 1, s + 1 < 2 * a ? s + 1 : 2 * a)) : (o = r.slice(0, e), l = r.slice(e + 1, a)) : n ? (o = r.concat(r).slice(i + a, e + a), l = r.concat(r).slice(e + 1, s + 1)) : i >= 0 && s < a ? (o = r.slice(i, e), l = r.slice(e + 1, s + 1)) : i < 0 ? (o = r.slice(0, e), l = r.slice(e + 1, 2 * t + 1)) : (l = r.slice(e + 1, a), o = r.slice(a - 2 * t - 1, e)); const u = ase(o.reverse(), l); return Array.from(new Set(u)) }, lse = ["icon", "footer"]; class cse extends ve { constructor(e) { var t; super(Object.assign({}, e)), t = this, this._timer = null, this._startMouseDown = { x: 0, y: 0 }, this.handleViewVisibleChange = () => { const { viewerVisible: n } = this.getStates(); n && (this.setState({ viewerVisible: !1 }), this.clearTimer()) }, this.handleMouseMove = n => { this._persistEvent(n), this.mouseMoveHandler(n) }, this.mouseMoveHandler = xo(n => { const { viewerVisible: i } = this.getStates(); this._adapter.isValidTarget(n) ? (i || this.setState({ viewerVisible: !0 }), this.updateTimer()) : this.clearTimer() }, 50), this.updateTimer = () => { const { viewerVisibleDelay: n } = this.getProps(); this.clearTimer(), this._timer = setTimeout(this.handleViewVisibleChange, n) }, this.clearTimer = () => { this._timer && (clearTimeout(this._timer), this._timer = null) }, this.handleWheel = n => { this.onWheel(n), yn(n) }, this.onWheel = n => { const { zoomStep: i, maxZoom: s, minZoom: a } = this.getProps(), { zoom: o } = this.getStates(); let l; n.deltaY < 0 ? o + i <= s && (l = Number((o + i).toFixed(2))) : n.deltaY > 0 && o - i >= a && (l = Number((o - i).toFixed(2))), st(l) || this.handleZoomImage(l, !0, n) }, this.handleMouseUp = n => { const { maskClosable: i } = this.getProps(); let s = !ise(n, lse); const { clientX: a, clientY: o } = n, { x: l, y: u } = this._startMouseDown; (Math.abs(a - l) > 5 || Math.abs(u - o) > 5) && (s = !1), s && i && this._adapter.notifyVisibleChange(!1) }, this.handleMouseDown = n => { const { clientX: i, clientY: s } = n; this._startMouseDown = { x: i, y: s } }, this.handleKeyDown = n => { const { closeOnEsc: i } = this.getProps(); if (i && n.keyCode === Tn.ESC) { n.stopPropagation(), this._adapter.notifyVisibleChange(!1), this._adapter.notifyClose(); return } }, this.handleSwitchImage = n => { const i = n === "prev" ? -1 : 1, { imgSrc: s, currentIndex: a } = this.getStates(), o = s.length, l = (a + i + o) % o; "currentIndex" in this.getProps() ? this._adapter.getIsInGroup() && this._adapter.getContext("setCurrentIndex")(l) : this.setState({ currentIndex: l }), this._adapter.notifyChange(l, n), this.setState({ direction: n, rotation: 0 }) }, this.handleDownload = () => { const { currentIndex: n, imgSrc: i } = this.getStates(), s = this._adapter.getSetDownloadFunc(), a = i[n], o = s ? s(a) : a.slice(a.lastIndexOf("/") + 1).split("?")[0]; sse(a, o, this._adapter.notifyDownloadError), this._adapter.notifyDownload(a, n) }, this.handlePreviewClose = n => { this._adapter.notifyVisibleChange(!1), this._adapter.notifyClose(), yn(n) }, this.handleAdjustRatio = n => { this.setState({ ratio: n }), this._adapter.notifyRatioChange(n) }, this.handleRotateImage = n => { const { rotation: i } = this.getStates(), a = i + (n === "left" ? -90 : 90); this.setState({ rotation: a }), this._adapter.notifyRotateChange(a) }, this.handleZoomImage = function (n) { let i = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0, s = arguments.length > 2 ? arguments[2] : void 0; const { zoom: a } = t.getStates(); a !== n && (i && t._adapter.notifyZoom(n, n > a), t._adapter.changeImageZoom(n, s), t.setState({ zoom: n })) }, this.preloadGapImage = () => { const { preLoad: n, preLoadGap: i, infinite: s, currentIndex: a } = this.getProps(), { imgSrc: o } = this.getStates(); if (!n || typeof i != "number" || i < 1) return; const l = ose(o, a, i, s); if (l.length === 0) return; const u = new Image; let d = 0; function h(g) { d++, d < l.length && (u.src = l[d]) } u.onload = g => { this.setLoadSuccessStatus(u.src), h() }, u.onerror = h, u.src = l[0] }, this.preloadSingleImage = () => { const { preLoad: n, preLoadGap: i, infinite: s } = this.getProps(), { imgSrc: a, currentIndex: o, direction: l, imgLoadStatus: u } = this.getStates(); if (!n || typeof i != "number" || i < 1) return; let d = o + (l === "prev" ? -1 : 1) * i; if (d < 0 || d >= a.length) if (s) d = (d + a.length) % a.length; else return; if (!u[d]) { const h = new Image; h.onload = g => { this.setLoadSuccessStatus(a[d]) }, h.src = a[d] } }, this.setLoadSuccessStatus = n => { const { imgLoadStatus: i } = this.getStates(), s = Object.assign({}, i); s[n] = !0, this.setState({ imgLoadStatus: s }) }, this.onImageLoad = n => { const { preloadAfterVisibleChange: i } = this.getStates(); this.setLoadSuccessStatus(n), i ? (this.preloadGapImage(), this.setState({ preloadAfterVisibleChange: !1 })) : this.preloadSingleImage() } } beforeShow() { this._adapter.registerKeyDownListener(), this._adapter.disabledBodyScroll(), this.updateTimer() } afterHide() { this._adapter.unregisterKeyDownListener(), this._adapter.enabledBodyScroll(), this.clearTimer() } } const Dw = il.PREFIX; class Kc extends de { get adapter() { var e = this; return Object.assign(Object.assign({}, super.adapter), { getIsInGroup: () => this.isInGroup(), disabledBodyScroll: () => { const { getPopupContainer: t } = this.props; this.bodyOverflow = document.body.style.overflow || "", !t && this.bodyOverflow !== "hidden" && (document.body.style.overflow = "hidden", document.body.style.width = `calc(${this.originBodyWidth || "100%"} - ${this.scrollBarWidth}px)`) }, enabledBodyScroll: () => { const { getPopupContainer: t } = this.props; !t && this.bodyOverflow !== "hidden" && (document.body.style.overflow = this.bodyOverflow, document.body.style.width = this.originBodyWidth) }, notifyChange: (t, n) => { const { onChange: i, onPrev: s, onNext: a } = this.props; we(i) && i(t), n === "prev" ? s && s(t) : a && a(t) }, notifyZoom: (t, n) => { const { onZoomIn: i, onZoomOut: s } = this.props; n ? we(i) && i(t) : we(s) && s(t) }, notifyClose: () => { const { onClose: t } = this.props; we(t) && t() }, notifyVisibleChange: t => { const { onVisibleChange: n } = this.props; we(n) && n(t) }, notifyRatioChange: t => { const { onRatioChange: n } = this.props; we(n) && n(t) }, notifyRotateChange: t => { const { onRotateLeft: n } = this.props; we(n) && n(t) }, notifyDownload: (t, n) => { const { onDownload: i } = this.props; we(i) && i(t, n) }, notifyDownloadError: t => { const { onDownloadError: n } = this.props; we(n) && n(t) }, registerKeyDownListener: () => { window && window.addEventListener("keydown", this.handleKeyDown) }, unregisterKeyDownListener: () => { window && window.removeEventListener("keydown", this.handleKeyDown) }, getSetDownloadFunc: () => { var t, n; return (n = (t = this.context) === null || t === void 0 ? void 0 : t.setDownloadName) !== null && n !== void 0 ? n : this.props.setDownloadName }, isValidTarget: t => { const n = this.headerRef && this.headerRef.current, i = this.footerRef && this.footerRef.current, s = this.leftIconRef && this.leftIconRef.current, a = this.rightIconRef && this.rightIconRef.current, o = t.target; return !(n && n.contains(o) || i && i.contains(o) || s && s.contains(o) || a && a.contains(o)) }, changeImageZoom: function () { var t; !((t = e.imageRef) === null || t === void 0) && t.current && e.imageRef.current.foundation.changeZoom(...arguments) } }) } constructor(e) { var t; super(e), t = this, this.viewVisibleChange = () => { this.foundation.handleViewVisibleChange() }, this.handleSwitchImage = n => { this.foundation.handleSwitchImage(n) }, this.handleDownload = () => { this.foundation.handleDownload() }, this.handlePreviewClose = n => { this.foundation.handlePreviewClose(n) }, this.handleAdjustRatio = n => { this.foundation.handleAdjustRatio(n) }, this.handleRotateImage = n => { this.foundation.handleRotateImage(n) }, this.handleZoomImage = function (n) { let i = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0; t.foundation.handleZoomImage(n, i) }, this.handleMouseUp = n => { this.foundation.handleMouseUp(n.nativeEvent) }, this.handleMouseMove = n => { this.foundation.handleMouseMove(n) }, this.handleKeyDown = n => { this.foundation.handleKeyDown(n) }, this.onImageError = () => { this.foundation.preloadSingleImage() }, this.onImageLoad = n => { this.foundation.onImageLoad(n) }, this.handleMouseDown = n => { this.foundation.handleMouseDown(n) }, this.handleWheel = n => { this.foundation.handleWheel(n) }, this.registryImageWrapRef = n => { this.imageWrapRef && this.imageWrapRef.removeEventListener("wheel", this.handleWheel), n && n.addEventListener("wheel", this.handleWheel, { passive: !1 }), this.imageWrapRef = n }, this.state = { imgSrc: [], imgLoadStatus: new Map, zoom: .1, currentIndex: 0, ratio: "adaptation", rotation: 0, viewerVisible: !0, visible: !1, preloadAfterVisibleChange: !0, direction: "" }, this.foundation = new cse(this.adapter), this.bodyOverflow = "", this.originBodyWidth = "100%", this.scrollBarWidth = 0, this.imageWrapRef = null, this.imageRef = f.createRef(), this.headerRef = f.createRef(), this.footerRef = f.createRef(), this.leftIconRef = f.createRef(), this.rightIconRef = f.createRef() } static getDerivedStateFromProps(e, t) { const n = {}; let i = []; return e.visible && (i = Array.isArray(e.src) ? e.src : [e.src]), ke(i, t.imgSrc) || (n.imgSrc = i), e.visible !== t.visible && (n.visible = e.visible, e.visible && (n.preloadAfterVisibleChange = !0, n.viewerVisible = !0, n.rotation = 0, n.ratio = "adaptation")), "currentIndex" in e && e.currentIndex !== t.currentIndex && (n.currentIndex = e.currentIndex, n.ratio = "adaptation"), n } componentDidMount() { this.scrollBarWidth = Nm(), this.originBodyWidth = document.body.style.width, this.props.visible && this.foundation.beforeShow() } componentDidUpdate(e, t) { e.src !== this.props.src && this.foundation.updateTimer(), !e.visible && this.props.visible && this.foundation.beforeShow(), e.visible && !this.props.visible && this.foundation.afterHide() } componentWillUnmount() { this.foundation.clearTimer() } isInGroup() { return !!(this.context && this.context.isGroup) } render() { const { getPopupContainer: e, closable: t, zIndex: n, visible: i, className: s, style: a, infinite: o, zoomStep: l, crossOrigin: u, prevTip: d, nextTip: h, zoomInTip: g, zoomOutTip: m, rotateTip: b, downloadTip: y, adaptiveTip: w, originTip: x, showTooltip: S, disableDownload: C, renderPreviewMenu: O, renderHeader: E } = this.props, { currentIndex: v, imgSrc: T, zoom: I, ratio: k, rotation: P, viewerVisible: N } = this.state; let M = { zIndex: n }; e && (M = { zIndex: n, position: "static" }); const B = `${Dw}-preview`, K = F(B, { [`${Dw}-hide`]: !i, [`${B}-popup`]: e }, s), U = N ? "" : `${B}-hide`, W = T.length, Z = W !== 1 && (o || v !== 0), J = W !== 1 && (o || v !== W - 1); return i && f.createElement(Oa, { getPopupContainer: e, style: M }, f.createElement("div", { className: K, style: a, onMouseDown: this.handleMouseDown, onMouseUp: this.handleMouseUp, ref: this.registryImageWrapRef, onMouseMove: this.handleMouseMove }, f.createElement(Qie, { ref: this.headerRef, className: F(U), onClose: this.handlePreviewClose, renderHeader: E, closable: t }), f.createElement(Eb, { ref: this.imageRef, src: T[v], onZoom: this.handleZoomImage, disableDownload: C, setRatio: this.handleAdjustRatio, zoom: I, ratio: k, rotation: P, crossOrigin: u, onError: this.onImageError, onLoad: this.onImageLoad }), Z && f.createElement("div", { ref: this.leftIconRef, className: F(`${B}-icon`, `${B}-prev`, U), onClick: () => this.handleSwitchImage("prev") }, f.createElement(vz, { size: "large" })), J && f.createElement("div", { ref: this.rightIconRef, className: F(`${B}-icon`, `${B}-next`, U), onClick: () => this.handleSwitchImage("next") }, f.createElement(BS, { size: "large" })), f.createElement(Sb, { forwardRef: this.footerRef, className: U, totalNum: W, curPage: v + 1, disabledPrev: !Z, disabledNext: !J, zoom: I * 100, step: l * 100, showTooltip: S, ratio: k, prevTip: d, nextTip: h, zIndex: n, zoomInTip: g, zoomOutTip: m, rotateTip: b, downloadTip: y, disableDownload: C, adaptiveTip: w, originTip: x, onPrev: () => this.handleSwitchImage("prev"), onNext: () => this.handleSwitchImage("next"), onZoomIn: this.handleZoomImage, onZoomOut: this.handleZoomImage, onDownload: this.handleDownload, onRotate: this.handleRotateImage, onAdjustRatio: this.handleAdjustRatio, renderPreviewMenu: O }))) } } Kc.contextType = $h; Kc.propTypes = { style: c.object, className: c.string, visible: c.bool, src: c.oneOfType([c.string, c.array]), currentIndex: c.number, defaultCurrentIndex: c.number, defaultVisible: c.bool, maskClosable: c.bool, closable: c.bool, zoomStep: c.number, infinite: c.bool, showTooltip: c.bool, closeOnEsc: c.bool, prevTip: c.string, nextTip: c.string, zoomInTip: c.string, zoomOutTip: c.string, downloadTip: c.string, adaptiveTip: c.string, originTip: c.string, lazyLoad: c.bool, preLoad: c.bool, preLoadGap: c.number, disableDownload: c.bool, viewerVisibleDelay: c.number, zIndex: c.number, maxZoom: c.number, minZoom: c.number, renderHeader: c.func, renderPreviewMenu: c.func, getPopupContainer: c.func, onVisibleChange: c.func, onChange: c.func, onClose: c.func, onZoomIn: c.func, onZoomOut: c.func, onPrev: c.func, onNext: c.func, onDownload: c.func, onRatioChange: c.func, onRotateLeft: c.func }; Kc.defaultProps = { showTooltip: !1, zoomStep: .1, infinite: !1, closeOnEsc: !0, lazyLoad: !1, preLoad: !0, preLoadGap: 2, zIndex: Jie.DEFAULT_Z_INDEX, maskClosable: !0, viewerVisibleDelay: 1e4, maxZoom: 5, minZoom: .1 }; class use extends ve { constructor(e) { super(Object.assign({}, e)), this.handleClick = t => { const { imageID: n, preview: i } = this.getProps(); if (i) if (this._adapter.getIsInGroup()) { const { setCurrentIndex: s, handleVisibleChange: a } = this._adapter.getContexts(); s(n), a(!0) } else this.handlePreviewVisibleChange(!0) }, this.handleLoaded = t => { const { onLoad: n } = this.getProps(); n && n(t), this.setState({ loadStatus: "success" }) }, this.handleError = t => { const { onError: n } = this.getProps(); n && n(t), this.setState({ loadStatus: "error" }) }, this.handlePreviewVisibleChange = t => { const { preview: n } = this.getProps(); if (an(n)) { const { onVisibleChange: i } = n; i && i(t), "visible" in n || this.setState({ previewVisible: t }) } else this.setState({ previewVisible: t }) } } } var dse = function (r, e) { var t = {}; for (var n in r) Object.prototype.hasOwnProperty.call(r, n) && e.indexOf(n) < 0 && (t[n] = r[n]); if (r != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, n = Object.getOwnPropertySymbols(r); i < n.length; i++)e.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(r, n[i]) && (t[n[i]] = r[n[i]]); return t }; const si = il.PREFIX; let sl = class extends de { get adapter() { return Object.assign(Object.assign({}, super.adapter), { getIsInGroup: () => this.isInGroup() }) } constructor(e) { super(e), this.handleClick = t => { this.foundation.handleClick(t) }, this.handleLoaded = t => { this.foundation.handleLoaded(t) }, this.handleError = t => { this.foundation.handleError(t) }, this.handlePreviewVisibleChange = t => { this.foundation.handlePreviewVisibleChange(t) }, this.renderDefaultLoading = () => { const { width: t, height: n } = this.props; return f.createElement(gi.Image, { style: { width: t, height: n } }) }, this.renderDefaultError = () => { const t = `${si}-status`; return f.createElement("div", { className: t }, f.createElement(XS, { size: "extra-large" })) }, this.renderLoad = () => { const t = `${si}-status`, { placeholder: n } = this.props; return n ? f.createElement("div", { className: t }, n) : this.renderDefaultLoading() }, this.renderError = () => { const { fallback: t } = this.props, n = `${si}-status`, i = typeof t == "string" ? f.createElement("img", { style: { width: "100%", height: "100%" }, src: t, alt: "fallback" }) : t; return t ? f.createElement("div", { className: n }, i) : this.renderDefaultError() }, this.renderExtra = () => { const { loadStatus: t } = this.state; return f.createElement("div", { className: `${si}-overlay` }, t === "error" && this.renderError(), t === "loading" && this.renderLoad()) }, this.getLocalTextByKey = t => f.createElement(Ke, { componentName: "Image" }, n => n[t]), this.renderMask = () => f.createElement("div", { className: `${si}-mask` }, f.createElement("div", { className: `${si}-mask-info` }, f.createElement(WS, { size: "extra-large" }), f.createElement("span", { className: `${si}-mask-info-text` }, this.getLocalTextByKey("preview")))), this.state = { src: "", loadStatus: "loading", previewVisible: !1 }, this.foundation = new use(this.adapter), this.imgRef = f.createRef() } static getDerivedStateFromProps(e, t) { const n = {}; if (e.src !== t.src && (n.src = e.src, n.loadStatus = "loading"), an(e.preview)) { const { visible: i } = e.preview; oy(i) && (n.previewVisible = i) } return n } isInGroup() { return !!(this.context && this.context.isGroup) } isLazyLoad() { return this.context ? this.context.lazyLoad : !1 } render() { var e; const { src: t, loadStatus: n, previewVisible: i } = this.state, s = this.props, { src: a, width: o, height: l, alt: u, style: d, className: h, crossOrigin: g, preview: m, fallback: b, placeholder: y, imageID: w, setDownloadName: x, imgCls: S, imgStyle: C } = s, O = dse(s, ["src", "width", "height", "alt", "style", "className", "crossOrigin", "preview", "fallback", "placeholder", "imageID", "setDownloadName", "imgCls", "imgStyle"]), E = Object.assign({ width: o, height: l }, d), v = F(si, h), T = n === "success" && m && !this.isInGroup(), I = m && n === "success", k = an(m) && (e = m.src) !== null && e !== void 0 ? e : t, P = an(m) && T ? Object.assign(Object.assign({}, Ht(m, ["className", "style", "previewCls", "previewStyle"])), { className: m == null ? void 0 : m.previewCls, style: m == null ? void 0 : m.previewStyle }) : {}; return f.createElement("div", { style: E, className: v, onClick: this.handleClick }, f.createElement("img", Object.assign({ ref: this.imgRef }, O, { src: this.isInGroup() && this.isLazyLoad() ? void 0 : t, "data-src": t, alt: u, style: C, className: F(`${si}-img`, { [`${si}-img-preview`]: I, [`${si}-img-error`]: n === "error", [S]: !!S }), width: o, height: l, crossOrigin: g, onError: this.handleError, onLoad: this.handleLoaded })), n !== "success" && this.renderExtra(), T && f.createElement(Kc, Object.assign({}, P, { src: k, visible: i, onVisibleChange: this.handlePreviewVisibleChange, crossOrigin: st(g) ? P == null ? void 0 : P.crossOrigin : g, setDownloadName: x }))) } }; sl.isSemiImage = !0; sl.contextType = $h; sl.propTypes = { style: c.object, className: c.string, src: c.string, width: c.oneOfType([c.string, c.number]), height: c.oneOfType([c.string, c.number]), alt: c.string, placeholder: c.node, fallback: c.oneOfType([c.string, c.node]), preview: c.oneOfType([c.bool, c.object]), onLoad: c.func, onError: c.func, onClick: c.func, crossOrigin: c.string, imageID: c.number }; sl.defaultProps = { preview: !0 }; class hse extends ve { constructor() { super(...arguments), this.handleVisibleChange = e => { const { visible: t, onVisibleChange: n } = this.getProps(); t in this.getProps() || this.setState({ visible: e }), n && n(e) }, this.handleCurrentIndexChange = e => { const { currentIndex: t, onChange: n } = this.getProps(); t in this.getProps() || this.setState({ currentIndex: e }), n && n(e) } } } var pse = function (r, e) { var t = {}; for (var n in r) Object.prototype.hasOwnProperty.call(r, n) && e.indexOf(n) < 0 && (t[n] = r[n]); if (r != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, n = Object.getOwnPropertySymbols(r); i < n.length; i++)e.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(r, n[i]) && (t[n[i]] = r[n[i]]); return t }; const Aw = il.PREFIX; class aT extends de { get adapter() { return Object.assign({}, super.adapter) } constructor(e) { super(e), this.observerImages = () => { this.previewObserver ? this.previewObserver.disconnect() : this.previewObserver = new IntersectionObserver(n => { n.forEach(i => { var s; const a = (s = i.target.dataset) === null || s === void 0 ? void 0 : s.src; i.isIntersecting && a && (i.target.src = a, i.target.removeAttribute("data-src"), this.previewObserver.unobserve(i.target)) }) }, { root: document.querySelector(`#${this.previewGroupId}`), rootMargin: this.props.lazyLoadMargin }), document.querySelectorAll(`.${Aw}-img`).forEach(n => this.previewObserver.observe(n)) }, this.handleVisibleChange = t => { this.foundation.handleVisibleChange(t) }, this.handleCurrentIndexChange = t => { this.foundation.handleCurrentIndexChange(t) }, this.loopImageIndex = () => { const { children: t } = this.props; let n = 0; const i = [], s = [], a = o => f.Children.map(o, l => { var u; if (l && l.props && l.type && l.type.isSemiImage) { const { src: d, preview: h, alt: g } = l.props; if (h) { const m = an(h) && (u = h.src) !== null && u !== void 0 ? u : d; return i.push(m), s.push(h == null ? void 0 : h.previewTitle), f.cloneElement(l, { imageID: n++ }) } return l } return l && l.props && l.props.children ? f.cloneElement(l, { children: a(l.props.children) }) : l }); return { srcListInChildren: i, newChildren: a(t), titles: s } }, this.state = { currentIndex: e.currentIndex || e.defaultCurrentIndex || 0, visible: e.visible || e.currentDefaultVisible || !1 }, this.foundation = new hse(this.adapter), this.previewGroupId = zi({ prefix: "semi-image-preview-group", length: 4 }), this.previewRef = f.createRef() } componentDidMount() { this.props.lazyLoad && this.observerImages() } componentDidUpdate(e) { if (this.props.lazyLoad) { const t = f.Children.toArray(e.children).map(i => R.isValidElement(i) ? i.key : null), n = f.Children.toArray(this.props.children).map(i => R.isValidElement(i) ? i.key : null); ke(t, n) || this.observerImages() } } static getDerivedStateFromProps(e, t) { const n = {}; return "currentIndex" in e && e.currentIndex !== t.currentIndex && (n.currentIndex = e.currentIndex), "visible" in e && e.visible !== t.visible && (n.visible = e.visible), n } componentWillUnmount() { this.previewObserver && (this.previewObserver.disconnect(), this.previewObserver = null) } render() { const e = this.props, { src: t, className: n, style: i, lazyLoad: s, setDownloadName: a } = e, o = pse(e, ["src", "className", "style", "lazyLoad", "setDownloadName"]), l = Object.assign(Object.assign({}, Ht(o, ["previewCls", "previewStyle"])), { className: o == null ? void 0 : o.previewCls, style: o == null ? void 0 : o.previewStyle }), { currentIndex: u, visible: d } = this.state, { srcListInChildren: h, newChildren: g, titles: m } = this.loopImageIndex(), y = [...Array.isArray(t) ? t : typeof t == "string" ? [t] : [], ...h]; return f.createElement($h.Provider, { value: { isGroup: !0, previewSrc: y, titles: m, currentIndex: u, visible: d, lazyLoad: s, previewObserver: this.previewObserver, setCurrentIndex: this.handleCurrentIndexChange, handleVisibleChange: this.handleVisibleChange, setDownloadName: a } }, f.createElement("div", { id: this.previewGroupId, style: i, className: F(`${Aw}-preview-group`, n) }, g), f.createElement(Kc, Object.assign({}, l, { ref: this.previewRef, src: y, currentIndex: u, visible: d, onVisibleChange: this.handleVisibleChange }))) } } aT.propTypes = { style: c.object, className: c.string, visible: c.bool, src: c.oneOfType([c.string, c.array]), currentIndex: c.number, defaultCurrentIndex: c.number, defaultVisible: c.bool, maskClosable: c.bool, closable: c.bool, zoomStep: c.number, infinite: c.bool, showTooltip: c.bool, closeOnEsc: c.bool, prevTip: c.string, nextTip: c.string, zoomInTip: c.string, zoomOutTip: c.string, downloadTip: c.string, adaptiveTip: c.string, originTip: c.string, lazyLoad: c.bool, lazyLoadMargin: c.string, preLoad: c.bool, preLoadGap: c.number, previewCls: c.string, previewStyle: c.object, disableDownload: c.bool, zIndex: c.number, renderHeader: c.func, renderPreviewMenu: c.func, getPopupContainer: c.func, onVisibleChange: c.func, onChange: c.func, onClose: c.func, onZoomIn: c.func, onZoomOut: c.func, onPrev: c.func, onNext: c.func, onDownload: c.func, onRotateLeft: c.func, onRatioChange: c.func }; aT.defaultProps = { src: [], lazyLoad: !0, lazyLoadMargin: "0px 100px 100px 0px", closable: !0 }; function Wr(r) { return !r || typeof r != "object" ? "" : "position" in r || "type" in r ? Nw(r.position) : "start" in r || "end" in r ? Nw(r) : "line" in r || "column" in r ? qg(r) : "" } function qg(r) { return Fw(r && r.line) + ":" + Fw(r && r.column) } function Nw(r) { return qg(r && r.start) + "-" + qg(r && r.end) } function Fw(r) { return r && typeof r == "number" ? r : 1 } class vt extends Error { constructor(e, t, n) { super(), typeof t == "string" && (n = t, t = void 0); let i = "", s = {}, a = !1; if (t && ("line" in t && "column" in t ? s = { place: t } : "start" in t && "end" in t ? s = { place: t } : "type" in t ? s = { ancestors: [t], place: t.position } : s = { ...t }), typeof e == "string" ? i = e : !s.cause && e && (a = !0, i = e.message, s.cause = e), !s.ruleId && !s.source && typeof n == "string") { const l = n.indexOf(":"); l === -1 ? s.ruleId = n : (s.source = n.slice(0, l), s.ruleId = n.slice(l + 1)) } if (!s.place && s.ancestors && s.ancestors) { const l = s.ancestors[s.ancestors.length - 1]; l && (s.place = l.position) } const o = s.place && "start" in s.place ? s.place.start : s.place; this.ancestors = s.ancestors || void 0, this.cause = s.cause || void 0, this.column = o ? o.column : void 0, this.fatal = void 0, this.file, this.message = i, this.line = o ? o.line : void 0, this.name = Wr(s.place) || "1:1", this.place = s.place || void 0, this.reason = this.message, this.ruleId = s.ruleId || void 0, this.source = s.source || void 0, this.stack = a && s.cause && typeof s.cause.stack == "string" ? s.cause.stack : "", this.actual, this.expected, this.note, this.url } } vt.prototype.file = ""; vt.prototype.name = ""; vt.prototype.reason = ""; vt.prototype.message = ""; vt.prototype.stack = ""; vt.prototype.column = void 0; vt.prototype.line = void 0; vt.prototype.ancestors = void 0; vt.prototype.cause = void 0; vt.prototype.fatal = void 0; vt.prototype.place = void 0; vt.prototype.ruleId = void 0; vt.prototype.source = void 0; const ki = { basename: fse, dirname: gse, extname: mse, join: yse, sep: "/" }; function fse(r, e) { if (e !== void 0 && typeof e != "string") throw new TypeError('"ext" argument must be a string'); Uc(r); let t = 0, n = -1, i = r.length, s; if (e === void 0 || e.length === 0 || e.length > r.length) { for (; i--;)if (r.codePointAt(i) === 47) { if (s) { t = i + 1; break } } else n < 0 && (s = !0, n = i + 1); return n < 0 ? "" : r.slice(t, n) } if (e === r) return ""; let a = -1, o = e.length - 1; for (; i--;)if (r.codePointAt(i) === 47) { if (s) { t = i + 1; break } } else a < 0 && (s = !0, a = i + 1), o > -1 && (r.codePointAt(i) === e.codePointAt(o--) ? o < 0 && (n = i) : (o = -1, n = a)); return t === n ? n = a : n < 0 && (n = r.length), r.slice(t, n) } function gse(r) { if (Uc(r), r.length === 0) return "."; let e = -1, t = r.length, n; for (; --t;)if (r.codePointAt(t) === 47) { if (n) { e = t; break } } else n || (n = !0); return e < 0 ? r.codePointAt(0) === 47 ? "/" : "." : e === 1 && r.codePointAt(0) === 47 ? "//" : r.slice(0, e) } function mse(r) { Uc(r); let e = r.length, t = -1, n = 0, i = -1, s = 0, a; for (; e--;) { const o = r.codePointAt(e); if (o === 47) { if (a) { n = e + 1; break } continue } t < 0 && (a = !0, t = e + 1), o === 46 ? i < 0 ? i = e : s !== 1 && (s = 1) : i > -1 && (s = -1) } return i < 0 || t < 0 || s === 0 || s === 1 && i === t - 1 && i === n + 1 ? "" : r.slice(i, t) } function yse(...r) { let e = -1, t; for (; ++e < r.length;)Uc(r[e]), r[e] && (t = t === void 0 ? r[e] : t + "/" + r[e]); return t === void 0 ? "." : bse(t) } function bse(r) { Uc(r); const e = r.codePointAt(0) === 47; let t = vse(r, !e); return t.length === 0 && !e && (t = "."), t.length > 0 && r.codePointAt(r.length - 1) === 47 && (t += "/"), e ? "/" + t : t } function vse(r, e) { let t = "", n = 0, i = -1, s = 0, a = -1, o, l; for (; ++a <= r.length;) { if (a < r.length) o = r.codePointAt(a); else { if (o === 47) break; o = 47 } if (o === 47) { if (!(i === a - 1 || s === 1)) if (i !== a - 1 && s === 2) { if (t.length < 2 || n !== 2 || t.codePointAt(t.length - 1) !== 46 || t.codePointAt(t.length - 2) !== 46) { if (t.length > 2) { if (l = t.lastIndexOf("/"), l !== t.length - 1) { l < 0 ? (t = "", n = 0) : (t = t.slice(0, l), n = t.length - 1 - t.lastIndexOf("/")), i = a, s = 0; continue } } else if (t.length > 0) { t = "", n = 0, i = a, s = 0; continue } } e && (t = t.length > 0 ? t + "/.." : "..", n = 2) } else t.length > 0 ? t += "/" + r.slice(i + 1, a) : t = r.slice(i + 1, a), n = a - i - 1; i = a, s = 0 } else o === 46 && s > -1 ? s++ : s = -1 } return t } function Uc(r) { if (typeof r != "string") throw new TypeError("Path must be a string. Received " + JSON.stringify(r)) } const xse = { cwd: wse }; function wse() { return "/" } function Zg(r) { return !!(r !== null && typeof r == "object" && "href" in r && r.href && "protocol" in r && r.protocol && r.auth === void 0) } function Cse(r) { if (typeof r == "string") r = new URL(r); else if (!Zg(r)) { const e = new TypeError('The "path" argument must be of type string or an instance of URL. Received `' + r + "`"); throw e.code = "ERR_INVALID_ARG_TYPE", e } if (r.protocol !== "file:") { const e = new TypeError("The URL must be of scheme file"); throw e.code = "ERR_INVALID_URL_SCHEME", e } return Sse(r) } function Sse(r) { if (r.hostname !== "") { const n = new TypeError('File URL host must be "localhost" or empty on darwin'); throw n.code = "ERR_INVALID_FILE_URL_HOST", n } const e = r.pathname; let t = -1; for (; ++t < e.length;)if (e.codePointAt(t) === 37 && e.codePointAt(t + 1) === 50) { const n = e.codePointAt(t + 2); if (n === 70 || n === 102) { const i = new TypeError("File URL path must not include encoded / characters"); throw i.code = "ERR_INVALID_FILE_URL_PATH", i } } return decodeURIComponent(e) } const Wp = ["history", "path", "basename", "stem", "extname", "dirname"]; class oT { constructor(e) { let t; e ? Zg(e) ? t = { path: e } : typeof e == "string" || Ese(e) ? t = { value: e } : t = e : t = {}, this.cwd = "cwd" in t ? "" : xse.cwd(), this.data = {}, this.history = [], this.messages = [], this.value, this.map, this.result, this.stored; let n = -1; for (; ++n < Wp.length;) { const s = Wp[n]; s in t && t[s] !== void 0 && t[s] !== null && (this[s] = s === "history" ? [...t[s]] : t[s]) } let i; for (i in t) Wp.includes(i) || (this[i] = t[i]) } get basename() { return typeof this.path == "string" ? ki.basename(this.path) : void 0 } set basename(e) { Yp(e, "basename"), Gp(e, "basename"), this.path = ki.join(this.dirname || "", e) } get dirname() { return typeof this.path == "string" ? ki.dirname(this.path) : void 0 } set dirname(e) { $w(this.basename, "dirname"), this.path = ki.join(e || "", this.basename) } get extname() { return typeof this.path == "string" ? ki.extname(this.path) : void 0 } set extname(e) { if (Gp(e, "extname"), $w(this.dirname, "extname"), e) { if (e.codePointAt(0) !== 46) throw new Error("`extname` must start with `.`"); if (e.includes(".", 1)) throw new Error("`extname` cannot contain multiple dots") } this.path = ki.join(this.dirname, this.stem + (e || "")) } get path() { return this.history[this.history.length - 1] } set path(e) { Zg(e) && (e = Cse(e)), Yp(e, "path"), this.path !== e && this.history.push(e) } get stem() { return typeof this.path == "string" ? ki.basename(this.path, this.extname) : void 0 } set stem(e) { Yp(e, "stem"), Gp(e, "stem"), this.path = ki.join(this.dirname || "", e + (this.extname || "")) } fail(e, t, n) { const i = this.message(e, t, n); throw i.fatal = !0, i } info(e, t, n) { const i = this.message(e, t, n); return i.fatal = void 0, i } message(e, t, n) { const i = new vt(e, t, n); return this.path && (i.name = this.path + ":" + i.name, i.file = this.path), i.fatal = !1, this.messages.push(i), i } toString(e) { return this.value === void 0 ? "" : typeof this.value == "string" ? this.value : new TextDecoder(e || void 0).decode(this.value) } } function Gp(r, e) { if (r && r.includes(ki.sep)) throw new Error("`" + e + "` cannot be a path: did not expect `" + ki.sep + "`") } function Yp(r, e) { if (!r) throw new Error("`" + e + "` cannot be empty") } function $w(r, e) { if (!r) throw new Error("Setting `" + e + "` requires `path` to be set too") } function Ese(r) { return !!(r && typeof r == "object" && "byteLength" in r && "byteOffset" in r) } const _se = ["md", "markdown", "mdown", "mkdn", "mkd", "mdwn", "mkdown", "ron"], Ose = _se.map(function (r) { return "." + r }); function lT(r, e) { const t = Tse(r) ? r : new oT(r), { format: n, ...i } = e || {}; return { file: t, options: { format: n === "md" || n === "mdx" ? n : t.extname && (i.mdExtensions || Ose).includes(t.extname) ? "md" : "mdx", ...i } } } function Tse(r) { return !!(r && typeof r == "object" && "message" in r && "messages" in r) } const Ise = /[$_\p{ID_Start}]/u, Pse = /[$_\u{200C}\u{200D}\p{ID_Continue}]/u, kse = /[-$_\u{200C}\u{200D}\p{ID_Continue}]/u, Rse = /^[$_\p{ID_Start}][$_\u{200C}\u{200D}\p{ID_Continue}]*$/u, Dse = /^[$_\p{ID_Start}][-$_\u{200C}\u{200D}\p{ID_Continue}]*$/u, cT = {}; function ai(r) { return r ? Ise.test(String.fromCodePoint(r)) : !1 } function Sl(r, e) { const n = (e || cT).jsx ? kse : Pse; return r ? n.test(String.fromCodePoint(r)) : !1 } function Bi(r, e) { return ((e || cT).jsx ? Dse : Rse).test(r) } class Ase { constructor() { this.should_skip = !1, this.should_remove = !1, this.replacement = null, this.context = { skip: () => this.should_skip = !0, remove: () => this.should_remove = !0, replace: e => this.replacement = e } } replace(e, t, n, i) { e && t && (n != null ? e[t][n] = i : e[t] = i) } remove(e, t, n) { e && t && (n != null ? e[t].splice(n, 1) : delete e[t]) } } class Nse extends Ase { constructor(e, t) { super(), this.should_skip = !1, this.should_remove = !1, this.replacement = null, this.context = { skip: () => this.should_skip = !0, remove: () => this.should_remove = !0, replace: n => this.replacement = n }, this.enter = e, this.leave = t } visit(e, t, n, i) { if (e) { if (this.enter) { const a = this.should_skip, o = this.should_remove, l = this.replacement; this.should_skip = !1, this.should_remove = !1, this.replacement = null, this.enter.call(this.context, e, t, n, i), this.replacement && (e = this.replacement, this.replace(t, n, i, e)), this.should_remove && this.remove(t, n, i); const u = this.should_skip, d = this.should_remove; if (this.should_skip = a, this.should_remove = o, this.replacement = l, u) return e; if (d) return null } let s; for (s in e) { const a = e[s]; if (a && typeof a == "object") if (Array.isArray(a)) { const o = a; for (let l = 0; l < o.length; l += 1) { const u = o[l]; Lw(u) && (this.visit(u, e, s, l) || l--) } } else Lw(a) && this.visit(a, e, s, null) } if (this.leave) { const a = this.replacement, o = this.should_remove; this.replacement = null, this.should_remove = !1, this.leave.call(this.context, e, t, n, i), this.replacement && (e = this.replacement, this.replace(t, n, i, e)), this.should_remove && this.remove(t, n, i); const l = this.should_remove; if (this.replacement = a, this.should_remove = o, l) return null } } return e } } function Lw(r) { return r !== null && typeof r == "object" && "type" in r && typeof r.type == "string" } function bo(r, { enter: e, leave: t }) { return new Nse(e, t).visit(r, null) } const Xp = /@(jsx|jsxFrag|jsxImportSource|jsxRuntime)\s+(\S+)/g; function Fse(r, e) {
  const t = e; let n = t.runtime === "automatic"; const i = {}, s = {}; bo(r, {
    enter(a) { if (a.type === "Program") { const o = a.comments || []; let l = -1; for (; ++l < o.length;) { Xp.lastIndex = 0; let u = Xp.exec(o[l].value); for (; u;)i[u[1]] = u[2], u = Xp.exec(o[l].value) } if (i.jsxRuntime) if (i.jsxRuntime === "automatic") { if (n = !0, i.jsx) throw new Error("Unexpected `@jsx` pragma w/ automatic runtime"); if (i.jsxFrag) throw new Error("Unexpected `@jsxFrag` pragma w/ automatic runtime") } else if (i.jsxRuntime === "classic") { if (n = !1, i.jsxImportSource) throw new Error("Unexpected `@jsxImportSource` w/ classic runtime") } else throw new Error("Unexpected `jsxRuntime` `" + i.jsxRuntime + "`, expected `automatic` or `classic`") } }, leave(a) {
      if (a.type === "Program") { const y = []; if (s.fragment && y.push({ type: "ImportSpecifier", imported: { type: "Identifier", name: "Fragment" }, local: { type: "Identifier", name: "_Fragment" } }), s.jsx && y.push({ type: "ImportSpecifier", imported: { type: "Identifier", name: "jsx" }, local: { type: "Identifier", name: "_jsx" } }), s.jsxs && y.push({ type: "ImportSpecifier", imported: { type: "Identifier", name: "jsxs" }, local: { type: "Identifier", name: "_jsxs" } }), s.jsxDEV && y.push({ type: "ImportSpecifier", imported: { type: "Identifier", name: "jsxDEV" }, local: { type: "Identifier", name: "_jsxDEV" } }), y.length > 0) { let w = 0; for (; w < a.body.length;) { const x = a.body[w]; if ("directive" in x && x.directive) w++; else break } a.body.splice(w, 0, { type: "ImportDeclaration", specifiers: y, source: { type: "Literal", value: (i.jsxImportSource || t.importSource || "react") + (t.development ? "/jsx-dev-runtime" : "/jsx-runtime") } }) } } if (a.type !== "JSXElement" && a.type !== "JSXFragment") return; const o = []; let l = -1; for (; ++l < a.children.length;) {
        const y = a.children[l]; if (y.type === "JSXExpressionContainer") y.expression.type !== "JSXEmptyExpression" && o.push(y.expression); else if (y.type === "JSXText") {
          const w = y.value.replace(/\t/g, " ").replace(/ *(\r?\n|\r) */g, `
`).replace(/\n+/g, `
`).replace(/\n+$/, "").replace(/^\n+/, "").replace(/\n/g, " "); if (w) { const x = { type: "Literal", value: w }; $l(y, x), o.push(x) }
        } else y.type !== "JSXElement" && y.type !== "JSXFragment" && y.type, o.push(y)
      } let u; const d = []; let h = [], g; if (a.type === "JSXElement") { if (u = vd(a.openingElement.name), u.type === "Identifier" && /^[a-z]/.test(u.name)) { const S = { type: "Literal", value: u.name }; $l(u, S), u = S } let y; const w = a.openingElement.attributes; let x = -1; for (; ++x < w.length;) { const S = w[x]; if (S.type === "JSXSpreadAttribute") S.argument.type === "ObjectExpression" ? d.push(...S.argument.properties) : d.push({ type: "SpreadElement", argument: S.argument }), y = !0; else { const C = $se(S); if (n && C.key.type === "Identifier" && C.key.name === "key") { if (y) throw new Error("Expected `key` to come before any spread expressions"); const O = C.value; O.type !== "AssignmentPattern" && O.type !== "ArrayPattern" && O.type !== "ObjectPattern" && O.type, g = O } else d.push(C) } } } else n ? (s.fragment = !0, u = { type: "Identifier", name: "_Fragment" }) : u = Mw(i.jsxFrag || t.pragmaFrag || "React.Fragment"); n ? o.length > 0 && d.push({ type: "Property", key: { type: "Identifier", name: "children" }, value: o.length > 1 ? { type: "ArrayExpression", elements: o } : o[0], kind: "init", method: !1, shorthand: !1, computed: !1 }) : h = o; let m; if (n) { h.push({ type: "ObjectExpression", properties: d }), g ? h.push(g) : t.development && h.push({ type: "Identifier", name: "undefined" }); const y = o.length > 1; if (t.development) { s.jsxDEV = !0, m = { type: "Identifier", name: "_jsxDEV" }, h.push({ type: "Literal", value: y }); const w = { type: "ObjectExpression", properties: [{ type: "Property", method: !1, shorthand: !1, computed: !1, kind: "init", key: { type: "Identifier", name: "fileName" }, value: { type: "Literal", value: t.filePath || "<source.js>" } }] }; a.loc && w.properties.push({ type: "Property", method: !1, shorthand: !1, computed: !1, kind: "init", key: { type: "Identifier", name: "lineNumber" }, value: { type: "Literal", value: a.loc.start.line } }, { type: "Property", method: !1, shorthand: !1, computed: !1, kind: "init", key: { type: "Identifier", name: "columnNumber" }, value: { type: "Literal", value: a.loc.start.column + 1 } }), h.push(w, { type: "ThisExpression" }) } else y ? (s.jsxs = !0, m = { type: "Identifier", name: "_jsxs" }) : (s.jsx = !0, m = { type: "Identifier", name: "_jsx" }) } else d.length > 0 ? h.unshift({ type: "ObjectExpression", properties: d }) : h.length > 0 && h.unshift({ type: "Literal", value: null }), m = Mw(i.jsx || t.pragma || "React.createElement"); h.unshift(u); const b = { type: "CallExpression", callee: m, arguments: h, optional: !1 }; $l(a, b), this.replace(b)
    }
  })
} function $se(r) { let e; if (r.value) if (r.value.type === "JSXExpressionContainer") { const n = r.value.expression; n.type, e = n } else { const n = r.value; n.type !== "JSXElement" && n.type, e = n, delete e.raw } else e = { type: "Literal", value: !0 }; const t = { type: "Property", key: vd(r.name), value: e, kind: "init", method: !1, shorthand: !1, computed: !1 }; return $l(r, t), t } function vd(r) { let e; if (r.type === "JSXMemberExpression") { const t = vd(r.property); e = { type: "MemberExpression", object: vd(r.object), property: t, computed: t.type === "Literal", optional: !1 } } else r.type === "JSXNamespacedName" ? e = { type: "Literal", value: r.namespace.name + ":" + r.name.name } : e = Bi(r.name) ? { type: "Identifier", name: r.name } : { type: "Literal", value: r.name }; return $l(r, e), e } function Mw(r) { const e = r.split("."); let t = -1, n; for (; ++t < e.length;) { const i = Bi(e[t]) ? { type: "Identifier", name: e[t] } : { type: "Literal", value: e[t] }; n = n ? { type: "MemberExpression", object: n, property: i, computed: !!(t && i.type === "Literal"), optional: !1 } : i } return n } function $l(r, e) { const t = ["start", "end", "loc", "range", "comments"]; let n = -1; for (; ++n < t.length;) { const i = t[n]; i in r && (e[i] = r[i]) } } function Lse(r) { return function (e, t) { Fse(e, { filePath: t.history[0], ...r }) } } var uT = { exports: {} }, Mse = { quot: '"', amp: "&", apos: "'", lt: "<", gt: ">", nbsp: " ", iexcl: "¡", cent: "¢", pound: "£", curren: "¤", yen: "¥", brvbar: "¦", sect: "§", uml: "¨", copy: "©", ordf: "ª", laquo: "«", not: "¬", shy: "­", reg: "®", macr: "¯", deg: "°", plusmn: "±", sup2: "²", sup3: "³", acute: "´", micro: "µ", para: "¶", middot: "·", cedil: "¸", sup1: "¹", ordm: "º", raquo: "»", frac14: "¼", frac12: "½", frac34: "¾", iquest: "¿", Agrave: "À", Aacute: "Á", Acirc: "Â", Atilde: "Ã", Auml: "Ä", Aring: "Å", AElig: "Æ", Ccedil: "Ç", Egrave: "È", Eacute: "É", Ecirc: "Ê", Euml: "Ë", Igrave: "Ì", Iacute: "Í", Icirc: "Î", Iuml: "Ï", ETH: "Ð", Ntilde: "Ñ", Ograve: "Ò", Oacute: "Ó", Ocirc: "Ô", Otilde: "Õ", Ouml: "Ö", times: "×", Oslash: "Ø", Ugrave: "Ù", Uacute: "Ú", Ucirc: "Û", Uuml: "Ü", Yacute: "Ý", THORN: "Þ", szlig: "ß", agrave: "à", aacute: "á", acirc: "â", atilde: "ã", auml: "ä", aring: "å", aelig: "æ", ccedil: "ç", egrave: "è", eacute: "é", ecirc: "ê", euml: "ë", igrave: "ì", iacute: "í", icirc: "î", iuml: "ï", eth: "ð", ntilde: "ñ", ograve: "ò", oacute: "ó", ocirc: "ô", otilde: "õ", ouml: "ö", divide: "÷", oslash: "ø", ugrave: "ù", uacute: "ú", ucirc: "û", uuml: "ü", yacute: "ý", thorn: "þ", yuml: "ÿ", OElig: "Œ", oelig: "œ", Scaron: "Š", scaron: "š", Yuml: "Ÿ", fnof: "ƒ", circ: "ˆ", tilde: "˜", Alpha: "Α", Beta: "Β", Gamma: "Γ", Delta: "Δ", Epsilon: "Ε", Zeta: "Ζ", Eta: "Η", Theta: "Θ", Iota: "Ι", Kappa: "Κ", Lambda: "Λ", Mu: "Μ", Nu: "Ν", Xi: "Ξ", Omicron: "Ο", Pi: "Π", Rho: "Ρ", Sigma: "Σ", Tau: "Τ", Upsilon: "Υ", Phi: "Φ", Chi: "Χ", Psi: "Ψ", Omega: "Ω", alpha: "α", beta: "β", gamma: "γ", delta: "δ", epsilon: "ε", zeta: "ζ", eta: "η", theta: "θ", iota: "ι", kappa: "κ", lambda: "λ", mu: "μ", nu: "ν", xi: "ξ", omicron: "ο", pi: "π", rho: "ρ", sigmaf: "ς", sigma: "σ", tau: "τ", upsilon: "υ", phi: "φ", chi: "χ", psi: "ψ", omega: "ω", thetasym: "ϑ", upsih: "ϒ", piv: "ϖ", ensp: " ", emsp: " ", thinsp: " ", zwnj: "‌", zwj: "‍", lrm: "‎", rlm: "‏", ndash: "–", mdash: "—", lsquo: "‘", rsquo: "’", sbquo: "‚", ldquo: "“", rdquo: "”", bdquo: "„", dagger: "†", Dagger: "‡", bull: "•", hellip: "…", permil: "‰", prime: "′", Prime: "″", lsaquo: "‹", rsaquo: "›", oline: "‾", frasl: "⁄", euro: "€", image: "ℑ", weierp: "℘", real: "ℜ", trade: "™", alefsym: "ℵ", larr: "←", uarr: "↑", rarr: "→", darr: "↓", harr: "↔", crarr: "↵", lArr: "⇐", uArr: "⇑", rArr: "⇒", dArr: "⇓", hArr: "⇔", forall: "∀", part: "∂", exist: "∃", empty: "∅", nabla: "∇", isin: "∈", notin: "∉", ni: "∋", prod: "∏", sum: "∑", minus: "−", lowast: "∗", radic: "√", prop: "∝", infin: "∞", ang: "∠", and: "∧", or: "∨", cap: "∩", cup: "∪", int: "∫", there4: "∴", sim: "∼", cong: "≅", asymp: "≈", ne: "≠", equiv: "≡", le: "≤", ge: "≥", sub: "⊂", sup: "⊃", nsub: "⊄", sube: "⊆", supe: "⊇", oplus: "⊕", otimes: "⊗", perp: "⊥", sdot: "⋅", lceil: "⌈", rceil: "⌉", lfloor: "⌊", rfloor: "⌋", lang: "〈", rang: "〉", loz: "◊", spades: "♠", clubs: "♣", hearts: "♥", diams: "♦" }, gu = { exports: {} }, jw; function Jg() {
  return jw || (jw = 1, function (r, e) {
    (function (t, n) { n(e) })(Qi, function (t) {
      var n = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 7, 9, 32, 4, 318, 1, 80, 3, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 68, 8, 2, 0, 3, 0, 2, 3, 2, 4, 2, 0, 15, 1, 83, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 7, 19, 58, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 343, 9, 54, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 10, 5350, 0, 7, 14, 11465, 27, 2343, 9, 87, 9, 39, 4, 60, 6, 26, 9, 535, 9, 470, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4178, 9, 519, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 245, 1, 2, 9, 726, 6, 110, 6, 6, 9, 4759, 9, 787719, 239], i = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 4, 51, 13, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 39, 27, 10, 22, 251, 41, 7, 1, 17, 2, 60, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 31, 9, 2, 0, 3, 0, 2, 37, 2, 0, 26, 0, 2, 0, 45, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 200, 32, 32, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071, 18, 5, 26, 3994, 6, 582, 6842, 29, 1763, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 433, 44, 212, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 42, 9, 8936, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43, 485, 27, 229, 29, 3, 0, 496, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4153, 7, 221, 3, 5761, 15, 7472, 16, 621, 2467, 541, 1507, 4938, 6, 4191], s = "‌‍·̀-ͯ·҃-֑҇-ׇֽֿׁׂׅׄؐ-ًؚ-٩ٰۖ-ۜ۟-۪ۤۧۨ-ۭ۰-۹ܑܰ-݊ަ-ް߀-߉߫-߽߳ࠖ-࠙ࠛ-ࠣࠥ-ࠧࠩ-࡙࠭-࡛ࢗ-࢟࣊-ࣣ࣡-ःऺ-़ा-ॏ॑-ॗॢॣ०-९ঁ-ঃ়া-ৄেৈো-্ৗৢৣ০-৯৾ਁ-ਃ਼ਾ-ੂੇੈੋ-੍ੑ੦-ੱੵઁ-ઃ઼ા-ૅે-ૉો-્ૢૣ૦-૯ૺ-૿ଁ-ଃ଼ା-ୄେୈୋ-୍୕-ୗୢୣ୦-୯ஂா-ூெ-ைொ-்ௗ௦-௯ఀ-ఄ఼ా-ౄె-ైొ-్ౕౖౢౣ౦-౯ಁ-ಃ಼ಾ-ೄೆ-ೈೊ-್ೕೖೢೣ೦-೯ೳഀ-ഃ഻഼ാ-ൄെ-ൈൊ-്ൗൢൣ൦-൯ඁ-ඃ්ා-ුූෘ-ෟ෦-෯ෲෳัิ-ฺ็-๎๐-๙ັິ-ຼ່-໎໐-໙༘༙༠-༩༹༵༷༾༿ཱ-྄྆྇ྍ-ྗྙ-ྼ࿆ါ-ှ၀-၉ၖ-ၙၞ-ၠၢ-ၤၧ-ၭၱ-ၴႂ-ႍႏ-ႝ፝-፟፩-፱ᜒ-᜕ᜲ-᜴ᝒᝓᝲᝳ឴-៓៝០-៩᠋-᠍᠏-᠙ᢩᤠ-ᤫᤰ-᤻᥆-᥏᧐-᧚ᨗ-ᨛᩕ-ᩞ᩠-᩿᩼-᪉᪐-᪙᪰-᪽ᪿ-ᫎᬀ-ᬄ᬴-᭄᭐-᭙᭫-᭳ᮀ-ᮂᮡ-ᮭ᮰-᮹᯦-᯳ᰤ-᰷᱀-᱉᱐-᱙᳐-᳔᳒-᳨᳭᳴᳷-᳹᷀-᷿‌‍‿⁀⁔⃐-⃥⃜⃡-⃰⳯-⵿⳱ⷠ-〪ⷿ-゙゚〯・꘠-꘩꙯ꙴ-꙽ꚞꚟ꛰꛱ꠂ꠆ꠋꠣ-ꠧ꠬ꢀꢁꢴ-ꣅ꣐-꣙꣠-꣱ꣿ-꤉ꤦ-꤭ꥇ-꥓ꦀ-ꦃ꦳-꧀꧐-꧙ꧥ꧰-꧹ꨩ-ꨶꩃꩌꩍ꩐-꩙ꩻ-ꩽꪰꪲ-ꪴꪷꪸꪾ꪿꫁ꫫ-ꫯꫵ꫶ꯣ-ꯪ꯬꯭꯰-꯹ﬞ︀-️︠-︯︳︴﹍-﹏０-９＿･", a = "ªµºÀ-ÖØ-öø-ˁˆ-ˑˠ-ˤˬˮͰ-ʹͶͷͺ-ͽͿΆΈ-ΊΌΎ-ΡΣ-ϵϷ-ҁҊ-ԯԱ-Ֆՙՠ-ֈא-תׯ-ײؠ-يٮٯٱ-ۓەۥۦۮۯۺ-ۼۿܐܒ-ܯݍ-ޥޱߊ-ߪߴߵߺࠀ-ࠕࠚࠤࠨࡀ-ࡘࡠ-ࡪࡰ-ࢇࢉ-ࢎࢠ-ࣉऄ-हऽॐक़-ॡॱ-ঀঅ-ঌএঐও-নপ-রলশ-হঽৎড়ঢ়য়-ৡৰৱৼਅ-ਊਏਐਓ-ਨਪ-ਰਲਲ਼ਵਸ਼ਸਹਖ਼-ੜਫ਼ੲ-ੴઅ-ઍએ-ઑઓ-નપ-રલળવ-હઽૐૠૡૹଅ-ଌଏଐଓ-ନପ-ରଲଳଵ-ହଽଡ଼ଢ଼ୟ-ୡୱஃஅ-ஊஎ-ஐஒ-கஙசஜஞடணதந-பம-ஹௐఅ-ఌఎ-ఐఒ-నప-హఽౘ-ౚౝౠౡಀಅ-ಌಎ-ಐಒ-ನಪ-ಳವ-ಹಽೝೞೠೡೱೲഄ-ഌഎ-ഐഒ-ഺഽൎൔ-ൖൟ-ൡൺ-ൿඅ-ඖක-නඳ-රලව-ෆก-ะาำเ-ๆກຂຄຆ-ຊຌ-ຣລວ-ະາຳຽເ-ໄໆໜ-ໟༀཀ-ཇཉ-ཬྈ-ྌက-ဪဿၐ-ၕၚ-ၝၡၥၦၮ-ၰၵ-ႁႎႠ-ჅჇჍა-ჺჼ-ቈቊ-ቍቐ-ቖቘቚ-ቝበ-ኈኊ-ኍነ-ኰኲ-ኵኸ-ኾዀዂ-ዅወ-ዖዘ-ጐጒ-ጕጘ-ፚᎀ-ᎏᎠ-Ᏽᏸ-ᏽᐁ-ᙬᙯ-ᙿᚁ-ᚚᚠ-ᛪᛮ-ᛸᜀ-ᜑᜟ-ᜱᝀ-ᝑᝠ-ᝬᝮ-ᝰក-ឳៗៜᠠ-ᡸᢀ-ᢨᢪᢰ-ᣵᤀ-ᤞᥐ-ᥭᥰ-ᥴᦀ-ᦫᦰ-ᧉᨀ-ᨖᨠ-ᩔᪧᬅ-ᬳᭅ-ᭌᮃ-ᮠᮮᮯᮺ-ᯥᰀ-ᰣᱍ-ᱏᱚ-ᱽᲀ-ᲊᲐ-ᲺᲽ-Ჿᳩ-ᳬᳮ-ᳳᳵᳶᳺᴀ-ᶿḀ-ἕἘ-Ἕἠ-ὅὈ-Ὅὐ-ὗὙὛὝὟ-ώᾀ-ᾴᾶ-ᾼιῂ-ῄῆ-ῌῐ-ΐῖ-Ίῠ-Ῥῲ-ῴῶ-ῼⁱⁿₐ-ₜℂℇℊ-ℓℕ℘-ℝℤΩℨK-ℹℼ-ℿⅅ-ⅉⅎⅠ-ↈⰀ-ⳤⳫ-ⳮⳲⳳⴀ-ⴥⴧⴭⴰ-ⵧⵯⶀ-ⶖⶠ-ⶦⶨ-ⶮⶰ-ⶶⶸ-ⶾⷀ-ⷆⷈ-ⷎⷐ-ⷖⷘ-ⷞ々-〇〡-〩〱-〵〸-〼ぁ-ゖ゛-ゟァ-ヺー-ヿㄅ-ㄯㄱ-ㆎㆠ-ㆿㇰ-ㇿ㐀-䶿一-ꒌꓐ-ꓽꔀ-ꘌꘐ-ꘟꘪꘫꙀ-ꙮꙿ-ꚝꚠ-ꛯꜗ-ꜟꜢ-ꞈꞋ-ꟍꟐꟑꟓꟕ-Ƛꟲ-ꠁꠃ-ꠅꠇ-ꠊꠌ-ꠢꡀ-ꡳꢂ-ꢳꣲ-ꣷꣻꣽꣾꤊ-ꤥꤰ-ꥆꥠ-ꥼꦄ-ꦲꧏꧠ-ꧤꧦ-ꧯꧺ-ꧾꨀ-ꨨꩀ-ꩂꩄ-ꩋꩠ-ꩶꩺꩾ-ꪯꪱꪵꪶꪹ-ꪽꫀꫂꫛ-ꫝꫠ-ꫪꫲ-ꫴꬁ-ꬆꬉ-ꬎꬑ-ꬖꬠ-ꬦꬨ-ꬮꬰ-ꭚꭜ-ꭩꭰ-ꯢ가-힣ힰ-ퟆퟋ-ퟻ豈-舘並-龎ﬀ-ﬆﬓ-ﬗיִײַ-ﬨשׁ-זּטּ-לּמּנּסּףּפּצּ-ﮱﯓ-ﴽﵐ-ﶏﶒ-ﷇﷰ-ﷻﹰ-ﹴﹶ-ﻼＡ-Ｚａ-ｚｦ-ﾾￂ-ￇￊ-ￏￒ-ￗￚ-ￜ", o = { 3: "abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile", 5: "class enum extends super const export import", 6: "enum", strict: "implements interface let package private protected public static yield", strictBind: "eval arguments" }, l = "break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this", u = { 5: l, "5module": l + " export import", 6: l + " const class extends export import super" }, d = /^in(stanceof)?$/, h = new RegExp("[" + a + "]"), g = new RegExp("[" + a + s + "]"); function m(p, _) { for (var D = 65536, A = 0; A < _.length; A += 2) { if (D += _[A], D > p) return !1; if (D += _[A + 1], D >= p) return !0 } return !1 } function b(p, _) { return p < 65 ? p === 36 : p < 91 ? !0 : p < 97 ? p === 95 : p < 123 ? !0 : p <= 65535 ? p >= 170 && h.test(String.fromCharCode(p)) : _ === !1 ? !1 : m(p, i) } function y(p, _) { return p < 48 ? p === 36 : p < 58 ? !0 : p < 65 ? !1 : p < 91 ? !0 : p < 97 ? p === 95 : p < 123 ? !0 : p <= 65535 ? p >= 170 && g.test(String.fromCharCode(p)) : _ === !1 ? !1 : m(p, i) || m(p, n) } var w = function (_, D) { D === void 0 && (D = {}), this.label = _, this.keyword = D.keyword, this.beforeExpr = !!D.beforeExpr, this.startsExpr = !!D.startsExpr, this.isLoop = !!D.isLoop, this.isAssign = !!D.isAssign, this.prefix = !!D.prefix, this.postfix = !!D.postfix, this.binop = D.binop || null, this.updateContext = null }; function x(p, _) { return new w(p, { beforeExpr: !0, binop: _ }) } var S = { beforeExpr: !0 }, C = { startsExpr: !0 }, O = {}; function E(p, _) { return _ === void 0 && (_ = {}), _.keyword = p, O[p] = new w(p, _) } var v = { num: new w("num", C), regexp: new w("regexp", C), string: new w("string", C), name: new w("name", C), privateId: new w("privateId", C), eof: new w("eof"), bracketL: new w("[", { beforeExpr: !0, startsExpr: !0 }), bracketR: new w("]"), braceL: new w("{", { beforeExpr: !0, startsExpr: !0 }), braceR: new w("}"), parenL: new w("(", { beforeExpr: !0, startsExpr: !0 }), parenR: new w(")"), comma: new w(",", S), semi: new w(";", S), colon: new w(":", S), dot: new w("."), question: new w("?", S), questionDot: new w("?."), arrow: new w("=>", S), template: new w("template"), invalidTemplate: new w("invalidTemplate"), ellipsis: new w("...", S), backQuote: new w("`", C), dollarBraceL: new w("${", { beforeExpr: !0, startsExpr: !0 }), eq: new w("=", { beforeExpr: !0, isAssign: !0 }), assign: new w("_=", { beforeExpr: !0, isAssign: !0 }), incDec: new w("++/--", { prefix: !0, postfix: !0, startsExpr: !0 }), prefix: new w("!/~", { beforeExpr: !0, prefix: !0, startsExpr: !0 }), logicalOR: x("||", 1), logicalAND: x("&&", 2), bitwiseOR: x("|", 3), bitwiseXOR: x("^", 4), bitwiseAND: x("&", 5), equality: x("==/!=/===/!==", 6), relational: x("</>/<=/>=", 7), bitShift: x("<</>>/>>>", 8), plusMin: new w("+/-", { beforeExpr: !0, binop: 9, prefix: !0, startsExpr: !0 }), modulo: x("%", 10), star: x("*", 10), slash: x("/", 10), starstar: new w("**", { beforeExpr: !0 }), coalesce: x("??", 1), _break: E("break"), _case: E("case", S), _catch: E("catch"), _continue: E("continue"), _debugger: E("debugger"), _default: E("default", S), _do: E("do", { isLoop: !0, beforeExpr: !0 }), _else: E("else", S), _finally: E("finally"), _for: E("for", { isLoop: !0 }), _function: E("function", C), _if: E("if"), _return: E("return", S), _switch: E("switch"), _throw: E("throw", S), _try: E("try"), _var: E("var"), _const: E("const"), _while: E("while", { isLoop: !0 }), _with: E("with"), _new: E("new", { beforeExpr: !0, startsExpr: !0 }), _this: E("this", C), _super: E("super", C), _class: E("class", C), _extends: E("extends", S), _export: E("export"), _import: E("import", C), _null: E("null", C), _true: E("true", C), _false: E("false", C), _in: E("in", { beforeExpr: !0, binop: 7 }), _instanceof: E("instanceof", { beforeExpr: !0, binop: 7 }), _typeof: E("typeof", { beforeExpr: !0, prefix: !0, startsExpr: !0 }), _void: E("void", { beforeExpr: !0, prefix: !0, startsExpr: !0 }), _delete: E("delete", { beforeExpr: !0, prefix: !0, startsExpr: !0 }) }, T = /\r\n?|\n|\u2028|\u2029/, I = new RegExp(T.source, "g"); function k(p) { return p === 10 || p === 13 || p === 8232 || p === 8233 } function P(p, _, D) { D === void 0 && (D = p.length); for (var A = _; A < D; A++) { var V = p.charCodeAt(A); if (k(V)) return A < D - 1 && V === 13 && p.charCodeAt(A + 1) === 10 ? A + 2 : A + 1 } return -1 } var N = /[\u1680\u2000-\u200a\u202f\u205f\u3000\ufeff]/, M = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g, B = Object.prototype, K = B.hasOwnProperty, U = B.toString, W = Object.hasOwn || function (p, _) { return K.call(p, _) }, Z = Array.isArray || function (p) { return U.call(p) === "[object Array]" }, J = Object.create(null); function ee(p) { return J[p] || (J[p] = new RegExp("^(?:" + p.replace(/ /g, "|") + ")$")) } function $(p) { return p <= 65535 ? String.fromCharCode(p) : (p -= 65536, String.fromCharCode((p >> 10) + 55296, (p & 1023) + 56320)) } var pe = /(?:[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/, re = function (_, D) { this.line = _, this.column = D }; re.prototype.offset = function (_) { return new re(this.line, this.column + _) }; var j = function (_, D, A) { this.start = D, this.end = A, _.sourceFile !== null && (this.source = _.sourceFile) }; function ae(p, _) { for (var D = 1, A = 0; ;) { var V = P(p, A, _); if (V < 0) return new re(D, _ - A); ++D, A = V } } var be = { ecmaVersion: null, sourceType: "script", onInsertedSemicolon: null, onTrailingComma: null, allowReserved: null, allowReturnOutsideFunction: !1, allowImportExportEverywhere: !1, allowAwaitOutsideFunction: null, allowSuperOutsideMethod: null, allowHashBang: !1, checkPrivateFields: !0, locations: !1, onToken: null, onComment: null, ranges: !1, program: null, sourceFile: null, directSourceFile: null, preserveParens: !1 }, fe = !1; function Ce(p) {
        var _ = {}; for (var D in be) _[D] = p && W(p, D) ? p[D] : be[D]; if (_.ecmaVersion === "latest" ? _.ecmaVersion = 1e8 : _.ecmaVersion == null ? (!fe && typeof console == "object" && console.warn && (fe = !0, console.warn(`Since Acorn 8.0.0, options.ecmaVersion is required.
Defaulting to 2020, but this will stop working in the future.`)), _.ecmaVersion = 11) : _.ecmaVersion >= 2015 && (_.ecmaVersion -= 2009), _.allowReserved == null && (_.allowReserved = _.ecmaVersion < 5), (!p || p.allowHashBang == null) && (_.allowHashBang = _.ecmaVersion >= 14), Z(_.onToken)) { var A = _.onToken; _.onToken = function (V) { return A.push(V) } } return Z(_.onComment) && (_.onComment = ue(_, _.onComment)), _
      } function ue(p, _) { return function (D, A, V, Y, q, oe) { var ce = { type: D ? "Block" : "Line", value: A, start: V, end: Y }; p.locations && (ce.loc = new j(this, q, oe)), p.ranges && (ce.range = [V, Y]), _.push(ce) } } var te = 1, le = 2, Re = 4, at = 8, yt = 16, ht = 32, Ft = 64, qe = 128, $t = 256, gn = te | le | $t; function Hn(p, _) { return le | (p ? Re : 0) | (_ ? at : 0) } var ot = 0, Ut = 1, Wt = 2, wn = 3, Ze = 4, hr = 5, X = function (_, D, A) {
        this.options = _ = Ce(_), this.sourceFile = _.sourceFile, this.keywords = ee(u[_.ecmaVersion >= 6 ? 6 : _.sourceType === "module" ? "5module" : 5]); var V = ""; _.allowReserved !== !0 && (V = o[_.ecmaVersion >= 6 ? 6 : _.ecmaVersion === 5 ? 5 : 3], _.sourceType === "module" && (V += " await")), this.reservedWords = ee(V); var Y = (V ? V + " " : "") + o.strict; this.reservedWordsStrict = ee(Y), this.reservedWordsStrictBind = ee(Y + " " + o.strictBind), this.input = String(D), this.containsEsc = !1, A ? (this.pos = A, this.lineStart = this.input.lastIndexOf(`
`, A - 1) + 1, this.curLine = this.input.slice(0, this.lineStart).split(T).length) : (this.pos = this.lineStart = 0, this.curLine = 1), this.type = v.eof, this.value = null, this.start = this.end = this.pos, this.startLoc = this.endLoc = this.curPosition(), this.lastTokEndLoc = this.lastTokStartLoc = null, this.lastTokStart = this.lastTokEnd = this.pos, this.context = this.initialContext(), this.exprAllowed = !0, this.inModule = _.sourceType === "module", this.strict = this.inModule || this.strictDirective(this.pos), this.potentialArrowAt = -1, this.potentialArrowInForAwait = !1, this.yieldPos = this.awaitPos = this.awaitIdentPos = 0, this.labels = [], this.undefinedExports = Object.create(null), this.pos === 0 && _.allowHashBang && this.input.slice(0, 2) === "#!" && this.skipLineComment(2), this.scopeStack = [], this.enterScope(te), this.regexpState = null, this.privateNameStack = []
      }, Q = { inFunction: { configurable: !0 }, inGenerator: { configurable: !0 }, inAsync: { configurable: !0 }, canAwait: { configurable: !0 }, allowSuper: { configurable: !0 }, allowDirectSuper: { configurable: !0 }, treatFunctionsAsVar: { configurable: !0 }, allowNewDotTarget: { configurable: !0 }, inClassStaticBlock: { configurable: !0 } }; X.prototype.parse = function () { var _ = this.options.program || this.startNode(); return this.nextToken(), this.parseTopLevel(_) }, Q.inFunction.get = function () { return (this.currentVarScope().flags & le) > 0 }, Q.inGenerator.get = function () { return (this.currentVarScope().flags & at) > 0 && !this.currentVarScope().inClassFieldInit }, Q.inAsync.get = function () { return (this.currentVarScope().flags & Re) > 0 && !this.currentVarScope().inClassFieldInit }, Q.canAwait.get = function () { for (var p = this.scopeStack.length - 1; p >= 0; p--) { var _ = this.scopeStack[p]; if (_.inClassFieldInit || _.flags & $t) return !1; if (_.flags & le) return (_.flags & Re) > 0 } return this.inModule && this.options.ecmaVersion >= 13 || this.options.allowAwaitOutsideFunction }, Q.allowSuper.get = function () { var p = this.currentThisScope(), _ = p.flags, D = p.inClassFieldInit; return (_ & Ft) > 0 || D || this.options.allowSuperOutsideMethod }, Q.allowDirectSuper.get = function () { return (this.currentThisScope().flags & qe) > 0 }, Q.treatFunctionsAsVar.get = function () { return this.treatFunctionsAsVarInScope(this.currentScope()) }, Q.allowNewDotTarget.get = function () { var p = this.currentThisScope(), _ = p.flags, D = p.inClassFieldInit; return (_ & (le | $t)) > 0 || D }, Q.inClassStaticBlock.get = function () { return (this.currentVarScope().flags & $t) > 0 }, X.extend = function () { for (var _ = [], D = arguments.length; D--;)_[D] = arguments[D]; for (var A = this, V = 0; V < _.length; V++)A = _[V](A); return A }, X.parse = function (_, D) { return new this(D, _).parse() }, X.parseExpressionAt = function (_, D, A) { var V = new this(A, _, D); return V.nextToken(), V.parseExpression() }, X.tokenizer = function (_, D) { return new this(D, _) }, Object.defineProperties(X.prototype, Q); var L = X.prototype, Oe = /^(?:'((?:\\[^]|[^'\\])*?)'|"((?:\\[^]|[^"\\])*?)")/; L.strictDirective = function (p) { if (this.options.ecmaVersion < 5) return !1; for (; ;) { M.lastIndex = p, p += M.exec(this.input)[0].length; var _ = Oe.exec(this.input.slice(p)); if (!_) return !1; if ((_[1] || _[2]) === "use strict") { M.lastIndex = p + _[0].length; var D = M.exec(this.input), A = D.index + D[0].length, V = this.input.charAt(A); return V === ";" || V === "}" || T.test(D[0]) && !(/[(`.[+\-/*%<>=,?^&]/.test(V) || V === "!" && this.input.charAt(A + 1) === "=") } p += _[0].length, M.lastIndex = p, p += M.exec(this.input)[0].length, this.input[p] === ";" && p++ } }, L.eat = function (p) { return this.type === p ? (this.next(), !0) : !1 }, L.isContextual = function (p) { return this.type === v.name && this.value === p && !this.containsEsc }, L.eatContextual = function (p) { return this.isContextual(p) ? (this.next(), !0) : !1 }, L.expectContextual = function (p) { this.eatContextual(p) || this.unexpected() }, L.canInsertSemicolon = function () { return this.type === v.eof || this.type === v.braceR || T.test(this.input.slice(this.lastTokEnd, this.start)) }, L.insertSemicolon = function () { if (this.canInsertSemicolon()) return this.options.onInsertedSemicolon && this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc), !0 }, L.semicolon = function () { !this.eat(v.semi) && !this.insertSemicolon() && this.unexpected() }, L.afterTrailingComma = function (p, _) { if (this.type === p) return this.options.onTrailingComma && this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc), _ || this.next(), !0 }, L.expect = function (p) { this.eat(p) || this.unexpected() }, L.unexpected = function (p) { this.raise(p ?? this.start, "Unexpected token") }; var De = function () { this.shorthandAssign = this.trailingComma = this.parenthesizedAssign = this.parenthesizedBind = this.doubleProto = -1 }; L.checkPatternErrors = function (p, _) { if (p) { p.trailingComma > -1 && this.raiseRecoverable(p.trailingComma, "Comma is not permitted after the rest element"); var D = _ ? p.parenthesizedAssign : p.parenthesizedBind; D > -1 && this.raiseRecoverable(D, _ ? "Assigning to rvalue" : "Parenthesized pattern") } }, L.checkExpressionErrors = function (p, _) { if (!p) return !1; var D = p.shorthandAssign, A = p.doubleProto; if (!_) return D >= 0 || A >= 0; D >= 0 && this.raise(D, "Shorthand property assignments are valid only in destructuring patterns"), A >= 0 && this.raiseRecoverable(A, "Redefinition of __proto__ property") }, L.checkYieldAwaitInDefaultParams = function () { this.yieldPos && (!this.awaitPos || this.yieldPos < this.awaitPos) && this.raise(this.yieldPos, "Yield expression cannot be a default value"), this.awaitPos && this.raise(this.awaitPos, "Await expression cannot be a default value") }, L.isSimpleAssignTarget = function (p) { return p.type === "ParenthesizedExpression" ? this.isSimpleAssignTarget(p.expression) : p.type === "Identifier" || p.type === "MemberExpression" }; var ie = X.prototype; ie.parseTopLevel = function (p) { var _ = Object.create(null); for (p.body || (p.body = []); this.type !== v.eof;) { var D = this.parseStatement(null, !0, _); p.body.push(D) } if (this.inModule) for (var A = 0, V = Object.keys(this.undefinedExports); A < V.length; A += 1) { var Y = V[A]; this.raiseRecoverable(this.undefinedExports[Y].start, "Export '" + Y + "' is not defined") } return this.adaptDirectivePrologue(p.body), this.next(), p.sourceType = this.options.sourceType, this.finishNode(p, "Program") }; var un = { kind: "loop" }, Qt = { kind: "switch" }; ie.isLet = function (p) { if (this.options.ecmaVersion < 6 || !this.isContextual("let")) return !1; M.lastIndex = this.pos; var _ = M.exec(this.input), D = this.pos + _[0].length, A = this.input.charCodeAt(D); if (A === 91 || A === 92) return !0; if (p) return !1; if (A === 123 || A > 55295 && A < 56320) return !0; if (b(A, !0)) { for (var V = D + 1; y(A = this.input.charCodeAt(V), !0);)++V; if (A === 92 || A > 55295 && A < 56320) return !0; var Y = this.input.slice(D, V); if (!d.test(Y)) return !0 } return !1 }, ie.isAsyncFunction = function () { if (this.options.ecmaVersion < 8 || !this.isContextual("async")) return !1; M.lastIndex = this.pos; var p = M.exec(this.input), _ = this.pos + p[0].length, D; return !T.test(this.input.slice(this.pos, _)) && this.input.slice(_, _ + 8) === "function" && (_ + 8 === this.input.length || !(y(D = this.input.charCodeAt(_ + 8)) || D > 55295 && D < 56320)) }, ie.parseStatement = function (p, _, D) { var A = this.type, V = this.startNode(), Y; switch (this.isLet(p) && (A = v._var, Y = "let"), A) { case v._break: case v._continue: return this.parseBreakContinueStatement(V, A.keyword); case v._debugger: return this.parseDebuggerStatement(V); case v._do: return this.parseDoStatement(V); case v._for: return this.parseForStatement(V); case v._function: return p && (this.strict || p !== "if" && p !== "label") && this.options.ecmaVersion >= 6 && this.unexpected(), this.parseFunctionStatement(V, !1, !p); case v._class: return p && this.unexpected(), this.parseClass(V, !0); case v._if: return this.parseIfStatement(V); case v._return: return this.parseReturnStatement(V); case v._switch: return this.parseSwitchStatement(V); case v._throw: return this.parseThrowStatement(V); case v._try: return this.parseTryStatement(V); case v._const: case v._var: return Y = Y || this.value, p && Y !== "var" && this.unexpected(), this.parseVarStatement(V, Y); case v._while: return this.parseWhileStatement(V); case v._with: return this.parseWithStatement(V); case v.braceL: return this.parseBlock(!0, V); case v.semi: return this.parseEmptyStatement(V); case v._export: case v._import: if (this.options.ecmaVersion > 10 && A === v._import) { M.lastIndex = this.pos; var q = M.exec(this.input), oe = this.pos + q[0].length, ce = this.input.charCodeAt(oe); if (ce === 40 || ce === 46) return this.parseExpressionStatement(V, this.parseExpression()) } return this.options.allowImportExportEverywhere || (_ || this.raise(this.start, "'import' and 'export' may only appear at the top level"), this.inModule || this.raise(this.start, "'import' and 'export' may appear only with 'sourceType: module'")), A === v._import ? this.parseImport(V) : this.parseExport(V, D); default: if (this.isAsyncFunction()) return p && this.unexpected(), this.next(), this.parseFunctionStatement(V, !0, !p); var Le = this.value, Ne = this.parseExpression(); return A === v.name && Ne.type === "Identifier" && this.eat(v.colon) ? this.parseLabeledStatement(V, Le, Ne, p) : this.parseExpressionStatement(V, Ne) } }, ie.parseBreakContinueStatement = function (p, _) { var D = _ === "break"; this.next(), this.eat(v.semi) || this.insertSemicolon() ? p.label = null : this.type !== v.name ? this.unexpected() : (p.label = this.parseIdent(), this.semicolon()); for (var A = 0; A < this.labels.length; ++A) { var V = this.labels[A]; if ((p.label == null || V.name === p.label.name) && (V.kind != null && (D || V.kind === "loop") || p.label && D)) break } return A === this.labels.length && this.raise(p.start, "Unsyntactic " + _), this.finishNode(p, D ? "BreakStatement" : "ContinueStatement") }, ie.parseDebuggerStatement = function (p) { return this.next(), this.semicolon(), this.finishNode(p, "DebuggerStatement") }, ie.parseDoStatement = function (p) { return this.next(), this.labels.push(un), p.body = this.parseStatement("do"), this.labels.pop(), this.expect(v._while), p.test = this.parseParenExpression(), this.options.ecmaVersion >= 6 ? this.eat(v.semi) : this.semicolon(), this.finishNode(p, "DoWhileStatement") }, ie.parseForStatement = function (p) { this.next(); var _ = this.options.ecmaVersion >= 9 && this.canAwait && this.eatContextual("await") ? this.lastTokStart : -1; if (this.labels.push(un), this.enterScope(0), this.expect(v.parenL), this.type === v.semi) return _ > -1 && this.unexpected(_), this.parseFor(p, null); var D = this.isLet(); if (this.type === v._var || this.type === v._const || D) { var A = this.startNode(), V = D ? "let" : this.value; return this.next(), this.parseVar(A, !0, V), this.finishNode(A, "VariableDeclaration"), (this.type === v._in || this.options.ecmaVersion >= 6 && this.isContextual("of")) && A.declarations.length === 1 ? (this.options.ecmaVersion >= 9 && (this.type === v._in ? _ > -1 && this.unexpected(_) : p.await = _ > -1), this.parseForIn(p, A)) : (_ > -1 && this.unexpected(_), this.parseFor(p, A)) } var Y = this.isContextual("let"), q = !1, oe = this.containsEsc, ce = new De, Le = this.start, Ne = _ > -1 ? this.parseExprSubscripts(ce, "await") : this.parseExpression(!0, ce); return this.type === v._in || (q = this.options.ecmaVersion >= 6 && this.isContextual("of")) ? (_ > -1 ? (this.type === v._in && this.unexpected(_), p.await = !0) : q && this.options.ecmaVersion >= 8 && (Ne.start === Le && !oe && Ne.type === "Identifier" && Ne.name === "async" ? this.unexpected() : this.options.ecmaVersion >= 9 && (p.await = !1)), Y && q && this.raise(Ne.start, "The left-hand side of a for-of loop may not start with 'let'."), this.toAssignable(Ne, !1, ce), this.checkLValPattern(Ne), this.parseForIn(p, Ne)) : (this.checkExpressionErrors(ce, !0), _ > -1 && this.unexpected(_), this.parseFor(p, Ne)) }, ie.parseFunctionStatement = function (p, _, D) { return this.next(), this.parseFunction(p, Et | (D ? 0 : _t), !1, _) }, ie.parseIfStatement = function (p) { return this.next(), p.test = this.parseParenExpression(), p.consequent = this.parseStatement("if"), p.alternate = this.eat(v._else) ? this.parseStatement("if") : null, this.finishNode(p, "IfStatement") }, ie.parseReturnStatement = function (p) { return !this.inFunction && !this.options.allowReturnOutsideFunction && this.raise(this.start, "'return' outside of function"), this.next(), this.eat(v.semi) || this.insertSemicolon() ? p.argument = null : (p.argument = this.parseExpression(), this.semicolon()), this.finishNode(p, "ReturnStatement") }, ie.parseSwitchStatement = function (p) { this.next(), p.discriminant = this.parseParenExpression(), p.cases = [], this.expect(v.braceL), this.labels.push(Qt), this.enterScope(0); for (var _, D = !1; this.type !== v.braceR;)if (this.type === v._case || this.type === v._default) { var A = this.type === v._case; _ && this.finishNode(_, "SwitchCase"), p.cases.push(_ = this.startNode()), _.consequent = [], this.next(), A ? _.test = this.parseExpression() : (D && this.raiseRecoverable(this.lastTokStart, "Multiple default clauses"), D = !0, _.test = null), this.expect(v.colon) } else _ || this.unexpected(), _.consequent.push(this.parseStatement(null)); return this.exitScope(), _ && this.finishNode(_, "SwitchCase"), this.next(), this.labels.pop(), this.finishNode(p, "SwitchStatement") }, ie.parseThrowStatement = function (p) { return this.next(), T.test(this.input.slice(this.lastTokEnd, this.start)) && this.raise(this.lastTokEnd, "Illegal newline after throw"), p.argument = this.parseExpression(), this.semicolon(), this.finishNode(p, "ThrowStatement") }; var jn = []; ie.parseCatchClauseParam = function () { var p = this.parseBindingAtom(), _ = p.type === "Identifier"; return this.enterScope(_ ? ht : 0), this.checkLValPattern(p, _ ? Ze : Wt), this.expect(v.parenR), p }, ie.parseTryStatement = function (p) { if (this.next(), p.block = this.parseBlock(), p.handler = null, this.type === v._catch) { var _ = this.startNode(); this.next(), this.eat(v.parenL) ? _.param = this.parseCatchClauseParam() : (this.options.ecmaVersion < 10 && this.unexpected(), _.param = null, this.enterScope(0)), _.body = this.parseBlock(!1), this.exitScope(), p.handler = this.finishNode(_, "CatchClause") } return p.finalizer = this.eat(v._finally) ? this.parseBlock() : null, !p.handler && !p.finalizer && this.raise(p.start, "Missing catch or finally clause"), this.finishNode(p, "TryStatement") }, ie.parseVarStatement = function (p, _, D) { return this.next(), this.parseVar(p, !1, _, D), this.semicolon(), this.finishNode(p, "VariableDeclaration") }, ie.parseWhileStatement = function (p) { return this.next(), p.test = this.parseParenExpression(), this.labels.push(un), p.body = this.parseStatement("while"), this.labels.pop(), this.finishNode(p, "WhileStatement") }, ie.parseWithStatement = function (p) { return this.strict && this.raise(this.start, "'with' in strict mode"), this.next(), p.object = this.parseParenExpression(), p.body = this.parseStatement("with"), this.finishNode(p, "WithStatement") }, ie.parseEmptyStatement = function (p) { return this.next(), this.finishNode(p, "EmptyStatement") }, ie.parseLabeledStatement = function (p, _, D, A) { for (var V = 0, Y = this.labels; V < Y.length; V += 1) { var q = Y[V]; q.name === _ && this.raise(D.start, "Label '" + _ + "' is already declared") } for (var oe = this.type.isLoop ? "loop" : this.type === v._switch ? "switch" : null, ce = this.labels.length - 1; ce >= 0; ce--) { var Le = this.labels[ce]; if (Le.statementStart === p.start) Le.statementStart = this.start, Le.kind = oe; else break } return this.labels.push({ name: _, kind: oe, statementStart: this.start }), p.body = this.parseStatement(A ? A.indexOf("label") === -1 ? A + "label" : A : "label"), this.labels.pop(), p.label = D, this.finishNode(p, "LabeledStatement") }, ie.parseExpressionStatement = function (p, _) { return p.expression = _, this.semicolon(), this.finishNode(p, "ExpressionStatement") }, ie.parseBlock = function (p, _, D) { for (p === void 0 && (p = !0), _ === void 0 && (_ = this.startNode()), _.body = [], this.expect(v.braceL), p && this.enterScope(0); this.type !== v.braceR;) { var A = this.parseStatement(null); _.body.push(A) } return D && (this.strict = !1), this.next(), p && this.exitScope(), this.finishNode(_, "BlockStatement") }, ie.parseFor = function (p, _) { return p.init = _, this.expect(v.semi), p.test = this.type === v.semi ? null : this.parseExpression(), this.expect(v.semi), p.update = this.type === v.parenR ? null : this.parseExpression(), this.expect(v.parenR), p.body = this.parseStatement("for"), this.exitScope(), this.labels.pop(), this.finishNode(p, "ForStatement") }, ie.parseForIn = function (p, _) { var D = this.type === v._in; return this.next(), _.type === "VariableDeclaration" && _.declarations[0].init != null && (!D || this.options.ecmaVersion < 8 || this.strict || _.kind !== "var" || _.declarations[0].id.type !== "Identifier") && this.raise(_.start, (D ? "for-in" : "for-of") + " loop variable declaration may not have an initializer"), p.left = _, p.right = D ? this.parseExpression() : this.parseMaybeAssign(), this.expect(v.parenR), p.body = this.parseStatement("for"), this.exitScope(), this.labels.pop(), this.finishNode(p, D ? "ForInStatement" : "ForOfStatement") }, ie.parseVar = function (p, _, D, A) { for (p.declarations = [], p.kind = D; ;) { var V = this.startNode(); if (this.parseVarId(V, D), this.eat(v.eq) ? V.init = this.parseMaybeAssign(_) : !A && D === "const" && !(this.type === v._in || this.options.ecmaVersion >= 6 && this.isContextual("of")) ? this.unexpected() : !A && V.id.type !== "Identifier" && !(_ && (this.type === v._in || this.isContextual("of"))) ? this.raise(this.lastTokEnd, "Complex binding patterns require an initialization value") : V.init = null, p.declarations.push(this.finishNode(V, "VariableDeclarator")), !this.eat(v.comma)) break } return p }, ie.parseVarId = function (p, _) { p.id = this.parseBindingAtom(), this.checkLValPattern(p.id, _ === "var" ? Ut : Wt, !1) }; var Et = 1, _t = 2, Nn = 4; ie.parseFunction = function (p, _, D, A, V) { this.initFunction(p), (this.options.ecmaVersion >= 9 || this.options.ecmaVersion >= 6 && !A) && (this.type === v.star && _ & _t && this.unexpected(), p.generator = this.eat(v.star)), this.options.ecmaVersion >= 8 && (p.async = !!A), _ & Et && (p.id = _ & Nn && this.type !== v.name ? null : this.parseIdent(), p.id && !(_ & _t) && this.checkLValSimple(p.id, this.strict || p.generator || p.async ? this.treatFunctionsAsVar ? Ut : Wt : wn)); var Y = this.yieldPos, q = this.awaitPos, oe = this.awaitIdentPos; return this.yieldPos = 0, this.awaitPos = 0, this.awaitIdentPos = 0, this.enterScope(Hn(p.async, p.generator)), _ & Et || (p.id = this.type === v.name ? this.parseIdent() : null), this.parseFunctionParams(p), this.parseFunctionBody(p, D, !1, V), this.yieldPos = Y, this.awaitPos = q, this.awaitIdentPos = oe, this.finishNode(p, _ & Et ? "FunctionDeclaration" : "FunctionExpression") }, ie.parseFunctionParams = function (p) { this.expect(v.parenL), p.params = this.parseBindingList(v.parenR, !1, this.options.ecmaVersion >= 8), this.checkYieldAwaitInDefaultParams() }, ie.parseClass = function (p, _) { this.next(); var D = this.strict; this.strict = !0, this.parseClassId(p, _), this.parseClassSuper(p); var A = this.enterClassBody(), V = this.startNode(), Y = !1; for (V.body = [], this.expect(v.braceL); this.type !== v.braceR;) { var q = this.parseClassElement(p.superClass !== null); q && (V.body.push(q), q.type === "MethodDefinition" && q.kind === "constructor" ? (Y && this.raiseRecoverable(q.start, "Duplicate constructor in the same class"), Y = !0) : q.key && q.key.type === "PrivateIdentifier" && Cn(A, q) && this.raiseRecoverable(q.key.start, "Identifier '#" + q.key.name + "' has already been declared")) } return this.strict = D, this.next(), p.body = this.finishNode(V, "ClassBody"), this.exitClassBody(), this.finishNode(p, _ ? "ClassDeclaration" : "ClassExpression") }, ie.parseClassElement = function (p) { if (this.eat(v.semi)) return null; var _ = this.options.ecmaVersion, D = this.startNode(), A = "", V = !1, Y = !1, q = "method", oe = !1; if (this.eatContextual("static")) { if (_ >= 13 && this.eat(v.braceL)) return this.parseClassStaticBlock(D), D; this.isClassElementNameStart() || this.type === v.star ? oe = !0 : A = "static" } if (D.static = oe, !A && _ >= 8 && this.eatContextual("async") && ((this.isClassElementNameStart() || this.type === v.star) && !this.canInsertSemicolon() ? Y = !0 : A = "async"), !A && (_ >= 9 || !Y) && this.eat(v.star) && (V = !0), !A && !Y && !V) { var ce = this.value; (this.eatContextual("get") || this.eatContextual("set")) && (this.isClassElementNameStart() ? q = ce : A = ce) } if (A ? (D.computed = !1, D.key = this.startNodeAt(this.lastTokStart, this.lastTokStartLoc), D.key.name = A, this.finishNode(D.key, "Identifier")) : this.parseClassElementName(D), _ < 13 || this.type === v.parenL || q !== "method" || V || Y) { var Le = !D.static && Ar(D, "constructor"), Ne = Le && p; Le && q !== "method" && this.raise(D.key.start, "Constructor can't have get/set modifier"), D.kind = Le ? "constructor" : q, this.parseClassMethod(D, V, Y, Ne) } else this.parseClassField(D); return D }, ie.isClassElementNameStart = function () { return this.type === v.name || this.type === v.privateId || this.type === v.num || this.type === v.string || this.type === v.bracketL || this.type.keyword }, ie.parseClassElementName = function (p) { this.type === v.privateId ? (this.value === "constructor" && this.raise(this.start, "Classes can't have an element named '#constructor'"), p.computed = !1, p.key = this.parsePrivateIdent()) : this.parsePropertyName(p) }, ie.parseClassMethod = function (p, _, D, A) { var V = p.key; p.kind === "constructor" ? (_ && this.raise(V.start, "Constructor can't be a generator"), D && this.raise(V.start, "Constructor can't be an async method")) : p.static && Ar(p, "prototype") && this.raise(V.start, "Classes may not have a static property named prototype"); var Y = p.value = this.parseMethod(_, D, A); return p.kind === "get" && Y.params.length !== 0 && this.raiseRecoverable(Y.start, "getter should have no params"), p.kind === "set" && Y.params.length !== 1 && this.raiseRecoverable(Y.start, "setter should have exactly one param"), p.kind === "set" && Y.params[0].type === "RestElement" && this.raiseRecoverable(Y.params[0].start, "Setter cannot use rest params"), this.finishNode(p, "MethodDefinition") }, ie.parseClassField = function (p) { if (Ar(p, "constructor") ? this.raise(p.key.start, "Classes can't have a field named 'constructor'") : p.static && Ar(p, "prototype") && this.raise(p.key.start, "Classes can't have a static field named 'prototype'"), this.eat(v.eq)) { var _ = this.currentThisScope(), D = _.inClassFieldInit; _.inClassFieldInit = !0, p.value = this.parseMaybeAssign(), _.inClassFieldInit = D } else p.value = null; return this.semicolon(), this.finishNode(p, "PropertyDefinition") }, ie.parseClassStaticBlock = function (p) { p.body = []; var _ = this.labels; for (this.labels = [], this.enterScope($t | Ft); this.type !== v.braceR;) { var D = this.parseStatement(null); p.body.push(D) } return this.next(), this.exitScope(), this.labels = _, this.finishNode(p, "StaticBlock") }, ie.parseClassId = function (p, _) { this.type === v.name ? (p.id = this.parseIdent(), _ && this.checkLValSimple(p.id, Wt, !1)) : (_ === !0 && this.unexpected(), p.id = null) }, ie.parseClassSuper = function (p) { p.superClass = this.eat(v._extends) ? this.parseExprSubscripts(null, !1) : null }, ie.enterClassBody = function () { var p = { declared: Object.create(null), used: [] }; return this.privateNameStack.push(p), p.declared }, ie.exitClassBody = function () { var p = this.privateNameStack.pop(), _ = p.declared, D = p.used; if (this.options.checkPrivateFields) for (var A = this.privateNameStack.length, V = A === 0 ? null : this.privateNameStack[A - 1], Y = 0; Y < D.length; ++Y) { var q = D[Y]; W(_, q.name) || (V ? V.used.push(q) : this.raiseRecoverable(q.start, "Private field '#" + q.name + "' must be declared in an enclosing class")) } }; function Cn(p, _) { var D = _.key.name, A = p[D], V = "true"; return _.type === "MethodDefinition" && (_.kind === "get" || _.kind === "set") && (V = (_.static ? "s" : "i") + _.kind), A === "iget" && V === "iset" || A === "iset" && V === "iget" || A === "sget" && V === "sset" || A === "sset" && V === "sget" ? (p[D] = "true", !1) : A ? !0 : (p[D] = V, !1) } function Ar(p, _) { var D = p.computed, A = p.key; return !D && (A.type === "Identifier" && A.name === _ || A.type === "Literal" && A.value === _) } ie.parseExportAllDeclaration = function (p, _) { return this.options.ecmaVersion >= 11 && (this.eatContextual("as") ? (p.exported = this.parseModuleExportName(), this.checkExport(_, p.exported, this.lastTokStart)) : p.exported = null), this.expectContextual("from"), this.type !== v.string && this.unexpected(), p.source = this.parseExprAtom(), this.options.ecmaVersion >= 16 && (p.attributes = this.parseWithClause()), this.semicolon(), this.finishNode(p, "ExportAllDeclaration") }, ie.parseExport = function (p, _) { if (this.next(), this.eat(v.star)) return this.parseExportAllDeclaration(p, _); if (this.eat(v._default)) return this.checkExport(_, "default", this.lastTokStart), p.declaration = this.parseExportDefaultDeclaration(), this.finishNode(p, "ExportDefaultDeclaration"); if (this.shouldParseExportStatement()) p.declaration = this.parseExportDeclaration(p), p.declaration.type === "VariableDeclaration" ? this.checkVariableExport(_, p.declaration.declarations) : this.checkExport(_, p.declaration.id, p.declaration.id.start), p.specifiers = [], p.source = null; else { if (p.declaration = null, p.specifiers = this.parseExportSpecifiers(_), this.eatContextual("from")) this.type !== v.string && this.unexpected(), p.source = this.parseExprAtom(), this.options.ecmaVersion >= 16 && (p.attributes = this.parseWithClause()); else { for (var D = 0, A = p.specifiers; D < A.length; D += 1) { var V = A[D]; this.checkUnreserved(V.local), this.checkLocalExport(V.local), V.local.type === "Literal" && this.raise(V.local.start, "A string literal cannot be used as an exported binding without `from`.") } p.source = null } this.semicolon() } return this.finishNode(p, "ExportNamedDeclaration") }, ie.parseExportDeclaration = function (p) { return this.parseStatement(null) }, ie.parseExportDefaultDeclaration = function () { var p; if (this.type === v._function || (p = this.isAsyncFunction())) { var _ = this.startNode(); return this.next(), p && this.next(), this.parseFunction(_, Et | Nn, !1, p) } else if (this.type === v._class) { var D = this.startNode(); return this.parseClass(D, "nullableID") } else { var A = this.parseMaybeAssign(); return this.semicolon(), A } }, ie.checkExport = function (p, _, D) { p && (typeof _ != "string" && (_ = _.type === "Identifier" ? _.name : _.value), W(p, _) && this.raiseRecoverable(D, "Duplicate export '" + _ + "'"), p[_] = !0) }, ie.checkPatternExport = function (p, _) { var D = _.type; if (D === "Identifier") this.checkExport(p, _, _.start); else if (D === "ObjectPattern") for (var A = 0, V = _.properties; A < V.length; A += 1) { var Y = V[A]; this.checkPatternExport(p, Y) } else if (D === "ArrayPattern") for (var q = 0, oe = _.elements; q < oe.length; q += 1) { var ce = oe[q]; ce && this.checkPatternExport(p, ce) } else D === "Property" ? this.checkPatternExport(p, _.value) : D === "AssignmentPattern" ? this.checkPatternExport(p, _.left) : D === "RestElement" && this.checkPatternExport(p, _.argument) }, ie.checkVariableExport = function (p, _) { if (p) for (var D = 0, A = _; D < A.length; D += 1) { var V = A[D]; this.checkPatternExport(p, V.id) } }, ie.shouldParseExportStatement = function () { return this.type.keyword === "var" || this.type.keyword === "const" || this.type.keyword === "class" || this.type.keyword === "function" || this.isLet() || this.isAsyncFunction() }, ie.parseExportSpecifier = function (p) { var _ = this.startNode(); return _.local = this.parseModuleExportName(), _.exported = this.eatContextual("as") ? this.parseModuleExportName() : _.local, this.checkExport(p, _.exported, _.exported.start), this.finishNode(_, "ExportSpecifier") }, ie.parseExportSpecifiers = function (p) { var _ = [], D = !0; for (this.expect(v.braceL); !this.eat(v.braceR);) { if (D) D = !1; else if (this.expect(v.comma), this.afterTrailingComma(v.braceR)) break; _.push(this.parseExportSpecifier(p)) } return _ }, ie.parseImport = function (p) { return this.next(), this.type === v.string ? (p.specifiers = jn, p.source = this.parseExprAtom()) : (p.specifiers = this.parseImportSpecifiers(), this.expectContextual("from"), p.source = this.type === v.string ? this.parseExprAtom() : this.unexpected()), this.options.ecmaVersion >= 16 && (p.attributes = this.parseWithClause()), this.semicolon(), this.finishNode(p, "ImportDeclaration") }, ie.parseImportSpecifier = function () { var p = this.startNode(); return p.imported = this.parseModuleExportName(), this.eatContextual("as") ? p.local = this.parseIdent() : (this.checkUnreserved(p.imported), p.local = p.imported), this.checkLValSimple(p.local, Wt), this.finishNode(p, "ImportSpecifier") }, ie.parseImportDefaultSpecifier = function () { var p = this.startNode(); return p.local = this.parseIdent(), this.checkLValSimple(p.local, Wt), this.finishNode(p, "ImportDefaultSpecifier") }, ie.parseImportNamespaceSpecifier = function () { var p = this.startNode(); return this.next(), this.expectContextual("as"), p.local = this.parseIdent(), this.checkLValSimple(p.local, Wt), this.finishNode(p, "ImportNamespaceSpecifier") }, ie.parseImportSpecifiers = function () { var p = [], _ = !0; if (this.type === v.name && (p.push(this.parseImportDefaultSpecifier()), !this.eat(v.comma))) return p; if (this.type === v.star) return p.push(this.parseImportNamespaceSpecifier()), p; for (this.expect(v.braceL); !this.eat(v.braceR);) { if (_) _ = !1; else if (this.expect(v.comma), this.afterTrailingComma(v.braceR)) break; p.push(this.parseImportSpecifier()) } return p }, ie.parseWithClause = function () { var p = []; if (!this.eat(v._with)) return p; this.expect(v.braceL); for (var _ = {}, D = !0; !this.eat(v.braceR);) { if (D) D = !1; else if (this.expect(v.comma), this.afterTrailingComma(v.braceR)) break; var A = this.parseImportAttribute(), V = A.key.type === "Identifier" ? A.key.name : A.key.value; W(_, V) && this.raiseRecoverable(A.key.start, "Duplicate attribute key '" + V + "'"), _[V] = !0, p.push(A) } return p }, ie.parseImportAttribute = function () { var p = this.startNode(); return p.key = this.type === v.string ? this.parseExprAtom() : this.parseIdent(this.options.allowReserved !== "never"), this.expect(v.colon), this.type !== v.string && this.unexpected(), p.value = this.parseExprAtom(), this.finishNode(p, "ImportAttribute") }, ie.parseModuleExportName = function () { if (this.options.ecmaVersion >= 13 && this.type === v.string) { var p = this.parseLiteral(this.value); return pe.test(p.value) && this.raise(p.start, "An export name cannot include a lone surrogate."), p } return this.parseIdent(!0) }, ie.adaptDirectivePrologue = function (p) { for (var _ = 0; _ < p.length && this.isDirectiveCandidate(p[_]); ++_)p[_].directive = p[_].expression.raw.slice(1, -1) }, ie.isDirectiveCandidate = function (p) { return this.options.ecmaVersion >= 5 && p.type === "ExpressionStatement" && p.expression.type === "Literal" && typeof p.expression.value == "string" && (this.input[p.start] === '"' || this.input[p.start] === "'") }; var en = X.prototype; en.toAssignable = function (p, _, D) { if (this.options.ecmaVersion >= 6 && p) switch (p.type) { case "Identifier": this.inAsync && p.name === "await" && this.raise(p.start, "Cannot use 'await' as identifier inside an async function"); break; case "ObjectPattern": case "ArrayPattern": case "AssignmentPattern": case "RestElement": break; case "ObjectExpression": p.type = "ObjectPattern", D && this.checkPatternErrors(D, !0); for (var A = 0, V = p.properties; A < V.length; A += 1) { var Y = V[A]; this.toAssignable(Y, _), Y.type === "RestElement" && (Y.argument.type === "ArrayPattern" || Y.argument.type === "ObjectPattern") && this.raise(Y.argument.start, "Unexpected token") } break; case "Property": p.kind !== "init" && this.raise(p.key.start, "Object pattern can't contain getter or setter"), this.toAssignable(p.value, _); break; case "ArrayExpression": p.type = "ArrayPattern", D && this.checkPatternErrors(D, !0), this.toAssignableList(p.elements, _); break; case "SpreadElement": p.type = "RestElement", this.toAssignable(p.argument, _), p.argument.type === "AssignmentPattern" && this.raise(p.argument.start, "Rest elements cannot have a default value"); break; case "AssignmentExpression": p.operator !== "=" && this.raise(p.left.end, "Only '=' operator can be used for specifying default value."), p.type = "AssignmentPattern", delete p.operator, this.toAssignable(p.left, _); break; case "ParenthesizedExpression": this.toAssignable(p.expression, _, D); break; case "ChainExpression": this.raiseRecoverable(p.start, "Optional chaining cannot appear in left-hand side"); break; case "MemberExpression": if (!_) break; default: this.raise(p.start, "Assigning to rvalue") } else D && this.checkPatternErrors(D, !0); return p }, en.toAssignableList = function (p, _) { for (var D = p.length, A = 0; A < D; A++) { var V = p[A]; V && this.toAssignable(V, _) } if (D) { var Y = p[D - 1]; this.options.ecmaVersion === 6 && _ && Y && Y.type === "RestElement" && Y.argument.type !== "Identifier" && this.unexpected(Y.argument.start) } return p }, en.parseSpread = function (p) { var _ = this.startNode(); return this.next(), _.argument = this.parseMaybeAssign(!1, p), this.finishNode(_, "SpreadElement") }, en.parseRestBinding = function () { var p = this.startNode(); return this.next(), this.options.ecmaVersion === 6 && this.type !== v.name && this.unexpected(), p.argument = this.parseBindingAtom(), this.finishNode(p, "RestElement") }, en.parseBindingAtom = function () { if (this.options.ecmaVersion >= 6) switch (this.type) { case v.bracketL: var p = this.startNode(); return this.next(), p.elements = this.parseBindingList(v.bracketR, !0, !0), this.finishNode(p, "ArrayPattern"); case v.braceL: return this.parseObj(!0) }return this.parseIdent() }, en.parseBindingList = function (p, _, D, A) { for (var V = [], Y = !0; !this.eat(p);)if (Y ? Y = !1 : this.expect(v.comma), _ && this.type === v.comma) V.push(null); else { if (D && this.afterTrailingComma(p)) break; if (this.type === v.ellipsis) { var q = this.parseRestBinding(); this.parseBindingListItem(q), V.push(q), this.type === v.comma && this.raiseRecoverable(this.start, "Comma is not permitted after the rest element"), this.expect(p); break } else V.push(this.parseAssignableListItem(A)) } return V }, en.parseAssignableListItem = function (p) { var _ = this.parseMaybeDefault(this.start, this.startLoc); return this.parseBindingListItem(_), _ }, en.parseBindingListItem = function (p) { return p }, en.parseMaybeDefault = function (p, _, D) { if (D = D || this.parseBindingAtom(), this.options.ecmaVersion < 6 || !this.eat(v.eq)) return D; var A = this.startNodeAt(p, _); return A.left = D, A.right = this.parseMaybeAssign(), this.finishNode(A, "AssignmentPattern") }, en.checkLValSimple = function (p, _, D) { _ === void 0 && (_ = ot); var A = _ !== ot; switch (p.type) { case "Identifier": this.strict && this.reservedWordsStrictBind.test(p.name) && this.raiseRecoverable(p.start, (A ? "Binding " : "Assigning to ") + p.name + " in strict mode"), A && (_ === Wt && p.name === "let" && this.raiseRecoverable(p.start, "let is disallowed as a lexically bound name"), D && (W(D, p.name) && this.raiseRecoverable(p.start, "Argument name clash"), D[p.name] = !0), _ !== hr && this.declareName(p.name, _, p.start)); break; case "ChainExpression": this.raiseRecoverable(p.start, "Optional chaining cannot appear in left-hand side"); break; case "MemberExpression": A && this.raiseRecoverable(p.start, "Binding member expression"); break; case "ParenthesizedExpression": return A && this.raiseRecoverable(p.start, "Binding parenthesized expression"), this.checkLValSimple(p.expression, _, D); default: this.raise(p.start, (A ? "Binding" : "Assigning to") + " rvalue") } }, en.checkLValPattern = function (p, _, D) { switch (_ === void 0 && (_ = ot), p.type) { case "ObjectPattern": for (var A = 0, V = p.properties; A < V.length; A += 1) { var Y = V[A]; this.checkLValInnerPattern(Y, _, D) } break; case "ArrayPattern": for (var q = 0, oe = p.elements; q < oe.length; q += 1) { var ce = oe[q]; ce && this.checkLValInnerPattern(ce, _, D) } break; default: this.checkLValSimple(p, _, D) } }, en.checkLValInnerPattern = function (p, _, D) { switch (_ === void 0 && (_ = ot), p.type) { case "Property": this.checkLValInnerPattern(p.value, _, D); break; case "AssignmentPattern": this.checkLValPattern(p.left, _, D); break; case "RestElement": this.checkLValPattern(p.argument, _, D); break; default: this.checkLValPattern(p, _, D) } }; var Sn = function (_, D, A, V, Y) { this.token = _, this.isExpr = !!D, this.preserveSpace = !!A, this.override = V, this.generator = !!Y }, Ie = { b_stat: new Sn("{", !1), b_expr: new Sn("{", !0), b_tmpl: new Sn("${", !1), p_stat: new Sn("(", !1), p_expr: new Sn("(", !0), q_tmpl: new Sn("`", !0, !0, function (p) { return p.tryReadTemplateToken() }), f_stat: new Sn("function", !1), f_expr: new Sn("function", !0), f_expr_gen: new Sn("function", !0, !1, null, !0), f_gen: new Sn("function", !1, !1, null, !0) }, Dt = X.prototype; Dt.initialContext = function () { return [Ie.b_stat] }, Dt.curContext = function () { return this.context[this.context.length - 1] }, Dt.braceIsBlock = function (p) { var _ = this.curContext(); return _ === Ie.f_expr || _ === Ie.f_stat ? !0 : p === v.colon && (_ === Ie.b_stat || _ === Ie.b_expr) ? !_.isExpr : p === v._return || p === v.name && this.exprAllowed ? T.test(this.input.slice(this.lastTokEnd, this.start)) : p === v._else || p === v.semi || p === v.eof || p === v.parenR || p === v.arrow ? !0 : p === v.braceL ? _ === Ie.b_stat : p === v._var || p === v._const || p === v.name ? !1 : !this.exprAllowed }, Dt.inGeneratorContext = function () { for (var p = this.context.length - 1; p >= 1; p--) { var _ = this.context[p]; if (_.token === "function") return _.generator } return !1 }, Dt.updateContext = function (p) { var _, D = this.type; D.keyword && p === v.dot ? this.exprAllowed = !1 : (_ = D.updateContext) ? _.call(this, p) : this.exprAllowed = D.beforeExpr }, Dt.overrideContext = function (p) { this.curContext() !== p && (this.context[this.context.length - 1] = p) }, v.parenR.updateContext = v.braceR.updateContext = function () { if (this.context.length === 1) { this.exprAllowed = !0; return } var p = this.context.pop(); p === Ie.b_stat && this.curContext().token === "function" && (p = this.context.pop()), this.exprAllowed = !p.isExpr }, v.braceL.updateContext = function (p) { this.context.push(this.braceIsBlock(p) ? Ie.b_stat : Ie.b_expr), this.exprAllowed = !0 }, v.dollarBraceL.updateContext = function () { this.context.push(Ie.b_tmpl), this.exprAllowed = !0 }, v.parenL.updateContext = function (p) { var _ = p === v._if || p === v._for || p === v._with || p === v._while; this.context.push(_ ? Ie.p_stat : Ie.p_expr), this.exprAllowed = !0 }, v.incDec.updateContext = function () { }, v._function.updateContext = v._class.updateContext = function (p) { p.beforeExpr && p !== v._else && !(p === v.semi && this.curContext() !== Ie.p_stat) && !(p === v._return && T.test(this.input.slice(this.lastTokEnd, this.start))) && !((p === v.colon || p === v.braceL) && this.curContext() === Ie.b_stat) ? this.context.push(Ie.f_expr) : this.context.push(Ie.f_stat), this.exprAllowed = !1 }, v.colon.updateContext = function () { this.curContext().token === "function" && this.context.pop(), this.exprAllowed = !0 }, v.backQuote.updateContext = function () { this.curContext() === Ie.q_tmpl ? this.context.pop() : this.context.push(Ie.q_tmpl), this.exprAllowed = !1 }, v.star.updateContext = function (p) { if (p === v._function) { var _ = this.context.length - 1; this.context[_] === Ie.f_expr ? this.context[_] = Ie.f_expr_gen : this.context[_] = Ie.f_gen } this.exprAllowed = !0 }, v.name.updateContext = function (p) { var _ = !1; this.options.ecmaVersion >= 6 && p !== v.dot && (this.value === "of" && !this.exprAllowed || this.value === "yield" && this.inGeneratorContext()) && (_ = !0), this.exprAllowed = _ }; var me = X.prototype; me.checkPropClash = function (p, _, D) { if (!(this.options.ecmaVersion >= 9 && p.type === "SpreadElement") && !(this.options.ecmaVersion >= 6 && (p.computed || p.method || p.shorthand))) { var A = p.key, V; switch (A.type) { case "Identifier": V = A.name; break; case "Literal": V = String(A.value); break; default: return }var Y = p.kind; if (this.options.ecmaVersion >= 6) { V === "__proto__" && Y === "init" && (_.proto && (D ? D.doubleProto < 0 && (D.doubleProto = A.start) : this.raiseRecoverable(A.start, "Redefinition of __proto__ property")), _.proto = !0); return } V = "$" + V; var q = _[V]; if (q) { var oe; Y === "init" ? oe = this.strict && q.init || q.get || q.set : oe = q.init || q[Y], oe && this.raiseRecoverable(A.start, "Redefinition of property") } else q = _[V] = { init: !1, get: !1, set: !1 }; q[Y] = !0 } }, me.parseExpression = function (p, _) { var D = this.start, A = this.startLoc, V = this.parseMaybeAssign(p, _); if (this.type === v.comma) { var Y = this.startNodeAt(D, A); for (Y.expressions = [V]; this.eat(v.comma);)Y.expressions.push(this.parseMaybeAssign(p, _)); return this.finishNode(Y, "SequenceExpression") } return V }, me.parseMaybeAssign = function (p, _, D) { if (this.isContextual("yield")) { if (this.inGenerator) return this.parseYield(p); this.exprAllowed = !1 } var A = !1, V = -1, Y = -1, q = -1; _ ? (V = _.parenthesizedAssign, Y = _.trailingComma, q = _.doubleProto, _.parenthesizedAssign = _.trailingComma = -1) : (_ = new De, A = !0); var oe = this.start, ce = this.startLoc; (this.type === v.parenL || this.type === v.name) && (this.potentialArrowAt = this.start, this.potentialArrowInForAwait = p === "await"); var Le = this.parseMaybeConditional(p, _); if (D && (Le = D.call(this, Le, oe, ce)), this.type.isAssign) { var Ne = this.startNodeAt(oe, ce); return Ne.operator = this.value, this.type === v.eq && (Le = this.toAssignable(Le, !1, _)), A || (_.parenthesizedAssign = _.trailingComma = _.doubleProto = -1), _.shorthandAssign >= Le.start && (_.shorthandAssign = -1), this.type === v.eq ? this.checkLValPattern(Le) : this.checkLValSimple(Le), Ne.left = Le, this.next(), Ne.right = this.parseMaybeAssign(p), q > -1 && (_.doubleProto = q), this.finishNode(Ne, "AssignmentExpression") } else A && this.checkExpressionErrors(_, !0); return V > -1 && (_.parenthesizedAssign = V), Y > -1 && (_.trailingComma = Y), Le }, me.parseMaybeConditional = function (p, _) { var D = this.start, A = this.startLoc, V = this.parseExprOps(p, _); if (this.checkExpressionErrors(_)) return V; if (this.eat(v.question)) { var Y = this.startNodeAt(D, A); return Y.test = V, Y.consequent = this.parseMaybeAssign(), this.expect(v.colon), Y.alternate = this.parseMaybeAssign(p), this.finishNode(Y, "ConditionalExpression") } return V }, me.parseExprOps = function (p, _) { var D = this.start, A = this.startLoc, V = this.parseMaybeUnary(_, !1, !1, p); return this.checkExpressionErrors(_) || V.start === D && V.type === "ArrowFunctionExpression" ? V : this.parseExprOp(V, D, A, -1, p) }, me.parseExprOp = function (p, _, D, A, V) { var Y = this.type.binop; if (Y != null && (!V || this.type !== v._in) && Y > A) { var q = this.type === v.logicalOR || this.type === v.logicalAND, oe = this.type === v.coalesce; oe && (Y = v.logicalAND.binop); var ce = this.value; this.next(); var Le = this.start, Ne = this.startLoc, In = this.parseExprOp(this.parseMaybeUnary(null, !1, !1, V), Le, Ne, Y, V), Us = this.buildBinary(_, D, p, In, ce, q || oe); return (q && this.type === v.coalesce || oe && (this.type === v.logicalOR || this.type === v.logicalAND)) && this.raiseRecoverable(this.start, "Logical expressions and coalesce expressions cannot be mixed. Wrap either by parentheses"), this.parseExprOp(Us, _, D, A, V) } return p }, me.buildBinary = function (p, _, D, A, V, Y) { A.type === "PrivateIdentifier" && this.raise(A.start, "Private identifier can only be left side of binary expression"); var q = this.startNodeAt(p, _); return q.left = D, q.operator = V, q.right = A, this.finishNode(q, Y ? "LogicalExpression" : "BinaryExpression") }, me.parseMaybeUnary = function (p, _, D, A) { var V = this.start, Y = this.startLoc, q; if (this.isContextual("await") && this.canAwait) q = this.parseAwait(A), _ = !0; else if (this.type.prefix) { var oe = this.startNode(), ce = this.type === v.incDec; oe.operator = this.value, oe.prefix = !0, this.next(), oe.argument = this.parseMaybeUnary(null, !0, ce, A), this.checkExpressionErrors(p, !0), ce ? this.checkLValSimple(oe.argument) : this.strict && oe.operator === "delete" && tn(oe.argument) ? this.raiseRecoverable(oe.start, "Deleting local variable in strict mode") : oe.operator === "delete" && Gt(oe.argument) ? this.raiseRecoverable(oe.start, "Private fields can not be deleted") : _ = !0, q = this.finishNode(oe, ce ? "UpdateExpression" : "UnaryExpression") } else if (!_ && this.type === v.privateId) (A || this.privateNameStack.length === 0) && this.options.checkPrivateFields && this.unexpected(), q = this.parsePrivateIdent(), this.type !== v._in && this.unexpected(); else { if (q = this.parseExprSubscripts(p, A), this.checkExpressionErrors(p)) return q; for (; this.type.postfix && !this.canInsertSemicolon();) { var Le = this.startNodeAt(V, Y); Le.operator = this.value, Le.prefix = !1, Le.argument = q, this.checkLValSimple(q), this.next(), q = this.finishNode(Le, "UpdateExpression") } } if (!D && this.eat(v.starstar)) if (_) this.unexpected(this.lastTokStart); else return this.buildBinary(V, Y, q, this.parseMaybeUnary(null, !1, !1, A), "**", !1); else return q }; function tn(p) { return p.type === "Identifier" || p.type === "ParenthesizedExpression" && tn(p.expression) } function Gt(p) { return p.type === "MemberExpression" && p.property.type === "PrivateIdentifier" || p.type === "ChainExpression" && Gt(p.expression) || p.type === "ParenthesizedExpression" && Gt(p.expression) } me.parseExprSubscripts = function (p, _) { var D = this.start, A = this.startLoc, V = this.parseExprAtom(p, _); if (V.type === "ArrowFunctionExpression" && this.input.slice(this.lastTokStart, this.lastTokEnd) !== ")") return V; var Y = this.parseSubscripts(V, D, A, !1, _); return p && Y.type === "MemberExpression" && (p.parenthesizedAssign >= Y.start && (p.parenthesizedAssign = -1), p.parenthesizedBind >= Y.start && (p.parenthesizedBind = -1), p.trailingComma >= Y.start && (p.trailingComma = -1)), Y }, me.parseSubscripts = function (p, _, D, A, V) { for (var Y = this.options.ecmaVersion >= 8 && p.type === "Identifier" && p.name === "async" && this.lastTokEnd === p.end && !this.canInsertSemicolon() && p.end - p.start === 5 && this.potentialArrowAt === p.start, q = !1; ;) { var oe = this.parseSubscript(p, _, D, A, Y, q, V); if (oe.optional && (q = !0), oe === p || oe.type === "ArrowFunctionExpression") { if (q) { var ce = this.startNodeAt(_, D); ce.expression = oe, oe = this.finishNode(ce, "ChainExpression") } return oe } p = oe } }, me.shouldParseAsyncArrow = function () { return !this.canInsertSemicolon() && this.eat(v.arrow) }, me.parseSubscriptAsyncArrow = function (p, _, D, A) { return this.parseArrowExpression(this.startNodeAt(p, _), D, !0, A) }, me.parseSubscript = function (p, _, D, A, V, Y, q) { var oe = this.options.ecmaVersion >= 11, ce = oe && this.eat(v.questionDot); A && ce && this.raise(this.lastTokStart, "Optional chaining cannot appear in the callee of new expressions"); var Le = this.eat(v.bracketL); if (Le || ce && this.type !== v.parenL && this.type !== v.backQuote || this.eat(v.dot)) { var Ne = this.startNodeAt(_, D); Ne.object = p, Le ? (Ne.property = this.parseExpression(), this.expect(v.bracketR)) : this.type === v.privateId && p.type !== "Super" ? Ne.property = this.parsePrivateIdent() : Ne.property = this.parseIdent(this.options.allowReserved !== "never"), Ne.computed = !!Le, oe && (Ne.optional = ce), p = this.finishNode(Ne, "MemberExpression") } else if (!A && this.eat(v.parenL)) { var In = new De, Us = this.yieldPos, cl = this.awaitPos, Ma = this.awaitIdentPos; this.yieldPos = 0, this.awaitPos = 0, this.awaitIdentPos = 0; var qc = this.parseExprList(v.parenR, this.options.ecmaVersion >= 8, !1, In); if (V && !ce && this.shouldParseAsyncArrow()) return this.checkPatternErrors(In, !1), this.checkYieldAwaitInDefaultParams(), this.awaitIdentPos > 0 && this.raise(this.awaitIdentPos, "Cannot use 'await' as identifier inside an async function"), this.yieldPos = Us, this.awaitPos = cl, this.awaitIdentPos = Ma, this.parseSubscriptAsyncArrow(_, D, qc, q); this.checkExpressionErrors(In, !0), this.yieldPos = Us || this.yieldPos, this.awaitPos = cl || this.awaitPos, this.awaitIdentPos = Ma || this.awaitIdentPos; var ja = this.startNodeAt(_, D); ja.callee = p, ja.arguments = qc, oe && (ja.optional = ce), p = this.finishNode(ja, "CallExpression") } else if (this.type === v.backQuote) { (ce || Y) && this.raise(this.start, "Optional chaining cannot appear in the tag of tagged template expressions"); var Va = this.startNodeAt(_, D); Va.tag = p, Va.quasi = this.parseTemplate({ isTagged: !0 }), p = this.finishNode(Va, "TaggedTemplateExpression") } return p }, me.parseExprAtom = function (p, _, D) { this.type === v.slash && this.readRegexp(); var A, V = this.potentialArrowAt === this.start; switch (this.type) { case v._super: return this.allowSuper || this.raise(this.start, "'super' keyword outside a method"), A = this.startNode(), this.next(), this.type === v.parenL && !this.allowDirectSuper && this.raise(A.start, "super() call outside constructor of a subclass"), this.type !== v.dot && this.type !== v.bracketL && this.type !== v.parenL && this.unexpected(), this.finishNode(A, "Super"); case v._this: return A = this.startNode(), this.next(), this.finishNode(A, "ThisExpression"); case v.name: var Y = this.start, q = this.startLoc, oe = this.containsEsc, ce = this.parseIdent(!1); if (this.options.ecmaVersion >= 8 && !oe && ce.name === "async" && !this.canInsertSemicolon() && this.eat(v._function)) return this.overrideContext(Ie.f_expr), this.parseFunction(this.startNodeAt(Y, q), 0, !1, !0, _); if (V && !this.canInsertSemicolon()) { if (this.eat(v.arrow)) return this.parseArrowExpression(this.startNodeAt(Y, q), [ce], !1, _); if (this.options.ecmaVersion >= 8 && ce.name === "async" && this.type === v.name && !oe && (!this.potentialArrowInForAwait || this.value !== "of" || this.containsEsc)) return ce = this.parseIdent(!1), (this.canInsertSemicolon() || !this.eat(v.arrow)) && this.unexpected(), this.parseArrowExpression(this.startNodeAt(Y, q), [ce], !0, _) } return ce; case v.regexp: var Le = this.value; return A = this.parseLiteral(Le.value), A.regex = { pattern: Le.pattern, flags: Le.flags }, A; case v.num: case v.string: return this.parseLiteral(this.value); case v._null: case v._true: case v._false: return A = this.startNode(), A.value = this.type === v._null ? null : this.type === v._true, A.raw = this.type.keyword, this.next(), this.finishNode(A, "Literal"); case v.parenL: var Ne = this.start, In = this.parseParenAndDistinguishExpression(V, _); return p && (p.parenthesizedAssign < 0 && !this.isSimpleAssignTarget(In) && (p.parenthesizedAssign = Ne), p.parenthesizedBind < 0 && (p.parenthesizedBind = Ne)), In; case v.bracketL: return A = this.startNode(), this.next(), A.elements = this.parseExprList(v.bracketR, !0, !0, p), this.finishNode(A, "ArrayExpression"); case v.braceL: return this.overrideContext(Ie.b_expr), this.parseObj(!1, p); case v._function: return A = this.startNode(), this.next(), this.parseFunction(A, 0); case v._class: return this.parseClass(this.startNode(), !1); case v._new: return this.parseNew(); case v.backQuote: return this.parseTemplate(); case v._import: return this.options.ecmaVersion >= 11 ? this.parseExprImport(D) : this.unexpected(); default: return this.parseExprAtomDefault() } }, me.parseExprAtomDefault = function () { this.unexpected() }, me.parseExprImport = function (p) { var _ = this.startNode(); if (this.containsEsc && this.raiseRecoverable(this.start, "Escape sequence in keyword import"), this.next(), this.type === v.parenL && !p) return this.parseDynamicImport(_); if (this.type === v.dot) { var D = this.startNodeAt(_.start, _.loc && _.loc.start); return D.name = "import", _.meta = this.finishNode(D, "Identifier"), this.parseImportMeta(_) } else this.unexpected() }, me.parseDynamicImport = function (p) { if (this.next(), p.source = this.parseMaybeAssign(), this.options.ecmaVersion >= 16) this.eat(v.parenR) ? p.options = null : (this.expect(v.comma), this.afterTrailingComma(v.parenR) ? p.options = null : (p.options = this.parseMaybeAssign(), this.eat(v.parenR) || (this.expect(v.comma), this.afterTrailingComma(v.parenR) || this.unexpected()))); else if (!this.eat(v.parenR)) { var _ = this.start; this.eat(v.comma) && this.eat(v.parenR) ? this.raiseRecoverable(_, "Trailing comma is not allowed in import()") : this.unexpected(_) } return this.finishNode(p, "ImportExpression") }, me.parseImportMeta = function (p) { this.next(); var _ = this.containsEsc; return p.property = this.parseIdent(!0), p.property.name !== "meta" && this.raiseRecoverable(p.property.start, "The only valid meta property for import is 'import.meta'"), _ && this.raiseRecoverable(p.start, "'import.meta' must not contain escaped characters"), this.options.sourceType !== "module" && !this.options.allowImportExportEverywhere && this.raiseRecoverable(p.start, "Cannot use 'import.meta' outside a module"), this.finishNode(p, "MetaProperty") }, me.parseLiteral = function (p) { var _ = this.startNode(); return _.value = p, _.raw = this.input.slice(this.start, this.end), _.raw.charCodeAt(_.raw.length - 1) === 110 && (_.bigint = _.raw.slice(0, -1).replace(/_/g, "")), this.next(), this.finishNode(_, "Literal") }, me.parseParenExpression = function () { this.expect(v.parenL); var p = this.parseExpression(); return this.expect(v.parenR), p }, me.shouldParseArrow = function (p) { return !this.canInsertSemicolon() }, me.parseParenAndDistinguishExpression = function (p, _) { var D = this.start, A = this.startLoc, V, Y = this.options.ecmaVersion >= 8; if (this.options.ecmaVersion >= 6) { this.next(); var q = this.start, oe = this.startLoc, ce = [], Le = !0, Ne = !1, In = new De, Us = this.yieldPos, cl = this.awaitPos, Ma; for (this.yieldPos = 0, this.awaitPos = 0; this.type !== v.parenR;)if (Le ? Le = !1 : this.expect(v.comma), Y && this.afterTrailingComma(v.parenR, !0)) { Ne = !0; break } else if (this.type === v.ellipsis) { Ma = this.start, ce.push(this.parseParenItem(this.parseRestBinding())), this.type === v.comma && this.raiseRecoverable(this.start, "Comma is not permitted after the rest element"); break } else ce.push(this.parseMaybeAssign(!1, In, this.parseParenItem)); var qc = this.lastTokEnd, ja = this.lastTokEndLoc; if (this.expect(v.parenR), p && this.shouldParseArrow(ce) && this.eat(v.arrow)) return this.checkPatternErrors(In, !1), this.checkYieldAwaitInDefaultParams(), this.yieldPos = Us, this.awaitPos = cl, this.parseParenArrowList(D, A, ce, _); (!ce.length || Ne) && this.unexpected(this.lastTokStart), Ma && this.unexpected(Ma), this.checkExpressionErrors(In, !0), this.yieldPos = Us || this.yieldPos, this.awaitPos = cl || this.awaitPos, ce.length > 1 ? (V = this.startNodeAt(q, oe), V.expressions = ce, this.finishNodeAt(V, "SequenceExpression", qc, ja)) : V = ce[0] } else V = this.parseParenExpression(); if (this.options.preserveParens) { var Va = this.startNodeAt(D, A); return Va.expression = V, this.finishNode(Va, "ParenthesizedExpression") } else return V }, me.parseParenItem = function (p) { return p }, me.parseParenArrowList = function (p, _, D, A) { return this.parseArrowExpression(this.startNodeAt(p, _), D, !1, A) }; var nn = []; me.parseNew = function () { this.containsEsc && this.raiseRecoverable(this.start, "Escape sequence in keyword new"); var p = this.startNode(); if (this.next(), this.options.ecmaVersion >= 6 && this.type === v.dot) { var _ = this.startNodeAt(p.start, p.loc && p.loc.start); _.name = "new", p.meta = this.finishNode(_, "Identifier"), this.next(); var D = this.containsEsc; return p.property = this.parseIdent(!0), p.property.name !== "target" && this.raiseRecoverable(p.property.start, "The only valid meta property for new is 'new.target'"), D && this.raiseRecoverable(p.start, "'new.target' must not contain escaped characters"), this.allowNewDotTarget || this.raiseRecoverable(p.start, "'new.target' can only be used in functions and class static block"), this.finishNode(p, "MetaProperty") } var A = this.start, V = this.startLoc; return p.callee = this.parseSubscripts(this.parseExprAtom(null, !1, !0), A, V, !0, !1), this.eat(v.parenL) ? p.arguments = this.parseExprList(v.parenR, this.options.ecmaVersion >= 8, !1) : p.arguments = nn, this.finishNode(p, "NewExpression") }, me.parseTemplateElement = function (p) {
        var _ = p.isTagged, D = this.startNode(); return this.type === v.invalidTemplate ? (_ || this.raiseRecoverable(this.start, "Bad escape sequence in untagged template literal"), D.value = {
          raw: this.value.replace(/\r\n?/g, `
`), cooked: null
        }) : D.value = {
          raw: this.input.slice(this.start, this.end).replace(/\r\n?/g, `
`), cooked: this.value
        }, this.next(), D.tail = this.type === v.backQuote, this.finishNode(D, "TemplateElement")
      }, me.parseTemplate = function (p) { p === void 0 && (p = {}); var _ = p.isTagged; _ === void 0 && (_ = !1); var D = this.startNode(); this.next(), D.expressions = []; var A = this.parseTemplateElement({ isTagged: _ }); for (D.quasis = [A]; !A.tail;)this.type === v.eof && this.raise(this.pos, "Unterminated template literal"), this.expect(v.dollarBraceL), D.expressions.push(this.parseExpression()), this.expect(v.braceR), D.quasis.push(A = this.parseTemplateElement({ isTagged: _ })); return this.next(), this.finishNode(D, "TemplateLiteral") }, me.isAsyncProp = function (p) { return !p.computed && p.key.type === "Identifier" && p.key.name === "async" && (this.type === v.name || this.type === v.num || this.type === v.string || this.type === v.bracketL || this.type.keyword || this.options.ecmaVersion >= 9 && this.type === v.star) && !T.test(this.input.slice(this.lastTokEnd, this.start)) }, me.parseObj = function (p, _) { var D = this.startNode(), A = !0, V = {}; for (D.properties = [], this.next(); !this.eat(v.braceR);) { if (A) A = !1; else if (this.expect(v.comma), this.options.ecmaVersion >= 5 && this.afterTrailingComma(v.braceR)) break; var Y = this.parseProperty(p, _); p || this.checkPropClash(Y, V, _), D.properties.push(Y) } return this.finishNode(D, p ? "ObjectPattern" : "ObjectExpression") }, me.parseProperty = function (p, _) { var D = this.startNode(), A, V, Y, q; if (this.options.ecmaVersion >= 9 && this.eat(v.ellipsis)) return p ? (D.argument = this.parseIdent(!1), this.type === v.comma && this.raiseRecoverable(this.start, "Comma is not permitted after the rest element"), this.finishNode(D, "RestElement")) : (D.argument = this.parseMaybeAssign(!1, _), this.type === v.comma && _ && _.trailingComma < 0 && (_.trailingComma = this.start), this.finishNode(D, "SpreadElement")); this.options.ecmaVersion >= 6 && (D.method = !1, D.shorthand = !1, (p || _) && (Y = this.start, q = this.startLoc), p || (A = this.eat(v.star))); var oe = this.containsEsc; return this.parsePropertyName(D), !p && !oe && this.options.ecmaVersion >= 8 && !A && this.isAsyncProp(D) ? (V = !0, A = this.options.ecmaVersion >= 9 && this.eat(v.star), this.parsePropertyName(D)) : V = !1, this.parsePropertyValue(D, p, A, V, Y, q, _, oe), this.finishNode(D, "Property") }, me.parseGetterSetter = function (p) { p.kind = p.key.name, this.parsePropertyName(p), p.value = this.parseMethod(!1); var _ = p.kind === "get" ? 0 : 1; if (p.value.params.length !== _) { var D = p.value.start; p.kind === "get" ? this.raiseRecoverable(D, "getter should have no params") : this.raiseRecoverable(D, "setter should have exactly one param") } else p.kind === "set" && p.value.params[0].type === "RestElement" && this.raiseRecoverable(p.value.params[0].start, "Setter cannot use rest params") }, me.parsePropertyValue = function (p, _, D, A, V, Y, q, oe) { (D || A) && this.type === v.colon && this.unexpected(), this.eat(v.colon) ? (p.value = _ ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(!1, q), p.kind = "init") : this.options.ecmaVersion >= 6 && this.type === v.parenL ? (_ && this.unexpected(), p.kind = "init", p.method = !0, p.value = this.parseMethod(D, A)) : !_ && !oe && this.options.ecmaVersion >= 5 && !p.computed && p.key.type === "Identifier" && (p.key.name === "get" || p.key.name === "set") && this.type !== v.comma && this.type !== v.braceR && this.type !== v.eq ? ((D || A) && this.unexpected(), this.parseGetterSetter(p)) : this.options.ecmaVersion >= 6 && !p.computed && p.key.type === "Identifier" ? ((D || A) && this.unexpected(), this.checkUnreserved(p.key), p.key.name === "await" && !this.awaitIdentPos && (this.awaitIdentPos = V), p.kind = "init", _ ? p.value = this.parseMaybeDefault(V, Y, this.copyNode(p.key)) : this.type === v.eq && q ? (q.shorthandAssign < 0 && (q.shorthandAssign = this.start), p.value = this.parseMaybeDefault(V, Y, this.copyNode(p.key))) : p.value = this.copyNode(p.key), p.shorthand = !0) : this.unexpected() }, me.parsePropertyName = function (p) { if (this.options.ecmaVersion >= 6) { if (this.eat(v.bracketL)) return p.computed = !0, p.key = this.parseMaybeAssign(), this.expect(v.bracketR), p.key; p.computed = !1 } return p.key = this.type === v.num || this.type === v.string ? this.parseExprAtom() : this.parseIdent(this.options.allowReserved !== "never") }, me.initFunction = function (p) { p.id = null, this.options.ecmaVersion >= 6 && (p.generator = p.expression = !1), this.options.ecmaVersion >= 8 && (p.async = !1) }, me.parseMethod = function (p, _, D) { var A = this.startNode(), V = this.yieldPos, Y = this.awaitPos, q = this.awaitIdentPos; return this.initFunction(A), this.options.ecmaVersion >= 6 && (A.generator = p), this.options.ecmaVersion >= 8 && (A.async = !!_), this.yieldPos = 0, this.awaitPos = 0, this.awaitIdentPos = 0, this.enterScope(Hn(_, A.generator) | Ft | (D ? qe : 0)), this.expect(v.parenL), A.params = this.parseBindingList(v.parenR, !1, this.options.ecmaVersion >= 8), this.checkYieldAwaitInDefaultParams(), this.parseFunctionBody(A, !1, !0, !1), this.yieldPos = V, this.awaitPos = Y, this.awaitIdentPos = q, this.finishNode(A, "FunctionExpression") }, me.parseArrowExpression = function (p, _, D, A) { var V = this.yieldPos, Y = this.awaitPos, q = this.awaitIdentPos; return this.enterScope(Hn(D, !1) | yt), this.initFunction(p), this.options.ecmaVersion >= 8 && (p.async = !!D), this.yieldPos = 0, this.awaitPos = 0, this.awaitIdentPos = 0, p.params = this.toAssignableList(_, !0), this.parseFunctionBody(p, !0, !1, A), this.yieldPos = V, this.awaitPos = Y, this.awaitIdentPos = q, this.finishNode(p, "ArrowFunctionExpression") }, me.parseFunctionBody = function (p, _, D, A) { var V = _ && this.type !== v.braceL, Y = this.strict, q = !1; if (V) p.body = this.parseMaybeAssign(A), p.expression = !0, this.checkParams(p, !1); else { var oe = this.options.ecmaVersion >= 7 && !this.isSimpleParamList(p.params); (!Y || oe) && (q = this.strictDirective(this.end), q && oe && this.raiseRecoverable(p.start, "Illegal 'use strict' directive in function with non-simple parameter list")); var ce = this.labels; this.labels = [], q && (this.strict = !0), this.checkParams(p, !Y && !q && !_ && !D && this.isSimpleParamList(p.params)), this.strict && p.id && this.checkLValSimple(p.id, hr), p.body = this.parseBlock(!1, void 0, q && !Y), p.expression = !1, this.adaptDirectivePrologue(p.body.body), this.labels = ce } this.exitScope() }, me.isSimpleParamList = function (p) { for (var _ = 0, D = p; _ < D.length; _ += 1) { var A = D[_]; if (A.type !== "Identifier") return !1 } return !0 }, me.checkParams = function (p, _) { for (var D = Object.create(null), A = 0, V = p.params; A < V.length; A += 1) { var Y = V[A]; this.checkLValInnerPattern(Y, Ut, _ ? null : D) } }, me.parseExprList = function (p, _, D, A) { for (var V = [], Y = !0; !this.eat(p);) { if (Y) Y = !1; else if (this.expect(v.comma), _ && this.afterTrailingComma(p)) break; var q = void 0; D && this.type === v.comma ? q = null : this.type === v.ellipsis ? (q = this.parseSpread(A), A && this.type === v.comma && A.trailingComma < 0 && (A.trailingComma = this.start)) : q = this.parseMaybeAssign(!1, A), V.push(q) } return V }, me.checkUnreserved = function (p) { var _ = p.start, D = p.end, A = p.name; if (this.inGenerator && A === "yield" && this.raiseRecoverable(_, "Cannot use 'yield' as identifier inside a generator"), this.inAsync && A === "await" && this.raiseRecoverable(_, "Cannot use 'await' as identifier inside an async function"), this.currentThisScope().inClassFieldInit && A === "arguments" && this.raiseRecoverable(_, "Cannot use 'arguments' in class field initializer"), this.inClassStaticBlock && (A === "arguments" || A === "await") && this.raise(_, "Cannot use " + A + " in class static initialization block"), this.keywords.test(A) && this.raise(_, "Unexpected keyword '" + A + "'"), !(this.options.ecmaVersion < 6 && this.input.slice(_, D).indexOf("\\") !== -1)) { var V = this.strict ? this.reservedWordsStrict : this.reservedWords; V.test(A) && (!this.inAsync && A === "await" && this.raiseRecoverable(_, "Cannot use keyword 'await' outside an async function"), this.raiseRecoverable(_, "The keyword '" + A + "' is reserved")) } }, me.parseIdent = function (p) { var _ = this.parseIdentNode(); return this.next(!!p), this.finishNode(_, "Identifier"), p || (this.checkUnreserved(_), _.name === "await" && !this.awaitIdentPos && (this.awaitIdentPos = _.start)), _ }, me.parseIdentNode = function () { var p = this.startNode(); return this.type === v.name ? p.name = this.value : this.type.keyword ? (p.name = this.type.keyword, (p.name === "class" || p.name === "function") && (this.lastTokEnd !== this.lastTokStart + 1 || this.input.charCodeAt(this.lastTokStart) !== 46) && this.context.pop(), this.type = v.name) : this.unexpected(), p }, me.parsePrivateIdent = function () { var p = this.startNode(); return this.type === v.privateId ? p.name = this.value : this.unexpected(), this.next(), this.finishNode(p, "PrivateIdentifier"), this.options.checkPrivateFields && (this.privateNameStack.length === 0 ? this.raise(p.start, "Private field '#" + p.name + "' must be declared in an enclosing class") : this.privateNameStack[this.privateNameStack.length - 1].used.push(p)), p }, me.parseYield = function (p) { this.yieldPos || (this.yieldPos = this.start); var _ = this.startNode(); return this.next(), this.type === v.semi || this.canInsertSemicolon() || this.type !== v.star && !this.type.startsExpr ? (_.delegate = !1, _.argument = null) : (_.delegate = this.eat(v.star), _.argument = this.parseMaybeAssign(p)), this.finishNode(_, "YieldExpression") }, me.parseAwait = function (p) { this.awaitPos || (this.awaitPos = this.start); var _ = this.startNode(); return this.next(), _.argument = this.parseMaybeUnary(null, !0, !1, p), this.finishNode(_, "AwaitExpression") }; var En = X.prototype; En.raise = function (p, _) { var D = ae(this.input, p); _ += " (" + D.line + ":" + D.column + ")"; var A = new SyntaxError(_); throw A.pos = p, A.loc = D, A.raisedAt = this.pos, A }, En.raiseRecoverable = En.raise, En.curPosition = function () { if (this.options.locations) return new re(this.curLine, this.pos - this.lineStart) }; var Fn = X.prototype, dn = function (_) { this.flags = _, this.var = [], this.lexical = [], this.functions = [], this.inClassFieldInit = !1 }; Fn.enterScope = function (p) { this.scopeStack.push(new dn(p)) }, Fn.exitScope = function () { this.scopeStack.pop() }, Fn.treatFunctionsAsVarInScope = function (p) { return p.flags & le || !this.inModule && p.flags & te }, Fn.declareName = function (p, _, D) { var A = !1; if (_ === Wt) { var V = this.currentScope(); A = V.lexical.indexOf(p) > -1 || V.functions.indexOf(p) > -1 || V.var.indexOf(p) > -1, V.lexical.push(p), this.inModule && V.flags & te && delete this.undefinedExports[p] } else if (_ === Ze) { var Y = this.currentScope(); Y.lexical.push(p) } else if (_ === wn) { var q = this.currentScope(); this.treatFunctionsAsVar ? A = q.lexical.indexOf(p) > -1 : A = q.lexical.indexOf(p) > -1 || q.var.indexOf(p) > -1, q.functions.push(p) } else for (var oe = this.scopeStack.length - 1; oe >= 0; --oe) { var ce = this.scopeStack[oe]; if (ce.lexical.indexOf(p) > -1 && !(ce.flags & ht && ce.lexical[0] === p) || !this.treatFunctionsAsVarInScope(ce) && ce.functions.indexOf(p) > -1) { A = !0; break } if (ce.var.push(p), this.inModule && ce.flags & te && delete this.undefinedExports[p], ce.flags & gn) break } A && this.raiseRecoverable(D, "Identifier '" + p + "' has already been declared") }, Fn.checkLocalExport = function (p) { this.scopeStack[0].lexical.indexOf(p.name) === -1 && this.scopeStack[0].var.indexOf(p.name) === -1 && (this.undefinedExports[p.name] = p) }, Fn.currentScope = function () { return this.scopeStack[this.scopeStack.length - 1] }, Fn.currentVarScope = function () { for (var p = this.scopeStack.length - 1; ; p--) { var _ = this.scopeStack[p]; if (_.flags & gn) return _ } }, Fn.currentThisScope = function () { for (var p = this.scopeStack.length - 1; ; p--) { var _ = this.scopeStack[p]; if (_.flags & gn && !(_.flags & yt)) return _ } }; var Kn = function (_, D, A) { this.type = "", this.start = D, this.end = 0, _.options.locations && (this.loc = new j(_, A)), _.options.directSourceFile && (this.sourceFile = _.options.directSourceFile), _.options.ranges && (this.range = [D, 0]) }, Pe = X.prototype; Pe.startNode = function () { return new Kn(this, this.start, this.startLoc) }, Pe.startNodeAt = function (p, _) { return new Kn(this, p, _) }; function Je(p, _, D, A) { return p.type = _, p.end = D, this.options.locations && (p.loc.end = A), this.options.ranges && (p.range[1] = D), p } Pe.finishNode = function (p, _) { return Je.call(this, p, _, this.lastTokEnd, this.lastTokEndLoc) }, Pe.finishNodeAt = function (p, _, D, A) { return Je.call(this, p, _, D, A) }, Pe.copyNode = function (p) { var _ = new Kn(this, p.start, this.startLoc); for (var D in p) _[D] = p[D]; return _ }; var Bt = "Gara Garay Gukh Gurung_Khema Hrkt Katakana_Or_Hiragana Kawi Kirat_Rai Krai Nag_Mundari Nagm Ol_Onal Onao Sunu Sunuwar Todhri Todr Tulu_Tigalari Tutg Unknown Zzzz", lt = "ASCII ASCII_Hex_Digit AHex Alphabetic Alpha Any Assigned Bidi_Control Bidi_C Bidi_Mirrored Bidi_M Case_Ignorable CI Cased Changes_When_Casefolded CWCF Changes_When_Casemapped CWCM Changes_When_Lowercased CWL Changes_When_NFKC_Casefolded CWKCF Changes_When_Titlecased CWT Changes_When_Uppercased CWU Dash Default_Ignorable_Code_Point DI Deprecated Dep Diacritic Dia Emoji Emoji_Component Emoji_Modifier Emoji_Modifier_Base Emoji_Presentation Extender Ext Grapheme_Base Gr_Base Grapheme_Extend Gr_Ext Hex_Digit Hex IDS_Binary_Operator IDSB IDS_Trinary_Operator IDST ID_Continue IDC ID_Start IDS Ideographic Ideo Join_Control Join_C Logical_Order_Exception LOE Lowercase Lower Math Noncharacter_Code_Point NChar Pattern_Syntax Pat_Syn Pattern_White_Space Pat_WS Quotation_Mark QMark Radical Regional_Indicator RI Sentence_Terminal STerm Soft_Dotted SD Terminal_Punctuation Term Unified_Ideograph UIdeo Uppercase Upper Variation_Selector VS White_Space space XID_Continue XIDC XID_Start XIDS", Yt = lt + " Extended_Pictographic", Ot = Yt, Rt = Ot + " EBase EComp EMod EPres ExtPict", $a = Rt, Qr = $a, ei = { 9: lt, 10: Yt, 11: Ot, 12: Rt, 13: $a, 14: Qr }, La = "Basic_Emoji Emoji_Keycap_Sequence RGI_Emoji_Modifier_Sequence RGI_Emoji_Flag_Sequence RGI_Emoji_Tag_Sequence RGI_Emoji_ZWJ_Sequence RGI_Emoji", qi = { 9: "", 10: "", 11: "", 12: "", 13: "", 14: La }, fs = "Cased_Letter LC Close_Punctuation Pe Connector_Punctuation Pc Control Cc cntrl Currency_Symbol Sc Dash_Punctuation Pd Decimal_Number Nd digit Enclosing_Mark Me Final_Punctuation Pf Format Cf Initial_Punctuation Pi Letter L Letter_Number Nl Line_Separator Zl Lowercase_Letter Ll Mark M Combining_Mark Math_Symbol Sm Modifier_Letter Lm Modifier_Symbol Sk Nonspacing_Mark Mn Number N Open_Punctuation Ps Other C Other_Letter Lo Other_Number No Other_Punctuation Po Other_Symbol So Paragraph_Separator Zp Private_Use Co Punctuation P punct Separator Z Space_Separator Zs Spacing_Mark Mc Surrogate Cs Symbol S Titlecase_Letter Lt Unassigned Cn Uppercase_Letter Lu", Bb = "Adlam Adlm Ahom Anatolian_Hieroglyphs Hluw Arabic Arab Armenian Armn Avestan Avst Balinese Bali Bamum Bamu Bassa_Vah Bass Batak Batk Bengali Beng Bhaiksuki Bhks Bopomofo Bopo Brahmi Brah Braille Brai Buginese Bugi Buhid Buhd Canadian_Aboriginal Cans Carian Cari Caucasian_Albanian Aghb Chakma Cakm Cham Cham Cherokee Cher Common Zyyy Coptic Copt Qaac Cuneiform Xsux Cypriot Cprt Cyrillic Cyrl Deseret Dsrt Devanagari Deva Duployan Dupl Egyptian_Hieroglyphs Egyp Elbasan Elba Ethiopic Ethi Georgian Geor Glagolitic Glag Gothic Goth Grantha Gran Greek Grek Gujarati Gujr Gurmukhi Guru Han Hani Hangul Hang Hanunoo Hano Hatran Hatr Hebrew Hebr Hiragana Hira Imperial_Aramaic Armi Inherited Zinh Qaai Inscriptional_Pahlavi Phli Inscriptional_Parthian Prti Javanese Java Kaithi Kthi Kannada Knda Katakana Kana Kayah_Li Kali Kharoshthi Khar Khmer Khmr Khojki Khoj Khudawadi Sind Lao Laoo Latin Latn Lepcha Lepc Limbu Limb Linear_A Lina Linear_B Linb Lisu Lisu Lycian Lyci Lydian Lydi Mahajani Mahj Malayalam Mlym Mandaic Mand Manichaean Mani Marchen Marc Masaram_Gondi Gonm Meetei_Mayek Mtei Mende_Kikakui Mend Meroitic_Cursive Merc Meroitic_Hieroglyphs Mero Miao Plrd Modi Mongolian Mong Mro Mroo Multani Mult Myanmar Mymr Nabataean Nbat New_Tai_Lue Talu Newa Newa Nko Nkoo Nushu Nshu Ogham Ogam Ol_Chiki Olck Old_Hungarian Hung Old_Italic Ital Old_North_Arabian Narb Old_Permic Perm Old_Persian Xpeo Old_South_Arabian Sarb Old_Turkic Orkh Oriya Orya Osage Osge Osmanya Osma Pahawh_Hmong Hmng Palmyrene Palm Pau_Cin_Hau Pauc Phags_Pa Phag Phoenician Phnx Psalter_Pahlavi Phlp Rejang Rjng Runic Runr Samaritan Samr Saurashtra Saur Sharada Shrd Shavian Shaw Siddham Sidd SignWriting Sgnw Sinhala Sinh Sora_Sompeng Sora Soyombo Soyo Sundanese Sund Syloti_Nagri Sylo Syriac Syrc Tagalog Tglg Tagbanwa Tagb Tai_Le Tale Tai_Tham Lana Tai_Viet Tavt Takri Takr Tamil Taml Tangut Tang Telugu Telu Thaana Thaa Thai Thai Tibetan Tibt Tifinagh Tfng Tirhuta Tirh Ugaritic Ugar Vai Vaii Warang_Citi Wara Yi Yiii Zanabazar_Square Zanb", zb = Bb + " Dogra Dogr Gunjala_Gondi Gong Hanifi_Rohingya Rohg Makasar Maka Medefaidrin Medf Old_Sogdian Sogo Sogdian Sogd", Hb = zb + " Elymaic Elym Nandinagari Nand Nyiakeng_Puachue_Hmong Hmnp Wancho Wcho", Kb = Hb + " Chorasmian Chrs Diak Dives_Akuru Khitan_Small_Script Kits Yezi Yezidi", Ub = Kb + " Cypro_Minoan Cpmn Old_Uyghur Ougr Tangsa Tnsa Toto Vithkuqi Vith", LI = Ub + " " + Bt, MI = { 9: Bb, 10: zb, 11: Hb, 12: Kb, 13: Ub, 14: LI }, Wb = {}; function jI(p) { var _ = Wb[p] = { binary: ee(ei[p] + " " + fs), binaryOfStrings: ee(qi[p]), nonBinary: { General_Category: ee(fs), Script: ee(MI[p]) } }; _.nonBinary.Script_Extensions = _.nonBinary.Script, _.nonBinary.gc = _.nonBinary.General_Category, _.nonBinary.sc = _.nonBinary.Script, _.nonBinary.scx = _.nonBinary.Script_Extensions } for (var Hh = 0, Gb = [9, 10, 11, 12, 13, 14]; Hh < Gb.length; Hh += 1) { var VI = Gb[Hh]; jI(VI) } var xe = X.prototype, Gc = function (_, D) { this.parent = _, this.base = D || this }; Gc.prototype.separatedFrom = function (_) { for (var D = this; D; D = D.parent)for (var A = _; A; A = A.parent)if (D.base === A.base && D !== A) return !0; return !1 }, Gc.prototype.sibling = function () { return new Gc(this.parent, this.base) }; var Oi = function (_) { this.parser = _, this.validFlags = "gim" + (_.options.ecmaVersion >= 6 ? "uy" : "") + (_.options.ecmaVersion >= 9 ? "s" : "") + (_.options.ecmaVersion >= 13 ? "d" : "") + (_.options.ecmaVersion >= 15 ? "v" : ""), this.unicodeProperties = Wb[_.options.ecmaVersion >= 14 ? 14 : _.options.ecmaVersion], this.source = "", this.flags = "", this.start = 0, this.switchU = !1, this.switchV = !1, this.switchN = !1, this.pos = 0, this.lastIntValue = 0, this.lastStringValue = "", this.lastAssertionIsQuantifiable = !1, this.numCapturingParens = 0, this.maxBackReference = 0, this.groupNames = Object.create(null), this.backReferenceNames = [], this.branchID = null }; Oi.prototype.reset = function (_, D, A) { var V = A.indexOf("v") !== -1, Y = A.indexOf("u") !== -1; this.start = _ | 0, this.source = D + "", this.flags = A, V && this.parser.options.ecmaVersion >= 15 ? (this.switchU = !0, this.switchV = !0, this.switchN = !0) : (this.switchU = Y && this.parser.options.ecmaVersion >= 6, this.switchV = !1, this.switchN = Y && this.parser.options.ecmaVersion >= 9) }, Oi.prototype.raise = function (_) { this.parser.raiseRecoverable(this.start, "Invalid regular expression: /" + this.source + "/: " + _) }, Oi.prototype.at = function (_, D) { D === void 0 && (D = !1); var A = this.source, V = A.length; if (_ >= V) return -1; var Y = A.charCodeAt(_); if (!(D || this.switchU) || Y <= 55295 || Y >= 57344 || _ + 1 >= V) return Y; var q = A.charCodeAt(_ + 1); return q >= 56320 && q <= 57343 ? (Y << 10) + q - 56613888 : Y }, Oi.prototype.nextIndex = function (_, D) { D === void 0 && (D = !1); var A = this.source, V = A.length; if (_ >= V) return V; var Y = A.charCodeAt(_), q; return !(D || this.switchU) || Y <= 55295 || Y >= 57344 || _ + 1 >= V || (q = A.charCodeAt(_ + 1)) < 56320 || q > 57343 ? _ + 1 : _ + 2 }, Oi.prototype.current = function (_) { return _ === void 0 && (_ = !1), this.at(this.pos, _) }, Oi.prototype.lookahead = function (_) { return _ === void 0 && (_ = !1), this.at(this.nextIndex(this.pos, _), _) }, Oi.prototype.advance = function (_) { _ === void 0 && (_ = !1), this.pos = this.nextIndex(this.pos, _) }, Oi.prototype.eat = function (_, D) { return D === void 0 && (D = !1), this.current(D) === _ ? (this.advance(D), !0) : !1 }, Oi.prototype.eatChars = function (_, D) { D === void 0 && (D = !1); for (var A = this.pos, V = 0, Y = _; V < Y.length; V += 1) { var q = Y[V], oe = this.at(A, D); if (oe === -1 || oe !== q) return !1; A = this.nextIndex(A, D) } return this.pos = A, !0 }, xe.validateRegExpFlags = function (p) { for (var _ = p.validFlags, D = p.flags, A = !1, V = !1, Y = 0; Y < D.length; Y++) { var q = D.charAt(Y); _.indexOf(q) === -1 && this.raise(p.start, "Invalid regular expression flag"), D.indexOf(q, Y + 1) > -1 && this.raise(p.start, "Duplicate regular expression flag"), q === "u" && (A = !0), q === "v" && (V = !0) } this.options.ecmaVersion >= 15 && A && V && this.raise(p.start, "Invalid regular expression flag") }; function BI(p) { for (var _ in p) return !0; return !1 } xe.validateRegExpPattern = function (p) { this.regexp_pattern(p), !p.switchN && this.options.ecmaVersion >= 9 && BI(p.groupNames) && (p.switchN = !0, this.regexp_pattern(p)) }, xe.regexp_pattern = function (p) { p.pos = 0, p.lastIntValue = 0, p.lastStringValue = "", p.lastAssertionIsQuantifiable = !1, p.numCapturingParens = 0, p.maxBackReference = 0, p.groupNames = Object.create(null), p.backReferenceNames.length = 0, p.branchID = null, this.regexp_disjunction(p), p.pos !== p.source.length && (p.eat(41) && p.raise("Unmatched ')'"), (p.eat(93) || p.eat(125)) && p.raise("Lone quantifier brackets")), p.maxBackReference > p.numCapturingParens && p.raise("Invalid escape"); for (var _ = 0, D = p.backReferenceNames; _ < D.length; _ += 1) { var A = D[_]; p.groupNames[A] || p.raise("Invalid named capture referenced") } }, xe.regexp_disjunction = function (p) { var _ = this.options.ecmaVersion >= 16; for (_ && (p.branchID = new Gc(p.branchID, null)), this.regexp_alternative(p); p.eat(124);)_ && (p.branchID = p.branchID.sibling()), this.regexp_alternative(p); _ && (p.branchID = p.branchID.parent), this.regexp_eatQuantifier(p, !0) && p.raise("Nothing to repeat"), p.eat(123) && p.raise("Lone quantifier brackets") }, xe.regexp_alternative = function (p) { for (; p.pos < p.source.length && this.regexp_eatTerm(p);); }, xe.regexp_eatTerm = function (p) { return this.regexp_eatAssertion(p) ? (p.lastAssertionIsQuantifiable && this.regexp_eatQuantifier(p) && p.switchU && p.raise("Invalid quantifier"), !0) : (p.switchU ? this.regexp_eatAtom(p) : this.regexp_eatExtendedAtom(p)) ? (this.regexp_eatQuantifier(p), !0) : !1 }, xe.regexp_eatAssertion = function (p) { var _ = p.pos; if (p.lastAssertionIsQuantifiable = !1, p.eat(94) || p.eat(36)) return !0; if (p.eat(92)) { if (p.eat(66) || p.eat(98)) return !0; p.pos = _ } if (p.eat(40) && p.eat(63)) { var D = !1; if (this.options.ecmaVersion >= 9 && (D = p.eat(60)), p.eat(61) || p.eat(33)) return this.regexp_disjunction(p), p.eat(41) || p.raise("Unterminated group"), p.lastAssertionIsQuantifiable = !D, !0 } return p.pos = _, !1 }, xe.regexp_eatQuantifier = function (p, _) { return _ === void 0 && (_ = !1), this.regexp_eatQuantifierPrefix(p, _) ? (p.eat(63), !0) : !1 }, xe.regexp_eatQuantifierPrefix = function (p, _) { return p.eat(42) || p.eat(43) || p.eat(63) || this.regexp_eatBracedQuantifier(p, _) }, xe.regexp_eatBracedQuantifier = function (p, _) { var D = p.pos; if (p.eat(123)) { var A = 0, V = -1; if (this.regexp_eatDecimalDigits(p) && (A = p.lastIntValue, p.eat(44) && this.regexp_eatDecimalDigits(p) && (V = p.lastIntValue), p.eat(125))) return V !== -1 && V < A && !_ && p.raise("numbers out of order in {} quantifier"), !0; p.switchU && !_ && p.raise("Incomplete quantifier"), p.pos = D } return !1 }, xe.regexp_eatAtom = function (p) { return this.regexp_eatPatternCharacters(p) || p.eat(46) || this.regexp_eatReverseSolidusAtomEscape(p) || this.regexp_eatCharacterClass(p) || this.regexp_eatUncapturingGroup(p) || this.regexp_eatCapturingGroup(p) }, xe.regexp_eatReverseSolidusAtomEscape = function (p) { var _ = p.pos; if (p.eat(92)) { if (this.regexp_eatAtomEscape(p)) return !0; p.pos = _ } return !1 }, xe.regexp_eatUncapturingGroup = function (p) { var _ = p.pos; if (p.eat(40)) { if (p.eat(63)) { if (this.options.ecmaVersion >= 16) { var D = this.regexp_eatModifiers(p), A = p.eat(45); if (D || A) { for (var V = 0; V < D.length; V++) { var Y = D.charAt(V); D.indexOf(Y, V + 1) > -1 && p.raise("Duplicate regular expression modifiers") } if (A) { var q = this.regexp_eatModifiers(p); !D && !q && p.current() === 58 && p.raise("Invalid regular expression modifiers"); for (var oe = 0; oe < q.length; oe++) { var ce = q.charAt(oe); (q.indexOf(ce, oe + 1) > -1 || D.indexOf(ce) > -1) && p.raise("Duplicate regular expression modifiers") } } } } if (p.eat(58)) { if (this.regexp_disjunction(p), p.eat(41)) return !0; p.raise("Unterminated group") } } p.pos = _ } return !1 }, xe.regexp_eatCapturingGroup = function (p) { if (p.eat(40)) { if (this.options.ecmaVersion >= 9 ? this.regexp_groupSpecifier(p) : p.current() === 63 && p.raise("Invalid group"), this.regexp_disjunction(p), p.eat(41)) return p.numCapturingParens += 1, !0; p.raise("Unterminated group") } return !1 }, xe.regexp_eatModifiers = function (p) { for (var _ = "", D = 0; (D = p.current()) !== -1 && zI(D);)_ += $(D), p.advance(); return _ }; function zI(p) { return p === 105 || p === 109 || p === 115 } xe.regexp_eatExtendedAtom = function (p) { return p.eat(46) || this.regexp_eatReverseSolidusAtomEscape(p) || this.regexp_eatCharacterClass(p) || this.regexp_eatUncapturingGroup(p) || this.regexp_eatCapturingGroup(p) || this.regexp_eatInvalidBracedQuantifier(p) || this.regexp_eatExtendedPatternCharacter(p) }, xe.regexp_eatInvalidBracedQuantifier = function (p) { return this.regexp_eatBracedQuantifier(p, !0) && p.raise("Nothing to repeat"), !1 }, xe.regexp_eatSyntaxCharacter = function (p) { var _ = p.current(); return Yb(_) ? (p.lastIntValue = _, p.advance(), !0) : !1 }; function Yb(p) { return p === 36 || p >= 40 && p <= 43 || p === 46 || p === 63 || p >= 91 && p <= 94 || p >= 123 && p <= 125 } xe.regexp_eatPatternCharacters = function (p) { for (var _ = p.pos, D = 0; (D = p.current()) !== -1 && !Yb(D);)p.advance(); return p.pos !== _ }, xe.regexp_eatExtendedPatternCharacter = function (p) { var _ = p.current(); return _ !== -1 && _ !== 36 && !(_ >= 40 && _ <= 43) && _ !== 46 && _ !== 63 && _ !== 91 && _ !== 94 && _ !== 124 ? (p.advance(), !0) : !1 }, xe.regexp_groupSpecifier = function (p) { if (p.eat(63)) { this.regexp_eatGroupName(p) || p.raise("Invalid group"); var _ = this.options.ecmaVersion >= 16, D = p.groupNames[p.lastStringValue]; if (D) if (_) for (var A = 0, V = D; A < V.length; A += 1) { var Y = V[A]; Y.separatedFrom(p.branchID) || p.raise("Duplicate capture group name") } else p.raise("Duplicate capture group name"); _ ? (D || (p.groupNames[p.lastStringValue] = [])).push(p.branchID) : p.groupNames[p.lastStringValue] = !0 } }, xe.regexp_eatGroupName = function (p) { if (p.lastStringValue = "", p.eat(60)) { if (this.regexp_eatRegExpIdentifierName(p) && p.eat(62)) return !0; p.raise("Invalid capture group name") } return !1 }, xe.regexp_eatRegExpIdentifierName = function (p) { if (p.lastStringValue = "", this.regexp_eatRegExpIdentifierStart(p)) { for (p.lastStringValue += $(p.lastIntValue); this.regexp_eatRegExpIdentifierPart(p);)p.lastStringValue += $(p.lastIntValue); return !0 } return !1 }, xe.regexp_eatRegExpIdentifierStart = function (p) { var _ = p.pos, D = this.options.ecmaVersion >= 11, A = p.current(D); return p.advance(D), A === 92 && this.regexp_eatRegExpUnicodeEscapeSequence(p, D) && (A = p.lastIntValue), HI(A) ? (p.lastIntValue = A, !0) : (p.pos = _, !1) }; function HI(p) { return b(p, !0) || p === 36 || p === 95 } xe.regexp_eatRegExpIdentifierPart = function (p) { var _ = p.pos, D = this.options.ecmaVersion >= 11, A = p.current(D); return p.advance(D), A === 92 && this.regexp_eatRegExpUnicodeEscapeSequence(p, D) && (A = p.lastIntValue), KI(A) ? (p.lastIntValue = A, !0) : (p.pos = _, !1) }; function KI(p) { return y(p, !0) || p === 36 || p === 95 || p === 8204 || p === 8205 } xe.regexp_eatAtomEscape = function (p) { return this.regexp_eatBackReference(p) || this.regexp_eatCharacterClassEscape(p) || this.regexp_eatCharacterEscape(p) || p.switchN && this.regexp_eatKGroupName(p) ? !0 : (p.switchU && (p.current() === 99 && p.raise("Invalid unicode escape"), p.raise("Invalid escape")), !1) }, xe.regexp_eatBackReference = function (p) { var _ = p.pos; if (this.regexp_eatDecimalEscape(p)) { var D = p.lastIntValue; if (p.switchU) return D > p.maxBackReference && (p.maxBackReference = D), !0; if (D <= p.numCapturingParens) return !0; p.pos = _ } return !1 }, xe.regexp_eatKGroupName = function (p) { if (p.eat(107)) { if (this.regexp_eatGroupName(p)) return p.backReferenceNames.push(p.lastStringValue), !0; p.raise("Invalid named reference") } return !1 }, xe.regexp_eatCharacterEscape = function (p) { return this.regexp_eatControlEscape(p) || this.regexp_eatCControlLetter(p) || this.regexp_eatZero(p) || this.regexp_eatHexEscapeSequence(p) || this.regexp_eatRegExpUnicodeEscapeSequence(p, !1) || !p.switchU && this.regexp_eatLegacyOctalEscapeSequence(p) || this.regexp_eatIdentityEscape(p) }, xe.regexp_eatCControlLetter = function (p) { var _ = p.pos; if (p.eat(99)) { if (this.regexp_eatControlLetter(p)) return !0; p.pos = _ } return !1 }, xe.regexp_eatZero = function (p) { return p.current() === 48 && !Yc(p.lookahead()) ? (p.lastIntValue = 0, p.advance(), !0) : !1 }, xe.regexp_eatControlEscape = function (p) { var _ = p.current(); return _ === 116 ? (p.lastIntValue = 9, p.advance(), !0) : _ === 110 ? (p.lastIntValue = 10, p.advance(), !0) : _ === 118 ? (p.lastIntValue = 11, p.advance(), !0) : _ === 102 ? (p.lastIntValue = 12, p.advance(), !0) : _ === 114 ? (p.lastIntValue = 13, p.advance(), !0) : !1 }, xe.regexp_eatControlLetter = function (p) { var _ = p.current(); return Xb(_) ? (p.lastIntValue = _ % 32, p.advance(), !0) : !1 }; function Xb(p) { return p >= 65 && p <= 90 || p >= 97 && p <= 122 } xe.regexp_eatRegExpUnicodeEscapeSequence = function (p, _) { _ === void 0 && (_ = !1); var D = p.pos, A = _ || p.switchU; if (p.eat(117)) { if (this.regexp_eatFixedHexDigits(p, 4)) { var V = p.lastIntValue; if (A && V >= 55296 && V <= 56319) { var Y = p.pos; if (p.eat(92) && p.eat(117) && this.regexp_eatFixedHexDigits(p, 4)) { var q = p.lastIntValue; if (q >= 56320 && q <= 57343) return p.lastIntValue = (V - 55296) * 1024 + (q - 56320) + 65536, !0 } p.pos = Y, p.lastIntValue = V } return !0 } if (A && p.eat(123) && this.regexp_eatHexDigits(p) && p.eat(125) && UI(p.lastIntValue)) return !0; A && p.raise("Invalid unicode escape"), p.pos = D } return !1 }; function UI(p) { return p >= 0 && p <= 1114111 } xe.regexp_eatIdentityEscape = function (p) { if (p.switchU) return this.regexp_eatSyntaxCharacter(p) ? !0 : p.eat(47) ? (p.lastIntValue = 47, !0) : !1; var _ = p.current(); return _ !== 99 && (!p.switchN || _ !== 107) ? (p.lastIntValue = _, p.advance(), !0) : !1 }, xe.regexp_eatDecimalEscape = function (p) { p.lastIntValue = 0; var _ = p.current(); if (_ >= 49 && _ <= 57) { do p.lastIntValue = 10 * p.lastIntValue + (_ - 48), p.advance(); while ((_ = p.current()) >= 48 && _ <= 57); return !0 } return !1 }; var qb = 0, Zi = 1, Nr = 2; xe.regexp_eatCharacterClassEscape = function (p) { var _ = p.current(); if (WI(_)) return p.lastIntValue = -1, p.advance(), Zi; var D = !1; if (p.switchU && this.options.ecmaVersion >= 9 && ((D = _ === 80) || _ === 112)) { p.lastIntValue = -1, p.advance(); var A; if (p.eat(123) && (A = this.regexp_eatUnicodePropertyValueExpression(p)) && p.eat(125)) return D && A === Nr && p.raise("Invalid property name"), A; p.raise("Invalid property name") } return qb }; function WI(p) { return p === 100 || p === 68 || p === 115 || p === 83 || p === 119 || p === 87 } xe.regexp_eatUnicodePropertyValueExpression = function (p) { var _ = p.pos; if (this.regexp_eatUnicodePropertyName(p) && p.eat(61)) { var D = p.lastStringValue; if (this.regexp_eatUnicodePropertyValue(p)) { var A = p.lastStringValue; return this.regexp_validateUnicodePropertyNameAndValue(p, D, A), Zi } } if (p.pos = _, this.regexp_eatLoneUnicodePropertyNameOrValue(p)) { var V = p.lastStringValue; return this.regexp_validateUnicodePropertyNameOrValue(p, V) } return qb }, xe.regexp_validateUnicodePropertyNameAndValue = function (p, _, D) { W(p.unicodeProperties.nonBinary, _) || p.raise("Invalid property name"), p.unicodeProperties.nonBinary[_].test(D) || p.raise("Invalid property value") }, xe.regexp_validateUnicodePropertyNameOrValue = function (p, _) { if (p.unicodeProperties.binary.test(_)) return Zi; if (p.switchV && p.unicodeProperties.binaryOfStrings.test(_)) return Nr; p.raise("Invalid property name") }, xe.regexp_eatUnicodePropertyName = function (p) { var _ = 0; for (p.lastStringValue = ""; Zb(_ = p.current());)p.lastStringValue += $(_), p.advance(); return p.lastStringValue !== "" }; function Zb(p) { return Xb(p) || p === 95 } xe.regexp_eatUnicodePropertyValue = function (p) { var _ = 0; for (p.lastStringValue = ""; GI(_ = p.current());)p.lastStringValue += $(_), p.advance(); return p.lastStringValue !== "" }; function GI(p) { return Zb(p) || Yc(p) } xe.regexp_eatLoneUnicodePropertyNameOrValue = function (p) { return this.regexp_eatUnicodePropertyValue(p) }, xe.regexp_eatCharacterClass = function (p) { if (p.eat(91)) { var _ = p.eat(94), D = this.regexp_classContents(p); return p.eat(93) || p.raise("Unterminated character class"), _ && D === Nr && p.raise("Negated character class may contain strings"), !0 } return !1 }, xe.regexp_classContents = function (p) { return p.current() === 93 ? Zi : p.switchV ? this.regexp_classSetExpression(p) : (this.regexp_nonEmptyClassRanges(p), Zi) }, xe.regexp_nonEmptyClassRanges = function (p) { for (; this.regexp_eatClassAtom(p);) { var _ = p.lastIntValue; if (p.eat(45) && this.regexp_eatClassAtom(p)) { var D = p.lastIntValue; p.switchU && (_ === -1 || D === -1) && p.raise("Invalid character class"), _ !== -1 && D !== -1 && _ > D && p.raise("Range out of order in character class") } } }, xe.regexp_eatClassAtom = function (p) { var _ = p.pos; if (p.eat(92)) { if (this.regexp_eatClassEscape(p)) return !0; if (p.switchU) { var D = p.current(); (D === 99 || ev(D)) && p.raise("Invalid class escape"), p.raise("Invalid escape") } p.pos = _ } var A = p.current(); return A !== 93 ? (p.lastIntValue = A, p.advance(), !0) : !1 }, xe.regexp_eatClassEscape = function (p) { var _ = p.pos; if (p.eat(98)) return p.lastIntValue = 8, !0; if (p.switchU && p.eat(45)) return p.lastIntValue = 45, !0; if (!p.switchU && p.eat(99)) { if (this.regexp_eatClassControlLetter(p)) return !0; p.pos = _ } return this.regexp_eatCharacterClassEscape(p) || this.regexp_eatCharacterEscape(p) }, xe.regexp_classSetExpression = function (p) { var _ = Zi, D; if (!this.regexp_eatClassSetRange(p)) if (D = this.regexp_eatClassSetOperand(p)) { D === Nr && (_ = Nr); for (var A = p.pos; p.eatChars([38, 38]);) { if (p.current() !== 38 && (D = this.regexp_eatClassSetOperand(p))) { D !== Nr && (_ = Zi); continue } p.raise("Invalid character in character class") } if (A !== p.pos) return _; for (; p.eatChars([45, 45]);)this.regexp_eatClassSetOperand(p) || p.raise("Invalid character in character class"); if (A !== p.pos) return _ } else p.raise("Invalid character in character class"); for (; ;)if (!this.regexp_eatClassSetRange(p)) { if (D = this.regexp_eatClassSetOperand(p), !D) return _; D === Nr && (_ = Nr) } }, xe.regexp_eatClassSetRange = function (p) { var _ = p.pos; if (this.regexp_eatClassSetCharacter(p)) { var D = p.lastIntValue; if (p.eat(45) && this.regexp_eatClassSetCharacter(p)) { var A = p.lastIntValue; return D !== -1 && A !== -1 && D > A && p.raise("Range out of order in character class"), !0 } p.pos = _ } return !1 }, xe.regexp_eatClassSetOperand = function (p) { return this.regexp_eatClassSetCharacter(p) ? Zi : this.regexp_eatClassStringDisjunction(p) || this.regexp_eatNestedClass(p) }, xe.regexp_eatNestedClass = function (p) { var _ = p.pos; if (p.eat(91)) { var D = p.eat(94), A = this.regexp_classContents(p); if (p.eat(93)) return D && A === Nr && p.raise("Negated character class may contain strings"), A; p.pos = _ } if (p.eat(92)) { var V = this.regexp_eatCharacterClassEscape(p); if (V) return V; p.pos = _ } return null }, xe.regexp_eatClassStringDisjunction = function (p) { var _ = p.pos; if (p.eatChars([92, 113])) { if (p.eat(123)) { var D = this.regexp_classStringDisjunctionContents(p); if (p.eat(125)) return D } else p.raise("Invalid escape"); p.pos = _ } return null }, xe.regexp_classStringDisjunctionContents = function (p) { for (var _ = this.regexp_classString(p); p.eat(124);)this.regexp_classString(p) === Nr && (_ = Nr); return _ }, xe.regexp_classString = function (p) { for (var _ = 0; this.regexp_eatClassSetCharacter(p);)_++; return _ === 1 ? Zi : Nr }, xe.regexp_eatClassSetCharacter = function (p) { var _ = p.pos; if (p.eat(92)) return this.regexp_eatCharacterEscape(p) || this.regexp_eatClassSetReservedPunctuator(p) ? !0 : p.eat(98) ? (p.lastIntValue = 8, !0) : (p.pos = _, !1); var D = p.current(); return D < 0 || D === p.lookahead() && YI(D) || XI(D) ? !1 : (p.advance(), p.lastIntValue = D, !0) }; function YI(p) { return p === 33 || p >= 35 && p <= 38 || p >= 42 && p <= 44 || p === 46 || p >= 58 && p <= 64 || p === 94 || p === 96 || p === 126 } function XI(p) { return p === 40 || p === 41 || p === 45 || p === 47 || p >= 91 && p <= 93 || p >= 123 && p <= 125 } xe.regexp_eatClassSetReservedPunctuator = function (p) { var _ = p.current(); return qI(_) ? (p.lastIntValue = _, p.advance(), !0) : !1 }; function qI(p) { return p === 33 || p === 35 || p === 37 || p === 38 || p === 44 || p === 45 || p >= 58 && p <= 62 || p === 64 || p === 96 || p === 126 } xe.regexp_eatClassControlLetter = function (p) { var _ = p.current(); return Yc(_) || _ === 95 ? (p.lastIntValue = _ % 32, p.advance(), !0) : !1 }, xe.regexp_eatHexEscapeSequence = function (p) { var _ = p.pos; if (p.eat(120)) { if (this.regexp_eatFixedHexDigits(p, 2)) return !0; p.switchU && p.raise("Invalid escape"), p.pos = _ } return !1 }, xe.regexp_eatDecimalDigits = function (p) { var _ = p.pos, D = 0; for (p.lastIntValue = 0; Yc(D = p.current());)p.lastIntValue = 10 * p.lastIntValue + (D - 48), p.advance(); return p.pos !== _ }; function Yc(p) { return p >= 48 && p <= 57 } xe.regexp_eatHexDigits = function (p) { var _ = p.pos, D = 0; for (p.lastIntValue = 0; Jb(D = p.current());)p.lastIntValue = 16 * p.lastIntValue + Qb(D), p.advance(); return p.pos !== _ }; function Jb(p) { return p >= 48 && p <= 57 || p >= 65 && p <= 70 || p >= 97 && p <= 102 } function Qb(p) { return p >= 65 && p <= 70 ? 10 + (p - 65) : p >= 97 && p <= 102 ? 10 + (p - 97) : p - 48 } xe.regexp_eatLegacyOctalEscapeSequence = function (p) { if (this.regexp_eatOctalDigit(p)) { var _ = p.lastIntValue; if (this.regexp_eatOctalDigit(p)) { var D = p.lastIntValue; _ <= 3 && this.regexp_eatOctalDigit(p) ? p.lastIntValue = _ * 64 + D * 8 + p.lastIntValue : p.lastIntValue = _ * 8 + D } else p.lastIntValue = _; return !0 } return !1 }, xe.regexp_eatOctalDigit = function (p) { var _ = p.current(); return ev(_) ? (p.lastIntValue = _ - 48, p.advance(), !0) : (p.lastIntValue = 0, !1) }; function ev(p) { return p >= 48 && p <= 55 } xe.regexp_eatFixedHexDigits = function (p, _) { var D = p.pos; p.lastIntValue = 0; for (var A = 0; A < _; ++A) { var V = p.current(); if (!Jb(V)) return p.pos = D, !1; p.lastIntValue = 16 * p.lastIntValue + Qb(V), p.advance() } return !0 }; var Xc = function (_) { this.type = _.type, this.value = _.value, this.start = _.start, this.end = _.end, _.options.locations && (this.loc = new j(_, _.startLoc, _.endLoc)), _.options.ranges && (this.range = [_.start, _.end]) }, Ye = X.prototype; Ye.next = function (p) { !p && this.type.keyword && this.containsEsc && this.raiseRecoverable(this.start, "Escape sequence in keyword " + this.type.keyword), this.options.onToken && this.options.onToken(new Xc(this)), this.lastTokEnd = this.end, this.lastTokStart = this.start, this.lastTokEndLoc = this.endLoc, this.lastTokStartLoc = this.startLoc, this.nextToken() }, Ye.getToken = function () { return this.next(), new Xc(this) }, typeof Symbol < "u" && (Ye[Symbol.iterator] = function () { var p = this; return { next: function () { var _ = p.getToken(); return { done: _.type === v.eof, value: _ } } } }), Ye.nextToken = function () { var p = this.curContext(); if ((!p || !p.preserveSpace) && this.skipSpace(), this.start = this.pos, this.options.locations && (this.startLoc = this.curPosition()), this.pos >= this.input.length) return this.finishToken(v.eof); if (p.override) return p.override(this); this.readToken(this.fullCharCodeAtPos()) }, Ye.readToken = function (p) { return b(p, this.options.ecmaVersion >= 6) || p === 92 ? this.readWord() : this.getTokenFromCode(p) }, Ye.fullCharCodeAtPos = function () { var p = this.input.charCodeAt(this.pos); if (p <= 55295 || p >= 56320) return p; var _ = this.input.charCodeAt(this.pos + 1); return _ <= 56319 || _ >= 57344 ? p : (p << 10) + _ - 56613888 }, Ye.skipBlockComment = function () { var p = this.options.onComment && this.curPosition(), _ = this.pos, D = this.input.indexOf("*/", this.pos += 2); if (D === -1 && this.raise(this.pos - 2, "Unterminated comment"), this.pos = D + 2, this.options.locations) for (var A = void 0, V = _; (A = P(this.input, V, this.pos)) > -1;)++this.curLine, V = this.lineStart = A; this.options.onComment && this.options.onComment(!0, this.input.slice(_ + 2, D), _, this.pos, p, this.curPosition()) }, Ye.skipLineComment = function (p) { for (var _ = this.pos, D = this.options.onComment && this.curPosition(), A = this.input.charCodeAt(this.pos += p); this.pos < this.input.length && !k(A);)A = this.input.charCodeAt(++this.pos); this.options.onComment && this.options.onComment(!1, this.input.slice(_ + p, this.pos), _, this.pos, D, this.curPosition()) }, Ye.skipSpace = function () { e: for (; this.pos < this.input.length;) { var p = this.input.charCodeAt(this.pos); switch (p) { case 32: case 160: ++this.pos; break; case 13: this.input.charCodeAt(this.pos + 1) === 10 && ++this.pos; case 10: case 8232: case 8233: ++this.pos, this.options.locations && (++this.curLine, this.lineStart = this.pos); break; case 47: switch (this.input.charCodeAt(this.pos + 1)) { case 42: this.skipBlockComment(); break; case 47: this.skipLineComment(2); break; default: break e }break; default: if (p > 8 && p < 14 || p >= 5760 && N.test(String.fromCharCode(p))) ++this.pos; else break e } } }, Ye.finishToken = function (p, _) { this.end = this.pos, this.options.locations && (this.endLoc = this.curPosition()); var D = this.type; this.type = p, this.value = _, this.updateContext(D) }, Ye.readToken_dot = function () { var p = this.input.charCodeAt(this.pos + 1); if (p >= 48 && p <= 57) return this.readNumber(!0); var _ = this.input.charCodeAt(this.pos + 2); return this.options.ecmaVersion >= 6 && p === 46 && _ === 46 ? (this.pos += 3, this.finishToken(v.ellipsis)) : (++this.pos, this.finishToken(v.dot)) }, Ye.readToken_slash = function () { var p = this.input.charCodeAt(this.pos + 1); return this.exprAllowed ? (++this.pos, this.readRegexp()) : p === 61 ? this.finishOp(v.assign, 2) : this.finishOp(v.slash, 1) }, Ye.readToken_mult_modulo_exp = function (p) { var _ = this.input.charCodeAt(this.pos + 1), D = 1, A = p === 42 ? v.star : v.modulo; return this.options.ecmaVersion >= 7 && p === 42 && _ === 42 && (++D, A = v.starstar, _ = this.input.charCodeAt(this.pos + 2)), _ === 61 ? this.finishOp(v.assign, D + 1) : this.finishOp(A, D) }, Ye.readToken_pipe_amp = function (p) { var _ = this.input.charCodeAt(this.pos + 1); if (_ === p) { if (this.options.ecmaVersion >= 12) { var D = this.input.charCodeAt(this.pos + 2); if (D === 61) return this.finishOp(v.assign, 3) } return this.finishOp(p === 124 ? v.logicalOR : v.logicalAND, 2) } return _ === 61 ? this.finishOp(v.assign, 2) : this.finishOp(p === 124 ? v.bitwiseOR : v.bitwiseAND, 1) }, Ye.readToken_caret = function () { var p = this.input.charCodeAt(this.pos + 1); return p === 61 ? this.finishOp(v.assign, 2) : this.finishOp(v.bitwiseXOR, 1) }, Ye.readToken_plus_min = function (p) { var _ = this.input.charCodeAt(this.pos + 1); return _ === p ? _ === 45 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 62 && (this.lastTokEnd === 0 || T.test(this.input.slice(this.lastTokEnd, this.pos))) ? (this.skipLineComment(3), this.skipSpace(), this.nextToken()) : this.finishOp(v.incDec, 2) : _ === 61 ? this.finishOp(v.assign, 2) : this.finishOp(v.plusMin, 1) }, Ye.readToken_lt_gt = function (p) { var _ = this.input.charCodeAt(this.pos + 1), D = 1; return _ === p ? (D = p === 62 && this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2, this.input.charCodeAt(this.pos + D) === 61 ? this.finishOp(v.assign, D + 1) : this.finishOp(v.bitShift, D)) : _ === 33 && p === 60 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 45 && this.input.charCodeAt(this.pos + 3) === 45 ? (this.skipLineComment(4), this.skipSpace(), this.nextToken()) : (_ === 61 && (D = 2), this.finishOp(v.relational, D)) }, Ye.readToken_eq_excl = function (p) { var _ = this.input.charCodeAt(this.pos + 1); return _ === 61 ? this.finishOp(v.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2) : p === 61 && _ === 62 && this.options.ecmaVersion >= 6 ? (this.pos += 2, this.finishToken(v.arrow)) : this.finishOp(p === 61 ? v.eq : v.prefix, 1) }, Ye.readToken_question = function () { var p = this.options.ecmaVersion; if (p >= 11) { var _ = this.input.charCodeAt(this.pos + 1); if (_ === 46) { var D = this.input.charCodeAt(this.pos + 2); if (D < 48 || D > 57) return this.finishOp(v.questionDot, 2) } if (_ === 63) { if (p >= 12) { var A = this.input.charCodeAt(this.pos + 2); if (A === 61) return this.finishOp(v.assign, 3) } return this.finishOp(v.coalesce, 2) } } return this.finishOp(v.question, 1) }, Ye.readToken_numberSign = function () { var p = this.options.ecmaVersion, _ = 35; if (p >= 13 && (++this.pos, _ = this.fullCharCodeAtPos(), b(_, !0) || _ === 92)) return this.finishToken(v.privateId, this.readWord1()); this.raise(this.pos, "Unexpected character '" + $(_) + "'") }, Ye.getTokenFromCode = function (p) { switch (p) { case 46: return this.readToken_dot(); case 40: return ++this.pos, this.finishToken(v.parenL); case 41: return ++this.pos, this.finishToken(v.parenR); case 59: return ++this.pos, this.finishToken(v.semi); case 44: return ++this.pos, this.finishToken(v.comma); case 91: return ++this.pos, this.finishToken(v.bracketL); case 93: return ++this.pos, this.finishToken(v.bracketR); case 123: return ++this.pos, this.finishToken(v.braceL); case 125: return ++this.pos, this.finishToken(v.braceR); case 58: return ++this.pos, this.finishToken(v.colon); case 96: if (this.options.ecmaVersion < 6) break; return ++this.pos, this.finishToken(v.backQuote); case 48: var _ = this.input.charCodeAt(this.pos + 1); if (_ === 120 || _ === 88) return this.readRadixNumber(16); if (this.options.ecmaVersion >= 6) { if (_ === 111 || _ === 79) return this.readRadixNumber(8); if (_ === 98 || _ === 66) return this.readRadixNumber(2) } case 49: case 50: case 51: case 52: case 53: case 54: case 55: case 56: case 57: return this.readNumber(!1); case 34: case 39: return this.readString(p); case 47: return this.readToken_slash(); case 37: case 42: return this.readToken_mult_modulo_exp(p); case 124: case 38: return this.readToken_pipe_amp(p); case 94: return this.readToken_caret(); case 43: case 45: return this.readToken_plus_min(p); case 60: case 62: return this.readToken_lt_gt(p); case 61: case 33: return this.readToken_eq_excl(p); case 63: return this.readToken_question(); case 126: return this.finishOp(v.prefix, 1); case 35: return this.readToken_numberSign() }this.raise(this.pos, "Unexpected character '" + $(p) + "'") }, Ye.finishOp = function (p, _) { var D = this.input.slice(this.pos, this.pos + _); return this.pos += _, this.finishToken(p, D) }, Ye.readRegexp = function () { for (var p, _, D = this.pos; ;) { this.pos >= this.input.length && this.raise(D, "Unterminated regular expression"); var A = this.input.charAt(this.pos); if (T.test(A) && this.raise(D, "Unterminated regular expression"), p) p = !1; else { if (A === "[") _ = !0; else if (A === "]" && _) _ = !1; else if (A === "/" && !_) break; p = A === "\\" } ++this.pos } var V = this.input.slice(D, this.pos); ++this.pos; var Y = this.pos, q = this.readWord1(); this.containsEsc && this.unexpected(Y); var oe = this.regexpState || (this.regexpState = new Oi(this)); oe.reset(D, V, q), this.validateRegExpFlags(oe), this.validateRegExpPattern(oe); var ce = null; try { ce = new RegExp(V, q) } catch { } return this.finishToken(v.regexp, { pattern: V, flags: q, value: ce }) }, Ye.readInt = function (p, _, D) { for (var A = this.options.ecmaVersion >= 12 && _ === void 0, V = D && this.input.charCodeAt(this.pos) === 48, Y = this.pos, q = 0, oe = 0, ce = 0, Le = _ ?? 1 / 0; ce < Le; ++ce, ++this.pos) { var Ne = this.input.charCodeAt(this.pos), In = void 0; if (A && Ne === 95) { V && this.raiseRecoverable(this.pos, "Numeric separator is not allowed in legacy octal numeric literals"), oe === 95 && this.raiseRecoverable(this.pos, "Numeric separator must be exactly one underscore"), ce === 0 && this.raiseRecoverable(this.pos, "Numeric separator is not allowed at the first of digits"), oe = Ne; continue } if (Ne >= 97 ? In = Ne - 97 + 10 : Ne >= 65 ? In = Ne - 65 + 10 : Ne >= 48 && Ne <= 57 ? In = Ne - 48 : In = 1 / 0, In >= p) break; oe = Ne, q = q * p + In } return A && oe === 95 && this.raiseRecoverable(this.pos - 1, "Numeric separator is not allowed at the last of digits"), this.pos === Y || _ != null && this.pos - Y !== _ ? null : q }; function ZI(p, _) { return _ ? parseInt(p, 8) : parseFloat(p.replace(/_/g, "")) } function tv(p) { return typeof BigInt != "function" ? null : BigInt(p.replace(/_/g, "")) } Ye.readRadixNumber = function (p) { var _ = this.pos; this.pos += 2; var D = this.readInt(p); return D == null && this.raise(this.start + 2, "Expected number in radix " + p), this.options.ecmaVersion >= 11 && this.input.charCodeAt(this.pos) === 110 ? (D = tv(this.input.slice(_, this.pos)), ++this.pos) : b(this.fullCharCodeAtPos()) && this.raise(this.pos, "Identifier directly after number"), this.finishToken(v.num, D) }, Ye.readNumber = function (p) { var _ = this.pos; !p && this.readInt(10, void 0, !0) === null && this.raise(_, "Invalid number"); var D = this.pos - _ >= 2 && this.input.charCodeAt(_) === 48; D && this.strict && this.raise(_, "Invalid number"); var A = this.input.charCodeAt(this.pos); if (!D && !p && this.options.ecmaVersion >= 11 && A === 110) { var V = tv(this.input.slice(_, this.pos)); return ++this.pos, b(this.fullCharCodeAtPos()) && this.raise(this.pos, "Identifier directly after number"), this.finishToken(v.num, V) } D && /[89]/.test(this.input.slice(_, this.pos)) && (D = !1), A === 46 && !D && (++this.pos, this.readInt(10), A = this.input.charCodeAt(this.pos)), (A === 69 || A === 101) && !D && (A = this.input.charCodeAt(++this.pos), (A === 43 || A === 45) && ++this.pos, this.readInt(10) === null && this.raise(_, "Invalid number")), b(this.fullCharCodeAtPos()) && this.raise(this.pos, "Identifier directly after number"); var Y = ZI(this.input.slice(_, this.pos), D); return this.finishToken(v.num, Y) }, Ye.readCodePoint = function () { var p = this.input.charCodeAt(this.pos), _; if (p === 123) { this.options.ecmaVersion < 6 && this.unexpected(); var D = ++this.pos; _ = this.readHexChar(this.input.indexOf("}", this.pos) - this.pos), ++this.pos, _ > 1114111 && this.invalidStringToken(D, "Code point out of bounds") } else _ = this.readHexChar(4); return _ }, Ye.readString = function (p) { for (var _ = "", D = ++this.pos; ;) { this.pos >= this.input.length && this.raise(this.start, "Unterminated string constant"); var A = this.input.charCodeAt(this.pos); if (A === p) break; A === 92 ? (_ += this.input.slice(D, this.pos), _ += this.readEscapedChar(!1), D = this.pos) : A === 8232 || A === 8233 ? (this.options.ecmaVersion < 10 && this.raise(this.start, "Unterminated string constant"), ++this.pos, this.options.locations && (this.curLine++, this.lineStart = this.pos)) : (k(A) && this.raise(this.start, "Unterminated string constant"), ++this.pos) } return _ += this.input.slice(D, this.pos++), this.finishToken(v.string, _) }; var nv = {}; Ye.tryReadTemplateToken = function () { this.inTemplateElement = !0; try { this.readTmplToken() } catch (p) { if (p === nv) this.readInvalidTemplateToken(); else throw p } this.inTemplateElement = !1 }, Ye.invalidStringToken = function (p, _) { if (this.inTemplateElement && this.options.ecmaVersion >= 9) throw nv; this.raise(p, _) }, Ye.readTmplToken = function () {
        for (var p = "", _ = this.pos; ;) {
          this.pos >= this.input.length && this.raise(this.start, "Unterminated template"); var D = this.input.charCodeAt(this.pos); if (D === 96 || D === 36 && this.input.charCodeAt(this.pos + 1) === 123) return this.pos === this.start && (this.type === v.template || this.type === v.invalidTemplate) ? D === 36 ? (this.pos += 2, this.finishToken(v.dollarBraceL)) : (++this.pos, this.finishToken(v.backQuote)) : (p += this.input.slice(_, this.pos), this.finishToken(v.template, p)); if (D === 92) p += this.input.slice(_, this.pos), p += this.readEscapedChar(!0), _ = this.pos; else if (k(D)) {
            switch (p += this.input.slice(_, this.pos), ++this.pos, D) {
              case 13: this.input.charCodeAt(this.pos) === 10 && ++this.pos; case 10: p += `
`; break; default: p += String.fromCharCode(D); break
            }this.options.locations && (++this.curLine, this.lineStart = this.pos), _ = this.pos
          } else ++this.pos
        }
      }, Ye.readInvalidTemplateToken = function () {
        for (; this.pos < this.input.length; this.pos++)switch (this.input[this.pos]) {
          case "\\": ++this.pos; break; case "$": if (this.input[this.pos + 1] !== "{") break; case "`": return this.finishToken(v.invalidTemplate, this.input.slice(this.start, this.pos)); case "\r": this.input[this.pos + 1] === `
`&& ++this.pos; case `
`: case "\u2028": case "\u2029": ++this.curLine, this.lineStart = this.pos + 1; break
        }this.raise(this.start, "Unterminated template")
      }, Ye.readEscapedChar = function (p) {
        var _ = this.input.charCodeAt(++this.pos); switch (++this.pos, _) {
          case 110: return `
`; case 114: return "\r"; case 120: return String.fromCharCode(this.readHexChar(2)); case 117: return $(this.readCodePoint()); case 116: return "	"; case 98: return "\b"; case 118: return "\v"; case 102: return "\f"; case 13: this.input.charCodeAt(this.pos) === 10 && ++this.pos; case 10: return this.options.locations && (this.lineStart = this.pos, ++this.curLine), ""; case 56: case 57: if (this.strict && this.invalidStringToken(this.pos - 1, "Invalid escape sequence"), p) { var D = this.pos - 1; this.invalidStringToken(D, "Invalid escape sequence in template string") } default: if (_ >= 48 && _ <= 55) { var A = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0], V = parseInt(A, 8); return V > 255 && (A = A.slice(0, -1), V = parseInt(A, 8)), this.pos += A.length - 1, _ = this.input.charCodeAt(this.pos), (A !== "0" || _ === 56 || _ === 57) && (this.strict || p) && this.invalidStringToken(this.pos - 1 - A.length, p ? "Octal literal in template string" : "Octal literal in strict mode"), String.fromCharCode(V) } return k(_) ? (this.options.locations && (this.lineStart = this.pos, ++this.curLine), "") : String.fromCharCode(_)
        }
      }, Ye.readHexChar = function (p) { var _ = this.pos, D = this.readInt(16, p); return D === null && this.invalidStringToken(_, "Bad character escape sequence"), D }, Ye.readWord1 = function () { this.containsEsc = !1; for (var p = "", _ = !0, D = this.pos, A = this.options.ecmaVersion >= 6; this.pos < this.input.length;) { var V = this.fullCharCodeAtPos(); if (y(V, A)) this.pos += V <= 65535 ? 1 : 2; else if (V === 92) { this.containsEsc = !0, p += this.input.slice(D, this.pos); var Y = this.pos; this.input.charCodeAt(++this.pos) !== 117 && this.invalidStringToken(this.pos, "Expecting Unicode escape sequence \\uXXXX"), ++this.pos; var q = this.readCodePoint(); (_ ? b : y)(q, A) || this.invalidStringToken(Y, "Invalid Unicode escape"), p += $(q), D = this.pos } else break; _ = !1 } return p + this.input.slice(D, this.pos) }, Ye.readWord = function () { var p = this.readWord1(), _ = v.name; return this.keywords.test(p) && (_ = O[p]), this.finishToken(_, p) }; var rv = "8.14.0"; X.acorn = { Parser: X, version: rv, defaultOptions: be, Position: re, SourceLocation: j, getLineInfo: ae, Node: Kn, TokenType: w, tokTypes: v, keywordTypes: O, TokContext: Sn, tokContexts: Ie, isIdentifierChar: y, isIdentifierStart: b, Token: Xc, isNewLine: k, lineBreak: T, lineBreakG: I, nonASCIIwhitespace: N }; function JI(p, _) { return X.parse(p, _) } function QI(p, _, D) { return X.parseExpressionAt(p, _, D) } function eP(p, _) { return X.tokenizer(p, _) } t.Node = Kn, t.Parser = X, t.Position = re, t.SourceLocation = j, t.TokContext = Sn, t.Token = Xc, t.TokenType = w, t.defaultOptions = be, t.getLineInfo = ae, t.isIdentifierChar = y, t.isIdentifierStart = b, t.isNewLine = k, t.keywordTypes = O, t.lineBreak = T, t.lineBreakG = I, t.nonASCIIwhitespace = N, t.parse = JI, t.parseExpressionAt = QI, t.tokContexts = Ie, t.tokTypes = v, t.tokenizer = eP, t.version = rv
    })
  }(gu, gu.exports)), gu.exports
} (function (r) {
  const e = Mse, t = /^[\da-fA-F]+$/, n = /^\d+$/, i = new WeakMap; function s(l) { l = l.Parser.acorn || l; let u = i.get(l); if (!u) { const d = l.tokTypes, h = l.TokContext, g = l.TokenType, m = new h("<tag", !1), b = new h("</tag", !1), y = new h("<tag>...</tag>", !0, !0), w = { tc_oTag: m, tc_cTag: b, tc_expr: y }, x = { jsxName: new g("jsxName"), jsxText: new g("jsxText", { beforeExpr: !0 }), jsxTagStart: new g("jsxTagStart", { startsExpr: !0 }), jsxTagEnd: new g("jsxTagEnd") }; x.jsxTagStart.updateContext = function () { this.context.push(y), this.context.push(m), this.exprAllowed = !1 }, x.jsxTagEnd.updateContext = function (S) { let C = this.context.pop(); C === m && S === d.slash || C === b ? (this.context.pop(), this.exprAllowed = this.curContext() === y) : this.exprAllowed = !0 }, u = { tokContexts: w, tokTypes: x }, i.set(l, u) } return u } function a(l) { if (!l) return l; if (l.type === "JSXIdentifier") return l.name; if (l.type === "JSXNamespacedName") return l.namespace.name + ":" + l.name.name; if (l.type === "JSXMemberExpression") return a(l.object) + "." + a(l.property) } r.exports = function (l) { return l = l || {}, function (u) { return o({ allowNamespaces: l.allowNamespaces !== !1, allowNamespacedObjects: !!l.allowNamespacedObjects }, u) } }, Object.defineProperty(r.exports, "tokTypes", { get: function () { return s(Jg()).tokTypes }, configurable: !0, enumerable: !0 }); function o(l, u) {
    const d = u.acorn || Jg(), h = s(d), g = d.tokTypes, m = h.tokTypes, b = d.tokContexts, y = h.tokContexts.tc_oTag, w = h.tokContexts.tc_cTag, x = h.tokContexts.tc_expr, S = d.isNewLine, C = d.isIdentifierStart, O = d.isIdentifierChar; return class extends u {
      static get acornJsx() { return h } jsx_readToken() { let E = "", v = this.pos; for (; ;) { this.pos >= this.input.length && this.raise(this.start, "Unterminated JSX contents"); let T = this.input.charCodeAt(this.pos); switch (T) { case 60: case 123: return this.pos === this.start ? T === 60 && this.exprAllowed ? (++this.pos, this.finishToken(m.jsxTagStart)) : this.getTokenFromCode(T) : (E += this.input.slice(v, this.pos), this.finishToken(m.jsxText, E)); case 38: E += this.input.slice(v, this.pos), E += this.jsx_readEntity(), v = this.pos; break; case 62: case 125: this.raise(this.pos, "Unexpected token `" + this.input[this.pos] + "`. Did you mean `" + (T === 62 ? "&gt;" : "&rbrace;") + '` or `{"' + this.input[this.pos] + '"}`?'); default: S(T) ? (E += this.input.slice(v, this.pos), E += this.jsx_readNewLine(!0), v = this.pos) : ++this.pos } } } jsx_readNewLine(E) {
        let v = this.input.charCodeAt(this.pos), T; return ++this.pos, v === 13 && this.input.charCodeAt(this.pos) === 10 ? (++this.pos, T = E ? `
`: `\r
`) : T = String.fromCharCode(v), this.options.locations && (++this.curLine, this.lineStart = this.pos), T
      } jsx_readString(E) { let v = "", T = ++this.pos; for (; ;) { this.pos >= this.input.length && this.raise(this.start, "Unterminated string constant"); let I = this.input.charCodeAt(this.pos); if (I === E) break; I === 38 ? (v += this.input.slice(T, this.pos), v += this.jsx_readEntity(), T = this.pos) : S(I) ? (v += this.input.slice(T, this.pos), v += this.jsx_readNewLine(!1), T = this.pos) : ++this.pos } return v += this.input.slice(T, this.pos++), this.finishToken(g.string, v) } jsx_readEntity() { let E = "", v = 0, T, I = this.input[this.pos]; I !== "&" && this.raise(this.pos, "Entity must start with an ampersand"); let k = ++this.pos; for (; this.pos < this.input.length && v++ < 10;) { if (I = this.input[this.pos++], I === ";") { E[0] === "#" ? E[1] === "x" ? (E = E.substr(2), t.test(E) && (T = String.fromCharCode(parseInt(E, 16)))) : (E = E.substr(1), n.test(E) && (T = String.fromCharCode(parseInt(E, 10)))) : T = e[E]; break } E += I } return T || (this.pos = k, "&") } jsx_readWord() { let E, v = this.pos; do E = this.input.charCodeAt(++this.pos); while (O(E) || E === 45); return this.finishToken(m.jsxName, this.input.slice(v, this.pos)) } jsx_parseIdentifier() { let E = this.startNode(); return this.type === m.jsxName ? E.name = this.value : this.type.keyword ? E.name = this.type.keyword : this.unexpected(), this.next(), this.finishNode(E, "JSXIdentifier") } jsx_parseNamespacedName() { let E = this.start, v = this.startLoc, T = this.jsx_parseIdentifier(); if (!l.allowNamespaces || !this.eat(g.colon)) return T; var I = this.startNodeAt(E, v); return I.namespace = T, I.name = this.jsx_parseIdentifier(), this.finishNode(I, "JSXNamespacedName") } jsx_parseElementName() { if (this.type === m.jsxTagEnd) return ""; let E = this.start, v = this.startLoc, T = this.jsx_parseNamespacedName(); for (this.type === g.dot && T.type === "JSXNamespacedName" && !l.allowNamespacedObjects && this.unexpected(); this.eat(g.dot);) { let I = this.startNodeAt(E, v); I.object = T, I.property = this.jsx_parseIdentifier(), T = this.finishNode(I, "JSXMemberExpression") } return T } jsx_parseAttributeValue() { switch (this.type) { case g.braceL: let E = this.jsx_parseExpressionContainer(); return E.expression.type === "JSXEmptyExpression" && this.raise(E.start, "JSX attributes must only be assigned a non-empty expression"), E; case m.jsxTagStart: case g.string: return this.parseExprAtom(); default: this.raise(this.start, "JSX value should be either an expression or a quoted JSX text") } } jsx_parseEmptyExpression() { let E = this.startNodeAt(this.lastTokEnd, this.lastTokEndLoc); return this.finishNodeAt(E, "JSXEmptyExpression", this.start, this.startLoc) } jsx_parseExpressionContainer() { let E = this.startNode(); return this.next(), E.expression = this.type === g.braceR ? this.jsx_parseEmptyExpression() : this.parseExpression(), this.expect(g.braceR), this.finishNode(E, "JSXExpressionContainer") } jsx_parseAttribute() { let E = this.startNode(); return this.eat(g.braceL) ? (this.expect(g.ellipsis), E.argument = this.parseMaybeAssign(), this.expect(g.braceR), this.finishNode(E, "JSXSpreadAttribute")) : (E.name = this.jsx_parseNamespacedName(), E.value = this.eat(g.eq) ? this.jsx_parseAttributeValue() : null, this.finishNode(E, "JSXAttribute")) } jsx_parseOpeningElementAt(E, v) { let T = this.startNodeAt(E, v); T.attributes = []; let I = this.jsx_parseElementName(); for (I && (T.name = I); this.type !== g.slash && this.type !== m.jsxTagEnd;)T.attributes.push(this.jsx_parseAttribute()); return T.selfClosing = this.eat(g.slash), this.expect(m.jsxTagEnd), this.finishNode(T, I ? "JSXOpeningElement" : "JSXOpeningFragment") } jsx_parseClosingElementAt(E, v) { let T = this.startNodeAt(E, v), I = this.jsx_parseElementName(); return I && (T.name = I), this.expect(m.jsxTagEnd), this.finishNode(T, I ? "JSXClosingElement" : "JSXClosingFragment") } jsx_parseElementAt(E, v) { let T = this.startNodeAt(E, v), I = [], k = this.jsx_parseOpeningElementAt(E, v), P = null; if (!k.selfClosing) { e: for (; ;)switch (this.type) { case m.jsxTagStart: if (E = this.start, v = this.startLoc, this.next(), this.eat(g.slash)) { P = this.jsx_parseClosingElementAt(E, v); break e } I.push(this.jsx_parseElementAt(E, v)); break; case m.jsxText: I.push(this.parseExprAtom()); break; case g.braceL: I.push(this.jsx_parseExpressionContainer()); break; default: this.unexpected() }a(P.name) !== a(k.name) && this.raise(P.start, "Expected corresponding JSX closing tag for <" + a(k.name) + ">") } let N = k.name ? "Element" : "Fragment"; return T["opening" + N] = k, T["closing" + N] = P, T.children = I, this.type === g.relational && this.value === "<" && this.raise(this.start, "Adjacent JSX elements must be wrapped in an enclosing tag"), this.finishNode(T, "JSX" + N) } jsx_parseText() { let E = this.parseLiteral(this.value); return E.type = "JSXText", E } jsx_parseElement() { let E = this.start, v = this.startLoc; return this.next(), this.jsx_parseElementAt(E, v) } parseExprAtom(E) { return this.type === m.jsxText ? this.jsx_parseText() : this.type === m.jsxTagStart ? this.jsx_parseElement() : super.parseExprAtom(E) } readToken(E) { let v = this.curContext(); if (v === x) return this.jsx_readToken(); if (v === y || v === w) { if (C(E)) return this.jsx_readWord(); if (E == 62) return ++this.pos, this.finishToken(m.jsxTagEnd); if ((E === 34 || E === 39) && v == y) return this.jsx_readString(E) } return E === 60 && this.exprAllowed && this.input.charCodeAt(this.pos + 1) !== 33 ? (++this.pos, this.finishToken(m.jsxTagStart)) : super.readToken(E) } updateContext(E) { if (this.type == g.braceL) { var v = this.curContext(); v == y ? this.context.push(b.b_expr) : v == x ? this.context.push(b.b_tmpl) : super.updateContext(E), this.exprAllowed = !0 } else if (this.type === g.slash && E === m.jsxTagStart) this.context.length -= 2, this.context.push(w), this.exprAllowed = !1; else return super.updateContext(E) }
    }
  }
})(uT); var jse = uT.exports; const dT = _e(jse), { stringify: Vse } = JSON; if (!String.prototype.repeat) throw new Error("String.prototype.repeat is undefined, see https://github.com/davidbonnet/astring#installation"); if (!String.prototype.endsWith) throw new Error("String.prototype.endsWith is undefined, see https://github.com/davidbonnet/astring#installation"); const mu = { "||": 2, "??": 3, "&&": 4, "|": 5, "^": 6, "&": 7, "==": 8, "!=": 8, "===": 8, "!==": 8, "<": 9, ">": 9, "<=": 9, ">=": 9, in: 9, instanceof: 9, "<<": 10, ">>": 10, ">>>": 10, "+": 11, "-": 11, "*": 12, "%": 12, "/": 12, "**": 13 }, ci = 17, Bse = { ArrayExpression: 20, TaggedTemplateExpression: 20, ThisExpression: 20, Identifier: 20, PrivateIdentifier: 20, Literal: 18, TemplateLiteral: 20, Super: 20, SequenceExpression: 20, MemberExpression: 19, ChainExpression: 19, CallExpression: 19, NewExpression: 19, ArrowFunctionExpression: ci, ClassExpression: ci, FunctionExpression: ci, ObjectExpression: ci, UpdateExpression: 16, UnaryExpression: 15, AwaitExpression: 15, BinaryExpression: 14, LogicalExpression: 13, ConditionalExpression: 4, AssignmentExpression: 3, YieldExpression: 2, RestElement: 1 }; function Za(r, e) { const { generator: t } = r; if (r.write("("), e != null && e.length > 0) { t[e[0].type](e[0], r); const { length: n } = e; for (let i = 1; i < n; i++) { const s = e[i]; r.write(", "), t[s.type](s, r) } } r.write(")") } function hT(r, e, t, n) { const i = r.expressionsPrecedence[e.type]; if (i === ci) return !0; const s = r.expressionsPrecedence[t.type]; return i !== s ? !n && i === 15 && s === 14 && t.operator === "**" || i < s : i !== 13 && i !== 14 ? !1 : e.operator === "**" && t.operator === "**" ? !n : i === 13 && s === 13 && (e.operator === "??" || t.operator === "??") ? !0 : n ? mu[e.operator] <= mu[t.operator] : mu[e.operator] < mu[t.operator] } function yu(r, e, t, n) { const { generator: i } = r; hT(r, e, t, n) ? (r.write("("), i[e.type](e, r), r.write(")")) : i[e.type](e, r) } function zse(r, e, t, n) {
  const i = e.split(`
`), s = i.length - 1; if (r.write(i[0].trim()), s > 0) { r.write(n); for (let a = 1; a < s; a++)r.write(t + i[a].trim() + n); r.write(t + i[s].trim()) }
} function nr(r, e, t, n) {
  const { length: i } = e; for (let s = 0; s < i; s++) {
    const a = e[s]; r.write(t), a.type[0] === "L" ? r.write("// " + a.value.trim() + `
`, a) : (r.write("/*"), zse(r, a.value, t, n), r.write("*/" + n))
  }
} function Hse(r) { let e = r; for (; e != null;) { const { type: t } = e; if (t[0] === "C" && t[1] === "a") return !0; if (t[0] === "M" && t[1] === "e" && t[2] === "m") e = e.object; else return !1 } } function qp(r, e) { const { generator: t } = r, { declarations: n } = e; r.write(e.kind + " "); const { length: i } = n; if (i > 0) { t.VariableDeclarator(n[0], r); for (let s = 1; s < i; s++)r.write(", "), t.VariableDeclarator(n[s], r) } } let Vw, Bw, zw, Hw, Kw, Uw; const pT = { Program(r, e) { const t = e.indent.repeat(e.indentLevel), { lineEnd: n, writeComments: i } = e; i && r.comments != null && nr(e, r.comments, t, n); const s = r.body, { length: a } = s; for (let o = 0; o < a; o++) { const l = s[o]; i && l.comments != null && nr(e, l.comments, t, n), e.write(t), this[l.type](l, e), e.write(n) } i && r.trailingComments != null && nr(e, r.trailingComments, t, n) }, BlockStatement: Uw = function (r, e) { const t = e.indent.repeat(e.indentLevel++), { lineEnd: n, writeComments: i } = e, s = t + e.indent; e.write("{"); const a = r.body; if (a != null && a.length > 0) { e.write(n), i && r.comments != null && nr(e, r.comments, s, n); const { length: o } = a; for (let l = 0; l < o; l++) { const u = a[l]; i && u.comments != null && nr(e, u.comments, s, n), e.write(s), this[u.type](u, e), e.write(n) } e.write(t) } else i && r.comments != null && (e.write(n), nr(e, r.comments, s, n), e.write(t)); i && r.trailingComments != null && nr(e, r.trailingComments, s, n), e.write("}"), e.indentLevel-- }, ClassBody: Uw, StaticBlock(r, e) { e.write("static "), this.BlockStatement(r, e) }, EmptyStatement(r, e) { e.write(";") }, ExpressionStatement(r, e) { const t = e.expressionsPrecedence[r.expression.type]; t === ci || t === 3 && r.expression.left.type[0] === "O" ? (e.write("("), this[r.expression.type](r.expression, e), e.write(")")) : this[r.expression.type](r.expression, e), e.write(";") }, IfStatement(r, e) { e.write("if ("), this[r.test.type](r.test, e), e.write(") "), this[r.consequent.type](r.consequent, e), r.alternate != null && (e.write(" else "), this[r.alternate.type](r.alternate, e)) }, LabeledStatement(r, e) { this[r.label.type](r.label, e), e.write(": "), this[r.body.type](r.body, e) }, BreakStatement(r, e) { e.write("break"), r.label != null && (e.write(" "), this[r.label.type](r.label, e)), e.write(";") }, ContinueStatement(r, e) { e.write("continue"), r.label != null && (e.write(" "), this[r.label.type](r.label, e)), e.write(";") }, WithStatement(r, e) { e.write("with ("), this[r.object.type](r.object, e), e.write(") "), this[r.body.type](r.body, e) }, SwitchStatement(r, e) { const t = e.indent.repeat(e.indentLevel++), { lineEnd: n, writeComments: i } = e; e.indentLevel++; const s = t + e.indent, a = s + e.indent; e.write("switch ("), this[r.discriminant.type](r.discriminant, e), e.write(") {" + n); const { cases: o } = r, { length: l } = o; for (let u = 0; u < l; u++) { const d = o[u]; i && d.comments != null && nr(e, d.comments, s, n), d.test ? (e.write(s + "case "), this[d.test.type](d.test, e), e.write(":" + n)) : e.write(s + "default:" + n); const { consequent: h } = d, { length: g } = h; for (let m = 0; m < g; m++) { const b = h[m]; i && b.comments != null && nr(e, b.comments, a, n), e.write(a), this[b.type](b, e), e.write(n) } } e.indentLevel -= 2, e.write(t + "}") }, ReturnStatement(r, e) { e.write("return"), r.argument && (e.write(" "), this[r.argument.type](r.argument, e)), e.write(";") }, ThrowStatement(r, e) { e.write("throw "), this[r.argument.type](r.argument, e), e.write(";") }, TryStatement(r, e) { if (e.write("try "), this[r.block.type](r.block, e), r.handler) { const { handler: t } = r; t.param == null ? e.write(" catch ") : (e.write(" catch ("), this[t.param.type](t.param, e), e.write(") ")), this[t.body.type](t.body, e) } r.finalizer && (e.write(" finally "), this[r.finalizer.type](r.finalizer, e)) }, WhileStatement(r, e) { e.write("while ("), this[r.test.type](r.test, e), e.write(") "), this[r.body.type](r.body, e) }, DoWhileStatement(r, e) { e.write("do "), this[r.body.type](r.body, e), e.write(" while ("), this[r.test.type](r.test, e), e.write(");") }, ForStatement(r, e) { if (e.write("for ("), r.init != null) { const { init: t } = r; t.type[0] === "V" ? qp(e, t) : this[t.type](t, e) } e.write("; "), r.test && this[r.test.type](r.test, e), e.write("; "), r.update && this[r.update.type](r.update, e), e.write(") "), this[r.body.type](r.body, e) }, ForInStatement: Vw = function (r, e) { e.write(`for ${r.await ? "await " : ""}(`); const { left: t } = r; t.type[0] === "V" ? qp(e, t) : this[t.type](t, e), e.write(r.type[3] === "I" ? " in " : " of "), this[r.right.type](r.right, e), e.write(") "), this[r.body.type](r.body, e) }, ForOfStatement: Vw, DebuggerStatement(r, e) { e.write("debugger;", r) }, FunctionDeclaration: Bw = function (r, e) { e.write((r.async ? "async " : "") + (r.generator ? "function* " : "function ") + (r.id ? r.id.name : ""), r), Za(e, r.params), e.write(" "), this[r.body.type](r.body, e) }, FunctionExpression: Bw, VariableDeclaration(r, e) { qp(e, r), e.write(";") }, VariableDeclarator(r, e) { this[r.id.type](r.id, e), r.init != null && (e.write(" = "), this[r.init.type](r.init, e)) }, ClassDeclaration(r, e) { if (e.write("class " + (r.id ? `${r.id.name} ` : ""), r), r.superClass) { e.write("extends "); const { superClass: t } = r, { type: n } = t, i = e.expressionsPrecedence[n]; (n[0] !== "C" || n[1] !== "l" || n[5] !== "E") && (i === ci || i < e.expressionsPrecedence.ClassExpression) ? (e.write("("), this[r.superClass.type](t, e), e.write(")")) : this[t.type](t, e), e.write(" ") } this.ClassBody(r.body, e) }, ImportDeclaration(r, e) { e.write("import "); const { specifiers: t, attributes: n } = r, { length: i } = t; let s = 0; if (i > 0) { for (; s < i;) { s > 0 && e.write(", "); const a = t[s], o = a.type[6]; if (o === "D") e.write(a.local.name, a), s++; else if (o === "N") e.write("* as " + a.local.name, a), s++; else break } if (s < i) { for (e.write("{"); ;) { const a = t[s], { name: o } = a.imported; if (e.write(o, a), o !== a.local.name && e.write(" as " + a.local.name), ++s < i) e.write(", "); else break } e.write("}") } e.write(" from ") } if (this.Literal(r.source, e), n && n.length > 0) { e.write(" with { "); for (let a = 0; a < n.length; a++)this.ImportAttribute(n[a], e), a < n.length - 1 && e.write(", "); e.write(" }") } e.write(";") }, ImportAttribute(r, e) { this.Identifier(r.key, e), e.write(": "), this.Literal(r.value, e) }, ImportExpression(r, e) { e.write("import("), this[r.source.type](r.source, e), e.write(")") }, ExportDefaultDeclaration(r, e) { e.write("export default "), this[r.declaration.type](r.declaration, e), e.expressionsPrecedence[r.declaration.type] != null && r.declaration.type[0] !== "F" && e.write(";") }, ExportNamedDeclaration(r, e) { if (e.write("export "), r.declaration) this[r.declaration.type](r.declaration, e); else { e.write("{"); const { specifiers: t } = r, { length: n } = t; if (n > 0) for (let i = 0; ;) { const s = t[i], { name: a } = s.local; if (e.write(a, s), a !== s.exported.name && e.write(" as " + s.exported.name), ++i < n) e.write(", "); else break } if (e.write("}"), r.source && (e.write(" from "), this.Literal(r.source, e)), r.attributes && r.attributes.length > 0) { e.write(" with { "); for (let i = 0; i < r.attributes.length; i++)this.ImportAttribute(r.attributes[i], e), i < r.attributes.length - 1 && e.write(", "); e.write(" }") } e.write(";") } }, ExportAllDeclaration(r, e) { if (r.exported != null ? e.write("export * as " + r.exported.name + " from ") : e.write("export * from "), this.Literal(r.source, e), r.attributes && r.attributes.length > 0) { e.write(" with { "); for (let t = 0; t < r.attributes.length; t++)this.ImportAttribute(r.attributes[t], e), t < r.attributes.length - 1 && e.write(", "); e.write(" }") } e.write(";") }, MethodDefinition(r, e) { r.static && e.write("static "); const t = r.kind[0]; (t === "g" || t === "s") && e.write(r.kind + " "), r.value.async && e.write("async "), r.value.generator && e.write("*"), r.computed ? (e.write("["), this[r.key.type](r.key, e), e.write("]")) : this[r.key.type](r.key, e), Za(e, r.value.params), e.write(" "), this[r.value.body.type](r.value.body, e) }, ClassExpression(r, e) { this.ClassDeclaration(r, e) }, ArrowFunctionExpression(r, e) { e.write(r.async ? "async " : "", r); const { params: t } = r; t != null && (t.length === 1 && t[0].type[0] === "I" ? e.write(t[0].name, t[0]) : Za(e, r.params)), e.write(" => "), r.body.type[0] === "O" ? (e.write("("), this.ObjectExpression(r.body, e), e.write(")")) : this[r.body.type](r.body, e) }, ThisExpression(r, e) { e.write("this", r) }, Super(r, e) { e.write("super", r) }, RestElement: zw = function (r, e) { e.write("..."), this[r.argument.type](r.argument, e) }, SpreadElement: zw, YieldExpression(r, e) { e.write(r.delegate ? "yield*" : "yield"), r.argument && (e.write(" "), this[r.argument.type](r.argument, e)) }, AwaitExpression(r, e) { e.write("await ", r), yu(e, r.argument, r) }, TemplateLiteral(r, e) { const { quasis: t, expressions: n } = r; e.write("`"); const { length: i } = n; for (let a = 0; a < i; a++) { const o = n[a], l = t[a]; e.write(l.value.raw, l), e.write("${"), this[o.type](o, e), e.write("}") } const s = t[t.length - 1]; e.write(s.value.raw, s), e.write("`") }, TemplateElement(r, e) { e.write(r.value.raw, r) }, TaggedTemplateExpression(r, e) { yu(e, r.tag, r), this[r.quasi.type](r.quasi, e) }, ArrayExpression: Kw = function (r, e) { if (e.write("["), r.elements.length > 0) { const { elements: t } = r, { length: n } = t; for (let i = 0; ;) { const s = t[i]; if (s != null && this[s.type](s, e), ++i < n) e.write(", "); else { s == null && e.write(", "); break } } } e.write("]") }, ArrayPattern: Kw, ObjectExpression(r, e) { const t = e.indent.repeat(e.indentLevel++), { lineEnd: n, writeComments: i } = e, s = t + e.indent; if (e.write("{"), r.properties.length > 0) { e.write(n), i && r.comments != null && nr(e, r.comments, s, n); const a = "," + n, { properties: o } = r, { length: l } = o; for (let u = 0; ;) { const d = o[u]; if (i && d.comments != null && nr(e, d.comments, s, n), e.write(s), this[d.type](d, e), ++u < l) e.write(a); else break } e.write(n), i && r.trailingComments != null && nr(e, r.trailingComments, s, n), e.write(t + "}") } else i ? r.comments != null ? (e.write(n), nr(e, r.comments, s, n), r.trailingComments != null && nr(e, r.trailingComments, s, n), e.write(t + "}")) : r.trailingComments != null ? (e.write(n), nr(e, r.trailingComments, s, n), e.write(t + "}")) : e.write("}") : e.write("}"); e.indentLevel-- }, Property(r, e) { r.method || r.kind[0] !== "i" ? this.MethodDefinition(r, e) : (r.shorthand || (r.computed ? (e.write("["), this[r.key.type](r.key, e), e.write("]")) : this[r.key.type](r.key, e), e.write(": ")), this[r.value.type](r.value, e)) }, PropertyDefinition(r, e) { if (r.static && e.write("static "), r.computed && e.write("["), this[r.key.type](r.key, e), r.computed && e.write("]"), r.value == null) { r.key.type[0] !== "F" && e.write(";"); return } e.write(" = "), this[r.value.type](r.value, e), e.write(";") }, ObjectPattern(r, e) { if (e.write("{"), r.properties.length > 0) { const { properties: t } = r, { length: n } = t; for (let i = 0; this[t[i].type](t[i], e), ++i < n;)e.write(", ") } e.write("}") }, SequenceExpression(r, e) { Za(e, r.expressions) }, UnaryExpression(r, e) { if (r.prefix) { const { operator: t, argument: n, argument: { type: i } } = r; e.write(t); const s = hT(e, n, r); !s && (t.length > 1 || i[0] === "U" && (i[1] === "n" || i[1] === "p") && n.prefix && n.operator[0] === t && (t === "+" || t === "-")) && e.write(" "), s ? (e.write(t.length > 1 ? " (" : "("), this[i](n, e), e.write(")")) : this[i](n, e) } else this[r.argument.type](r.argument, e), e.write(r.operator) }, UpdateExpression(r, e) { r.prefix ? (e.write(r.operator), this[r.argument.type](r.argument, e)) : (this[r.argument.type](r.argument, e), e.write(r.operator)) }, AssignmentExpression(r, e) { this[r.left.type](r.left, e), e.write(" " + r.operator + " "), this[r.right.type](r.right, e) }, AssignmentPattern(r, e) { this[r.left.type](r.left, e), e.write(" = "), this[r.right.type](r.right, e) }, BinaryExpression: Hw = function (r, e) { const t = r.operator === "in"; t && e.write("("), yu(e, r.left, r, !1), e.write(" " + r.operator + " "), yu(e, r.right, r, !0), t && e.write(")") }, LogicalExpression: Hw, ConditionalExpression(r, e) { const { test: t } = r, n = e.expressionsPrecedence[t.type]; n === ci || n <= e.expressionsPrecedence.ConditionalExpression ? (e.write("("), this[t.type](t, e), e.write(")")) : this[t.type](t, e), e.write(" ? "), this[r.consequent.type](r.consequent, e), e.write(" : "), this[r.alternate.type](r.alternate, e) }, NewExpression(r, e) { e.write("new "); const t = e.expressionsPrecedence[r.callee.type]; t === ci || t < e.expressionsPrecedence.CallExpression || Hse(r.callee) ? (e.write("("), this[r.callee.type](r.callee, e), e.write(")")) : this[r.callee.type](r.callee, e), Za(e, r.arguments) }, CallExpression(r, e) { const t = e.expressionsPrecedence[r.callee.type]; t === ci || t < e.expressionsPrecedence.CallExpression ? (e.write("("), this[r.callee.type](r.callee, e), e.write(")")) : this[r.callee.type](r.callee, e), r.optional && e.write("?."), Za(e, r.arguments) }, ChainExpression(r, e) { this[r.expression.type](r.expression, e) }, MemberExpression(r, e) { const t = e.expressionsPrecedence[r.object.type]; t === ci || t < e.expressionsPrecedence.MemberExpression ? (e.write("("), this[r.object.type](r.object, e), e.write(")")) : this[r.object.type](r.object, e), r.computed ? (r.optional && e.write("?."), e.write("["), this[r.property.type](r.property, e), e.write("]")) : (r.optional ? e.write("?.") : e.write("."), this[r.property.type](r.property, e)) }, MetaProperty(r, e) { e.write(r.meta.name + "." + r.property.name, r) }, Identifier(r, e) { e.write(r.name, r) }, PrivateIdentifier(r, e) { e.write(`#${r.name}`, r) }, Literal(r, e) { r.raw != null ? e.write(r.raw, r) : r.regex != null ? this.RegExpLiteral(r, e) : r.bigint != null ? e.write(r.bigint + "n", r) : e.write(Vse(r.value), r) }, RegExpLiteral(r, e) { const { regex: t } = r; e.write(`/${t.pattern}/${t.flags}`, r) } }, Kse = {}; class Use {
  constructor(e) {
    const t = e ?? Kse; this.output = "", t.output != null ? (this.output = t.output, this.write = this.writeToStream) : this.output = "", this.generator = t.generator != null ? t.generator : pT, this.expressionsPrecedence = t.expressionsPrecedence != null ? t.expressionsPrecedence : Bse, this.indent = t.indent != null ? t.indent : "  ", this.lineEnd = t.lineEnd != null ? t.lineEnd : `
`, this.indentLevel = t.startingIndentLevel != null ? t.startingIndentLevel : 0, this.writeComments = t.comments ? t.comments : !1, t.sourceMap != null && (this.write = t.output == null ? this.writeAndMap : this.writeToStreamAndMap, this.sourceMap = t.sourceMap, this.line = 1, this.column = 0, this.lineEndSize = this.lineEnd.split(`
`).length - 1, this.mapping = { original: null, generated: this, name: void 0, source: t.sourceMap.file || t.sourceMap._file })
  } write(e) { this.output += e } writeToStream(e) { this.output.write(e) } writeAndMap(e, t) { this.output += e, this.map(e, t) } writeToStreamAndMap(e, t) { this.output.write(e), this.map(e, t) } map(e, t) {
    if (t != null) {
      const { type: s } = t; if (s[0] === "L" && s[2] === "n") { this.column = 0, this.line++; return } if (t.loc != null) { const { mapping: a } = this; a.original = t.loc.start, a.name = t.name, this.sourceMap.addMapping(a) } if (s[0] === "T" && s[8] === "E" || s[0] === "L" && s[1] === "i" && typeof t.value == "string") {
        const { length: a } = e; let { column: o, line: l } = this; for (let u = 0; u < a; u++)e[u] === `
`? (o = 0, l++) : o++; this.column = o, this.line = l; return
      }
    } const { length: n } = e, { lineEnd: i } = this; n > 0 && (this.lineEndSize > 0 && (i.length === 1 ? e[n - 1] === i : e.endsWith(i)) ? (this.line += this.lineEndSize, this.column = 0) : this.column += n)
  } toString() { return this.output }
} function Wse(r, e) { const t = new Use(e); return t.generator[r.type](r, t), t.output } function Gse(r, e) { const { SourceMapGenerator: t, filePath: n, handlers: i } = e, s = t ? new t({ file: n || "<unknown>.js" }) : void 0, a = Wse(r, { comments: !0, generator: { ...pT, ...i }, sourceMap: s || void 0 }), o = s ? s.toJSON() : void 0; return { value: a, map: o } } const Yse = { JSXAttribute: Xse, JSXClosingElement: qse, JSXClosingFragment: Zse, JSXElement: Jse, JSXEmptyExpression: Qse, JSXExpressionContainer: eae, JSXFragment: tae, JSXIdentifier: nae, JSXMemberExpression: rae, JSXNamespacedName: iae, JSXOpeningElement: sae, JSXOpeningFragment: aae, JSXSpreadAttribute: oae, JSXText: lae }; function Xse(r, e) { this[r.name.type](r.name, e), r.value !== null && r.value !== void 0 && (e.write("="), r.value.type === "Literal" ? e.write('"' + fT(String(r.value.value)).replace(/"/g, "&quot;") + '"', r) : this[r.value.type](r.value, e)) } function qse(r, e) { e.write("</"), this[r.name.type](r.name, e), e.write(">") } function Zse(r, e) { e.write("</>", r) } function Jse(r, e) { let t = -1; if (this[r.openingElement.type](r.openingElement, e), r.children) for (; ++t < r.children.length;) { const n = r.children[t]; if (n.type === "JSXSpreadChild") throw new Error("JSX spread children are not supported"); this[n.type](n, e) } r.closingElement && this[r.closingElement.type](r.closingElement, e) } function Qse() { } function eae(r, e) { e.write("{"), this[r.expression.type](r.expression, e), e.write("}") } function tae(r, e) { let t = -1; if (this[r.openingFragment.type](r.openingFragment, e), r.children) for (; ++t < r.children.length;) { const n = r.children[t]; if (n.type === "JSXSpreadChild") throw new Error("JSX spread children are not supported"); this[n.type](n, e) } this[r.closingFragment.type](r.closingFragment, e) } function nae(r, e) { e.write(r.name, r) } function rae(r, e) { this[r.object.type](r.object, e), e.write("."), this[r.property.type](r.property, e) } function iae(r, e) { this[r.namespace.type](r.namespace, e), e.write(":"), this[r.name.type](r.name, e) } function sae(r, e) { let t = -1; if (e.write("<"), this[r.name.type](r.name, e), r.attributes) for (; ++t < r.attributes.length;)e.write(" "), this[r.attributes[t].type](r.attributes[t], e); e.write(r.selfClosing ? " />" : ">") } function aae(r, e) { e.write("<>", r) } function oae(r, e) { e.write("{"), this.SpreadElement(r, e), e.write("}") } function lae(r, e) { e.write(fT(r.value).replace(/[<>{}]/g, cae), r) } function fT(r) { return r.replace(/&(?=[#a-z])/gi, "&amp;") } function cae(r) { return r === "<" ? "&lt;" : r === ">" ? "&gt;" : r === "{" ? "&#123;" : "&#125;" } function uae() { const r = this.data(), e = r.settings || (r.settings = {}), t = e.handlers || (e.handlers = {}); (e.plugins || (e.plugins = [])).push(dT()), Object.assign(t, Yse) } function dae(r) { const e = this; this.compiler = t; function t(n, i) { const s = { ...e.data("settings"), ...r }, a = Gse(n, { SourceMapGenerator: s.SourceMapGenerator, filePath: i.path || "unknown.js", handlers: s.handlers }); return i.map = a.map, a.value } } function hae(r, e) { const t = { type: "Block", value: r.value }; e.inherit(r, t), e.comments.push(t); const n = { type: "JSXEmptyExpression", comments: [Object.assign({}, t, { leading: !1, trailing: !0 })] }; e.patch(r, n); const i = { type: "JSXExpressionContainer", expression: n }; return e.patch(r, i), i } function pae(r, e) { const t = {}; return (r[r.length - 1] === "" ? [...r, ""] : r).join((t.padRight ? " " : "") + "," + (t.padLeft === !1 ? "" : " ")).trim() } class Wc { constructor(e, t, n) { this.property = e, this.normal = t, n && (this.space = n) } } Wc.prototype.property = {}; Wc.prototype.normal = {}; Wc.prototype.space = null; function gT(r, e) { const t = {}, n = {}; let i = -1; for (; ++i < r.length;)Object.assign(t, r[i].property), Object.assign(n, r[i].normal); return new Wc(t, n, e) } function Qg(r) { return r.toLowerCase() } class Jr { constructor(e, t) { this.property = e, this.attribute = t } } Jr.prototype.space = null; Jr.prototype.boolean = !1; Jr.prototype.booleanish = !1; Jr.prototype.overloadedBoolean = !1; Jr.prototype.number = !1; Jr.prototype.commaSeparated = !1; Jr.prototype.spaceSeparated = !1; Jr.prototype.commaOrSpaceSeparated = !1; Jr.prototype.mustUseProperty = !1; Jr.prototype.defined = !1; let fae = 0; const Me = Fa(), _n = Fa(), mT = Fa(), se = Fa(), jt = Fa(), vo = Fa(), Pr = Fa(); function Fa() { return 2 ** ++fae } const em = Object.freeze(Object.defineProperty({ __proto__: null, boolean: Me, booleanish: _n, commaOrSpaceSeparated: Pr, commaSeparated: vo, number: se, overloadedBoolean: mT, spaceSeparated: jt }, Symbol.toStringTag, { value: "Module" })), Zp = Object.keys(em); class _b extends Jr { constructor(e, t, n, i) { let s = -1; if (super(e, t), Ww(this, "space", i), typeof n == "number") for (; ++s < Zp.length;) { const a = Zp[s]; Ww(this, Zp[s], (n & em[a]) === em[a]) } } } _b.prototype.defined = !0; function Ww(r, e, t) { t && (r[e] = t) } const gae = {}.hasOwnProperty; function al(r) { const e = {}, t = {}; let n; for (n in r.properties) if (gae.call(r.properties, n)) { const i = r.properties[n], s = new _b(n, r.transform(r.attributes || {}, n), i, r.space); r.mustUseProperty && r.mustUseProperty.includes(n) && (s.mustUseProperty = !0), e[n] = s, t[Qg(n)] = n, t[Qg(s.attribute)] = n } return new Wc(e, t, r.space) } const yT = al({ space: "xlink", transform(r, e) { return "xlink:" + e.slice(5).toLowerCase() }, properties: { xLinkActuate: null, xLinkArcRole: null, xLinkHref: null, xLinkRole: null, xLinkShow: null, xLinkTitle: null, xLinkType: null } }), bT = al({ space: "xml", transform(r, e) { return "xml:" + e.slice(3).toLowerCase() }, properties: { xmlLang: null, xmlBase: null, xmlSpace: null } }); function vT(r, e) { return e in r ? r[e] : e } function xT(r, e) { return vT(r, e.toLowerCase()) } const wT = al({ space: "xmlns", attributes: { xmlnsxlink: "xmlns:xlink" }, transform: xT, properties: { xmlns: null, xmlnsXLink: null } }), CT = al({ transform(r, e) { return e === "role" ? e : "aria-" + e.slice(4).toLowerCase() }, properties: { ariaActiveDescendant: null, ariaAtomic: _n, ariaAutoComplete: null, ariaBusy: _n, ariaChecked: _n, ariaColCount: se, ariaColIndex: se, ariaColSpan: se, ariaControls: jt, ariaCurrent: null, ariaDescribedBy: jt, ariaDetails: null, ariaDisabled: _n, ariaDropEffect: jt, ariaErrorMessage: null, ariaExpanded: _n, ariaFlowTo: jt, ariaGrabbed: _n, ariaHasPopup: null, ariaHidden: _n, ariaInvalid: null, ariaKeyShortcuts: null, ariaLabel: null, ariaLabelledBy: jt, ariaLevel: se, ariaLive: null, ariaModal: _n, ariaMultiLine: _n, ariaMultiSelectable: _n, ariaOrientation: null, ariaOwns: jt, ariaPlaceholder: null, ariaPosInSet: se, ariaPressed: _n, ariaReadOnly: _n, ariaRelevant: null, ariaRequired: _n, ariaRoleDescription: jt, ariaRowCount: se, ariaRowIndex: se, ariaRowSpan: se, ariaSelected: _n, ariaSetSize: se, ariaSort: null, ariaValueMax: se, ariaValueMin: se, ariaValueNow: se, ariaValueText: null, role: null } }), mae = al({ space: "html", attributes: { acceptcharset: "accept-charset", classname: "class", htmlfor: "for", httpequiv: "http-equiv" }, transform: xT, mustUseProperty: ["checked", "multiple", "muted", "selected"], properties: { abbr: null, accept: vo, acceptCharset: jt, accessKey: jt, action: null, allow: null, allowFullScreen: Me, allowPaymentRequest: Me, allowUserMedia: Me, alt: null, as: null, async: Me, autoCapitalize: null, autoComplete: jt, autoFocus: Me, autoPlay: Me, blocking: jt, capture: null, charSet: null, checked: Me, cite: null, className: jt, cols: se, colSpan: null, content: null, contentEditable: _n, controls: Me, controlsList: jt, coords: se | vo, crossOrigin: null, data: null, dateTime: null, decoding: null, default: Me, defer: Me, dir: null, dirName: null, disabled: Me, download: mT, draggable: _n, encType: null, enterKeyHint: null, fetchPriority: null, form: null, formAction: null, formEncType: null, formMethod: null, formNoValidate: Me, formTarget: null, headers: jt, height: se, hidden: Me, high: se, href: null, hrefLang: null, htmlFor: jt, httpEquiv: jt, id: null, imageSizes: null, imageSrcSet: null, inert: Me, inputMode: null, integrity: null, is: null, isMap: Me, itemId: null, itemProp: jt, itemRef: jt, itemScope: Me, itemType: jt, kind: null, label: null, lang: null, language: null, list: null, loading: null, loop: Me, low: se, manifest: null, max: null, maxLength: se, media: null, method: null, min: null, minLength: se, multiple: Me, muted: Me, name: null, nonce: null, noModule: Me, noValidate: Me, onAbort: null, onAfterPrint: null, onAuxClick: null, onBeforeMatch: null, onBeforePrint: null, onBeforeToggle: null, onBeforeUnload: null, onBlur: null, onCancel: null, onCanPlay: null, onCanPlayThrough: null, onChange: null, onClick: null, onClose: null, onContextLost: null, onContextMenu: null, onContextRestored: null, onCopy: null, onCueChange: null, onCut: null, onDblClick: null, onDrag: null, onDragEnd: null, onDragEnter: null, onDragExit: null, onDragLeave: null, onDragOver: null, onDragStart: null, onDrop: null, onDurationChange: null, onEmptied: null, onEnded: null, onError: null, onFocus: null, onFormData: null, onHashChange: null, onInput: null, onInvalid: null, onKeyDown: null, onKeyPress: null, onKeyUp: null, onLanguageChange: null, onLoad: null, onLoadedData: null, onLoadedMetadata: null, onLoadEnd: null, onLoadStart: null, onMessage: null, onMessageError: null, onMouseDown: null, onMouseEnter: null, onMouseLeave: null, onMouseMove: null, onMouseOut: null, onMouseOver: null, onMouseUp: null, onOffline: null, onOnline: null, onPageHide: null, onPageShow: null, onPaste: null, onPause: null, onPlay: null, onPlaying: null, onPopState: null, onProgress: null, onRateChange: null, onRejectionHandled: null, onReset: null, onResize: null, onScroll: null, onScrollEnd: null, onSecurityPolicyViolation: null, onSeeked: null, onSeeking: null, onSelect: null, onSlotChange: null, onStalled: null, onStorage: null, onSubmit: null, onSuspend: null, onTimeUpdate: null, onToggle: null, onUnhandledRejection: null, onUnload: null, onVolumeChange: null, onWaiting: null, onWheel: null, open: Me, optimum: se, pattern: null, ping: jt, placeholder: null, playsInline: Me, popover: null, popoverTarget: null, popoverTargetAction: null, poster: null, preload: null, readOnly: Me, referrerPolicy: null, rel: jt, required: Me, reversed: Me, rows: se, rowSpan: se, sandbox: jt, scope: null, scoped: Me, seamless: Me, selected: Me, shadowRootClonable: Me, shadowRootDelegatesFocus: Me, shadowRootMode: null, shape: null, size: se, sizes: null, slot: null, span: se, spellCheck: _n, src: null, srcDoc: null, srcLang: null, srcSet: null, start: se, step: null, style: null, tabIndex: se, target: null, title: null, translate: null, type: null, typeMustMatch: Me, useMap: null, value: _n, width: se, wrap: null, writingSuggestions: null, align: null, aLink: null, archive: jt, axis: null, background: null, bgColor: null, border: se, borderColor: null, bottomMargin: se, cellPadding: null, cellSpacing: null, char: null, charOff: null, classId: null, clear: null, code: null, codeBase: null, codeType: null, color: null, compact: Me, declare: Me, event: null, face: null, frame: null, frameBorder: null, hSpace: se, leftMargin: se, link: null, longDesc: null, lowSrc: null, marginHeight: se, marginWidth: se, noResize: Me, noHref: Me, noShade: Me, noWrap: Me, object: null, profile: null, prompt: null, rev: null, rightMargin: se, rules: null, scheme: null, scrolling: _n, standby: null, summary: null, text: null, topMargin: se, valueType: null, version: null, vAlign: null, vLink: null, vSpace: se, allowTransparency: null, autoCorrect: null, autoSave: null, disablePictureInPicture: Me, disableRemotePlayback: Me, prefix: null, property: null, results: se, security: null, unselectable: null } }), yae = al({ space: "svg", attributes: { accentHeight: "accent-height", alignmentBaseline: "alignment-baseline", arabicForm: "arabic-form", baselineShift: "baseline-shift", capHeight: "cap-height", className: "class", clipPath: "clip-path", clipRule: "clip-rule", colorInterpolation: "color-interpolation", colorInterpolationFilters: "color-interpolation-filters", colorProfile: "color-profile", colorRendering: "color-rendering", crossOrigin: "crossorigin", dataType: "datatype", dominantBaseline: "dominant-baseline", enableBackground: "enable-background", fillOpacity: "fill-opacity", fillRule: "fill-rule", floodColor: "flood-color", floodOpacity: "flood-opacity", fontFamily: "font-family", fontSize: "font-size", fontSizeAdjust: "font-size-adjust", fontStretch: "font-stretch", fontStyle: "font-style", fontVariant: "font-variant", fontWeight: "font-weight", glyphName: "glyph-name", glyphOrientationHorizontal: "glyph-orientation-horizontal", glyphOrientationVertical: "glyph-orientation-vertical", hrefLang: "hreflang", horizAdvX: "horiz-adv-x", horizOriginX: "horiz-origin-x", horizOriginY: "horiz-origin-y", imageRendering: "image-rendering", letterSpacing: "letter-spacing", lightingColor: "lighting-color", markerEnd: "marker-end", markerMid: "marker-mid", markerStart: "marker-start", navDown: "nav-down", navDownLeft: "nav-down-left", navDownRight: "nav-down-right", navLeft: "nav-left", navNext: "nav-next", navPrev: "nav-prev", navRight: "nav-right", navUp: "nav-up", navUpLeft: "nav-up-left", navUpRight: "nav-up-right", onAbort: "onabort", onActivate: "onactivate", onAfterPrint: "onafterprint", onBeforePrint: "onbeforeprint", onBegin: "onbegin", onCancel: "oncancel", onCanPlay: "oncanplay", onCanPlayThrough: "oncanplaythrough", onChange: "onchange", onClick: "onclick", onClose: "onclose", onCopy: "oncopy", onCueChange: "oncuechange", onCut: "oncut", onDblClick: "ondblclick", onDrag: "ondrag", onDragEnd: "ondragend", onDragEnter: "ondragenter", onDragExit: "ondragexit", onDragLeave: "ondragleave", onDragOver: "ondragover", onDragStart: "ondragstart", onDrop: "ondrop", onDurationChange: "ondurationchange", onEmptied: "onemptied", onEnd: "onend", onEnded: "onended", onError: "onerror", onFocus: "onfocus", onFocusIn: "onfocusin", onFocusOut: "onfocusout", onHashChange: "onhashchange", onInput: "oninput", onInvalid: "oninvalid", onKeyDown: "onkeydown", onKeyPress: "onkeypress", onKeyUp: "onkeyup", onLoad: "onload", onLoadedData: "onloadeddata", onLoadedMetadata: "onloadedmetadata", onLoadStart: "onloadstart", onMessage: "onmessage", onMouseDown: "onmousedown", onMouseEnter: "onmouseenter", onMouseLeave: "onmouseleave", onMouseMove: "onmousemove", onMouseOut: "onmouseout", onMouseOver: "onmouseover", onMouseUp: "onmouseup", onMouseWheel: "onmousewheel", onOffline: "onoffline", onOnline: "ononline", onPageHide: "onpagehide", onPageShow: "onpageshow", onPaste: "onpaste", onPause: "onpause", onPlay: "onplay", onPlaying: "onplaying", onPopState: "onpopstate", onProgress: "onprogress", onRateChange: "onratechange", onRepeat: "onrepeat", onReset: "onreset", onResize: "onresize", onScroll: "onscroll", onSeeked: "onseeked", onSeeking: "onseeking", onSelect: "onselect", onShow: "onshow", onStalled: "onstalled", onStorage: "onstorage", onSubmit: "onsubmit", onSuspend: "onsuspend", onTimeUpdate: "ontimeupdate", onToggle: "ontoggle", onUnload: "onunload", onVolumeChange: "onvolumechange", onWaiting: "onwaiting", onZoom: "onzoom", overlinePosition: "overline-position", overlineThickness: "overline-thickness", paintOrder: "paint-order", panose1: "panose-1", pointerEvents: "pointer-events", referrerPolicy: "referrerpolicy", renderingIntent: "rendering-intent", shapeRendering: "shape-rendering", stopColor: "stop-color", stopOpacity: "stop-opacity", strikethroughPosition: "strikethrough-position", strikethroughThickness: "strikethrough-thickness", strokeDashArray: "stroke-dasharray", strokeDashOffset: "stroke-dashoffset", strokeLineCap: "stroke-linecap", strokeLineJoin: "stroke-linejoin", strokeMiterLimit: "stroke-miterlimit", strokeOpacity: "stroke-opacity", strokeWidth: "stroke-width", tabIndex: "tabindex", textAnchor: "text-anchor", textDecoration: "text-decoration", textRendering: "text-rendering", transformOrigin: "transform-origin", typeOf: "typeof", underlinePosition: "underline-position", underlineThickness: "underline-thickness", unicodeBidi: "unicode-bidi", unicodeRange: "unicode-range", unitsPerEm: "units-per-em", vAlphabetic: "v-alphabetic", vHanging: "v-hanging", vIdeographic: "v-ideographic", vMathematical: "v-mathematical", vectorEffect: "vector-effect", vertAdvY: "vert-adv-y", vertOriginX: "vert-origin-x", vertOriginY: "vert-origin-y", wordSpacing: "word-spacing", writingMode: "writing-mode", xHeight: "x-height", playbackOrder: "playbackorder", timelineBegin: "timelinebegin" }, transform: vT, properties: { about: Pr, accentHeight: se, accumulate: null, additive: null, alignmentBaseline: null, alphabetic: se, amplitude: se, arabicForm: null, ascent: se, attributeName: null, attributeType: null, azimuth: se, bandwidth: null, baselineShift: null, baseFrequency: null, baseProfile: null, bbox: null, begin: null, bias: se, by: null, calcMode: null, capHeight: se, className: jt, clip: null, clipPath: null, clipPathUnits: null, clipRule: null, color: null, colorInterpolation: null, colorInterpolationFilters: null, colorProfile: null, colorRendering: null, content: null, contentScriptType: null, contentStyleType: null, crossOrigin: null, cursor: null, cx: null, cy: null, d: null, dataType: null, defaultAction: null, descent: se, diffuseConstant: se, direction: null, display: null, dur: null, divisor: se, dominantBaseline: null, download: Me, dx: null, dy: null, edgeMode: null, editable: null, elevation: se, enableBackground: null, end: null, event: null, exponent: se, externalResourcesRequired: null, fill: null, fillOpacity: se, fillRule: null, filter: null, filterRes: null, filterUnits: null, floodColor: null, floodOpacity: null, focusable: null, focusHighlight: null, fontFamily: null, fontSize: null, fontSizeAdjust: null, fontStretch: null, fontStyle: null, fontVariant: null, fontWeight: null, format: null, fr: null, from: null, fx: null, fy: null, g1: vo, g2: vo, glyphName: vo, glyphOrientationHorizontal: null, glyphOrientationVertical: null, glyphRef: null, gradientTransform: null, gradientUnits: null, handler: null, hanging: se, hatchContentUnits: null, hatchUnits: null, height: null, href: null, hrefLang: null, horizAdvX: se, horizOriginX: se, horizOriginY: se, id: null, ideographic: se, imageRendering: null, initialVisibility: null, in: null, in2: null, intercept: se, k: se, k1: se, k2: se, k3: se, k4: se, kernelMatrix: Pr, kernelUnitLength: null, keyPoints: null, keySplines: null, keyTimes: null, kerning: null, lang: null, lengthAdjust: null, letterSpacing: null, lightingColor: null, limitingConeAngle: se, local: null, markerEnd: null, markerMid: null, markerStart: null, markerHeight: null, markerUnits: null, markerWidth: null, mask: null, maskContentUnits: null, maskUnits: null, mathematical: null, max: null, media: null, mediaCharacterEncoding: null, mediaContentEncodings: null, mediaSize: se, mediaTime: null, method: null, min: null, mode: null, name: null, navDown: null, navDownLeft: null, navDownRight: null, navLeft: null, navNext: null, navPrev: null, navRight: null, navUp: null, navUpLeft: null, navUpRight: null, numOctaves: null, observer: null, offset: null, onAbort: null, onActivate: null, onAfterPrint: null, onBeforePrint: null, onBegin: null, onCancel: null, onCanPlay: null, onCanPlayThrough: null, onChange: null, onClick: null, onClose: null, onCopy: null, onCueChange: null, onCut: null, onDblClick: null, onDrag: null, onDragEnd: null, onDragEnter: null, onDragExit: null, onDragLeave: null, onDragOver: null, onDragStart: null, onDrop: null, onDurationChange: null, onEmptied: null, onEnd: null, onEnded: null, onError: null, onFocus: null, onFocusIn: null, onFocusOut: null, onHashChange: null, onInput: null, onInvalid: null, onKeyDown: null, onKeyPress: null, onKeyUp: null, onLoad: null, onLoadedData: null, onLoadedMetadata: null, onLoadStart: null, onMessage: null, onMouseDown: null, onMouseEnter: null, onMouseLeave: null, onMouseMove: null, onMouseOut: null, onMouseOver: null, onMouseUp: null, onMouseWheel: null, onOffline: null, onOnline: null, onPageHide: null, onPageShow: null, onPaste: null, onPause: null, onPlay: null, onPlaying: null, onPopState: null, onProgress: null, onRateChange: null, onRepeat: null, onReset: null, onResize: null, onScroll: null, onSeeked: null, onSeeking: null, onSelect: null, onShow: null, onStalled: null, onStorage: null, onSubmit: null, onSuspend: null, onTimeUpdate: null, onToggle: null, onUnload: null, onVolumeChange: null, onWaiting: null, onZoom: null, opacity: null, operator: null, order: null, orient: null, orientation: null, origin: null, overflow: null, overlay: null, overlinePosition: se, overlineThickness: se, paintOrder: null, panose1: null, path: null, pathLength: se, patternContentUnits: null, patternTransform: null, patternUnits: null, phase: null, ping: jt, pitch: null, playbackOrder: null, pointerEvents: null, points: null, pointsAtX: se, pointsAtY: se, pointsAtZ: se, preserveAlpha: null, preserveAspectRatio: null, primitiveUnits: null, propagate: null, property: Pr, r: null, radius: null, referrerPolicy: null, refX: null, refY: null, rel: Pr, rev: Pr, renderingIntent: null, repeatCount: null, repeatDur: null, requiredExtensions: Pr, requiredFeatures: Pr, requiredFonts: Pr, requiredFormats: Pr, resource: null, restart: null, result: null, rotate: null, rx: null, ry: null, scale: null, seed: null, shapeRendering: null, side: null, slope: null, snapshotTime: null, specularConstant: se, specularExponent: se, spreadMethod: null, spacing: null, startOffset: null, stdDeviation: null, stemh: null, stemv: null, stitchTiles: null, stopColor: null, stopOpacity: null, strikethroughPosition: se, strikethroughThickness: se, string: null, stroke: null, strokeDashArray: Pr, strokeDashOffset: null, strokeLineCap: null, strokeLineJoin: null, strokeMiterLimit: se, strokeOpacity: se, strokeWidth: null, style: null, surfaceScale: se, syncBehavior: null, syncBehaviorDefault: null, syncMaster: null, syncTolerance: null, syncToleranceDefault: null, systemLanguage: Pr, tabIndex: se, tableValues: null, target: null, targetX: se, targetY: se, textAnchor: null, textDecoration: null, textRendering: null, textLength: null, timelineBegin: null, title: null, transformBehavior: null, type: null, typeOf: Pr, to: null, transform: null, transformOrigin: null, u1: null, u2: null, underlinePosition: se, underlineThickness: se, unicode: null, unicodeBidi: null, unicodeRange: null, unitsPerEm: se, values: null, vAlphabetic: se, vMathematical: se, vectorEffect: null, vHanging: se, vIdeographic: se, version: null, vertAdvY: se, vertOriginX: se, vertOriginY: se, viewBox: null, viewTarget: null, visibility: null, width: null, widths: null, wordSpacing: null, writingMode: null, x: null, x1: null, x2: null, xChannelSelector: null, xHeight: se, y: null, y1: null, y2: null, yChannelSelector: null, z: null, zoomAndPan: null } }), bae = /^data[-\w.:]+$/i, Gw = /-[a-z]/g, vae = /[A-Z]/g; function xae(r, e) { const t = Qg(e); let n = e, i = Jr; if (t in r.normal) return r.property[r.normal[t]]; if (t.length > 4 && t.slice(0, 4) === "data" && bae.test(e)) { if (e.charAt(4) === "-") { const s = e.slice(5).replace(Gw, Cae); n = "data" + s.charAt(0).toUpperCase() + s.slice(1) } else { const s = e.slice(4); if (!Gw.test(s)) { let a = s.replace(vae, wae); a.charAt(0) !== "-" && (a = "-" + a), e = "data" + a } } i = _b } return new i(n, e) } function wae(r) { return "-" + r.toLowerCase() } function Cae(r) { return r.charAt(1).toUpperCase() } const Sae = { classId: "classID", dataType: "datatype", itemId: "itemID", strokeDashArray: "strokeDasharray", strokeDashOffset: "strokeDashoffset", strokeLineCap: "strokeLinecap", strokeLineJoin: "strokeLinejoin", strokeMiterLimit: "strokeMiterlimit", typeOf: "typeof", xLinkActuate: "xlinkActuate", xLinkArcRole: "xlinkArcrole", xLinkHref: "xlinkHref", xLinkRole: "xlinkRole", xLinkShow: "xlinkShow", xLinkTitle: "xlinkTitle", xLinkType: "xlinkType", xmlnsXLink: "xmlnsXlink" }, Eae = gT([bT, yT, wT, CT, mae], "html"), Ob = gT([bT, yT, wT, CT, yae], "svg"); function _ae(r) { return r.join(" ").trim() } var ST = {}, Yw = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g, Oae = /\n/g, Tae = /^\s*/, Iae = /^(\*?[-#/*\\\w]+(\[[0-9a-z_-]+\])?)\s*/, Pae = /^:\s*/, kae = /^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};])+)/, Rae = /^[;\s]*/, Dae = /^\s+|\s+$/g, Aae = `
`, Xw = "/", qw = "*", sa = "", Nae = "comment", Fae = "declaration", $ae = function (r, e) { if (typeof r != "string") throw new TypeError("First argument must be a string"); if (!r) return []; e = e || {}; var t = 1, n = 1; function i(b) { var y = b.match(Oae); y && (t += y.length); var w = b.lastIndexOf(Aae); n = ~w ? b.length - w : n + b.length } function s() { var b = { line: t, column: n }; return function (y) { return y.position = new a(b), u(), y } } function a(b) { this.start = b, this.end = { line: t, column: n }, this.source = e.source } a.prototype.content = r; function o(b) { var y = new Error(e.source + ":" + t + ":" + n + ": " + b); if (y.reason = b, y.filename = e.source, y.line = t, y.column = n, y.source = r, !e.silent) throw y } function l(b) { var y = b.exec(r); if (y) { var w = y[0]; return i(w), r = r.slice(w.length), y } } function u() { l(Tae) } function d(b) { var y; for (b = b || []; y = h();)y !== !1 && b.push(y); return b } function h() { var b = s(); if (!(Xw != r.charAt(0) || qw != r.charAt(1))) { for (var y = 2; sa != r.charAt(y) && (qw != r.charAt(y) || Xw != r.charAt(y + 1));)++y; if (y += 2, sa === r.charAt(y - 1)) return o("End of comment missing"); var w = r.slice(2, y - 2); return n += 2, i(w), r = r.slice(y), n += 2, b({ type: Nae, comment: w }) } } function g() { var b = s(), y = l(Iae); if (y) { if (h(), !l(Pae)) return o("property missing ':'"); var w = l(kae), x = b({ type: Fae, property: Zw(y[0].replace(Yw, sa)), value: w ? Zw(w[0].replace(Yw, sa)) : sa }); return l(Rae), x } } function m() { var b = []; d(b); for (var y; y = g();)y !== !1 && (b.push(y), d(b)); return b } return u(), m() }; function Zw(r) { return r ? r.replace(Dae, sa) : sa } var Lae = Qi && Qi.__importDefault || function (r) { return r && r.__esModule ? r : { default: r } }; Object.defineProperty(ST, "__esModule", { value: !0 }); var Jw = ST.default = jae, Mae = Lae($ae); function jae(r, e) { var t = null; if (!r || typeof r != "string") return t; var n = (0, Mae.default)(r), i = typeof e == "function"; return n.forEach(function (s) { if (s.type === "declaration") { var a = s.property, o = s.value; i ? e(a, o, s) : o && (t = t || {}, t[a] = o) } }), t } const Vae = Jw.default || Jw, tm = {}.hasOwnProperty, Bae = /[A-Z]/g, zae = /-([a-z])/g, Hae = new Set(["td", "th"]); function Kae(r, e) { const t = e.schema; let n = t; const i = r.properties || {}; t.space === "html" && r.tagName.toLowerCase() === "svg" && (n = Ob, e.schema = n); const s = e.all(r), a = []; let o, l, u; for (o in i) if (tm.call(i, o)) { let h = i[o]; const g = xae(n, o); let m; if (h == null || h === !1 || typeof h == "number" && Number.isNaN(h) || !h && g.boolean) continue; if (o = e.elementAttributeNameCase === "react" && g.space ? Sae[g.property] || g.property : g.attribute, Array.isArray(h) && (h = g.commaSeparated ? pae(h) : _ae(h)), o === "style") { let b = typeof h == "object" ? h : Uae(String(h), r.tagName); e.stylePropertyNameCase === "css" && (b = Wae(b)); const y = []; let w; for (w in b) tm.call(b, w) && y.push({ type: "Property", method: !1, shorthand: !1, computed: !1, key: Bi(w) ? { type: "Identifier", name: w } : { type: "Literal", value: w }, value: { type: "Literal", value: String(b[w]) }, kind: "init" }); u = y, m = { type: "JSXExpressionContainer", expression: { type: "ObjectExpression", properties: y } } } else if (h === !0) m = null; else if (e.tableCellAlignToStyle && Hae.has(r.tagName) && o === "align") { l = String(h); continue } else m = { type: "Literal", value: String(h) }; Bi(o, { jsx: !0 }) ? a.push({ type: "JSXAttribute", name: { type: "JSXIdentifier", name: o }, value: m }) : a.push({ type: "JSXSpreadAttribute", argument: { type: "ObjectExpression", properties: [{ type: "Property", method: !1, shorthand: !1, computed: !1, key: { type: "Literal", value: String(o) }, value: m || { type: "Literal", value: !0 }, kind: "init" }] } }) } if (l !== void 0) { u || (u = [], a.push({ type: "JSXAttribute", name: { type: "JSXIdentifier", name: "style" }, value: { type: "JSXExpressionContainer", expression: { type: "ObjectExpression", properties: u } } })); const h = e.stylePropertyNameCase === "css" ? ET("textAlign") : "textAlign"; u.push({ type: "Property", method: !1, shorthand: !1, computed: !1, key: Bi(h) ? { type: "Identifier", name: h } : { type: "Literal", value: h }, value: { type: "Literal", value: l }, kind: "init" }) } e.schema = t; const d = { type: "JSXElement", openingElement: { type: "JSXOpeningElement", attributes: a, name: e.createJsxElementName(r.tagName), selfClosing: s.length === 0 }, closingElement: s.length > 0 ? { type: "JSXClosingElement", name: e.createJsxElementName(r.tagName) } : null, children: s }; return e.inherit(r, d), d } function Uae(r, e) { const t = {}; try { Vae(r, n) } catch (i) { const s = i; throw new Error("Could not parse `style` attribute on `" + e + "`", { cause: s }) } return t; function n(i, s) { let a = i; a.slice(0, 2) !== "--" && (a.slice(0, 4) === "-ms-" && (a = "ms-" + a.slice(4)), a = a.replace(zae, Gae)), t[a] = s } } function Wae(r) { const e = {}; let t; for (t in r) tm.call(r, t) && (e[ET(t)] = r[t]); return e } function ET(r) { let e = r.replace(Bae, Yae); return e.slice(0, 3) === "ms-" && (e = "-" + e), e } function Gae(r, e) { return e.toUpperCase() } function Yae(r) { return "-" + r.toLowerCase() } const Xae = {}.hasOwnProperty, qae = []; function xd(r, e) { const t = e ? [...e].sort(Tb) : qae; t.length > 0 && _T(r, { comments: t, index: 0 }) } function _T(r, e) { if (e.index === e.comments.length) return; const t = [], n = []; let i; for (i in r) if (Xae.call(r, i)) { const a = r[i]; if (a && typeof a == "object" && i !== "comments") if (Array.isArray(a)) { let o = -1; for (; ++o < a.length;)a[o] && typeof a[o].type == "string" && t.push(a[o]) } else typeof a.type == "string" && t.push(a) } t.sort(Tb), n.push(...Qw(e, r, !1, { leading: !0, trailing: !1 })); let s = -1; for (; ++s < t.length;)_T(t[s], e); n.push(...Qw(e, r, !0, { leading: !1, trailing: t.length > 0 })), n.length > 0 && (r.comments = n) } function Qw(r, e, t, n) { const i = []; for (; r.comments[r.index] && Tb(r.comments[r.index], e, t) < 1;)i.push(Object.assign({}, r.comments[r.index++], n)); return i } function Tb(r, e, t) { const n = t ? "end" : "start"; return r.range && e.range ? r.range[0] - e.range[t ? 1 : 0] : r.loc && r.loc.start && e.loc && e.loc[n] ? r.loc.start.line - e.loc[n].line || r.loc.start.column - e.loc[n].column : "start" in r && n in e ? r.start - e[n] : Number.NaN } function eC(r, e) { const t = r.data && r.data.estree, n = t && t.comments || []; let i; t && (e.comments.push(...n), xd(t, t.comments), i = t.body[0] && t.body[0].type === "ExpressionStatement" && t.body[0].expression || void 0), i || (i = { type: "JSXEmptyExpression" }, e.patch(r, i)); const s = { type: "JSXExpressionContainer", expression: i }; return e.inherit(r, s), s } function tC(r, e) { const t = e.schema; let n = t; const i = r.attributes || []; let s = -1; r.name && t.space === "html" && r.name.toLowerCase() === "svg" && (n = Ob, e.schema = n); const a = e.all(r), o = []; for (; ++s < i.length;) { const u = i[s], d = u.value; let h; if (u.type === "mdxJsxAttribute") { if (d == null) h = null; else if (typeof d == "object") { const m = d.data && d.data.estree, b = m && m.comments || []; let y; m && (e.comments.push(...b), xd(m, m.comments), y = m.body[0] && m.body[0].type === "ExpressionStatement" && m.body[0].expression || void 0), h = { type: "JSXExpressionContainer", expression: y || { type: "JSXEmptyExpression" } }, e.inherit(d, h) } else h = { type: "Literal", value: String(d) }; const g = { type: "JSXAttribute", name: e.createJsxAttributeName(u.name), value: h }; e.inherit(u, g), o.push(g) } else { const g = u.data && u.data.estree, m = g && g.comments || []; let b; g && (e.comments.push(...m), xd(g, g.comments), b = g.body[0] && g.body[0].type === "ExpressionStatement" && g.body[0].expression && g.body[0].expression.type === "ObjectExpression" && g.body[0].expression.properties && g.body[0].expression.properties[0] && g.body[0].expression.properties[0].type === "SpreadElement" && g.body[0].expression.properties[0].argument || void 0); const y = { type: "JSXSpreadAttribute", argument: b || { type: "ObjectExpression", properties: [] } }; e.inherit(u, y), o.push(y) } } e.schema = t; const l = r.name ? { type: "JSXElement", openingElement: { type: "JSXOpeningElement", attributes: o, name: e.createJsxElementName(r.name), selfClosing: a.length === 0 }, closingElement: a.length > 0 ? { type: "JSXClosingElement", name: e.createJsxElementName(r.name) } : null, children: a } : { type: "JSXFragment", openingFragment: { type: "JSXOpeningFragment" }, closingFragment: { type: "JSXClosingFragment" }, children: a }; return e.inherit(r, l), l } function Zae(r, e) { const t = r.data && r.data.estree, n = t && t.comments || []; t && (e.comments.push(...n), xd(t, n), e.esm.push(...t.body)) } const Jae = /[ \t\n\f\r]/g; function Qae(r) { return typeof r == "object" ? r.type === "text" ? nC(r.value) : !1 : nC(r) } function nC(r) { return r.replace(Jae, "") === "" } function eoe(r, e) { const t = e.all(r), n = []; let i = -1, s; for (; ++i < t.length;) { const o = t[i]; o.type === "JSXExpressionContainer" && o.expression.type === "Literal" && Qae(String(o.expression.value)) ? s && s.push(o) : (s && n.push(...s), n.push(o), s = []) } const a = { type: "JSXFragment", openingFragment: { type: "JSXOpeningFragment" }, closingFragment: { type: "JSXClosingFragment" }, children: n }; return e.inherit(r, a), a } function toe(r, e) { const t = String(r.value || ""); if (t) { const n = { type: "Literal", value: t }; e.inherit(r, n); const i = { type: "JSXExpressionContainer", expression: n }; return e.patch(r, i), i } } const noe = { comment: hae, doctype: roe, element: Kae, mdxFlowExpression: eC, mdxJsxFlowElement: tC, mdxJsxTextElement: tC, mdxTextExpression: eC, mdxjsEsm: Zae, root: eoe, text: toe }; function roe() { } const OT = IT("end"), TT = IT("start"); function IT(r) { return e; function e(t) { const n = t && t.position && t.position[r] || {}; if (typeof n.line == "number" && n.line > 0 && typeof n.column == "number" && n.column > 0) return { line: n.line, column: n.column, offset: typeof n.offset == "number" && n.offset > -1 ? n.offset : void 0 } } } function PT(r) { const e = TT(r), t = OT(r); if (e && t) return { start: e, end: t } } const rC = {}.hasOwnProperty; function ioe(r, e) { const t = e; function n(i, ...s) { let a = n.invalid; const o = n.handlers; if (i && rC.call(i, r)) { const l = String(i[r]); a = rC.call(o, l) ? o[l] : n.unknown } if (a) return a.call(this, i, ...s) } return n.handlers = t.handlers || {}, n.invalid = t.invalid, n.unknown = t.unknown, n } const soe = {}.hasOwnProperty, aoe = new Set(["table", "tbody", "thead", "tfoot", "tr"]); function ooe(r) { const e = ioe("type", { invalid: loe, unknown: coe, handlers: { ...noe, ...r.handlers } }); return { elementAttributeNameCase: r.elementAttributeNameCase || "react", schema: r.space === "svg" ? Ob : Eae, stylePropertyNameCase: r.stylePropertyNameCase || "dom", tableCellAlignToStyle: r.tableCellAlignToStyle !== !1, comments: [], esm: [], all: uoe, createJsxAttributeName: hoe, createJsxElementName: poe, handle: t, inherit: doe, patch: kT }; function t(n) { return e(n, this) } } function loe(r) { throw new Error("Cannot handle value `" + r + "`, expected node") } function coe(r) { throw new Error("Cannot handle unknown node `" + r.type + "`") } function uoe(r) {
  const e = r.children || []; let t = -1; const n = [], i = this.schema.space === "html" && r.type === "element" && aoe.has(r.tagName.toLowerCase()); for (; ++t < e.length;) {
    const s = e[t]; if (i && s.type === "text" && s.value === `
`) continue; const a = this.handle(s); Array.isArray(a) ? n.push(...a) : a && n.push(a)
  } return n
} function doe(r, e) { const t = r.data; let n, i; if (kT(r, e), t) { for (i in t) soe.call(t, i) && i !== "estree" && (n || (n = {}), n[i] = t[i]); n && (e.data = n) } } function kT(r, e) { const t = PT(r); t && t.start.offset !== void 0 && t.end.offset !== void 0 && (e.start = t.start.offset, e.end = t.end.offset, e.loc = { start: { line: t.start.line, column: t.start.column - 1 }, end: { line: t.end.line, column: t.end.column - 1 } }, e.range = [t.start.offset, t.end.offset]) } function hoe(r) { const e = RT(r); if (e.type === "JSXMemberExpression") throw new Error("Member expressions in attribute names are not supported"); return e } function poe(r) { return RT(r) } function RT(r) { if (r.includes(".")) { const e = r.split("."); let t = e.shift(), n = { type: "JSXIdentifier", name: t }; for (; t = e.shift();)n = { type: "JSXMemberExpression", object: n, property: { type: "JSXIdentifier", name: t } }; return n } if (r.includes(":")) { const e = r.split(":"); return { type: "JSXNamespacedName", namespace: { type: "JSXIdentifier", name: e[0] }, name: { type: "JSXIdentifier", name: e[1] } } } return { type: "JSXIdentifier", name: r } } function foe(r, e) { const t = ooe(e || {}); let n = t.handle(r); const i = t.esm; if (n) { n.type !== "JSXFragment" && n.type !== "JSXElement" && (n = { type: "JSXFragment", openingFragment: { type: "JSXOpeningFragment" }, closingFragment: { type: "JSXClosingFragment" }, children: [n] }, t.patch(r, n)); const a = { type: "ExpressionStatement", expression: n }; t.patch(r, a), i.push(a) } const s = { type: "Program", body: i, sourceType: "module", comments: t.comments }; return t.patch(r, s), s } function goe(r) { return function (e) { return foe(e, r) } } function moe() { return { enter: { mdxFlowExpression: boe, mdxTextExpression: voe }, exit: { mdxFlowExpression: iC, mdxFlowExpressionChunk: sC, mdxTextExpression: iC, mdxTextExpressionChunk: sC } } } function yoe() { return { handlers: { mdxFlowExpression: aC, mdxTextExpression: aC }, unsafe: [{ character: "{", inConstruct: ["phrasing"] }, { atBreak: !0, character: "{" }] } } function boe(r) { this.enter({ type: "mdxFlowExpression", value: "" }, r), this.buffer() } function voe(r) { this.enter({ type: "mdxTextExpression", value: "" }, r), this.buffer() } function iC(r) { const e = this.resume(), t = r.estree, n = this.stack[this.stack.length - 1]; n.type === "mdxFlowExpression" || n.type, this.exit(r), n.value = e, t && (n.data = { estree: t }) } function sC(r) { this.config.enter.data.call(this, r), this.config.exit.data.call(this, r) } function aC(r, e, t) { const n = r.value || ""; return "{" + t.indentLines(n, function (s, a, o) { return (a === 0 || o ? "" : "  ") + s }) + "}" } function wd(r, e) { const t = String(r); if (typeof e != "string") throw new TypeError("Expected character"); let n = 0, i = t.indexOf(e); for (; i !== -1;)n++, i = t.indexOf(e, i + e.length); return n } const xoe = ["AElig", "AMP", "Aacute", "Acirc", "Agrave", "Aring", "Atilde", "Auml", "COPY", "Ccedil", "ETH", "Eacute", "Ecirc", "Egrave", "Euml", "GT", "Iacute", "Icirc", "Igrave", "Iuml", "LT", "Ntilde", "Oacute", "Ocirc", "Ograve", "Oslash", "Otilde", "Ouml", "QUOT", "REG", "THORN", "Uacute", "Ucirc", "Ugrave", "Uuml", "Yacute", "aacute", "acirc", "acute", "aelig", "agrave", "amp", "aring", "atilde", "auml", "brvbar", "ccedil", "cedil", "cent", "copy", "curren", "deg", "divide", "eacute", "ecirc", "egrave", "eth", "euml", "frac12", "frac14", "frac34", "gt", "iacute", "icirc", "iexcl", "igrave", "iquest", "iuml", "laquo", "lt", "macr", "micro", "middot", "nbsp", "not", "ntilde", "oacute", "ocirc", "ograve", "ordf", "ordm", "oslash", "otilde", "ouml", "para", "plusmn", "pound", "quot", "raquo", "reg", "sect", "shy", "sup1", "sup2", "sup3", "szlig", "thorn", "times", "uacute", "ucirc", "ugrave", "uml", "uuml", "yacute", "yen", "yuml"], oC = { 0: "�", 128: "€", 130: "‚", 131: "ƒ", 132: "„", 133: "…", 134: "†", 135: "‡", 136: "ˆ", 137: "‰", 138: "Š", 139: "‹", 140: "Œ", 142: "Ž", 145: "‘", 146: "’", 147: "“", 148: "”", 149: "•", 150: "–", 151: "—", 152: "˜", 153: "™", 154: "š", 155: "›", 156: "œ", 158: "ž", 159: "Ÿ" }; function DT(r) { const e = typeof r == "string" ? r.charCodeAt(0) : r; return e >= 48 && e <= 57 } function woe(r) { const e = typeof r == "string" ? r.charCodeAt(0) : r; return e >= 97 && e <= 102 || e >= 65 && e <= 70 || e >= 48 && e <= 57 } function Coe(r) { const e = typeof r == "string" ? r.charCodeAt(0) : r; return e >= 97 && e <= 122 || e >= 65 && e <= 90 } function lC(r) { return Coe(r) || DT(r) } const cC = document.createElement("i"); function rc(r) { const e = "&" + r + ";"; cC.innerHTML = e; const t = cC.textContent; return t.charCodeAt(t.length - 1) === 59 && r !== "semi" || t === e ? !1 : t } const Soe = ["", "Named character references must be terminated by a semicolon", "Numeric character references must be terminated by a semicolon", "Named character references cannot be empty", "Numeric character references cannot be empty", "Named character references must be known", "Numeric character references cannot be disallowed", "Numeric character references cannot be outside the permissible Unicode range"]; function Eoe(r, e) { const t = e, n = typeof t.additional == "string" ? t.additional.charCodeAt(0) : t.additional, i = []; let s = 0, a = -1, o = "", l, u; t.position && ("start" in t.position || "indent" in t.position ? (u = t.position.indent, l = t.position.start) : l = t.position); let d = (l ? l.line : 0) || 1, h = (l ? l.column : 0) || 1, g = b(), m; for (s--; ++s <= r.length;)if (m === 10 && (h = (u ? u[a] : 0) || 1), m = r.charCodeAt(s), m === 38) { const x = r.charCodeAt(s + 1); if (x === 9 || x === 10 || x === 12 || x === 32 || x === 38 || x === 60 || Number.isNaN(x) || n && x === n) { o += String.fromCharCode(m), h++; continue } const S = s + 1; let C = S, O = S, E; if (x === 35) { O = ++C; const B = r.charCodeAt(O); B === 88 || B === 120 ? (E = "hexadecimal", O = ++C) : E = "decimal" } else E = "named"; let v = "", T = "", I = ""; const k = E === "named" ? lC : E === "decimal" ? DT : woe; for (O--; ++O <= r.length;) { const B = r.charCodeAt(O); if (!k(B)) break; I += String.fromCharCode(B), E === "named" && xoe.includes(I) && (v = I, T = rc(I)) } let P = r.charCodeAt(O) === 59; if (P) { O++; const B = E === "named" ? rc(I) : !1; B && (v = I, T = B) } let N = 1 + O - S, M = ""; if (!(!P && t.nonTerminated === !1)) if (!I) E !== "named" && y(4, N); else if (E === "named") { if (P && !T) y(5, 1); else if (v !== I && (O = C + v.length, N = 1 + O - C, P = !1), !P) { const B = v ? 1 : 3; if (t.attribute) { const K = r.charCodeAt(O); K === 61 ? (y(B, N), T = "") : lC(K) ? T = "" : y(B, N) } else y(B, N) } M = T } else { P || y(2, N); let B = Number.parseInt(I, E === "hexadecimal" ? 16 : 10); if (_oe(B)) y(7, N), M = "�"; else if (B in oC) y(6, N), M = oC[B]; else { let K = ""; Ooe(B) && y(6, N), B > 65535 && (B -= 65536, K += String.fromCharCode(B >>> 10 | 55296), B = 56320 | B & 1023), M = K + String.fromCharCode(B) } } if (M) { w(), g = b(), s = O - 1, h += O - S + 1, i.push(M); const B = b(); B.offset++, t.reference && t.reference.call(t.referenceContext || void 0, M, { start: g, end: B }, r.slice(S - 1, O)), g = B } else I = r.slice(S - 1, O), o += I, h += I.length, s = O - 1 } else m === 10 && (d++, a++, h = 0), Number.isNaN(m) ? w() : (o += String.fromCharCode(m), h++); return i.join(""); function b() { return { line: d, column: h, offset: s + ((l ? l.offset : 0) || 0) } } function y(x, S) { let C; t.warning && (C = b(), C.column += S, C.offset += S, t.warning.call(t.warningContext || void 0, Soe[x], C, x)) } function w() { o && (i.push(o), t.text && t.text.call(t.textContext || void 0, o, { start: g, end: b() }), o = "") } } function _oe(r) { return r >= 55296 && r <= 57343 || r > 1114111 } function Ooe(r) { return r >= 1 && r <= 8 || r === 11 || r >= 13 && r <= 31 || r >= 127 && r <= 159 || r >= 64976 && r <= 65007 || (r & 65535) === 65535 || (r & 65535) === 65534 } const Toe = /["&'<>`]/g, Ioe = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g, Poe = /[\x01-\t\v\f\x0E-\x1F\x7F\x81\x8D\x8F\x90\x9D\xA0-\uFFFF]/g, koe = /[|\\{}()[\]^$+*?.]/g, uC = new WeakMap; function Roe(r, e) { if (r = r.replace(e.subset ? Doe(e.subset) : Toe, n), e.subset || e.escapeOnly) return r; return r.replace(Ioe, t).replace(Poe, n); function t(i, s, a) { return e.format((i.charCodeAt(0) - 55296) * 1024 + i.charCodeAt(1) - 56320 + 65536, a.charCodeAt(s + 2), e) } function n(i, s, a) { return e.format(i.charCodeAt(0), a.charCodeAt(s + 1), e) } } function Doe(r) { let e = uC.get(r); return e || (e = Aoe(r), uC.set(r, e)), e } function Aoe(r) { const e = []; let t = -1; for (; ++t < r.length;)e.push(r[t].replace(koe, "\\$&")); return new RegExp("(?:" + e.join("|") + ")", "g") } function Noe(r) { return "&#x" + r.toString(16).toUpperCase() + ";" } function Foe(r, e) { return Roe(r, Object.assign({ format: Noe }, e)) } const AT = "  "; function $oe() { return { canContainEols: ["mdxJsxTextElement"], enter: { mdxJsxFlowTag: n, mdxJsxFlowTagClosingMarker: i, mdxJsxFlowTagAttribute: h, mdxJsxFlowTagExpressionAttribute: g, mdxJsxFlowTagAttributeValueLiteral: r, mdxJsxFlowTagAttributeValueExpression: r, mdxJsxFlowTagSelfClosingMarker: a, mdxJsxTextTag: n, mdxJsxTextTagClosingMarker: i, mdxJsxTextTagAttribute: h, mdxJsxTextTagExpressionAttribute: g, mdxJsxTextTagAttributeValueLiteral: r, mdxJsxTextTagAttributeValueExpression: r, mdxJsxTextTagSelfClosingMarker: a }, exit: { mdxJsxFlowTagClosingMarker: o, mdxJsxFlowTagNamePrimary: l, mdxJsxFlowTagNameMember: u, mdxJsxFlowTagNameLocal: d, mdxJsxFlowTagExpressionAttribute: m, mdxJsxFlowTagExpressionAttributeValue: t, mdxJsxFlowTagAttributeNamePrimary: b, mdxJsxFlowTagAttributeNameLocal: y, mdxJsxFlowTagAttributeValueLiteral: w, mdxJsxFlowTagAttributeValueLiteralValue: t, mdxJsxFlowTagAttributeValueExpression: x, mdxJsxFlowTagAttributeValueExpressionValue: t, mdxJsxFlowTagSelfClosingMarker: S, mdxJsxFlowTag: C, mdxJsxTextTagClosingMarker: o, mdxJsxTextTagNamePrimary: l, mdxJsxTextTagNameMember: u, mdxJsxTextTagNameLocal: d, mdxJsxTextTagExpressionAttribute: m, mdxJsxTextTagExpressionAttributeValue: t, mdxJsxTextTagAttributeNamePrimary: b, mdxJsxTextTagAttributeNameLocal: y, mdxJsxTextTagAttributeValueLiteral: w, mdxJsxTextTagAttributeValueLiteralValue: t, mdxJsxTextTagAttributeValueExpression: x, mdxJsxTextTagAttributeValueExpressionValue: t, mdxJsxTextTagSelfClosingMarker: S, mdxJsxTextTag: C } }; function r() { this.buffer() } function e(T) { return { line: T.line, column: T.column, offset: T.offset } } function t(T) { this.config.enter.data.call(this, T), this.config.exit.data.call(this, T) } function n(T) { const I = { name: void 0, attributes: [], close: !1, selfClosing: !1, start: T.start, end: T.end }; this.data.mdxJsxTagStack || (this.data.mdxJsxTagStack = []), this.data.mdxJsxTag = I, this.buffer() } function i(T) { if (this.data.mdxJsxTagStack.length === 0) throw new vt("Unexpected closing slash `/` in tag, expected an open tag first", { start: T.start, end: T.end }, "mdast-util-mdx-jsx:unexpected-closing-slash") } function s(T) { if (this.data.mdxJsxTag.close) throw new vt("Unexpected attribute in closing tag, expected the end of the tag", { start: T.start, end: T.end }, "mdast-util-mdx-jsx:unexpected-attribute") } function a(T) { if (this.data.mdxJsxTag.close) throw new vt("Unexpected self-closing slash `/` in closing tag, expected the end of the tag", { start: T.start, end: T.end }, "mdast-util-mdx-jsx:unexpected-self-closing-slash") } function o() { const T = this.data.mdxJsxTag; T.close = !0 } function l(T) { const I = this.data.mdxJsxTag; I.name = this.sliceSerialize(T) } function u(T) { const I = this.data.mdxJsxTag; I.name += "." + this.sliceSerialize(T) } function d(T) { const I = this.data.mdxJsxTag; I.name += ":" + this.sliceSerialize(T) } function h(T) { const I = this.data.mdxJsxTag; s.call(this, T), I.attributes.push({ type: "mdxJsxAttribute", name: "", value: null, position: { start: e(T.start), end: void 0 } }) } function g(T) { const I = this.data.mdxJsxTag; s.call(this, T), I.attributes.push({ type: "mdxJsxExpressionAttribute", value: "", position: { start: e(T.start), end: void 0 } }), this.buffer() } function m(T) { const I = this.data.mdxJsxTag, k = I.attributes[I.attributes.length - 1]; k.type; const P = T.estree; k.value = this.resume(), k.position, k.position.end = e(T.end), P && (k.data = { estree: P }) } function b(T) { const I = this.data.mdxJsxTag, k = I.attributes[I.attributes.length - 1]; k.type, k.name = this.sliceSerialize(T), k.position, k.position.end = e(T.end) } function y(T) { const I = this.data.mdxJsxTag, k = I.attributes[I.attributes.length - 1]; k.type, k.name += ":" + this.sliceSerialize(T), k.position, k.position.end = e(T.end) } function w(T) { const I = this.data.mdxJsxTag, k = I.attributes[I.attributes.length - 1]; k.value = Eoe(this.resume(), { nonTerminated: !1 }), k.position, k.position.end = e(T.end) } function x(T) { const I = this.data.mdxJsxTag, k = I.attributes[I.attributes.length - 1]; k.type; const P = { type: "mdxJsxAttributeValueExpression", value: this.resume() }, N = T.estree; N && (P.data = { estree: N }), k.value = P, k.position, k.position.end = e(T.end) } function S() { const T = this.data.mdxJsxTag; T.selfClosing = !0 } function C(T) { const I = this.data.mdxJsxTag, k = this.data.mdxJsxTagStack, P = k[k.length - 1]; if (I.close && P.name !== I.name) throw new vt("Unexpected closing tag `" + v(I) + "`, expected corresponding closing tag for `" + v(P) + "` (" + Wr(P) + ")", { start: T.start, end: T.end }, "mdast-util-mdx-jsx:end-tag-mismatch"); this.resume(), I.close ? k.pop() : this.enter({ type: T.type === "mdxJsxTextTag" ? "mdxJsxTextElement" : "mdxJsxFlowElement", name: I.name || null, attributes: I.attributes, children: [] }, T, O), I.selfClosing || I.close ? this.exit(T, E) : k.push(I) } function O(T, I) { const k = this.data.mdxJsxTagStack, P = k[k.length - 1], N = T ? " before the end of `" + T.type + "`" : "", M = T ? { start: T.start, end: T.end } : void 0; throw new vt("Expected a closing tag for `" + v(P) + "` (" + Wr({ start: I.start, end: I.end }) + ")" + N, M, "mdast-util-mdx-jsx:end-tag-mismatch") } function E(T, I) { const k = this.data.mdxJsxTag; throw new vt("Expected the closing tag `" + v(k) + "` either after the end of `" + I.type + "` (" + Wr(I.end) + ") or another opening tag after the start of `" + I.type + "` (" + Wr(I.start) + ")", { start: T.start, end: T.end }, "mdast-util-mdx-jsx:end-tag-mismatch") } function v(T) { return "<" + (T.close ? "/" : "") + (T.name || "") + ">" } } function Loe(r) {
  const e = r, t = e.quote || '"', n = e.quoteSmart || !1, i = e.tightSelfClosing || !1, s = e.printWidth || Number.POSITIVE_INFINITY, a = t === '"' ? "'" : '"'; if (t !== '"' && t !== "'") throw new Error("Cannot serialize attribute values with `" + t + "` for `options.quote`, expected `\"`, or `'`"); return o.peek = joe, { handlers: { mdxJsxFlowElement: o, mdxJsxTextElement: o }, unsafe: [{ character: "<", inConstruct: ["phrasing"] }, { atBreak: !0, character: "<" }], fences: !0, resourceLink: !0 }; function o(l, u, d, h) {
    const g = l.type === "mdxJsxFlowElement", m = l.name ? !l.children || l.children.length === 0 : !1, b = NT(d), y = FT(b), w = d.createTracker(h), x = d.createTracker(h), S = [], C = (g ? y : "") + "<" + (l.name || ""), O = d.enter(l.type); if (w.move(C), x.move(C), l.attributes && l.attributes.length > 0) { if (!l.name) throw new Error("Cannot serialize fragment w/ attributes"); let k = -1; for (; ++k < l.attributes.length;) { const P = l.attributes[k]; let N; if (P.type === "mdxJsxExpressionAttribute") N = "{" + (P.value || "") + "}"; else { if (!P.name) throw new Error("Cannot serialize attribute w/o name"); const M = P.value, B = P.name; let K = ""; if (M != null) if (typeof M == "object") K = "{" + (M.value || "") + "}"; else { const U = n && wd(M, t) > wd(M, a) ? a : t; K = U + Foe(M, { subset: [U] }) + U } N = B + (K ? "=" : "") + K } S.push(N) } } let E = !1; const v = S.join(" "); g && (/\r?\n|\r/.test(v) || w.current().now.column + v.length + (m ? i ? 2 : 3 : 1) > s) && (E = !0); let T = w, I = C; if (E) {
      T = x; let k = -1; for (; ++k < S.length;)S[k] = y + AT + S[k]; I += T.move(`
`+ S.join(`
`) + `
`+ y)
    } else v && (I += T.move(" " + v)); return m && (I += T.move((i || E ? "" : " ") + "/")), I += T.move(">"), l.children && l.children.length > 0 && (l.type === "mdxJsxTextElement" ? I += T.move(d.containerPhrasing(l, { ...T.current(), before: ">", after: "<" })) : (T.shift(2), I += T.move(`
`), I += T.move(Moe(l, d, T.current())), I += T.move(`
`))), m || (I += T.move((g ? y : "") + "</" + (l.name || "") + ">")), O(), I
  }
} function Moe(r, e, t) {
  const n = e.indexStack, i = r.children, s = e.createTracker(t), a = FT(NT(e)), o = []; let l = -1; for (n.push(-1); ++l < i.length;) {
    const u = i[l]; n[n.length - 1] = l; const d = {
      before: `
`, after: `
`, ...s.current()
    }, h = e.handle(u, r, e, d), g = u.type === "mdxJsxFlowElement" ? h : e.indentLines(h, function (m, b, y) { return (y ? "" : a) + m }); o.push(s.move(g)), u.type !== "list" && (e.bulletLastUsed = void 0), l < i.length - 1 && o.push(s.move(`

`))
  } return n.pop(), o.join("")
} function NT(r) { let e = 0, t = r.stack.length; for (; --t > -1;) { const n = r.stack[t]; if (n === "blockquote" || n === "listItem") break; n === "mdxJsxFlowElement" && e++ } return e } function FT(r) { return AT.repeat(r) } function joe() { return "<" } function Voe() { return { enter: { mdxjsEsm: zoe }, exit: { mdxjsEsm: Hoe, mdxjsEsmData: Koe } } } function Boe() { return { handlers: { mdxjsEsm: Uoe } } } function zoe(r) { this.enter({ type: "mdxjsEsm", value: "" }, r), this.buffer() } function Hoe(r) { const e = this.resume(), t = this.stack[this.stack.length - 1]; t.type, this.exit(r); const n = r.estree; t.value = e, n && (t.data = { estree: n }) } function Koe(r) { this.config.enter.data.call(this, r), this.config.exit.data.call(this, r) } function Uoe(r) { return r.value || "" } function Woe() { return [moe(), $oe(), Voe()] } function Goe(r) { return { extensions: [yoe(), Loe(r), Boe()] } } var Yoe = Jg(); const Xn = Ks(/[A-Za-z]/), Zn = Ks(/[\dA-Za-z]/), Xoe = Ks(/[#-'*+\--9=?A-Z^-~]/); function Cd(r) { return r !== null && (r < 32 || r === 127) } const nm = Ks(/\d/), qoe = Ks(/[\dA-Fa-f]/), Zoe = Ks(/[!-/:-@[-`{-~]/); function Ee(r) { return r !== null && r < -2 } function it(r) { return r !== null && (r < 0 || r === 32) } function Ve(r) { return r === -2 || r === -1 || r === 32 } const Lh = Ks(new RegExp("\\p{P}|\\p{S}", "u")), sr = Ks(/\s/); function Ks(r) { return e; function e(t) { return t !== null && t > -1 && r.test(String.fromCharCode(t)) } } function Ge(r, e, t, n) { const i = n ? n - 1 : Number.POSITIVE_INFINITY; let s = 0; return a; function a(l) { return Ve(l) ? (r.enter(t), o(l)) : e(l) } function o(l) { return Ve(l) && s++ < i ? (r.consume(l), o) : (r.exit(t), e(l)) } } const Joe = {}.hasOwnProperty, Qoe = Symbol("continue"), Jp = Symbol("exit"), ele = Symbol("skip"); function tle(r, e) { let t, n; typeof e == "function" ? t = e : typeof e == "object" && (e.enter && (t = e.enter), e.leave && (n = e.leave)), i(r, void 0, void 0, [])(); function i(s, a, o, l) { return Qp(s) && (u.displayName = "node (" + s.type + ")"), u; function u() { const d = t ? dC(t(s, a, o, l)) : []; if (d[0] === Jp) return d; if (d[0] !== ele) { let h; for (h in s) if (Joe.call(s, h) && s[h] && typeof s[h] == "object" && h !== "data" && h !== "position") { const g = l.concat(s), m = s[h]; if (Array.isArray(m)) { const b = m; let y = 0; for (; y > -1 && y < b.length;) { const w = b[y]; if (Qp(w)) { const x = i(w, h, y, g)(); if (x[0] === Jp) return x; y = typeof x[1] == "number" ? x[1] : y + 1 } else y++ } } else if (Qp(m)) { const b = i(m, h, void 0, g)(); if (b[0] === Jp) return b } } } return n ? dC(n(s, a, o, l)) : d } } } function dC(r) { return Array.isArray(r) ? r : typeof r == "number" ? [Qoe, r] : [r] } function Qp(r) { return !!(r && typeof r == "object" && "type" in r && typeof r.type == "string" && r.type.length > 0) } function $T(r, e) { const t = e.prefix || "", n = e.suffix || "", i = Object.assign({}, e.acornOptions), s = [], a = [], o = i.onComment, l = i.onToken; let u = !1, d, h; const g = Object.assign({}, i, { onComment: s, preserveParens: !0 }); l && (g.onToken = a); const m = nle(r, e.tokenTypes), b = m.value, y = t + b + n, w = e.expression && hC(b); if (w && !e.allowEmpty) throw new vt("Unexpected empty expression", { place: S(0), ruleId: "unexpected-empty-expression", source: "micromark-extension-mdx-expression" }); try { d = e.expression && !w ? e.acorn.parseExpressionAt(y, 0, g) : e.acorn.parse(y, g) } catch (C) { const O = C, E = S(O.pos); O.message = String(O.message).replace(/ \(\d+:\d+\)$/, ""), O.pos = E.offset, O.loc = { line: E.line, column: E.column - 1 }, h = O, u = O.raisedAt >= t.length + b.length || O.message === "Unterminated comment" } if (d && e.expression && !w) if (hC(y.slice(d.end, y.length - n.length))) d = { type: "Program", start: 0, end: t.length + b.length, body: [{ type: "ExpressionStatement", expression: d, start: 0, end: t.length + b.length }], sourceType: "module", comments: [] }; else { const C = S(d.end), O = new Error("Unexpected content after expression"); O.pos = C.offset, O.loc = { line: C.line, column: C.column - 1 }, h = O, d = void 0 } if (d) { if (d.comments = s, tle(d, function (C, O, E, v) { let T = v[v.length - 1], I = O; C.type === "ParenthesizedExpression" && T && I && (typeof E == "number" && (T = T[I], I = E), T[I] = C.expression), x(C) }), Array.isArray(o)) o.push(...s); else if (typeof o == "function") for (const C of s) o(C.type === "Block", C.value, C.start, C.end, C.loc.start, C.loc.end); for (const C of a) C.end <= t.length || C.start - t.length >= b.length || (x(C), Array.isArray(l) ? l.push(C) : l(C)) } return { estree: d, error: h, swallow: u }; function x(C) { const O = S(C.start), E = S(C.end); C.start = O.offset, C.end = E.offset, C.loc = { start: { line: O.line, column: O.column - 1, offset: O.offset }, end: { line: E.line, column: E.column - 1, offset: E.offset } }, C.range = [C.start, C.end] } function S(C) { let O = C - t.length; O < 0 ? O = 0 : O > b.length && (O = b.length); let E = rle(m.stops, O); return E || (E = { line: e.start.line, column: e.start.column, offset: e.start.offset }), E } } function hC(r) { return /^\s*$/.test(r.replace(/\/\*[\s\S]*?\*\//g, "").replace(/\/\/[^\r\n]*(\r\n|\n|\r)/g, "")) } function nle(r, e) { const t = { value: "", stops: [] }; let n = -1; for (; ++n < r.length;) { const i = r[n]; if (i[0] === "enter") { const s = i[1].type; if (s === "lineEnding" || e.includes(s)) { const a = i[2].sliceStream(i[1]); for (; a.length > 0 && a[0] === -1;)a.shift(); const o = ile(a); t.stops.push([t.value.length, i[1].start]), t.value += o, t.stops.push([t.value.length, i[1].end]) } } } return t } function rle(r, e) { let t = 0; for (; t < r.length && r[t][0] <= e;)t += 1; if (t === 0) return; const [n, i] = r[t - 1], s = e - n; return { line: i.line, column: i.column + s, offset: i.offset + s } } function ile(r) {
  let e = -1; const t = []; let n; for (; ++e < r.length;) {
    const i = r[e]; let s; if (typeof i == "string") s = i; else switch (i) {
      case -5: { s = "\r"; break } case -4: {
        s = `
`; break
      } case -3: {
        s = `\r
`; break
      } case -2: { s = "	"; break } case -1: { if (n) continue; s = " "; break } default: s = String.fromCharCode(i)
    }n = i === -2, t.push(s)
  } return t.join("")
} function ns(r) { const e = r || {}, t = e.loc || {}, n = e.range || [void 0, void 0], i = pC(t.start, n[0] || e.start), s = pC(t.end, n[1] || e.end); if (i && s) return { start: i, end: s } } function pC(r, e) { if (r && typeof r == "object") { const t = "line" in r ? ef(r.line) : void 0, n = "column" in r ? ef(r.column) : void 0; if (t && n !== void 0) return { line: t, column: n + 1, offset: ef(e) } } } function ef(r) { return typeof r == "number" && r > -1 ? r : void 0 } const sle = 2, uo = "https://github.com/micromark/micromark-extension-mdx-expression/tree/main/packages/micromark-extension-mdx-expression", ale = "#unexpected-end-of-file-in-expression-expected-a-corresponding-closing-brace-for-", ole = "#unexpected-lazy-line-in-expression-in-container-expected-line-to-be-prefixed", fC = "#unexpected-type-in-code-expected-an-object-spread-spread", lle = "#unexpected-extra-content-in-spread-only-a-single-spread-is-supported", cle = "#could-not-parse-expression-with-acorn"; function Sd(r, e, t, n, i, s, a, o, l, u, d) { const h = this, g = this.events.length + 3; let m = 0, b, y; return w; function w(O) { return r.enter(t), r.enter(n), r.consume(O), r.exit(n), b = h.now(), x } function x(O) { if (O === null) { if (y) throw y; const E = new vt("Unexpected end of file in expression, expected a corresponding closing brace for `{`", { place: h.now(), ruleId: "unexpected-eof", source: "micromark-extension-mdx-expression" }); throw E.url = uo + ale, E } if (Ee(O)) return r.enter("lineEnding"), r.consume(O), r.exit("lineEnding"), C; if (O === 125 && m === 0) { const E = s ? ule.call(h, s, a, i, g, b, u || !1, l || !1) : { type: "ok", estree: void 0 }; if (E.type === "ok") { r.enter(n), r.consume(O), r.exit(n); const v = r.exit(t); return o && E.estree && Object.assign(v, { estree: E.estree }), e } return y = E.message, r.enter(i), r.consume(O), S } return r.enter(i), S(O) } function S(O) { return O === 125 && m === 0 || O === null || Ee(O) ? (r.exit(i), x(O)) : (O === 123 && !s ? m += 1 : O === 125 && (m -= 1), r.consume(O), S) } function C(O) { const E = h.now(); if (E.line !== b.line && !d && h.parser.lazy[E.line]) { const v = new vt("Unexpected lazy line in expression in container, expected line to be prefixed with `>` when in a block quote, whitespace when in a list, etc", { place: h.now(), ruleId: "unexpected-lazy", source: "micromark-extension-mdx-expression" }); throw v.url = uo + ole, v } return Ve(O) ? Ge(r, x, "linePrefix", sle + 1)(O) : x(O) } } function ule(r, e, t, n, i, s, a) { const o = $T(this.events.slice(n), { acorn: r, tokenTypes: [t], acornOptions: e, start: i, expression: !0, allowEmpty: s, prefix: a ? "({" : "", suffix: a ? "})" : "" }), l = o.estree; if (a && l) { const u = l.body[0]; if (u.type !== "ExpressionStatement" || u.expression.type !== "ObjectExpression") { const d = ns(u), h = new vt("Unexpected `" + u.type + "` in code: expected an object spread (`{...spread}`)", { place: d.start, ruleId: "non-spread", source: "micromark-extension-mdx-expression" }); throw h.url = uo + fC, h } if (u.expression.properties[1]) { const d = ns(u.expression.properties[1]), h = new vt("Unexpected extra content in spread: only a single spread is supported", { place: d.start, ruleId: "spread-extra", source: "micromark-extension-mdx-expression" }); throw h.url = uo + lle, h } if (u.expression.properties[0] && u.expression.properties[0].type !== "SpreadElement") { const d = ns(u.expression.properties[0]), h = new vt("Unexpected `" + u.expression.properties[0].type + "` in code: only spread elements are supported", { place: d.start, ruleId: "non-spread", source: "micromark-extension-mdx-expression" }); throw h.url = uo + fC, h } } if (o.error) { const u = new vt("Could not parse expression with acorn", { cause: o.error, place: { line: o.error.loc.line, column: o.error.loc.column + 1, offset: o.error.pos }, ruleId: "acorn", source: "micromark-extension-mdx-expression" }); return u.url = uo + cle, { type: "nok", message: u } } return { type: "ok", estree: l } } function dle(r) { const e = r || {}, t = e.addResult, n = e.acorn, i = e.spread; let s = e.allowEmpty, a; if (s == null && (s = !0), n) { if (!n.parseExpressionAt) throw new Error("Expected a proper `acorn` instance passed in as `options.acorn`"); a = Object.assign({ ecmaVersion: 2024, sourceType: "module" }, e.acornOptions) } else if (e.acornOptions || e.addResult) throw new Error("Expected an `acorn` instance passed in as `options.acorn`"); return { flow: { 123: { name: "mdxFlowExpression", tokenize: o, concrete: !0 } }, text: { 123: { name: "mdxTextExpression", tokenize: l } } }; function o(u, d, h) { const g = this; return m; function m(x) { return b(x) } function b(x) { return Sd.call(g, u, y, "mdxFlowExpression", "mdxFlowExpressionMarker", "mdxFlowExpressionChunk", n, a, t, i, s)(x) } function y(x) { return Ve(x) ? Ge(u, w, "whitespace")(x) : w(x) } function w(x) { const S = g.parser.constructs.flow[60], O = (Array.isArray(S) ? S : S ? [S] : []).find(function (E) { return E.name === "mdxJsxFlowTag" }); return x === 60 && O ? u.attempt(O, w, h)(x) : x === null || Ee(x) ? d(x) : h(x) } } function l(u, d) { const h = this; return g; function g(m) { return Sd.call(h, u, d, "mdxTextExpression", "mdxTextExpressionMarker", "mdxTextExpressionChunk", n, a, t, i, s, !0)(m) } } } const gC = "https://github.com/micromark/micromark-extension-mdx-jsx"; function LT(r, e, t, n, i, s, a, o, l, u, d, h, g, m, b, y, w, x, S, C, O, E, v, T, I, k, P, N, M, B, K, U) { const W = this; let Z, J; return ee; function ee(L) { return r.enter(o), r.enter(l), r.consume(L), r.exit(l), $ } function $(L) { return it(L) ? t(L) : (Z = pe, Ze(L)) } function pe(L) { if (L === 47) return r.enter(u), r.consume(L), r.exit(u), Z = re, Ze; if (L === 62) return wn(L); if (L !== null && L >= 0 && ai(L)) return r.enter(h), r.enter(g), r.consume(L), j; Q(L, "before name", "a character that can start a name, such as a letter, `$`, or `_`" + (L === 33 ? " (note: to create a comment in MDX, use `{/* text */}`)" : "")) } function re(L) { if (L === 62) return wn(L); if (L !== null && L >= 0 && ai(L)) return r.enter(h), r.enter(g), r.consume(L), j; Q(L, "before name", "a character that can start a name, such as a letter, `$`, or `_`" + (L === 42 || L === 47 ? " (note: JS comments in JSX tags are not supported in MDX)" : "")) } function j(L) { if (L !== null && L >= 0 && Sl(L, { jsx: !0 })) return r.consume(L), j; if (L === 46 || L === 47 || L === 58 || L === 62 || L === 123 || it(L) || sr(L)) return r.exit(g), Z = ae, Ze(L); Q(L, "in name", "a name character such as letters, digits, `$`, or `_`; whitespace before attributes; or the end of the tag" + (L === 64 ? " (note: to create a link in MDX, use `[text](url)`)" : "")) } function ae(L) { if (L === 46) return r.enter(m), r.consume(L), r.exit(m), Z = be, Ze; if (L === 58) return r.enter(y), r.consume(L), r.exit(y), Z = ue, Ze; if (L === 47 || L === 62 || L === 123 || L !== null && L >= 0 && ai(L)) return r.exit(h), Re(L); Q(L, "after name", "a character that can start an attribute name, such as a letter, `$`, or `_`; whitespace before attributes; or the end of the tag") } function be(L) { if (L !== null && L >= 0 && ai(L)) return r.enter(b), r.consume(L), fe; Q(L, "before member name", "a character that can start an attribute name, such as a letter, `$`, or `_`; whitespace before attributes; or the end of the tag") } function fe(L) { if (L !== null && L >= 0 && Sl(L, { jsx: !0 })) return r.consume(L), fe; if (L === 46 || L === 47 || L === 62 || L === 123 || it(L) || sr(L)) return r.exit(b), Z = Ce, Ze(L); Q(L, "in member name", "a name character such as letters, digits, `$`, or `_`; whitespace before attributes; or the end of the tag" + (L === 64 ? " (note: to create a link in MDX, use `[text](url)`)" : "")) } function Ce(L) { if (L === 46) return r.enter(m), r.consume(L), r.exit(m), Z = be, Ze; if (L === 47 || L === 62 || L === 123 || L !== null && L >= 0 && ai(L)) return r.exit(h), Re(L); Q(L, "after member name", "a character that can start an attribute name, such as a letter, `$`, or `_`; whitespace before attributes; or the end of the tag") } function ue(L) { if (L !== null && L >= 0 && ai(L)) return r.enter(w), r.consume(L), te; Q(L, "before local name", "a character that can start a name, such as a letter, `$`, or `_`" + (L === 43 || L !== null && L > 46 && L < 58 ? " (note: to create a link in MDX, use `[text](url)`)" : "")) } function te(L) { if (L !== null && L >= 0 && Sl(L, { jsx: !0 })) return r.consume(L), te; if (L === 47 || L === 62 || L === 123 || it(L) || sr(L)) return r.exit(w), Z = le, Ze(L); Q(L, "in local name", "a name character such as letters, digits, `$`, or `_`; whitespace before attributes; or the end of the tag") } function le(L) { if (L === 47 || L === 62 || L === 123 || L !== null && L >= 0 && ai(L)) return r.exit(h), Re(L); Q(L, "after local name", "a character that can start an attribute name, such as a letter, `$`, or `_`; whitespace before attributes; or the end of the tag") } function Re(L) { if (L === 47) return r.enter(d), r.consume(L), r.exit(d), Z = Wt, Ze; if (L === 62) return wn(L); if (L === 123) return Sd.call(W, r, at, x, S, C, n, i, s, !0, !1, a)(L); if (L !== null && L >= 0 && ai(L)) return r.enter(O), r.enter(E), r.enter(v), r.consume(L), yt; Q(L, "before attribute name", "a character that can start an attribute name, such as a letter, `$`, or `_`; whitespace before attributes; or the end of the tag") } function at(L) { return Z = Re, Ze(L) } function yt(L) { if (L !== null && L >= 0 && Sl(L, { jsx: !0 })) return r.consume(L), yt; if (L === 47 || L === 58 || L === 61 || L === 62 || L === 123 || it(L) || sr(L)) return r.exit(v), Z = ht, Ze(L); Q(L, "in attribute name", "an attribute name character such as letters, digits, `$`, or `_`; `=` to initialize a value; whitespace before attributes; or the end of the tag") } function ht(L) { if (L === 58) return r.enter(T), r.consume(L), r.exit(T), Z = Ft, Ze; if (L === 61) return r.exit(E), r.enter(k), r.consume(L), r.exit(k), Z = gn, Ze; if (L === 47 || L === 62 || L === 123 || it(L) || sr(L) || L !== null && L >= 0 && ai(L)) return r.exit(E), r.exit(O), Z = Re, Ze(L); Q(L, "after attribute name", "a character that can start an attribute name, such as a letter, `$`, or `_`; `=` to initialize a value; or the end of the tag") } function Ft(L) { if (L !== null && L >= 0 && ai(L)) return r.enter(I), r.consume(L), qe; Q(L, "before local attribute name", "a character that can start an attribute name, such as a letter, `$`, or `_`; `=` to initialize a value; or the end of the tag") } function qe(L) { if (L !== null && L >= 0 && Sl(L, { jsx: !0 })) return r.consume(L), qe; if (L === 47 || L === 61 || L === 62 || L === 123 || it(L) || sr(L)) return r.exit(I), r.exit(E), Z = $t, Ze(L); Q(L, "in local attribute name", "an attribute name character such as letters, digits, `$`, or `_`; `=` to initialize a value; whitespace before attributes; or the end of the tag") } function $t(L) { if (L === 61) return r.enter(k), r.consume(L), r.exit(k), Z = gn, Ze; if (L === 47 || L === 62 || L === 123 || L !== null && L >= 0 && ai(L)) return r.exit(O), Re(L); Q(L, "after local attribute name", "a character that can start an attribute name, such as a letter, `$`, or `_`; `=` to initialize a value; or the end of the tag") } function gn(L) { if (L === 34 || L === 39) return r.enter(P), r.enter(N), r.consume(L), r.exit(N), J = L, ot; if (L === 123) return Sd.call(W, r, Hn, B, K, U, n, i, s, !1, !1, a)(L); Q(L, "before attribute value", "a character that can start an attribute value, such as `\"`, `'`, or `{`" + (L === 60 ? " (note: to use an element or fragment as a prop value in MDX, use `{<element />}`)" : "")) } function Hn(L) { return r.exit(O), Z = Re, Ze(L) } function ot(L) { return L === null && Q(L, "in attribute value", "a corresponding closing quote `" + String.fromCodePoint(J) + "`"), L === J ? (r.enter(N), r.consume(L), r.exit(N), r.exit(P), r.exit(O), J = void 0, Z = Re, Ze) : Ee(L) ? (Z = ot, Ze(L)) : (r.enter(M), Ut(L)) } function Ut(L) { return L === null || L === J || Ee(L) ? (r.exit(M), ot(L)) : (r.consume(L), Ut) } function Wt(L) { if (L === 62) return wn(L); Q(L, "after self-closing slash", "`>` to end the tag" + (L === 42 || L === 47 ? " (note: JS comments in JSX tags are not supported in MDX)" : "")) } function wn(L) { return r.enter(l), r.consume(L), r.exit(l), r.exit(o), e } function Ze(L) { return Ee(L) ? (r.enter("lineEnding"), r.consume(L), r.exit("lineEnding"), X) : Ve(L) || sr(L) ? (r.enter("esWhitespace"), hr(L)) : Z(L) } function hr(L) { return Ee(L) ? (r.exit("esWhitespace"), Ze(L)) : Ve(L) || sr(L) ? (r.consume(L), hr) : (r.exit("esWhitespace"), Z(L)) } function X(L) { if (!a && W.parser.lazy[W.now().line]) { const Oe = new vt("Unexpected lazy line in container, expected line to be prefixed with `>` when in a block quote, whitespace when in a list, etc", W.now(), "micromark-extension-mdx-jsx:unexpected-lazy"); throw Oe.url = gC + "#unexpected-lazy-line-in-container-expected-line-to-be", Oe } return Ze(L) } function Q(L, Oe, De) { const ie = new vt("Unexpected " + (L === null ? "end of file" : "character `" + (L === 96 ? "` ` `" : String.fromCodePoint(L)) + "` (" + hle(L) + ")") + " " + Oe + ", expected " + De, W.now(), "micromark-extension-mdx-jsx:unexpected-" + (L === null ? "eof" : "character")); throw ie.url = gC + (L === null ? "#unexpected-end-of-file-at-expected-expect" : "#unexpected-character-at-expected-expect"), ie } } function hle(r) { return "U+" + r.toString(16).toUpperCase().padStart(4, "0") } function ple(r, e) { return { name: "mdxJsxTextTag", tokenize: t }; function t(n, i, s) { return LT.call(this, n, i, s, r, e.acornOptions, e.addResult, !0, "mdxJsxTextTag", "mdxJsxTextTagMarker", "mdxJsxTextTagClosingMarker", "mdxJsxTextTagSelfClosingMarker", "mdxJsxTextTagName", "mdxJsxTextTagNamePrimary", "mdxJsxTextTagNameMemberMarker", "mdxJsxTextTagNameMember", "mdxJsxTextTagNamePrefixMarker", "mdxJsxTextTagNameLocal", "mdxJsxTextTagExpressionAttribute", "mdxJsxTextTagExpressionAttributeMarker", "mdxJsxTextTagExpressionAttributeValue", "mdxJsxTextTagAttribute", "mdxJsxTextTagAttributeName", "mdxJsxTextTagAttributeNamePrimary", "mdxJsxTextTagAttributeNamePrefixMarker", "mdxJsxTextTagAttributeNameLocal", "mdxJsxTextTagAttributeInitializerMarker", "mdxJsxTextTagAttributeValueLiteral", "mdxJsxTextTagAttributeValueLiteralMarker", "mdxJsxTextTagAttributeValueLiteralValue", "mdxJsxTextTagAttributeValueExpression", "mdxJsxTextTagAttributeValueExpressionMarker", "mdxJsxTextTagAttributeValueExpressionValue") } } function fle(r, e) { return { name: "mdxJsxFlowTag", tokenize: t, concrete: !0 }; function t(n, i, s) { const a = this; return o; function o(h) { return l(h) } function l(h) { return LT.call(a, n, u, s, r, e.acornOptions, e.addResult, !1, "mdxJsxFlowTag", "mdxJsxFlowTagMarker", "mdxJsxFlowTagClosingMarker", "mdxJsxFlowTagSelfClosingMarker", "mdxJsxFlowTagName", "mdxJsxFlowTagNamePrimary", "mdxJsxFlowTagNameMemberMarker", "mdxJsxFlowTagNameMember", "mdxJsxFlowTagNamePrefixMarker", "mdxJsxFlowTagNameLocal", "mdxJsxFlowTagExpressionAttribute", "mdxJsxFlowTagExpressionAttributeMarker", "mdxJsxFlowTagExpressionAttributeValue", "mdxJsxFlowTagAttribute", "mdxJsxFlowTagAttributeName", "mdxJsxFlowTagAttributeNamePrimary", "mdxJsxFlowTagAttributeNamePrefixMarker", "mdxJsxFlowTagAttributeNameLocal", "mdxJsxFlowTagAttributeInitializerMarker", "mdxJsxFlowTagAttributeValueLiteral", "mdxJsxFlowTagAttributeValueLiteralMarker", "mdxJsxFlowTagAttributeValueLiteralValue", "mdxJsxFlowTagAttributeValueExpression", "mdxJsxFlowTagAttributeValueExpressionMarker", "mdxJsxFlowTagAttributeValueExpressionValue")(h) } function u(h) { return Ve(h) ? Ge(n, d, "whitespace")(h) : d(h) } function d(h) { const g = a.parser.constructs.flow[123], b = (Array.isArray(g) ? g : g ? [g] : []).find(y => y.name === "mdxFlowExpression"); return h === 60 ? o(h) : h === 123 && b ? n.attempt(b, d, s)(h) : h === null || Ee(h) ? i(h) : s(h) } } } function gle(r) { const e = r || {}, t = e.acorn; let n; if (t) { if (!t.parse || !t.parseExpressionAt) throw new Error("Expected a proper `acorn` instance passed in as `options.acorn`"); n = Object.assign({ ecmaVersion: 2024, sourceType: "module" }, e.acornOptions, { locations: !0 }) } else if (e.acornOptions || e.addResult) throw new Error("Expected an `acorn` instance passed in as `options.acorn`"); return { flow: { 60: fle(t || void 0, { acornOptions: n, addResult: e.addResult || void 0 }) }, text: { 60: ple(t || void 0, { acornOptions: n, addResult: e.addResult || void 0 }) } } } function mle() { return { disable: { null: ["autolink", "codeIndented", "htmlFlow", "htmlText"] } } } function Dr(r, e, t, n) { const i = r.length; let s = 0, a; if (e < 0 ? e = -e > i ? 0 : i + e : e = e > i ? i : e, t = t > 0 ? t : 0, n.length < 1e4) a = Array.from(n), a.unshift(e, t), r.splice(...a); else for (t && r.splice(e, t); s < n.length;)a = n.slice(s, s + 1e4), a.unshift(e, 0), r.splice(...a), s += 1e4, e += 1e4 } function Br(r, e) { return r.length > 0 ? (Dr(r, r.length, 0, e), r) : e } function Ao(r) { if (r === null || it(r) || sr(r)) return 1; if (Lh(r)) return 2 } function Mh(r, e, t) { const n = []; let i = -1; for (; ++i < r.length;) { const s = r[i].resolveAll; s && !n.includes(s) && (e = s(e, t), n.push(s)) } return e } const rm = { name: "attention", resolveAll: yle, tokenize: ble }; function yle(r, e) { let t = -1, n, i, s, a, o, l, u, d; for (; ++t < r.length;)if (r[t][0] === "enter" && r[t][1].type === "attentionSequence" && r[t][1]._close) { for (n = t; n--;)if (r[n][0] === "exit" && r[n][1].type === "attentionSequence" && r[n][1]._open && e.sliceSerialize(r[n][1]).charCodeAt(0) === e.sliceSerialize(r[t][1]).charCodeAt(0)) { if ((r[n][1]._close || r[t][1]._open) && (r[t][1].end.offset - r[t][1].start.offset) % 3 && !((r[n][1].end.offset - r[n][1].start.offset + r[t][1].end.offset - r[t][1].start.offset) % 3)) continue; l = r[n][1].end.offset - r[n][1].start.offset > 1 && r[t][1].end.offset - r[t][1].start.offset > 1 ? 2 : 1; const h = { ...r[n][1].end }, g = { ...r[t][1].start }; mC(h, -l), mC(g, l), a = { type: l > 1 ? "strongSequence" : "emphasisSequence", start: h, end: { ...r[n][1].end } }, o = { type: l > 1 ? "strongSequence" : "emphasisSequence", start: { ...r[t][1].start }, end: g }, s = { type: l > 1 ? "strongText" : "emphasisText", start: { ...r[n][1].end }, end: { ...r[t][1].start } }, i = { type: l > 1 ? "strong" : "emphasis", start: { ...a.start }, end: { ...o.end } }, r[n][1].end = { ...a.start }, r[t][1].start = { ...o.end }, u = [], r[n][1].end.offset - r[n][1].start.offset && (u = Br(u, [["enter", r[n][1], e], ["exit", r[n][1], e]])), u = Br(u, [["enter", i, e], ["enter", a, e], ["exit", a, e], ["enter", s, e]]), u = Br(u, Mh(e.parser.constructs.insideSpan.null, r.slice(n + 1, t), e)), u = Br(u, [["exit", s, e], ["enter", o, e], ["exit", o, e], ["exit", i, e]]), r[t][1].end.offset - r[t][1].start.offset ? (d = 2, u = Br(u, [["enter", r[t][1], e], ["exit", r[t][1], e]])) : d = 0, Dr(r, n - 1, t - n + 3, u), t = n + u.length - d - 2; break } } for (t = -1; ++t < r.length;)r[t][1].type === "attentionSequence" && (r[t][1].type = "data"); return r } function ble(r, e) { const t = this.parser.constructs.attentionMarkers.null, n = this.previous, i = Ao(n); let s; return a; function a(l) { return s = l, r.enter("attentionSequence"), o(l) } function o(l) { if (l === s) return r.consume(l), o; const u = r.exit("attentionSequence"), d = Ao(l), h = !d || d === 2 && i || t.includes(l), g = !i || i === 2 && d || t.includes(n); return u._open = !!(s === 42 ? h : h && (i || !g)), u._close = !!(s === 42 ? g : g && (d || !h)), e(l) } } function mC(r, e) { r.column += e, r.offset += e, r._bufferIndex += e } const vle = { name: "autolink", tokenize: xle }; function xle(r, e, t) { let n = 0; return i; function i(m) { return r.enter("autolink"), r.enter("autolinkMarker"), r.consume(m), r.exit("autolinkMarker"), r.enter("autolinkProtocol"), s } function s(m) { return Xn(m) ? (r.consume(m), a) : m === 64 ? t(m) : u(m) } function a(m) { return m === 43 || m === 45 || m === 46 || Zn(m) ? (n = 1, o(m)) : u(m) } function o(m) { return m === 58 ? (r.consume(m), n = 0, l) : (m === 43 || m === 45 || m === 46 || Zn(m)) && n++ < 32 ? (r.consume(m), o) : (n = 0, u(m)) } function l(m) { return m === 62 ? (r.exit("autolinkProtocol"), r.enter("autolinkMarker"), r.consume(m), r.exit("autolinkMarker"), r.exit("autolink"), e) : m === null || m === 32 || m === 60 || Cd(m) ? t(m) : (r.consume(m), l) } function u(m) { return m === 64 ? (r.consume(m), d) : Xoe(m) ? (r.consume(m), u) : t(m) } function d(m) { return Zn(m) ? h(m) : t(m) } function h(m) { return m === 46 ? (r.consume(m), n = 0, d) : m === 62 ? (r.exit("autolinkProtocol").type = "autolinkEmail", r.enter("autolinkMarker"), r.consume(m), r.exit("autolinkMarker"), r.exit("autolink"), e) : g(m) } function g(m) { if ((m === 45 || Zn(m)) && n++ < 63) { const b = m === 45 ? g : h; return r.consume(m), b } return t(m) } } const ol = { partial: !0, tokenize: wle }; function wle(r, e, t) { return n; function n(s) { return Ve(s) ? Ge(r, i, "linePrefix")(s) : i(s) } function i(s) { return s === null || Ee(s) ? e(s) : t(s) } } const MT = { continuation: { tokenize: Sle }, exit: Ele, name: "blockQuote", tokenize: Cle }; function Cle(r, e, t) { const n = this; return i; function i(a) { if (a === 62) { const o = n.containerState; return o.open || (r.enter("blockQuote", { _container: !0 }), o.open = !0), r.enter("blockQuotePrefix"), r.enter("blockQuoteMarker"), r.consume(a), r.exit("blockQuoteMarker"), s } return t(a) } function s(a) { return Ve(a) ? (r.enter("blockQuotePrefixWhitespace"), r.consume(a), r.exit("blockQuotePrefixWhitespace"), r.exit("blockQuotePrefix"), e) : (r.exit("blockQuotePrefix"), e(a)) } } function Sle(r, e, t) { const n = this; return i; function i(a) { return Ve(a) ? Ge(r, s, "linePrefix", n.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(a) : s(a) } function s(a) { return r.attempt(MT, e, t)(a) } } function Ele(r) { r.exit("blockQuote") } const jT = { name: "characterEscape", tokenize: _le }; function _le(r, e, t) { return n; function n(s) { return r.enter("characterEscape"), r.enter("escapeMarker"), r.consume(s), r.exit("escapeMarker"), i } function i(s) { return Zoe(s) ? (r.enter("characterEscapeValue"), r.consume(s), r.exit("characterEscapeValue"), r.exit("characterEscape"), e) : t(s) } } const VT = { name: "characterReference", tokenize: Ole }; function Ole(r, e, t) { const n = this; let i = 0, s, a; return o; function o(h) { return r.enter("characterReference"), r.enter("characterReferenceMarker"), r.consume(h), r.exit("characterReferenceMarker"), l } function l(h) { return h === 35 ? (r.enter("characterReferenceMarkerNumeric"), r.consume(h), r.exit("characterReferenceMarkerNumeric"), u) : (r.enter("characterReferenceValue"), s = 31, a = Zn, d(h)) } function u(h) { return h === 88 || h === 120 ? (r.enter("characterReferenceMarkerHexadecimal"), r.consume(h), r.exit("characterReferenceMarkerHexadecimal"), r.enter("characterReferenceValue"), s = 6, a = qoe, d) : (r.enter("characterReferenceValue"), s = 7, a = nm, d(h)) } function d(h) { if (h === 59 && i) { const g = r.exit("characterReferenceValue"); return a === Zn && !rc(n.sliceSerialize(g)) ? t(h) : (r.enter("characterReferenceMarker"), r.consume(h), r.exit("characterReferenceMarker"), r.exit("characterReference"), e) } return a(h) && i++ < s ? (r.consume(h), d) : t(h) } } const yC = { partial: !0, tokenize: Ile }, bC = { concrete: !0, name: "codeFenced", tokenize: Tle }; function Tle(r, e, t) { const n = this, i = { partial: !0, tokenize: E }; let s = 0, a = 0, o; return l; function l(v) { return u(v) } function u(v) { const T = n.events[n.events.length - 1]; return s = T && T[1].type === "linePrefix" ? T[2].sliceSerialize(T[1], !0).length : 0, o = v, r.enter("codeFenced"), r.enter("codeFencedFence"), r.enter("codeFencedFenceSequence"), d(v) } function d(v) { return v === o ? (a++, r.consume(v), d) : a < 3 ? t(v) : (r.exit("codeFencedFenceSequence"), Ve(v) ? Ge(r, h, "whitespace")(v) : h(v)) } function h(v) { return v === null || Ee(v) ? (r.exit("codeFencedFence"), n.interrupt ? e(v) : r.check(yC, y, O)(v)) : (r.enter("codeFencedFenceInfo"), r.enter("chunkString", { contentType: "string" }), g(v)) } function g(v) { return v === null || Ee(v) ? (r.exit("chunkString"), r.exit("codeFencedFenceInfo"), h(v)) : Ve(v) ? (r.exit("chunkString"), r.exit("codeFencedFenceInfo"), Ge(r, m, "whitespace")(v)) : v === 96 && v === o ? t(v) : (r.consume(v), g) } function m(v) { return v === null || Ee(v) ? h(v) : (r.enter("codeFencedFenceMeta"), r.enter("chunkString", { contentType: "string" }), b(v)) } function b(v) { return v === null || Ee(v) ? (r.exit("chunkString"), r.exit("codeFencedFenceMeta"), h(v)) : v === 96 && v === o ? t(v) : (r.consume(v), b) } function y(v) { return r.attempt(i, O, w)(v) } function w(v) { return r.enter("lineEnding"), r.consume(v), r.exit("lineEnding"), x } function x(v) { return s > 0 && Ve(v) ? Ge(r, S, "linePrefix", s + 1)(v) : S(v) } function S(v) { return v === null || Ee(v) ? r.check(yC, y, O)(v) : (r.enter("codeFlowValue"), C(v)) } function C(v) { return v === null || Ee(v) ? (r.exit("codeFlowValue"), S(v)) : (r.consume(v), C) } function O(v) { return r.exit("codeFenced"), e(v) } function E(v, T, I) { let k = 0; return P; function P(U) { return v.enter("lineEnding"), v.consume(U), v.exit("lineEnding"), N } function N(U) { return v.enter("codeFencedFence"), Ve(U) ? Ge(v, M, "linePrefix", n.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(U) : M(U) } function M(U) { return U === o ? (v.enter("codeFencedFenceSequence"), B(U)) : I(U) } function B(U) { return U === o ? (k++, v.consume(U), B) : k >= a ? (v.exit("codeFencedFenceSequence"), Ve(U) ? Ge(v, K, "whitespace")(U) : K(U)) : I(U) } function K(U) { return U === null || Ee(U) ? (v.exit("codeFencedFence"), T(U)) : I(U) } } } function Ile(r, e, t) { const n = this; return i; function i(a) { return a === null ? t(a) : (r.enter("lineEnding"), r.consume(a), r.exit("lineEnding"), s) } function s(a) { return n.parser.lazy[n.now().line] ? t(a) : e(a) } } const tf = { name: "codeIndented", tokenize: kle }, Ple = { partial: !0, tokenize: Rle }; function kle(r, e, t) { const n = this; return i; function i(u) { return r.enter("codeIndented"), Ge(r, s, "linePrefix", 5)(u) } function s(u) { const d = n.events[n.events.length - 1]; return d && d[1].type === "linePrefix" && d[2].sliceSerialize(d[1], !0).length >= 4 ? a(u) : t(u) } function a(u) { return u === null ? l(u) : Ee(u) ? r.attempt(Ple, a, l)(u) : (r.enter("codeFlowValue"), o(u)) } function o(u) { return u === null || Ee(u) ? (r.exit("codeFlowValue"), a(u)) : (r.consume(u), o) } function l(u) { return r.exit("codeIndented"), e(u) } } function Rle(r, e, t) { const n = this; return i; function i(a) { return n.parser.lazy[n.now().line] ? t(a) : Ee(a) ? (r.enter("lineEnding"), r.consume(a), r.exit("lineEnding"), i) : Ge(r, s, "linePrefix", 5)(a) } function s(a) { const o = n.events[n.events.length - 1]; return o && o[1].type === "linePrefix" && o[2].sliceSerialize(o[1], !0).length >= 4 ? e(a) : Ee(a) ? i(a) : t(a) } } const Dle = { name: "codeText", previous: Nle, resolve: Ale, tokenize: Fle }; function Ale(r) { let e = r.length - 4, t = 3, n, i; if ((r[t][1].type === "lineEnding" || r[t][1].type === "space") && (r[e][1].type === "lineEnding" || r[e][1].type === "space")) { for (n = t; ++n < e;)if (r[n][1].type === "codeTextData") { r[t][1].type = "codeTextPadding", r[e][1].type = "codeTextPadding", t += 2, e -= 2; break } } for (n = t - 1, e++; ++n <= e;)i === void 0 ? n !== e && r[n][1].type !== "lineEnding" && (i = n) : (n === e || r[n][1].type === "lineEnding") && (r[i][1].type = "codeTextData", n !== i + 2 && (r[i][1].end = r[n - 1][1].end, r.splice(i + 2, n - i - 2), e -= n - i - 2, n = i + 2), i = void 0); return r } function Nle(r) { return r !== 96 || this.events[this.events.length - 1][1].type === "characterEscape" } function Fle(r, e, t) { let n = 0, i, s; return a; function a(h) { return r.enter("codeText"), r.enter("codeTextSequence"), o(h) } function o(h) { return h === 96 ? (r.consume(h), n++, o) : (r.exit("codeTextSequence"), l(h)) } function l(h) { return h === null ? t(h) : h === 32 ? (r.enter("space"), r.consume(h), r.exit("space"), l) : h === 96 ? (s = r.enter("codeTextSequence"), i = 0, d(h)) : Ee(h) ? (r.enter("lineEnding"), r.consume(h), r.exit("lineEnding"), l) : (r.enter("codeTextData"), u(h)) } function u(h) { return h === null || h === 32 || h === 96 || Ee(h) ? (r.exit("codeTextData"), l(h)) : (r.consume(h), u) } function d(h) { return h === 96 ? (r.consume(h), i++, d) : i === n ? (r.exit("codeTextSequence"), r.exit("codeText"), e(h)) : (s.type = "codeTextData", u(h)) } } class $le { constructor(e) { this.left = e ? [...e] : [], this.right = [] } get(e) { if (e < 0 || e >= this.left.length + this.right.length) throw new RangeError("Cannot access index `" + e + "` in a splice buffer of size `" + (this.left.length + this.right.length) + "`"); return e < this.left.length ? this.left[e] : this.right[this.right.length - e + this.left.length - 1] } get length() { return this.left.length + this.right.length } shift() { return this.setCursor(0), this.right.pop() } slice(e, t) { const n = t ?? Number.POSITIVE_INFINITY; return n < this.left.length ? this.left.slice(e, n) : e > this.left.length ? this.right.slice(this.right.length - n + this.left.length, this.right.length - e + this.left.length).reverse() : this.left.slice(e).concat(this.right.slice(this.right.length - n + this.left.length).reverse()) } splice(e, t, n) { const i = t || 0; this.setCursor(Math.trunc(e)); const s = this.right.splice(this.right.length - i, Number.POSITIVE_INFINITY); return n && El(this.left, n), s.reverse() } pop() { return this.setCursor(Number.POSITIVE_INFINITY), this.left.pop() } push(e) { this.setCursor(Number.POSITIVE_INFINITY), this.left.push(e) } pushMany(e) { this.setCursor(Number.POSITIVE_INFINITY), El(this.left, e) } unshift(e) { this.setCursor(0), this.right.push(e) } unshiftMany(e) { this.setCursor(0), El(this.right, e.reverse()) } setCursor(e) { if (!(e === this.left.length || e > this.left.length && this.right.length === 0 || e < 0 && this.left.length === 0)) if (e < this.left.length) { const t = this.left.splice(e, Number.POSITIVE_INFINITY); El(this.right, t.reverse()) } else { const t = this.right.splice(this.left.length + this.right.length - e, Number.POSITIVE_INFINITY); El(this.left, t.reverse()) } } } function El(r, e) { let t = 0; if (e.length < 1e4) r.push(...e); else for (; t < e.length;)r.push(...e.slice(t, t + 1e4)), t += 1e4 } function BT(r) { const e = {}; let t = -1, n, i, s, a, o, l, u; const d = new $le(r); for (; ++t < d.length;) { for (; t in e;)t = e[t]; if (n = d.get(t), t && n[1].type === "chunkFlow" && d.get(t - 1)[1].type === "listItemPrefix" && (l = n[1]._tokenizer.events, s = 0, s < l.length && l[s][1].type === "lineEndingBlank" && (s += 2), s < l.length && l[s][1].type === "content")) for (; ++s < l.length && l[s][1].type !== "content";)l[s][1].type === "chunkText" && (l[s][1]._isInFirstContentOfListItem = !0, s++); if (n[0] === "enter") n[1].contentType && (Object.assign(e, Lle(d, t)), t = e[t], u = !0); else if (n[1]._container) { for (s = t, i = void 0; s--;)if (a = d.get(s), a[1].type === "lineEnding" || a[1].type === "lineEndingBlank") a[0] === "enter" && (i && (d.get(i)[1].type = "lineEndingBlank"), a[1].type = "lineEnding", i = s); else if (a[1].type !== "linePrefix") break; i && (n[1].end = { ...d.get(i)[1].start }, o = d.slice(i, t), o.unshift(n), d.splice(i, t - i + 1, o)) } } return Dr(r, 0, Number.POSITIVE_INFINITY, d.slice(0)), !u } function Lle(r, e) { const t = r.get(e)[1], n = r.get(e)[2]; let i = e - 1; const s = [], a = t._tokenizer || n.parser[t.contentType](t.start), o = a.events, l = [], u = {}; let d, h, g = -1, m = t, b = 0, y = 0; const w = [y]; for (; m;) { for (; r.get(++i)[1] !== m;); s.push(i), m._tokenizer || (d = n.sliceStream(m), m.next || d.push(null), h && a.defineSkip(m.start), m._isInFirstContentOfListItem && (a._gfmTasklistFirstContentOfListItem = !0), a.write(d), m._isInFirstContentOfListItem && (a._gfmTasklistFirstContentOfListItem = void 0)), h = m, m = m.next } for (m = t; ++g < o.length;)o[g][0] === "exit" && o[g - 1][0] === "enter" && o[g][1].type === o[g - 1][1].type && o[g][1].start.line !== o[g][1].end.line && (y = g + 1, w.push(y), m._tokenizer = void 0, m.previous = void 0, m = m.next); for (a.events = [], m ? (m._tokenizer = void 0, m.previous = void 0) : w.pop(), g = w.length; g--;) { const x = o.slice(w[g], w[g + 1]), S = s.pop(); l.push([S, S + x.length - 1]), r.splice(S, 2, x) } for (l.reverse(), g = -1; ++g < l.length;)u[b + l[g][0]] = b + l[g][1], b += l[g][1] - l[g][0] - 1; return u } const Mle = { resolve: Vle, tokenize: Ble }, jle = { partial: !0, tokenize: zle }; function Vle(r) { return BT(r), r } function Ble(r, e) { let t; return n; function n(o) { return r.enter("content"), t = r.enter("chunkContent", { contentType: "content" }), i(o) } function i(o) { return o === null ? s(o) : Ee(o) ? r.check(jle, a, s)(o) : (r.consume(o), i) } function s(o) { return r.exit("chunkContent"), r.exit("content"), e(o) } function a(o) { return r.consume(o), r.exit("chunkContent"), t.next = r.enter("chunkContent", { contentType: "content", previous: t }), t = t.next, i } } function zle(r, e, t) { const n = this; return i; function i(a) { return r.exit("chunkContent"), r.enter("lineEnding"), r.consume(a), r.exit("lineEnding"), Ge(r, s, "linePrefix") } function s(a) { if (a === null || Ee(a)) return t(a); const o = n.events[n.events.length - 1]; return !n.parser.constructs.disable.null.includes("codeIndented") && o && o[1].type === "linePrefix" && o[2].sliceSerialize(o[1], !0).length >= 4 ? e(a) : r.interrupt(n.parser.constructs.flow, t, e)(a) } } function zT(r, e, t, n, i, s, a, o, l) { const u = l || Number.POSITIVE_INFINITY; let d = 0; return h; function h(x) { return x === 60 ? (r.enter(n), r.enter(i), r.enter(s), r.consume(x), r.exit(s), g) : x === null || x === 32 || x === 41 || Cd(x) ? t(x) : (r.enter(n), r.enter(a), r.enter(o), r.enter("chunkString", { contentType: "string" }), y(x)) } function g(x) { return x === 62 ? (r.enter(s), r.consume(x), r.exit(s), r.exit(i), r.exit(n), e) : (r.enter(o), r.enter("chunkString", { contentType: "string" }), m(x)) } function m(x) { return x === 62 ? (r.exit("chunkString"), r.exit(o), g(x)) : x === null || x === 60 || Ee(x) ? t(x) : (r.consume(x), x === 92 ? b : m) } function b(x) { return x === 60 || x === 62 || x === 92 ? (r.consume(x), m) : m(x) } function y(x) { return !d && (x === null || x === 41 || it(x)) ? (r.exit("chunkString"), r.exit(o), r.exit(a), r.exit(n), e(x)) : d < u && x === 40 ? (r.consume(x), d++, y) : x === 41 ? (r.consume(x), d--, y) : x === null || x === 32 || x === 40 || Cd(x) ? t(x) : (r.consume(x), x === 92 ? w : y) } function w(x) { return x === 40 || x === 41 || x === 92 ? (r.consume(x), y) : y(x) } } function HT(r, e, t, n, i, s) { const a = this; let o = 0, l; return u; function u(m) { return r.enter(n), r.enter(i), r.consume(m), r.exit(i), r.enter(s), d } function d(m) { return o > 999 || m === null || m === 91 || m === 93 && !l || m === 94 && !o && "_hiddenFootnoteSupport" in a.parser.constructs ? t(m) : m === 93 ? (r.exit(s), r.enter(i), r.consume(m), r.exit(i), r.exit(n), e) : Ee(m) ? (r.enter("lineEnding"), r.consume(m), r.exit("lineEnding"), d) : (r.enter("chunkString", { contentType: "string" }), h(m)) } function h(m) { return m === null || m === 91 || m === 93 || Ee(m) || o++ > 999 ? (r.exit("chunkString"), d(m)) : (r.consume(m), l || (l = !Ve(m)), m === 92 ? g : h) } function g(m) { return m === 91 || m === 92 || m === 93 ? (r.consume(m), o++, h) : h(m) } } function KT(r, e, t, n, i, s) { let a; return o; function o(g) { return g === 34 || g === 39 || g === 40 ? (r.enter(n), r.enter(i), r.consume(g), r.exit(i), a = g === 40 ? 41 : g, l) : t(g) } function l(g) { return g === a ? (r.enter(i), r.consume(g), r.exit(i), r.exit(n), e) : (r.enter(s), u(g)) } function u(g) { return g === a ? (r.exit(s), l(a)) : g === null ? t(g) : Ee(g) ? (r.enter("lineEnding"), r.consume(g), r.exit("lineEnding"), Ge(r, u, "linePrefix")) : (r.enter("chunkString", { contentType: "string" }), d(g)) } function d(g) { return g === a || g === null || Ee(g) ? (r.exit("chunkString"), u(g)) : (r.consume(g), g === 92 ? h : d) } function h(g) { return g === a || g === 92 ? (r.consume(g), d) : d(g) } } function Ll(r, e) { let t; return n; function n(i) { return Ee(i) ? (r.enter("lineEnding"), r.consume(i), r.exit("lineEnding"), t = !0, n) : Ve(i) ? Ge(r, n, t ? "linePrefix" : "lineSuffix")(i) : e(i) } } function mi(r) { return r.replace(/[\t\n\r ]+/g, " ").replace(/^ | $/g, "").toLowerCase().toUpperCase() } const Hle = { name: "definition", tokenize: Ule }, Kle = { partial: !0, tokenize: Wle }; function Ule(r, e, t) { const n = this; let i; return s; function s(m) { return r.enter("definition"), a(m) } function a(m) { return HT.call(n, r, o, t, "definitionLabel", "definitionLabelMarker", "definitionLabelString")(m) } function o(m) { return i = mi(n.sliceSerialize(n.events[n.events.length - 1][1]).slice(1, -1)), m === 58 ? (r.enter("definitionMarker"), r.consume(m), r.exit("definitionMarker"), l) : t(m) } function l(m) { return it(m) ? Ll(r, u)(m) : u(m) } function u(m) { return zT(r, d, t, "definitionDestination", "definitionDestinationLiteral", "definitionDestinationLiteralMarker", "definitionDestinationRaw", "definitionDestinationString")(m) } function d(m) { return r.attempt(Kle, h, h)(m) } function h(m) { return Ve(m) ? Ge(r, g, "whitespace")(m) : g(m) } function g(m) { return m === null || Ee(m) ? (r.exit("definition"), n.parser.defined.push(i), e(m)) : t(m) } } function Wle(r, e, t) { return n; function n(o) { return it(o) ? Ll(r, i)(o) : t(o) } function i(o) { return KT(r, s, t, "definitionTitle", "definitionTitleMarker", "definitionTitleString")(o) } function s(o) { return Ve(o) ? Ge(r, a, "whitespace")(o) : a(o) } function a(o) { return o === null || Ee(o) ? e(o) : t(o) } } const Gle = { name: "hardBreakEscape", tokenize: Yle }; function Yle(r, e, t) { return n; function n(s) { return r.enter("hardBreakEscape"), r.consume(s), i } function i(s) { return Ee(s) ? (r.exit("hardBreakEscape"), e(s)) : t(s) } } const Xle = { name: "headingAtx", resolve: qle, tokenize: Zle }; function qle(r, e) { let t = r.length - 2, n = 3, i, s; return r[n][1].type === "whitespace" && (n += 2), t - 2 > n && r[t][1].type === "whitespace" && (t -= 2), r[t][1].type === "atxHeadingSequence" && (n === t - 1 || t - 4 > n && r[t - 2][1].type === "whitespace") && (t -= n + 1 === t ? 2 : 4), t > n && (i = { type: "atxHeadingText", start: r[n][1].start, end: r[t][1].end }, s = { type: "chunkText", start: r[n][1].start, end: r[t][1].end, contentType: "text" }, Dr(r, n, t - n + 1, [["enter", i, e], ["enter", s, e], ["exit", s, e], ["exit", i, e]])), r } function Zle(r, e, t) { let n = 0; return i; function i(d) { return r.enter("atxHeading"), s(d) } function s(d) { return r.enter("atxHeadingSequence"), a(d) } function a(d) { return d === 35 && n++ < 6 ? (r.consume(d), a) : d === null || it(d) ? (r.exit("atxHeadingSequence"), o(d)) : t(d) } function o(d) { return d === 35 ? (r.enter("atxHeadingSequence"), l(d)) : d === null || Ee(d) ? (r.exit("atxHeading"), e(d)) : Ve(d) ? Ge(r, o, "whitespace")(d) : (r.enter("atxHeadingText"), u(d)) } function l(d) { return d === 35 ? (r.consume(d), l) : (r.exit("atxHeadingSequence"), o(d)) } function u(d) { return d === null || d === 35 || it(d) ? (r.exit("atxHeadingText"), o(d)) : (r.consume(d), u) } } const Jle = ["address", "article", "aside", "base", "basefont", "blockquote", "body", "caption", "center", "col", "colgroup", "dd", "details", "dialog", "dir", "div", "dl", "dt", "fieldset", "figcaption", "figure", "footer", "form", "frame", "frameset", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hr", "html", "iframe", "legend", "li", "link", "main", "menu", "menuitem", "nav", "noframes", "ol", "optgroup", "option", "p", "param", "search", "section", "summary", "table", "tbody", "td", "tfoot", "th", "thead", "title", "tr", "track", "ul"], vC = ["pre", "script", "style", "textarea"], Qle = { concrete: !0, name: "htmlFlow", resolveTo: nce, tokenize: rce }, ece = { partial: !0, tokenize: sce }, tce = { partial: !0, tokenize: ice }; function nce(r) { let e = r.length; for (; e-- && !(r[e][0] === "enter" && r[e][1].type === "htmlFlow");); return e > 1 && r[e - 2][1].type === "linePrefix" && (r[e][1].start = r[e - 2][1].start, r[e + 1][1].start = r[e - 2][1].start, r.splice(e - 2, 2)), r } function rce(r, e, t) { const n = this; let i, s, a, o, l; return u; function u(j) { return d(j) } function d(j) { return r.enter("htmlFlow"), r.enter("htmlFlowData"), r.consume(j), h } function h(j) { return j === 33 ? (r.consume(j), g) : j === 47 ? (r.consume(j), s = !0, y) : j === 63 ? (r.consume(j), i = 3, n.interrupt ? e : $) : Xn(j) ? (r.consume(j), a = String.fromCharCode(j), w) : t(j) } function g(j) { return j === 45 ? (r.consume(j), i = 2, m) : j === 91 ? (r.consume(j), i = 5, o = 0, b) : Xn(j) ? (r.consume(j), i = 4, n.interrupt ? e : $) : t(j) } function m(j) { return j === 45 ? (r.consume(j), n.interrupt ? e : $) : t(j) } function b(j) { const ae = "CDATA["; return j === ae.charCodeAt(o++) ? (r.consume(j), o === ae.length ? n.interrupt ? e : M : b) : t(j) } function y(j) { return Xn(j) ? (r.consume(j), a = String.fromCharCode(j), w) : t(j) } function w(j) { if (j === null || j === 47 || j === 62 || it(j)) { const ae = j === 47, be = a.toLowerCase(); return !ae && !s && vC.includes(be) ? (i = 1, n.interrupt ? e(j) : M(j)) : Jle.includes(a.toLowerCase()) ? (i = 6, ae ? (r.consume(j), x) : n.interrupt ? e(j) : M(j)) : (i = 7, n.interrupt && !n.parser.lazy[n.now().line] ? t(j) : s ? S(j) : C(j)) } return j === 45 || Zn(j) ? (r.consume(j), a += String.fromCharCode(j), w) : t(j) } function x(j) { return j === 62 ? (r.consume(j), n.interrupt ? e : M) : t(j) } function S(j) { return Ve(j) ? (r.consume(j), S) : P(j) } function C(j) { return j === 47 ? (r.consume(j), P) : j === 58 || j === 95 || Xn(j) ? (r.consume(j), O) : Ve(j) ? (r.consume(j), C) : P(j) } function O(j) { return j === 45 || j === 46 || j === 58 || j === 95 || Zn(j) ? (r.consume(j), O) : E(j) } function E(j) { return j === 61 ? (r.consume(j), v) : Ve(j) ? (r.consume(j), E) : C(j) } function v(j) { return j === null || j === 60 || j === 61 || j === 62 || j === 96 ? t(j) : j === 34 || j === 39 ? (r.consume(j), l = j, T) : Ve(j) ? (r.consume(j), v) : I(j) } function T(j) { return j === l ? (r.consume(j), l = null, k) : j === null || Ee(j) ? t(j) : (r.consume(j), T) } function I(j) { return j === null || j === 34 || j === 39 || j === 47 || j === 60 || j === 61 || j === 62 || j === 96 || it(j) ? E(j) : (r.consume(j), I) } function k(j) { return j === 47 || j === 62 || Ve(j) ? C(j) : t(j) } function P(j) { return j === 62 ? (r.consume(j), N) : t(j) } function N(j) { return j === null || Ee(j) ? M(j) : Ve(j) ? (r.consume(j), N) : t(j) } function M(j) { return j === 45 && i === 2 ? (r.consume(j), W) : j === 60 && i === 1 ? (r.consume(j), Z) : j === 62 && i === 4 ? (r.consume(j), pe) : j === 63 && i === 3 ? (r.consume(j), $) : j === 93 && i === 5 ? (r.consume(j), ee) : Ee(j) && (i === 6 || i === 7) ? (r.exit("htmlFlowData"), r.check(ece, re, B)(j)) : j === null || Ee(j) ? (r.exit("htmlFlowData"), B(j)) : (r.consume(j), M) } function B(j) { return r.check(tce, K, re)(j) } function K(j) { return r.enter("lineEnding"), r.consume(j), r.exit("lineEnding"), U } function U(j) { return j === null || Ee(j) ? B(j) : (r.enter("htmlFlowData"), M(j)) } function W(j) { return j === 45 ? (r.consume(j), $) : M(j) } function Z(j) { return j === 47 ? (r.consume(j), a = "", J) : M(j) } function J(j) { if (j === 62) { const ae = a.toLowerCase(); return vC.includes(ae) ? (r.consume(j), pe) : M(j) } return Xn(j) && a.length < 8 ? (r.consume(j), a += String.fromCharCode(j), J) : M(j) } function ee(j) { return j === 93 ? (r.consume(j), $) : M(j) } function $(j) { return j === 62 ? (r.consume(j), pe) : j === 45 && i === 2 ? (r.consume(j), $) : M(j) } function pe(j) { return j === null || Ee(j) ? (r.exit("htmlFlowData"), re(j)) : (r.consume(j), pe) } function re(j) { return r.exit("htmlFlow"), e(j) } } function ice(r, e, t) { const n = this; return i; function i(a) { return Ee(a) ? (r.enter("lineEnding"), r.consume(a), r.exit("lineEnding"), s) : t(a) } function s(a) { return n.parser.lazy[n.now().line] ? t(a) : e(a) } } function sce(r, e, t) { return n; function n(i) { return r.enter("lineEnding"), r.consume(i), r.exit("lineEnding"), r.attempt(ol, e, t) } } const ace = { name: "htmlText", tokenize: oce }; function oce(r, e, t) { const n = this; let i, s, a; return o; function o($) { return r.enter("htmlText"), r.enter("htmlTextData"), r.consume($), l } function l($) { return $ === 33 ? (r.consume($), u) : $ === 47 ? (r.consume($), E) : $ === 63 ? (r.consume($), C) : Xn($) ? (r.consume($), I) : t($) } function u($) { return $ === 45 ? (r.consume($), d) : $ === 91 ? (r.consume($), s = 0, b) : Xn($) ? (r.consume($), S) : t($) } function d($) { return $ === 45 ? (r.consume($), m) : t($) } function h($) { return $ === null ? t($) : $ === 45 ? (r.consume($), g) : Ee($) ? (a = h, Z($)) : (r.consume($), h) } function g($) { return $ === 45 ? (r.consume($), m) : h($) } function m($) { return $ === 62 ? W($) : $ === 45 ? g($) : h($) } function b($) { const pe = "CDATA["; return $ === pe.charCodeAt(s++) ? (r.consume($), s === pe.length ? y : b) : t($) } function y($) { return $ === null ? t($) : $ === 93 ? (r.consume($), w) : Ee($) ? (a = y, Z($)) : (r.consume($), y) } function w($) { return $ === 93 ? (r.consume($), x) : y($) } function x($) { return $ === 62 ? W($) : $ === 93 ? (r.consume($), x) : y($) } function S($) { return $ === null || $ === 62 ? W($) : Ee($) ? (a = S, Z($)) : (r.consume($), S) } function C($) { return $ === null ? t($) : $ === 63 ? (r.consume($), O) : Ee($) ? (a = C, Z($)) : (r.consume($), C) } function O($) { return $ === 62 ? W($) : C($) } function E($) { return Xn($) ? (r.consume($), v) : t($) } function v($) { return $ === 45 || Zn($) ? (r.consume($), v) : T($) } function T($) { return Ee($) ? (a = T, Z($)) : Ve($) ? (r.consume($), T) : W($) } function I($) { return $ === 45 || Zn($) ? (r.consume($), I) : $ === 47 || $ === 62 || it($) ? k($) : t($) } function k($) { return $ === 47 ? (r.consume($), W) : $ === 58 || $ === 95 || Xn($) ? (r.consume($), P) : Ee($) ? (a = k, Z($)) : Ve($) ? (r.consume($), k) : W($) } function P($) { return $ === 45 || $ === 46 || $ === 58 || $ === 95 || Zn($) ? (r.consume($), P) : N($) } function N($) { return $ === 61 ? (r.consume($), M) : Ee($) ? (a = N, Z($)) : Ve($) ? (r.consume($), N) : k($) } function M($) { return $ === null || $ === 60 || $ === 61 || $ === 62 || $ === 96 ? t($) : $ === 34 || $ === 39 ? (r.consume($), i = $, B) : Ee($) ? (a = M, Z($)) : Ve($) ? (r.consume($), M) : (r.consume($), K) } function B($) { return $ === i ? (r.consume($), i = void 0, U) : $ === null ? t($) : Ee($) ? (a = B, Z($)) : (r.consume($), B) } function K($) { return $ === null || $ === 34 || $ === 39 || $ === 60 || $ === 61 || $ === 96 ? t($) : $ === 47 || $ === 62 || it($) ? k($) : (r.consume($), K) } function U($) { return $ === 47 || $ === 62 || it($) ? k($) : t($) } function W($) { return $ === 62 ? (r.consume($), r.exit("htmlTextData"), r.exit("htmlText"), e) : t($) } function Z($) { return r.exit("htmlTextData"), r.enter("lineEnding"), r.consume($), r.exit("lineEnding"), J } function J($) { return Ve($) ? Ge(r, ee, "linePrefix", n.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)($) : ee($) } function ee($) { return r.enter("htmlTextData"), a($) } } const Ib = { name: "labelEnd", resolveAll: dce, resolveTo: hce, tokenize: pce }, lce = { tokenize: fce }, cce = { tokenize: gce }, uce = { tokenize: mce }; function dce(r) { let e = -1; const t = []; for (; ++e < r.length;) { const n = r[e][1]; if (t.push(r[e]), n.type === "labelImage" || n.type === "labelLink" || n.type === "labelEnd") { const i = n.type === "labelImage" ? 4 : 2; n.type = "data", e += i } } return r.length !== t.length && Dr(r, 0, r.length, t), r } function hce(r, e) { let t = r.length, n = 0, i, s, a, o; for (; t--;)if (i = r[t][1], s) { if (i.type === "link" || i.type === "labelLink" && i._inactive) break; r[t][0] === "enter" && i.type === "labelLink" && (i._inactive = !0) } else if (a) { if (r[t][0] === "enter" && (i.type === "labelImage" || i.type === "labelLink") && !i._balanced && (s = t, i.type !== "labelLink")) { n = 2; break } } else i.type === "labelEnd" && (a = t); const l = { type: r[s][1].type === "labelLink" ? "link" : "image", start: { ...r[s][1].start }, end: { ...r[r.length - 1][1].end } }, u = { type: "label", start: { ...r[s][1].start }, end: { ...r[a][1].end } }, d = { type: "labelText", start: { ...r[s + n + 2][1].end }, end: { ...r[a - 2][1].start } }; return o = [["enter", l, e], ["enter", u, e]], o = Br(o, r.slice(s + 1, s + n + 3)), o = Br(o, [["enter", d, e]]), o = Br(o, Mh(e.parser.constructs.insideSpan.null, r.slice(s + n + 4, a - 3), e)), o = Br(o, [["exit", d, e], r[a - 2], r[a - 1], ["exit", u, e]]), o = Br(o, r.slice(a + 1)), o = Br(o, [["exit", l, e]]), Dr(r, s, r.length, o), r } function pce(r, e, t) { const n = this; let i = n.events.length, s, a; for (; i--;)if ((n.events[i][1].type === "labelImage" || n.events[i][1].type === "labelLink") && !n.events[i][1]._balanced) { s = n.events[i][1]; break } return o; function o(g) { return s ? s._inactive ? h(g) : (a = n.parser.defined.includes(mi(n.sliceSerialize({ start: s.end, end: n.now() }))), r.enter("labelEnd"), r.enter("labelMarker"), r.consume(g), r.exit("labelMarker"), r.exit("labelEnd"), l) : t(g) } function l(g) { return g === 40 ? r.attempt(lce, d, a ? d : h)(g) : g === 91 ? r.attempt(cce, d, a ? u : h)(g) : a ? d(g) : h(g) } function u(g) { return r.attempt(uce, d, h)(g) } function d(g) { return e(g) } function h(g) { return s._balanced = !0, t(g) } } function fce(r, e, t) { return n; function n(h) { return r.enter("resource"), r.enter("resourceMarker"), r.consume(h), r.exit("resourceMarker"), i } function i(h) { return it(h) ? Ll(r, s)(h) : s(h) } function s(h) { return h === 41 ? d(h) : zT(r, a, o, "resourceDestination", "resourceDestinationLiteral", "resourceDestinationLiteralMarker", "resourceDestinationRaw", "resourceDestinationString", 32)(h) } function a(h) { return it(h) ? Ll(r, l)(h) : d(h) } function o(h) { return t(h) } function l(h) { return h === 34 || h === 39 || h === 40 ? KT(r, u, t, "resourceTitle", "resourceTitleMarker", "resourceTitleString")(h) : d(h) } function u(h) { return it(h) ? Ll(r, d)(h) : d(h) } function d(h) { return h === 41 ? (r.enter("resourceMarker"), r.consume(h), r.exit("resourceMarker"), r.exit("resource"), e) : t(h) } } function gce(r, e, t) { const n = this; return i; function i(o) { return HT.call(n, r, s, a, "reference", "referenceMarker", "referenceString")(o) } function s(o) { return n.parser.defined.includes(mi(n.sliceSerialize(n.events[n.events.length - 1][1]).slice(1, -1))) ? e(o) : t(o) } function a(o) { return t(o) } } function mce(r, e, t) { return n; function n(s) { return r.enter("reference"), r.enter("referenceMarker"), r.consume(s), r.exit("referenceMarker"), i } function i(s) { return s === 93 ? (r.enter("referenceMarker"), r.consume(s), r.exit("referenceMarker"), r.exit("reference"), e) : t(s) } } const yce = { name: "labelStartImage", resolveAll: Ib.resolveAll, tokenize: bce }; function bce(r, e, t) { const n = this; return i; function i(o) { return r.enter("labelImage"), r.enter("labelImageMarker"), r.consume(o), r.exit("labelImageMarker"), s } function s(o) { return o === 91 ? (r.enter("labelMarker"), r.consume(o), r.exit("labelMarker"), r.exit("labelImage"), a) : t(o) } function a(o) { return o === 94 && "_hiddenFootnoteSupport" in n.parser.constructs ? t(o) : e(o) } } const vce = { name: "labelStartLink", resolveAll: Ib.resolveAll, tokenize: xce }; function xce(r, e, t) { const n = this; return i; function i(a) { return r.enter("labelLink"), r.enter("labelMarker"), r.consume(a), r.exit("labelMarker"), r.exit("labelLink"), s } function s(a) { return a === 94 && "_hiddenFootnoteSupport" in n.parser.constructs ? t(a) : e(a) } } const nf = { name: "lineEnding", tokenize: wce }; function wce(r, e) { return t; function t(n) { return r.enter("lineEnding"), r.consume(n), r.exit("lineEnding"), Ge(r, e, "linePrefix") } } const zu = { name: "thematicBreak", tokenize: Cce }; function Cce(r, e, t) { let n = 0, i; return s; function s(u) { return r.enter("thematicBreak"), a(u) } function a(u) { return i = u, o(u) } function o(u) { return u === i ? (r.enter("thematicBreakSequence"), l(u)) : n >= 3 && (u === null || Ee(u)) ? (r.exit("thematicBreak"), e(u)) : t(u) } function l(u) { return u === i ? (r.consume(u), n++, l) : (r.exit("thematicBreakSequence"), Ve(u) ? Ge(r, o, "whitespace")(u) : o(u)) } } const gr = { continuation: { tokenize: Oce }, exit: Ice, name: "list", tokenize: _ce }, Sce = { partial: !0, tokenize: Pce }, Ece = { partial: !0, tokenize: Tce }; function _ce(r, e, t) { const n = this, i = n.events[n.events.length - 1]; let s = i && i[1].type === "linePrefix" ? i[2].sliceSerialize(i[1], !0).length : 0, a = 0; return o; function o(m) { const b = n.containerState.type || (m === 42 || m === 43 || m === 45 ? "listUnordered" : "listOrdered"); if (b === "listUnordered" ? !n.containerState.marker || m === n.containerState.marker : nm(m)) { if (n.containerState.type || (n.containerState.type = b, r.enter(b, { _container: !0 })), b === "listUnordered") return r.enter("listItemPrefix"), m === 42 || m === 45 ? r.check(zu, t, u)(m) : u(m); if (!n.interrupt || m === 49) return r.enter("listItemPrefix"), r.enter("listItemValue"), l(m) } return t(m) } function l(m) { return nm(m) && ++a < 10 ? (r.consume(m), l) : (!n.interrupt || a < 2) && (n.containerState.marker ? m === n.containerState.marker : m === 41 || m === 46) ? (r.exit("listItemValue"), u(m)) : t(m) } function u(m) { return r.enter("listItemMarker"), r.consume(m), r.exit("listItemMarker"), n.containerState.marker = n.containerState.marker || m, r.check(ol, n.interrupt ? t : d, r.attempt(Sce, g, h)) } function d(m) { return n.containerState.initialBlankLine = !0, s++, g(m) } function h(m) { return Ve(m) ? (r.enter("listItemPrefixWhitespace"), r.consume(m), r.exit("listItemPrefixWhitespace"), g) : t(m) } function g(m) { return n.containerState.size = s + n.sliceSerialize(r.exit("listItemPrefix"), !0).length, e(m) } } function Oce(r, e, t) { const n = this; return n.containerState._closeFlow = void 0, r.check(ol, i, s); function i(o) { return n.containerState.furtherBlankLines = n.containerState.furtherBlankLines || n.containerState.initialBlankLine, Ge(r, e, "listItemIndent", n.containerState.size + 1)(o) } function s(o) { return n.containerState.furtherBlankLines || !Ve(o) ? (n.containerState.furtherBlankLines = void 0, n.containerState.initialBlankLine = void 0, a(o)) : (n.containerState.furtherBlankLines = void 0, n.containerState.initialBlankLine = void 0, r.attempt(Ece, e, a)(o)) } function a(o) { return n.containerState._closeFlow = !0, n.interrupt = void 0, Ge(r, r.attempt(gr, e, t), "linePrefix", n.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(o) } } function Tce(r, e, t) { const n = this; return Ge(r, i, "listItemIndent", n.containerState.size + 1); function i(s) { const a = n.events[n.events.length - 1]; return a && a[1].type === "listItemIndent" && a[2].sliceSerialize(a[1], !0).length === n.containerState.size ? e(s) : t(s) } } function Ice(r) { r.exit(this.containerState.type) } function Pce(r, e, t) { const n = this; return Ge(r, i, "listItemPrefixWhitespace", n.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 5); function i(s) { const a = n.events[n.events.length - 1]; return !Ve(s) && a && a[1].type === "listItemPrefixWhitespace" ? e(s) : t(s) } } const xC = { name: "setextUnderline", resolveTo: kce, tokenize: Rce }; function kce(r, e) { let t = r.length, n, i, s; for (; t--;)if (r[t][0] === "enter") { if (r[t][1].type === "content") { n = t; break } r[t][1].type === "paragraph" && (i = t) } else r[t][1].type === "content" && r.splice(t, 1), !s && r[t][1].type === "definition" && (s = t); const a = { type: "setextHeading", start: { ...r[i][1].start }, end: { ...r[r.length - 1][1].end } }; return r[i][1].type = "setextHeadingText", s ? (r.splice(i, 0, ["enter", a, e]), r.splice(s + 1, 0, ["exit", r[n][1], e]), r[n][1].end = { ...r[s][1].end }) : r[n][1] = a, r.push(["exit", a, e]), r } function Rce(r, e, t) { const n = this; let i; return s; function s(u) { let d = n.events.length, h; for (; d--;)if (n.events[d][1].type !== "lineEnding" && n.events[d][1].type !== "linePrefix" && n.events[d][1].type !== "content") { h = n.events[d][1].type === "paragraph"; break } return !n.parser.lazy[n.now().line] && (n.interrupt || h) ? (r.enter("setextHeadingLine"), i = u, a(u)) : t(u) } function a(u) { return r.enter("setextHeadingLineSequence"), o(u) } function o(u) { return u === i ? (r.consume(u), o) : (r.exit("setextHeadingLineSequence"), Ve(u) ? Ge(r, l, "lineSuffix")(u) : l(u)) } function l(u) { return u === null || Ee(u) ? (r.exit("setextHeadingLine"), e(u)) : t(u) } } const Dce = { tokenize: Fce, partial: !0 }, wC = "https://github.com/micromark/micromark-extension-mdxjs-esm", Ace = new Set(["ExportAllDeclaration", "ExportDefaultDeclaration", "ExportNamedDeclaration", "ImportDeclaration"]); function Nce(r) {
  const e = { tokenize: i, concrete: !0 }; if (!r || !r.acorn || !r.acorn.parse) throw new Error("Expected an `acorn` instance passed in as `options.acorn`"); const t = r.acorn, n = Object.assign({ ecmaVersion: 2024, sourceType: "module" }, r.acornOptions, { locations: !0 }); return { flow: { 101: e, 105: e } }; function i(s, a, o) {
    const l = this, u = l.parser.definedModuleSpecifiers || (l.parser.definedModuleSpecifiers = []), d = this.events.length + 1; let h = ""; return l.interrupt ? o : g; function g(S) { return l.now().column > 1 ? o(S) : (s.enter("mdxjsEsm"), s.enter("mdxjsEsmData"), s.consume(S), h += String.fromCharCode(S), m) } function m(S) { return Xn(S) ? (s.consume(S), h += String.fromCharCode(S), m) : (h === "import" || h === "export") && S === 32 ? (s.consume(S), b) : o(S) } function b(S) { return S === null || Ee(S) ? (s.exit("mdxjsEsmData"), y(S)) : (s.consume(S), b) } function y(S) { return S === null ? x(S) : Ee(S) ? s.check(Dce, x, w)(S) : (s.enter("mdxjsEsmData"), b(S)) } function w(S) { return s.enter("lineEnding"), s.consume(S), s.exit("lineEnding"), y } function x(S) {
      const C = $T(l.events.slice(d), {
        acorn: t, acornOptions: n, tokenTypes: ["mdxjsEsmData"], prefix: u.length > 0 ? "var " + u.join(",") + `
`: ""
      }); if (C.error) { if (S !== null && C.swallow) return w(S); const E = new vt("Could not parse import/exports with acorn", { cause: C.error, place: { line: C.error.loc.line, column: C.error.loc.column + 1, offset: C.error.pos }, ruleId: "acorn", source: "micromark-extension-mdxjs-esm" }); throw E.url = wC + "#could-not-parse-importexports-with-acorn", E } u.length > 0 && C.estree.body.shift(); let O = -1; for (; ++O < C.estree.body.length;) { const E = C.estree.body[O]; if (!Ace.has(E.type)) { const v = new vt("Unexpected `" + E.type + "` in code: only import/exports are supported", { place: ns(E), ruleId: "non-esm", source: "micromark-extension-mdxjs-esm" }); throw v.url = wC + "#unexpected-type-in-code-only-importexports-are-supported", v } if (E.type === "ImportDeclaration" && !l.interrupt) { let v = -1; for (; ++v < E.specifiers.length;) { const T = E.specifiers[v]; u.push(T.local.name) } } } return Object.assign(s.exit("mdxjsEsm"), r.addResult ? { estree: C.estree } : void 0), a(S)
    }
  }
} function Fce(r, e, t) { return n; function n(i) { return r.enter("lineEndingBlank"), r.consume(i), r.exit("lineEndingBlank"), r.attempt(ol, e, t) } } const CC = {}.hasOwnProperty; function Pb(r) { const e = {}; let t = -1; for (; ++t < r.length;)$ce(e, r[t]); return e } function $ce(r, e) { let t; for (t in e) { const i = (CC.call(r, t) ? r[t] : void 0) || (r[t] = {}), s = e[t]; let a; if (s) for (a in s) { CC.call(i, a) || (i[a] = []); const o = s[a]; Lce(i[a], Array.isArray(o) ? o : o ? [o] : []) } } } function Lce(r, e) { let t = -1; const n = []; for (; ++t < e.length;)(e[t].add === "after" ? r : n).push(e[t]); Dr(r, 0, 0, n) } function Mce(r) { const e = Object.assign({ acorn: Yoe.Parser.extend(dT()), acornOptions: { ecmaVersion: 2024, sourceType: "module" }, addResult: !0 }, r); return Pb([Nce(e), dle(e), gle(e), mle()]) } const jce = {}; function Vce(r) { const e = this, t = r || jce, n = e.data(), i = n.micromarkExtensions || (n.micromarkExtensions = []), s = n.fromMarkdownExtensions || (n.fromMarkdownExtensions = []), a = n.toMarkdownExtensions || (n.toMarkdownExtensions = []); i.push(Mce(t)), s.push(Woe()), a.push(Goe(t)) } const Bce = {}; function kb(r, e) { const t = Bce, n = typeof t.includeImageAlt == "boolean" ? t.includeImageAlt : !0, i = typeof t.includeHtml == "boolean" ? t.includeHtml : !0; return UT(r, n, i) } function UT(r, e, t) { if (zce(r)) { if ("value" in r) return r.type === "html" && !t ? "" : r.value; if (e && "alt" in r && r.alt) return r.alt; if ("children" in r) return SC(r.children, e, t) } return Array.isArray(r) ? SC(r, e, t) : "" } function SC(r, e, t) { const n = []; let i = -1; for (; ++i < r.length;)n[i] = UT(r[i], e, t); return n.join("") } function zce(r) { return !!(r && typeof r == "object") } function WT(r, e) { const t = Number.parseInt(r, e); return t < 9 || t === 11 || t > 13 && t < 32 || t > 126 && t < 160 || t > 55295 && t < 57344 || t > 64975 && t < 65008 || (t & 65535) === 65535 || (t & 65535) === 65534 || t > 1114111 ? "�" : String.fromCodePoint(t) } function ll(r) { const e = []; let t = -1, n = 0, i = 0; for (; ++t < r.length;) { const s = r.charCodeAt(t); let a = ""; if (s === 37 && Zn(r.charCodeAt(t + 1)) && Zn(r.charCodeAt(t + 2))) i = 2; else if (s < 128) /[!#$&-;=?-Z_a-z~]/.test(String.fromCharCode(s)) || (a = String.fromCharCode(s)); else if (s > 55295 && s < 57344) { const o = r.charCodeAt(t + 1); s < 56320 && o > 56319 && o < 57344 ? (a = String.fromCharCode(s, o), i = 1) : a = "�" } else a = String.fromCharCode(s); a && (e.push(r.slice(n, t), encodeURIComponent(a)), n = t + i + 1, a = ""), i && (t += i, i = 0) } return e.join("") + r.slice(n) } const Hce = { tokenize: Kce }; function Kce(r) { const e = r.attempt(this.parser.constructs.contentInitial, n, i); let t; return e; function n(o) { if (o === null) { r.consume(o); return } return r.enter("lineEnding"), r.consume(o), r.exit("lineEnding"), Ge(r, e, "linePrefix") } function i(o) { return r.enter("paragraph"), s(o) } function s(o) { const l = r.enter("chunkText", { contentType: "text", previous: t }); return t && (t.next = l), t = l, a(o) } function a(o) { if (o === null) { r.exit("chunkText"), r.exit("paragraph"), r.consume(o); return } return Ee(o) ? (r.consume(o), r.exit("chunkText"), s) : (r.consume(o), a) } } const Uce = { tokenize: Wce }, EC = { tokenize: Gce }; function Wce(r) { const e = this, t = []; let n = 0, i, s, a; return o; function o(C) { if (n < t.length) { const O = t[n]; return e.containerState = O[1], r.attempt(O[0].continuation, l, u)(C) } return u(C) } function l(C) { if (n++, e.containerState._closeFlow) { e.containerState._closeFlow = void 0, i && S(); const O = e.events.length; let E = O, v; for (; E--;)if (e.events[E][0] === "exit" && e.events[E][1].type === "chunkFlow") { v = e.events[E][1].end; break } x(n); let T = O; for (; T < e.events.length;)e.events[T][1].end = { ...v }, T++; return Dr(e.events, E + 1, 0, e.events.slice(O)), e.events.length = T, u(C) } return o(C) } function u(C) { if (n === t.length) { if (!i) return g(C); if (i.currentConstruct && i.currentConstruct.concrete) return b(C); e.interrupt = !!(i.currentConstruct && !i._gfmTableDynamicInterruptHack) } return e.containerState = {}, r.check(EC, d, h)(C) } function d(C) { return i && S(), x(n), g(C) } function h(C) { return e.parser.lazy[e.now().line] = n !== t.length, a = e.now().offset, b(C) } function g(C) { return e.containerState = {}, r.attempt(EC, m, b)(C) } function m(C) { return n++, t.push([e.currentConstruct, e.containerState]), g(C) } function b(C) { if (C === null) { i && S(), x(0), r.consume(C); return } return i = i || e.parser.flow(e.now()), r.enter("chunkFlow", { _tokenizer: i, contentType: "flow", previous: s }), y(C) } function y(C) { if (C === null) { w(r.exit("chunkFlow"), !0), x(0), r.consume(C); return } return Ee(C) ? (r.consume(C), w(r.exit("chunkFlow")), n = 0, e.interrupt = void 0, o) : (r.consume(C), y) } function w(C, O) { const E = e.sliceStream(C); if (O && E.push(null), C.previous = s, s && (s.next = C), s = C, i.defineSkip(C.start), i.write(E), e.parser.lazy[C.start.line]) { let v = i.events.length; for (; v--;)if (i.events[v][1].start.offset < a && (!i.events[v][1].end || i.events[v][1].end.offset > a)) return; const T = e.events.length; let I = T, k, P; for (; I--;)if (e.events[I][0] === "exit" && e.events[I][1].type === "chunkFlow") { if (k) { P = e.events[I][1].end; break } k = !0 } for (x(n), v = T; v < e.events.length;)e.events[v][1].end = { ...P }, v++; Dr(e.events, I + 1, 0, e.events.slice(T)), e.events.length = v } } function x(C) { let O = t.length; for (; O-- > C;) { const E = t[O]; e.containerState = E[1], E[0].exit.call(e, r) } t.length = C } function S() { i.write([null]), s = void 0, i = void 0, e.containerState._closeFlow = void 0 } } function Gce(r, e, t) { return Ge(r, r.attempt(this.parser.constructs.document, e, t), "linePrefix", this.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4) } const Yce = { tokenize: Xce }; function Xce(r) { const e = this, t = r.attempt(ol, n, r.attempt(this.parser.constructs.flowInitial, i, Ge(r, r.attempt(this.parser.constructs.flow, i, r.attempt(Mle, i)), "linePrefix"))); return t; function n(s) { if (s === null) { r.consume(s); return } return r.enter("lineEndingBlank"), r.consume(s), r.exit("lineEndingBlank"), e.currentConstruct = void 0, t } function i(s) { if (s === null) { r.consume(s); return } return r.enter("lineEnding"), r.consume(s), r.exit("lineEnding"), e.currentConstruct = void 0, t } } const qce = { resolveAll: YT() }, Zce = GT("string"), Jce = GT("text"); function GT(r) { return { resolveAll: YT(r === "text" ? Qce : void 0), tokenize: e }; function e(t) { const n = this, i = this.parser.constructs[r], s = t.attempt(i, a, o); return a; function a(d) { return u(d) ? s(d) : o(d) } function o(d) { if (d === null) { t.consume(d); return } return t.enter("data"), t.consume(d), l } function l(d) { return u(d) ? (t.exit("data"), s(d)) : (t.consume(d), l) } function u(d) { if (d === null) return !0; const h = i[d]; let g = -1; if (h) for (; ++g < h.length;) { const m = h[g]; if (!m.previous || m.previous.call(n, n.previous)) return !0 } return !1 } } } function YT(r) { return e; function e(t, n) { let i = -1, s; for (; ++i <= t.length;)s === void 0 ? t[i] && t[i][1].type === "data" && (s = i, i++) : (!t[i] || t[i][1].type !== "data") && (i !== s + 2 && (t[s][1].end = t[i - 1][1].end, t.splice(s + 2, i - s - 2), i = s + 2), s = void 0); return r ? r(t, n) : t } } function Qce(r, e) { let t = 0; for (; ++t <= r.length;)if ((t === r.length || r[t][1].type === "lineEnding") && r[t - 1][1].type === "data") { const n = r[t - 1][1], i = e.sliceStream(n); let s = i.length, a = -1, o = 0, l; for (; s--;) { const u = i[s]; if (typeof u == "string") { for (a = u.length; u.charCodeAt(a - 1) === 32;)o++, a--; if (a) break; a = -1 } else if (u === -2) l = !0, o++; else if (u !== -1) { s++; break } } if (o) { const u = { type: t === r.length || l || o < 2 ? "lineSuffix" : "hardBreakTrailing", start: { _bufferIndex: s ? a : n.start._bufferIndex + a, _index: n.start._index + s, line: n.end.line, column: n.end.column - o, offset: n.end.offset - o }, end: { ...n.end } }; n.end = { ...u.start }, n.start.offset === n.end.offset ? Object.assign(n, u) : (r.splice(t, 0, ["enter", u, e], ["exit", u, e]), t += 2) } t++ } return r } const eue = { 42: gr, 43: gr, 45: gr, 48: gr, 49: gr, 50: gr, 51: gr, 52: gr, 53: gr, 54: gr, 55: gr, 56: gr, 57: gr, 62: MT }, tue = { 91: Hle }, nue = { [-2]: tf, [-1]: tf, 32: tf }, rue = { 35: Xle, 42: zu, 45: [xC, zu], 60: Qle, 61: xC, 95: zu, 96: bC, 126: bC }, iue = { 38: VT, 92: jT }, sue = { [-5]: nf, [-4]: nf, [-3]: nf, 33: yce, 38: VT, 42: rm, 60: [vle, ace], 91: vce, 92: [Gle, jT], 93: Ib, 95: rm, 96: Dle }, aue = { null: [rm, qce] }, oue = { null: [42, 95] }, lue = { null: [] }, cue = Object.freeze(Object.defineProperty({ __proto__: null, attentionMarkers: oue, contentInitial: tue, disable: lue, document: eue, flow: rue, flowInitial: nue, insideSpan: aue, string: iue, text: sue }, Symbol.toStringTag, { value: "Module" })); function uue(r, e, t) { let n = { _bufferIndex: -1, _index: 0, line: t && t.line || 1, column: t && t.column || 1, offset: t && t.offset || 0 }; const i = {}, s = []; let a = [], o = []; const l = { attempt: T(E), check: T(v), consume: S, enter: C, exit: O, interrupt: T(v, { interrupt: !0 }) }, u = { code: null, containerState: {}, defineSkip: y, events: [], now: b, parser: r, previous: null, sliceSerialize: g, sliceStream: m, write: h }; let d = e.tokenize.call(u, l); return e.resolveAll && s.push(e), u; function h(N) { return a = Br(a, N), w(), a[a.length - 1] !== null ? [] : (I(e, 0), u.events = Mh(s, u.events, u), u.events) } function g(N, M) { return hue(m(N), M) } function m(N) { return due(a, N) } function b() { const { _bufferIndex: N, _index: M, line: B, column: K, offset: U } = n; return { _bufferIndex: N, _index: M, line: B, column: K, offset: U } } function y(N) { i[N.line] = N.column, P() } function w() { let N; for (; n._index < a.length;) { const M = a[n._index]; if (typeof M == "string") for (N = n._index, n._bufferIndex < 0 && (n._bufferIndex = 0); n._index === N && n._bufferIndex < M.length;)x(M.charCodeAt(n._bufferIndex)); else x(M) } } function x(N) { d = d(N) } function S(N) { Ee(N) ? (n.line++, n.column = 1, n.offset += N === -3 ? 2 : 1, P()) : N !== -1 && (n.column++, n.offset++), n._bufferIndex < 0 ? n._index++ : (n._bufferIndex++, n._bufferIndex === a[n._index].length && (n._bufferIndex = -1, n._index++)), u.previous = N } function C(N, M) { const B = M || {}; return B.type = N, B.start = b(), u.events.push(["enter", B, u]), o.push(B), B } function O(N) { const M = o.pop(); return M.end = b(), u.events.push(["exit", M, u]), M } function E(N, M) { I(N, M.from) } function v(N, M) { M.restore() } function T(N, M) { return B; function B(K, U, W) { let Z, J, ee, $; return Array.isArray(K) ? re(K) : "tokenize" in K ? re([K]) : pe(K); function pe(fe) { return Ce; function Ce(ue) { const te = ue !== null && fe[ue], le = ue !== null && fe.null, Re = [...Array.isArray(te) ? te : te ? [te] : [], ...Array.isArray(le) ? le : le ? [le] : []]; return re(Re)(ue) } } function re(fe) { return Z = fe, J = 0, fe.length === 0 ? W : j(fe[J]) } function j(fe) { return Ce; function Ce(ue) { return $ = k(), ee = fe, fe.partial || (u.currentConstruct = fe), fe.name && u.parser.constructs.disable.null.includes(fe.name) ? be() : fe.tokenize.call(M ? Object.assign(Object.create(u), M) : u, l, ae, be)(ue) } } function ae(fe) { return N(ee, $), U } function be(fe) { return $.restore(), ++J < Z.length ? j(Z[J]) : W } } } function I(N, M) { N.resolveAll && !s.includes(N) && s.push(N), N.resolve && Dr(u.events, M, u.events.length - M, N.resolve(u.events.slice(M), u)), N.resolveTo && (u.events = N.resolveTo(u.events, u)) } function k() { const N = b(), M = u.previous, B = u.currentConstruct, K = u.events.length, U = Array.from(o); return { from: K, restore: W }; function W() { n = N, u.previous = M, u.currentConstruct = B, u.events.length = K, o = U, P() } } function P() { n.line in i && n.column < 2 && (n.column = i[n.line], n.offset += i[n.line] - 1) } } function due(r, e) { const t = e.start._index, n = e.start._bufferIndex, i = e.end._index, s = e.end._bufferIndex; let a; if (t === i) a = [r[t].slice(n, s)]; else { if (a = r.slice(t, i), n > -1) { const o = a[0]; typeof o == "string" ? a[0] = o.slice(n) : a.shift() } s > 0 && a.push(r[i].slice(0, s)) } return a } function hue(r, e) {
  let t = -1; const n = []; let i; for (; ++t < r.length;) {
    const s = r[t]; let a; if (typeof s == "string") a = s; else switch (s) {
      case -5: { a = "\r"; break } case -4: {
        a = `
`; break
      } case -3: {
        a = `\r
`; break
      } case -2: { a = e ? " " : "	"; break } case -1: { if (!e && i) continue; a = " "; break } default: a = String.fromCharCode(s)
    }i = s === -2, n.push(a)
  } return n.join("")
} function pue(r) { const n = { constructs: Pb([cue, ...(r || {}).extensions || []]), content: i(Hce), defined: [], document: i(Uce), flow: i(Yce), lazy: {}, string: i(Zce), text: i(Jce) }; return n; function i(s) { return a; function a(o) { return uue(n, s, o) } } } function fue(r) { for (; !BT(r);); return r } const _C = /[\0\t\n\r]/g; function gue() { let r = 1, e = "", t = !0, n; return i; function i(s, a, o) { const l = []; let u, d, h, g, m; for (s = e + (typeof s == "string" ? s.toString() : new TextDecoder(a || void 0).decode(s)), h = 0, e = "", t && (s.charCodeAt(0) === 65279 && h++, t = void 0); h < s.length;) { if (_C.lastIndex = h, u = _C.exec(s), g = u && u.index !== void 0 ? u.index : s.length, m = s.charCodeAt(g), !u) { e = s.slice(h); break } if (m === 10 && h === g && n) l.push(-3), n = void 0; else switch (n && (l.push(-5), n = void 0), h < g && (l.push(s.slice(h, g)), r += g - h), m) { case 0: { l.push(65533), r++; break } case 9: { for (d = Math.ceil(r / 4) * 4, l.push(-2); r++ < d;)l.push(-1); break } case 10: { l.push(-4), r = 1; break } default: n = !0, r = 1 }h = g + 1 } return o && (n && l.push(-5), e && l.push(e), l.push(null)), l } } const mue = /\\([!-/:-@[-`{-~])|&(#(?:\d{1,7}|x[\da-f]{1,6})|[\da-z]{1,31});/gi; function yue(r) { return r.replace(mue, bue) } function bue(r, e, t) { if (e) return e; if (t.charCodeAt(0) === 35) { const i = t.charCodeAt(1), s = i === 120 || i === 88; return WT(t.slice(s ? 2 : 1), s ? 16 : 10) } return rc(t) || r } const XT = {}.hasOwnProperty; function vue(r, e, t) { return typeof e != "string" && (t = e, e = void 0), xue(t)(fue(pue(t).document().write(gue()(r, e, !0)))) } function xue(r) { const e = { transforms: [], canContainEols: ["emphasis", "fragment", "heading", "paragraph", "strong"], enter: { autolink: s(Hn), autolinkProtocol: k, autolinkEmail: k, atxHeading: s(Ft), blockQuote: s(le), characterEscape: k, characterReference: k, codeFenced: s(Re), codeFencedFenceInfo: a, codeFencedFenceMeta: a, codeIndented: s(Re, a), codeText: s(at, a), codeTextData: k, data: k, codeFlowValue: k, definition: s(yt), definitionDestinationString: a, definitionLabelString: a, definitionTitleString: a, emphasis: s(ht), hardBreakEscape: s(qe), hardBreakTrailing: s(qe), htmlFlow: s($t, a), htmlFlowData: k, htmlText: s($t, a), htmlTextData: k, image: s(gn), label: a, link: s(Hn), listItem: s(Ut), listItemValue: g, listOrdered: s(ot, h), listUnordered: s(ot), paragraph: s(Wt), reference: j, referenceString: a, resourceDestinationString: a, resourceTitleString: a, setextHeading: s(Ft), strong: s(wn), thematicBreak: s(hr) }, exit: { atxHeading: l(), atxHeadingSequence: E, autolink: l(), autolinkEmail: te, autolinkProtocol: ue, blockQuote: l(), characterEscapeValue: P, characterReferenceMarkerHexadecimal: be, characterReferenceMarkerNumeric: be, characterReferenceValue: fe, characterReference: Ce, codeFenced: l(w), codeFencedFence: y, codeFencedFenceInfo: m, codeFencedFenceMeta: b, codeFlowValue: P, codeIndented: l(x), codeText: l(U), codeTextData: P, data: P, definition: l(), definitionDestinationString: O, definitionLabelString: S, definitionTitleString: C, emphasis: l(), hardBreakEscape: l(M), hardBreakTrailing: l(M), htmlFlow: l(B), htmlFlowData: P, htmlText: l(K), htmlTextData: P, image: l(Z), label: ee, labelText: J, lineEnding: N, link: l(W), listItem: l(), listOrdered: l(), listUnordered: l(), paragraph: l(), referenceString: ae, resourceDestinationString: $, resourceTitleString: pe, resource: re, setextHeading: l(I), setextHeadingLineSequence: T, setextHeadingText: v, strong: l(), thematicBreak: l() } }; qT(e, (r || {}).mdastExtensions || []); const t = {}; return n; function n(X) { let Q = { type: "root", children: [] }; const L = { stack: [Q], tokenStack: [], config: e, enter: o, exit: u, buffer: a, resume: d, data: t }, Oe = []; let De = -1; for (; ++De < X.length;)if (X[De][1].type === "listOrdered" || X[De][1].type === "listUnordered") if (X[De][0] === "enter") Oe.push(De); else { const ie = Oe.pop(); De = i(X, ie, De) } for (De = -1; ++De < X.length;) { const ie = e[X[De][0]]; XT.call(ie, X[De][1].type) && ie[X[De][1].type].call(Object.assign({ sliceSerialize: X[De][2].sliceSerialize }, L), X[De][1]) } if (L.tokenStack.length > 0) { const ie = L.tokenStack[L.tokenStack.length - 1]; (ie[1] || OC).call(L, void 0, ie[0]) } for (Q.position = { start: Cs(X.length > 0 ? X[0][1].start : { line: 1, column: 1, offset: 0 }), end: Cs(X.length > 0 ? X[X.length - 2][1].end : { line: 1, column: 1, offset: 0 }) }, De = -1; ++De < e.transforms.length;)Q = e.transforms[De](Q) || Q; return Q } function i(X, Q, L) { let Oe = Q - 1, De = -1, ie = !1, un, Qt, jn, Et; for (; ++Oe <= L;) { const _t = X[Oe]; switch (_t[1].type) { case "listUnordered": case "listOrdered": case "blockQuote": { _t[0] === "enter" ? De++ : De--, Et = void 0; break } case "lineEndingBlank": { _t[0] === "enter" && (un && !Et && !De && !jn && (jn = Oe), Et = void 0); break } case "linePrefix": case "listItemValue": case "listItemMarker": case "listItemPrefix": case "listItemPrefixWhitespace": break; default: Et = void 0 }if (!De && _t[0] === "enter" && _t[1].type === "listItemPrefix" || De === -1 && _t[0] === "exit" && (_t[1].type === "listUnordered" || _t[1].type === "listOrdered")) { if (un) { let Nn = Oe; for (Qt = void 0; Nn--;) { const Cn = X[Nn]; if (Cn[1].type === "lineEnding" || Cn[1].type === "lineEndingBlank") { if (Cn[0] === "exit") continue; Qt && (X[Qt][1].type = "lineEndingBlank", ie = !0), Cn[1].type = "lineEnding", Qt = Nn } else if (!(Cn[1].type === "linePrefix" || Cn[1].type === "blockQuotePrefix" || Cn[1].type === "blockQuotePrefixWhitespace" || Cn[1].type === "blockQuoteMarker" || Cn[1].type === "listItemIndent")) break } jn && (!Qt || jn < Qt) && (un._spread = !0), un.end = Object.assign({}, Qt ? X[Qt][1].start : _t[1].end), X.splice(Qt || Oe, 0, ["exit", un, _t[2]]), Oe++, L++ } if (_t[1].type === "listItemPrefix") { const Nn = { type: "listItem", _spread: !1, start: Object.assign({}, _t[1].start), end: void 0 }; un = Nn, X.splice(Oe, 0, ["enter", Nn, _t[2]]), Oe++, L++, jn = void 0, Et = !0 } } } return X[Q][1]._spread = ie, L } function s(X, Q) { return L; function L(Oe) { o.call(this, X(Oe), Oe), Q && Q.call(this, Oe) } } function a() { this.stack.push({ type: "fragment", children: [] }) } function o(X, Q, L) { this.stack[this.stack.length - 1].children.push(X), this.stack.push(X), this.tokenStack.push([Q, L || void 0]), X.position = { start: Cs(Q.start), end: void 0 } } function l(X) { return Q; function Q(L) { X && X.call(this, L), u.call(this, L) } } function u(X, Q) { const L = this.stack.pop(), Oe = this.tokenStack.pop(); if (Oe) Oe[0].type !== X.type && (Q ? Q.call(this, X, Oe[0]) : (Oe[1] || OC).call(this, X, Oe[0])); else throw new Error("Cannot close `" + X.type + "` (" + Wr({ start: X.start, end: X.end }) + "): it’s not open"); L.position.end = Cs(X.end) } function d() { return kb(this.stack.pop()) } function h() { this.data.expectingFirstListItemValue = !0 } function g(X) { if (this.data.expectingFirstListItemValue) { const Q = this.stack[this.stack.length - 2]; Q.start = Number.parseInt(this.sliceSerialize(X), 10), this.data.expectingFirstListItemValue = void 0 } } function m() { const X = this.resume(), Q = this.stack[this.stack.length - 1]; Q.lang = X } function b() { const X = this.resume(), Q = this.stack[this.stack.length - 1]; Q.meta = X } function y() { this.data.flowCodeInside || (this.buffer(), this.data.flowCodeInside = !0) } function w() { const X = this.resume(), Q = this.stack[this.stack.length - 1]; Q.value = X.replace(/^(\r?\n|\r)|(\r?\n|\r)$/g, ""), this.data.flowCodeInside = void 0 } function x() { const X = this.resume(), Q = this.stack[this.stack.length - 1]; Q.value = X.replace(/(\r?\n|\r)$/g, "") } function S(X) { const Q = this.resume(), L = this.stack[this.stack.length - 1]; L.label = Q, L.identifier = mi(this.sliceSerialize(X)).toLowerCase() } function C() { const X = this.resume(), Q = this.stack[this.stack.length - 1]; Q.title = X } function O() { const X = this.resume(), Q = this.stack[this.stack.length - 1]; Q.url = X } function E(X) { const Q = this.stack[this.stack.length - 1]; if (!Q.depth) { const L = this.sliceSerialize(X).length; Q.depth = L } } function v() { this.data.setextHeadingSlurpLineEnding = !0 } function T(X) { const Q = this.stack[this.stack.length - 1]; Q.depth = this.sliceSerialize(X).codePointAt(0) === 61 ? 1 : 2 } function I() { this.data.setextHeadingSlurpLineEnding = void 0 } function k(X) { const L = this.stack[this.stack.length - 1].children; let Oe = L[L.length - 1]; (!Oe || Oe.type !== "text") && (Oe = Ze(), Oe.position = { start: Cs(X.start), end: void 0 }, L.push(Oe)), this.stack.push(Oe) } function P(X) { const Q = this.stack.pop(); Q.value += this.sliceSerialize(X), Q.position.end = Cs(X.end) } function N(X) { const Q = this.stack[this.stack.length - 1]; if (this.data.atHardBreak) { const L = Q.children[Q.children.length - 1]; L.position.end = Cs(X.end), this.data.atHardBreak = void 0; return } !this.data.setextHeadingSlurpLineEnding && e.canContainEols.includes(Q.type) && (k.call(this, X), P.call(this, X)) } function M() { this.data.atHardBreak = !0 } function B() { const X = this.resume(), Q = this.stack[this.stack.length - 1]; Q.value = X } function K() { const X = this.resume(), Q = this.stack[this.stack.length - 1]; Q.value = X } function U() { const X = this.resume(), Q = this.stack[this.stack.length - 1]; Q.value = X } function W() { const X = this.stack[this.stack.length - 1]; if (this.data.inReference) { const Q = this.data.referenceType || "shortcut"; X.type += "Reference", X.referenceType = Q, delete X.url, delete X.title } else delete X.identifier, delete X.label; this.data.referenceType = void 0 } function Z() { const X = this.stack[this.stack.length - 1]; if (this.data.inReference) { const Q = this.data.referenceType || "shortcut"; X.type += "Reference", X.referenceType = Q, delete X.url, delete X.title } else delete X.identifier, delete X.label; this.data.referenceType = void 0 } function J(X) { const Q = this.sliceSerialize(X), L = this.stack[this.stack.length - 2]; L.label = yue(Q), L.identifier = mi(Q).toLowerCase() } function ee() { const X = this.stack[this.stack.length - 1], Q = this.resume(), L = this.stack[this.stack.length - 1]; if (this.data.inReference = !0, L.type === "link") { const Oe = X.children; L.children = Oe } else L.alt = Q } function $() { const X = this.resume(), Q = this.stack[this.stack.length - 1]; Q.url = X } function pe() { const X = this.resume(), Q = this.stack[this.stack.length - 1]; Q.title = X } function re() { this.data.inReference = void 0 } function j() { this.data.referenceType = "collapsed" } function ae(X) { const Q = this.resume(), L = this.stack[this.stack.length - 1]; L.label = Q, L.identifier = mi(this.sliceSerialize(X)).toLowerCase(), this.data.referenceType = "full" } function be(X) { this.data.characterReferenceType = X.type } function fe(X) { const Q = this.sliceSerialize(X), L = this.data.characterReferenceType; let Oe; L ? (Oe = WT(Q, L === "characterReferenceMarkerNumeric" ? 10 : 16), this.data.characterReferenceType = void 0) : Oe = rc(Q); const De = this.stack[this.stack.length - 1]; De.value += Oe } function Ce(X) { const Q = this.stack.pop(); Q.position.end = Cs(X.end) } function ue(X) { P.call(this, X); const Q = this.stack[this.stack.length - 1]; Q.url = this.sliceSerialize(X) } function te(X) { P.call(this, X); const Q = this.stack[this.stack.length - 1]; Q.url = "mailto:" + this.sliceSerialize(X) } function le() { return { type: "blockquote", children: [] } } function Re() { return { type: "code", lang: null, meta: null, value: "" } } function at() { return { type: "inlineCode", value: "" } } function yt() { return { type: "definition", identifier: "", label: null, title: null, url: "" } } function ht() { return { type: "emphasis", children: [] } } function Ft() { return { type: "heading", depth: 0, children: [] } } function qe() { return { type: "break" } } function $t() { return { type: "html", value: "" } } function gn() { return { type: "image", title: null, url: "", alt: null } } function Hn() { return { type: "link", title: null, url: "", children: [] } } function ot(X) { return { type: "list", ordered: X.type === "listOrdered", start: null, spread: X._spread, children: [] } } function Ut(X) { return { type: "listItem", spread: X._spread, checked: null, children: [] } } function Wt() { return { type: "paragraph", children: [] } } function wn() { return { type: "strong", children: [] } } function Ze() { return { type: "text", value: "" } } function hr() { return { type: "thematicBreak" } } } function Cs(r) { return { line: r.line, column: r.column, offset: r.offset } } function qT(r, e) { let t = -1; for (; ++t < e.length;) { const n = e[t]; Array.isArray(n) ? qT(r, n) : wue(r, n) } } function wue(r, e) { let t; for (t in e) if (XT.call(e, t)) switch (t) { case "canContainEols": { const n = e[t]; n && r[t].push(...n); break } case "transforms": { const n = e[t]; n && r[t].push(...n); break } case "enter": case "exit": { const n = e[t]; n && Object.assign(r[t], n); break } } } function OC(r, e) { throw r ? new Error("Cannot close `" + r.type + "` (" + Wr({ start: r.start, end: r.end }) + "): a different token (`" + e.type + "`, " + Wr({ start: e.start, end: e.end }) + ") is open") : new Error("Cannot close document, a token (`" + e.type + "`, " + Wr({ start: e.start, end: e.end }) + ") is still open") } function Cue(r) { const e = this; e.parser = t; function t(n) { return vue(n, { ...e.data("settings"), ...r, extensions: e.data("micromarkExtensions") || [], mdastExtensions: e.data("fromMarkdownExtensions") || [] }) } } function Sue(r, e) { const t = { type: "element", tagName: "blockquote", properties: {}, children: r.wrap(r.all(e), !0) }; return r.patch(e, t), r.applyData(e, t) } function Eue(r, e) {
  const t = { type: "element", tagName: "br", properties: {}, children: [] }; return r.patch(e, t), [r.applyData(e, t), {
    type: "text", value: `
`}]
} function _ue(r, e) {
  const t = e.value ? e.value + `
`: "", n = {}; e.lang && (n.className = ["language-" + e.lang]); let i = { type: "element", tagName: "code", properties: n, children: [{ type: "text", value: t }] }; return e.meta && (i.data = { meta: e.meta }), r.patch(e, i), i = r.applyData(e, i), i = { type: "element", tagName: "pre", properties: {}, children: [i] }, r.patch(e, i), i
} function Oue(r, e) { const t = { type: "element", tagName: "del", properties: {}, children: r.all(e) }; return r.patch(e, t), r.applyData(e, t) } function Tue(r, e) { const t = { type: "element", tagName: "em", properties: {}, children: r.all(e) }; return r.patch(e, t), r.applyData(e, t) } function Iue(r, e) { const t = typeof r.options.clobberPrefix == "string" ? r.options.clobberPrefix : "user-content-", n = String(e.identifier).toUpperCase(), i = ll(n.toLowerCase()), s = r.footnoteOrder.indexOf(n); let a, o = r.footnoteCounts.get(n); o === void 0 ? (o = 0, r.footnoteOrder.push(n), a = r.footnoteOrder.length) : a = s + 1, o += 1, r.footnoteCounts.set(n, o); const l = { type: "element", tagName: "a", properties: { href: "#" + t + "fn-" + i, id: t + "fnref-" + i + (o > 1 ? "-" + o : ""), dataFootnoteRef: !0, ariaDescribedBy: ["footnote-label"] }, children: [{ type: "text", value: String(a) }] }; r.patch(e, l); const u = { type: "element", tagName: "sup", properties: {}, children: [l] }; return r.patch(e, u), r.applyData(e, u) } function Pue(r, e) { const t = { type: "element", tagName: "h" + e.depth, properties: {}, children: r.all(e) }; return r.patch(e, t), r.applyData(e, t) } function kue(r, e) { if (r.options.allowDangerousHtml) { const t = { type: "raw", value: e.value }; return r.patch(e, t), r.applyData(e, t) } } function ZT(r, e) { const t = e.referenceType; let n = "]"; if (t === "collapsed" ? n += "[]" : t === "full" && (n += "[" + (e.label || e.identifier) + "]"), e.type === "imageReference") return [{ type: "text", value: "![" + e.alt + n }]; const i = r.all(e), s = i[0]; s && s.type === "text" ? s.value = "[" + s.value : i.unshift({ type: "text", value: "[" }); const a = i[i.length - 1]; return a && a.type === "text" ? a.value += n : i.push({ type: "text", value: n }), i } function Rue(r, e) { const t = String(e.identifier).toUpperCase(), n = r.definitionById.get(t); if (!n) return ZT(r, e); const i = { src: ll(n.url || ""), alt: e.alt }; n.title !== null && n.title !== void 0 && (i.title = n.title); const s = { type: "element", tagName: "img", properties: i, children: [] }; return r.patch(e, s), r.applyData(e, s) } function Due(r, e) { const t = { src: ll(e.url) }; e.alt !== null && e.alt !== void 0 && (t.alt = e.alt), e.title !== null && e.title !== void 0 && (t.title = e.title); const n = { type: "element", tagName: "img", properties: t, children: [] }; return r.patch(e, n), r.applyData(e, n) } function Aue(r, e) { const t = { type: "text", value: e.value.replace(/\r?\n|\r/g, " ") }; r.patch(e, t); const n = { type: "element", tagName: "code", properties: {}, children: [t] }; return r.patch(e, n), r.applyData(e, n) } function Nue(r, e) { const t = String(e.identifier).toUpperCase(), n = r.definitionById.get(t); if (!n) return ZT(r, e); const i = { href: ll(n.url || "") }; n.title !== null && n.title !== void 0 && (i.title = n.title); const s = { type: "element", tagName: "a", properties: i, children: r.all(e) }; return r.patch(e, s), r.applyData(e, s) } function Fue(r, e) { const t = { href: ll(e.url) }; e.title !== null && e.title !== void 0 && (t.title = e.title); const n = { type: "element", tagName: "a", properties: t, children: r.all(e) }; return r.patch(e, n), r.applyData(e, n) } function $ue(r, e, t) {
  const n = r.all(e), i = t ? Lue(t) : JT(e), s = {}, a = []; if (typeof e.checked == "boolean") { const d = n[0]; let h; d && d.type === "element" && d.tagName === "p" ? h = d : (h = { type: "element", tagName: "p", properties: {}, children: [] }, n.unshift(h)), h.children.length > 0 && h.children.unshift({ type: "text", value: " " }), h.children.unshift({ type: "element", tagName: "input", properties: { type: "checkbox", checked: e.checked, disabled: !0 }, children: [] }), s.className = ["task-list-item"] } let o = -1; for (; ++o < n.length;) {
    const d = n[o]; (i || o !== 0 || d.type !== "element" || d.tagName !== "p") && a.push({
      type: "text", value: `
`}), d.type === "element" && d.tagName === "p" && !i ? a.push(...d.children) : a.push(d)
  } const l = n[n.length - 1]; l && (i || l.type !== "element" || l.tagName !== "p") && a.push({
    type: "text", value: `
`}); const u = { type: "element", tagName: "li", properties: s, children: a }; return r.patch(e, u), r.applyData(e, u)
} function Lue(r) { let e = !1; if (r.type === "list") { e = r.spread || !1; const t = r.children; let n = -1; for (; !e && ++n < t.length;)e = JT(t[n]) } return e } function JT(r) { const e = r.spread; return e ?? r.children.length > 1 } function Mue(r, e) { const t = {}, n = r.all(e); let i = -1; for (typeof e.start == "number" && e.start !== 1 && (t.start = e.start); ++i < n.length;) { const a = n[i]; if (a.type === "element" && a.tagName === "li" && a.properties && Array.isArray(a.properties.className) && a.properties.className.includes("task-list-item")) { t.className = ["contains-task-list"]; break } } const s = { type: "element", tagName: e.ordered ? "ol" : "ul", properties: t, children: r.wrap(n, !0) }; return r.patch(e, s), r.applyData(e, s) } function jue(r, e) { const t = { type: "element", tagName: "p", properties: {}, children: r.all(e) }; return r.patch(e, t), r.applyData(e, t) } function Vue(r, e) { const t = { type: "root", children: r.wrap(r.all(e)) }; return r.patch(e, t), r.applyData(e, t) } function Bue(r, e) { const t = { type: "element", tagName: "strong", properties: {}, children: r.all(e) }; return r.patch(e, t), r.applyData(e, t) } function zue(r, e) { const t = r.all(e), n = t.shift(), i = []; if (n) { const a = { type: "element", tagName: "thead", properties: {}, children: r.wrap([n], !0) }; r.patch(e.children[0], a), i.push(a) } if (t.length > 0) { const a = { type: "element", tagName: "tbody", properties: {}, children: r.wrap(t, !0) }, o = TT(e.children[1]), l = OT(e.children[e.children.length - 1]); o && l && (a.position = { start: o, end: l }), i.push(a) } const s = { type: "element", tagName: "table", properties: {}, children: r.wrap(i, !0) }; return r.patch(e, s), r.applyData(e, s) } function Hue(r, e, t) { const n = t ? t.children : void 0, s = (n ? n.indexOf(e) : 1) === 0 ? "th" : "td", a = t && t.type === "table" ? t.align : void 0, o = a ? a.length : e.children.length; let l = -1; const u = []; for (; ++l < o;) { const h = e.children[l], g = {}, m = a ? a[l] : void 0; m && (g.align = m); let b = { type: "element", tagName: s, properties: g, children: [] }; h && (b.children = r.all(h), r.patch(h, b), b = r.applyData(h, b)), u.push(b) } const d = { type: "element", tagName: "tr", properties: {}, children: r.wrap(u, !0) }; return r.patch(e, d), r.applyData(e, d) } function Kue(r, e) { const t = { type: "element", tagName: "td", properties: {}, children: r.all(e) }; return r.patch(e, t), r.applyData(e, t) } const TC = 9, IC = 32; function Uue(r) { const e = String(r), t = /\r?\n|\r/g; let n = t.exec(e), i = 0; const s = []; for (; n;)s.push(PC(e.slice(i, n.index), i > 0, !0), n[0]), i = n.index + n[0].length, n = t.exec(e); return s.push(PC(e.slice(i), i > 0, !1)), s.join("") } function PC(r, e, t) { let n = 0, i = r.length; if (e) { let s = r.codePointAt(n); for (; s === TC || s === IC;)n++, s = r.codePointAt(n) } if (t) { let s = r.codePointAt(i - 1); for (; s === TC || s === IC;)i--, s = r.codePointAt(i - 1) } return i > n ? r.slice(n, i) : "" } function Wue(r, e) { const t = { type: "text", value: Uue(String(e.value)) }; return r.patch(e, t), r.applyData(e, t) } function Gue(r, e) { const t = { type: "element", tagName: "hr", properties: {}, children: [] }; return r.patch(e, t), r.applyData(e, t) } const Yue = { blockquote: Sue, break: Eue, code: _ue, delete: Oue, emphasis: Tue, footnoteReference: Iue, heading: Pue, html: kue, imageReference: Rue, image: Due, inlineCode: Aue, linkReference: Nue, link: Fue, listItem: $ue, list: Mue, paragraph: jue, root: Vue, strong: Bue, table: zue, tableCell: Kue, tableRow: Hue, text: Wue, thematicBreak: Gue, toml: bu, yaml: bu, definition: bu, footnoteDefinition: bu }; function bu() { } const QT = -1, jh = 0, Ml = 1, Ed = 2, Rb = 3, Db = 4, Ab = 5, Nb = 6, eI = 7, tI = 8, kC = typeof self == "object" ? self : globalThis, Xue = (r, e) => { const t = (i, s) => (r.set(s, i), i), n = i => { if (r.has(i)) return r.get(i); const [s, a] = e[i]; switch (s) { case jh: case QT: return t(a, i); case Ml: { const o = t([], i); for (const l of a) o.push(n(l)); return o } case Ed: { const o = t({}, i); for (const [l, u] of a) o[n(l)] = n(u); return o } case Rb: return t(new Date(a), i); case Db: { const { source: o, flags: l } = a; return t(new RegExp(o, l), i) } case Ab: { const o = t(new Map, i); for (const [l, u] of a) o.set(n(l), n(u)); return o } case Nb: { const o = t(new Set, i); for (const l of a) o.add(n(l)); return o } case eI: { const { name: o, message: l } = a; return t(new kC[o](l), i) } case tI: return t(BigInt(a), i); case "BigInt": return t(Object(BigInt(a)), i); case "ArrayBuffer": return t(new Uint8Array(a).buffer, a); case "DataView": { const { buffer: o } = new Uint8Array(a); return t(new DataView(o), a) } }return t(new kC[s](a), i) }; return n }, RC = r => Xue(new Map, r)(0), Ja = "", { toString: que } = {}, { keys: Zue } = Object, _l = r => { const e = typeof r; if (e !== "object" || !r) return [jh, e]; const t = que.call(r).slice(8, -1); switch (t) { case "Array": return [Ml, Ja]; case "Object": return [Ed, Ja]; case "Date": return [Rb, Ja]; case "RegExp": return [Db, Ja]; case "Map": return [Ab, Ja]; case "Set": return [Nb, Ja]; case "DataView": return [Ml, t] }return t.includes("Array") ? [Ml, t] : t.includes("Error") ? [eI, t] : [Ed, t] }, vu = ([r, e]) => r === jh && (e === "function" || e === "symbol"), Jue = (r, e, t, n) => { const i = (a, o) => { const l = n.push(a) - 1; return t.set(o, l), l }, s = a => { if (t.has(a)) return t.get(a); let [o, l] = _l(a); switch (o) { case jh: { let d = a; switch (l) { case "bigint": o = tI, d = a.toString(); break; case "function": case "symbol": if (r) throw new TypeError("unable to serialize " + l); d = null; break; case "undefined": return i([QT], a) }return i([o, d], a) } case Ml: { if (l) { let g = a; return l === "DataView" ? g = new Uint8Array(a.buffer) : l === "ArrayBuffer" && (g = new Uint8Array(a)), i([l, [...g]], a) } const d = [], h = i([o, d], a); for (const g of a) d.push(s(g)); return h } case Ed: { if (l) switch (l) { case "BigInt": return i([l, a.toString()], a); case "Boolean": case "Number": case "String": return i([l, a.valueOf()], a) }if (e && "toJSON" in a) return s(a.toJSON()); const d = [], h = i([o, d], a); for (const g of Zue(a)) (r || !vu(_l(a[g]))) && d.push([s(g), s(a[g])]); return h } case Rb: return i([o, a.toISOString()], a); case Db: { const { source: d, flags: h } = a; return i([o, { source: d, flags: h }], a) } case Ab: { const d = [], h = i([o, d], a); for (const [g, m] of a) (r || !(vu(_l(g)) || vu(_l(m)))) && d.push([s(g), s(m)]); return h } case Nb: { const d = [], h = i([o, d], a); for (const g of a) (r || !vu(_l(g))) && d.push(s(g)); return h } }const { message: u } = a; return i([o, { name: l, message: u }], a) }; return s }, DC = (r, { json: e, lossy: t } = {}) => { const n = []; return Jue(!(e || t), !!e, new Map, n)(r), n }, _d = typeof structuredClone == "function" ? (r, e) => e && ("json" in e || "lossy" in e) ? RC(DC(r, e)) : structuredClone(r) : (r, e) => RC(DC(r, e)); function Que(r, e) { const t = [{ type: "text", value: "↩" }]; return e > 1 && t.push({ type: "element", tagName: "sup", properties: {}, children: [{ type: "text", value: String(e) }] }), t } function ede(r, e) { return "Back to reference " + (r + 1) + (e > 1 ? "-" + e : "") } function tde(r) {
  const e = typeof r.options.clobberPrefix == "string" ? r.options.clobberPrefix : "user-content-", t = r.options.footnoteBackContent || Que, n = r.options.footnoteBackLabel || ede, i = r.options.footnoteLabel || "Footnotes", s = r.options.footnoteLabelTagName || "h2", a = r.options.footnoteLabelProperties || { className: ["sr-only"] }, o = []; let l = -1; for (; ++l < r.footnoteOrder.length;) { const u = r.footnoteById.get(r.footnoteOrder[l]); if (!u) continue; const d = r.all(u), h = String(u.identifier).toUpperCase(), g = ll(h.toLowerCase()); let m = 0; const b = [], y = r.footnoteCounts.get(h); for (; y !== void 0 && ++m <= y;) { b.length > 0 && b.push({ type: "text", value: " " }); let S = typeof t == "string" ? t : t(l, m); typeof S == "string" && (S = { type: "text", value: S }), b.push({ type: "element", tagName: "a", properties: { href: "#" + e + "fnref-" + g + (m > 1 ? "-" + m : ""), dataFootnoteBackref: "", ariaLabel: typeof n == "string" ? n : n(l, m), className: ["data-footnote-backref"] }, children: Array.isArray(S) ? S : [S] }) } const w = d[d.length - 1]; if (w && w.type === "element" && w.tagName === "p") { const S = w.children[w.children.length - 1]; S && S.type === "text" ? S.value += " " : w.children.push({ type: "text", value: " " }), w.children.push(...b) } else d.push(...b); const x = { type: "element", tagName: "li", properties: { id: e + "fn-" + g }, children: r.wrap(d, !0) }; r.patch(u, x), o.push(x) } if (o.length !== 0) return {
    type: "element", tagName: "section", properties: { dataFootnotes: !0, className: ["footnotes"] }, children: [{ type: "element", tagName: s, properties: { ..._d(a), id: "footnote-label" }, children: [{ type: "text", value: i }] }, {
      type: "text", value: `
`}, { type: "element", tagName: "ol", properties: {}, children: r.wrap(o, !0) }, {
      type: "text", value: `
`}]
  }
} const Vh = function (r) { if (r == null) return sde; if (typeof r == "function") return Bh(r); if (typeof r == "object") return Array.isArray(r) ? nde(r) : rde(r); if (typeof r == "string") return ide(r); throw new Error("Expected function, string, or object as test") }; function nde(r) { const e = []; let t = -1; for (; ++t < r.length;)e[t] = Vh(r[t]); return Bh(n); function n(...i) { let s = -1; for (; ++s < e.length;)if (e[s].apply(this, i)) return !0; return !1 } } function rde(r) { const e = r; return Bh(t); function t(n) { const i = n; let s; for (s in r) if (i[s] !== e[s]) return !1; return !0 } } function ide(r) { return Bh(e); function e(t) { return t && t.type === r } } function Bh(r) { return e; function e(t, n, i) { return !!(ade(t) && r.call(this, t, typeof n == "number" ? n : void 0, i || void 0)) } } function sde() { return !0 } function ade(r) { return r !== null && typeof r == "object" && "type" in r } const nI = [], ode = !0, im = !1, lde = "skip"; function rI(r, e, t, n) { let i; typeof e == "function" && typeof t != "function" ? (n = t, t = e) : i = e; const s = Vh(i), a = n ? -1 : 1; o(r, void 0, [])(); function o(l, u, d) { const h = l && typeof l == "object" ? l : {}; if (typeof h.type == "string") { const m = typeof h.tagName == "string" ? h.tagName : typeof h.name == "string" ? h.name : void 0; Object.defineProperty(g, "name", { value: "node (" + (l.type + (m ? "<" + m + ">" : "")) + ")" }) } return g; function g() { let m = nI, b, y, w; if ((!e || s(l, u, d[d.length - 1] || void 0)) && (m = cde(t(l, d)), m[0] === im)) return m; if ("children" in l && l.children) { const x = l; if (x.children && m[0] !== lde) for (y = (n ? x.children.length : -1) + a, w = d.concat(x); y > -1 && y < x.children.length;) { const S = x.children[y]; if (b = o(S, y, w)(), b[0] === im) return b; y = typeof b[1] == "number" ? b[1] : y + a } } return m } } } function cde(r) { return Array.isArray(r) ? r : typeof r == "number" ? [ode, r] : r == null ? nI : [r] } function zh(r, e, t, n) { let i, s, a; typeof e == "function" && typeof t != "function" ? (s = void 0, a = e, i = t) : (s = e, a = t, i = n), rI(r, s, o, i); function o(l, u) { const d = u[u.length - 1], h = d ? d.children.indexOf(l) : void 0; return a(l, h, d) } } const sm = {}.hasOwnProperty, ude = {}; function dde(r, e) { const t = e || ude, n = new Map, i = new Map, s = new Map, a = { ...Yue, ...t.handlers }, o = { all: u, applyData: pde, definitionById: n, footnoteById: i, footnoteCounts: s, footnoteOrder: [], handlers: a, one: l, options: t, patch: hde, wrap: gde }; return zh(r, function (d) { if (d.type === "definition" || d.type === "footnoteDefinition") { const h = d.type === "definition" ? n : i, g = String(d.identifier).toUpperCase(); h.has(g) || h.set(g, d) } }), o; function l(d, h) { const g = d.type, m = o.handlers[g]; if (sm.call(o.handlers, g) && m) return m(o, d, h); if (o.options.passThrough && o.options.passThrough.includes(g)) { if ("children" in d) { const { children: y, ...w } = d, x = _d(w); return x.children = o.all(d), x } return _d(d) } return (o.options.unknownHandler || fde)(o, d, h) } function u(d) { const h = []; if ("children" in d) { const g = d.children; let m = -1; for (; ++m < g.length;) { const b = o.one(g[m], d); if (b) { if (m && g[m - 1].type === "break" && (!Array.isArray(b) && b.type === "text" && (b.value = AC(b.value)), !Array.isArray(b) && b.type === "element")) { const y = b.children[0]; y && y.type === "text" && (y.value = AC(y.value)) } Array.isArray(b) ? h.push(...b) : h.push(b) } } } return h } } function hde(r, e) { r.position && (e.position = PT(r)) } function pde(r, e) { let t = e; if (r && r.data) { const n = r.data.hName, i = r.data.hChildren, s = r.data.hProperties; if (typeof n == "string") if (t.type === "element") t.tagName = n; else { const a = "children" in t ? t.children : [t]; t = { type: "element", tagName: n, properties: {}, children: a } } t.type === "element" && s && Object.assign(t.properties, _d(s)), "children" in t && t.children && i !== null && i !== void 0 && (t.children = i) } return t } function fde(r, e) { const t = e.data || {}, n = "value" in e && !(sm.call(t, "hProperties") || sm.call(t, "hChildren")) ? { type: "text", value: e.value } : { type: "element", tagName: "div", properties: {}, children: r.all(e) }; return r.patch(e, n), r.applyData(e, n) } function gde(r, e) {
  const t = []; let n = -1; for (e && t.push({
    type: "text", value: `
`}); ++n < r.length;)n && t.push({
      type: "text", value: `
`}), t.push(r[n]); return e && r.length > 0 && t.push({
        type: "text", value: `
`}), t
} function AC(r) { let e = 0, t = r.charCodeAt(e); for (; t === 9 || t === 32;)e++, t = r.charCodeAt(e); return r.slice(e) } function NC(r, e) {
  const t = dde(r, e), n = t.one(r, void 0), i = tde(t), s = Array.isArray(n) ? { type: "root", children: n } : n || { type: "root", children: [] }; return i && s.children.push({
    type: "text", value: `
`}, i), s
} function mde(r, e) { return r && "run" in r ? async function (t, n) { const i = NC(t, { file: n, ...e }); await r.run(i, n) } : function (t, n) { return NC(t, { file: n, ...r || e }) } } function FC(r) { if (r) throw r } var Hu = Object.prototype.hasOwnProperty, iI = Object.prototype.toString, $C = Object.defineProperty, LC = Object.getOwnPropertyDescriptor, MC = function (e) { return typeof Array.isArray == "function" ? Array.isArray(e) : iI.call(e) === "[object Array]" }, jC = function (e) { if (!e || iI.call(e) !== "[object Object]") return !1; var t = Hu.call(e, "constructor"), n = e.constructor && e.constructor.prototype && Hu.call(e.constructor.prototype, "isPrototypeOf"); if (e.constructor && !t && !n) return !1; var i; for (i in e); return typeof i > "u" || Hu.call(e, i) }, VC = function (e, t) { $C && t.name === "__proto__" ? $C(e, t.name, { enumerable: !0, configurable: !0, value: t.newValue, writable: !0 }) : e[t.name] = t.newValue }, BC = function (e, t) { if (t === "__proto__") if (Hu.call(e, t)) { if (LC) return LC(e, t).value } else return; return e[t] }, yde = function r() { var e, t, n, i, s, a, o = arguments[0], l = 1, u = arguments.length, d = !1; for (typeof o == "boolean" && (d = o, o = arguments[1] || {}, l = 2), (o == null || typeof o != "object" && typeof o != "function") && (o = {}); l < u; ++l)if (e = arguments[l], e != null) for (t in e) n = BC(o, t), i = BC(e, t), o !== i && (d && i && (jC(i) || (s = MC(i))) ? (s ? (s = !1, a = n && MC(n) ? n : []) : a = n && jC(n) ? n : {}, VC(o, { name: t, newValue: r(d, a, i) })) : typeof i < "u" && VC(o, { name: t, newValue: i })); return o }; const rf = _e(yde); function am(r) { if (typeof r != "object" || r === null) return !1; const e = Object.getPrototypeOf(r); return (e === null || e === Object.prototype || Object.getPrototypeOf(e) === null) && !(Symbol.toStringTag in r) && !(Symbol.iterator in r) } function bde() { const r = [], e = { run: t, use: n }; return e; function t(...i) { let s = -1; const a = i.pop(); if (typeof a != "function") throw new TypeError("Expected function as last argument, not " + a); o(null, ...i); function o(l, ...u) { const d = r[++s]; let h = -1; if (l) { a(l); return } for (; ++h < i.length;)(u[h] === null || u[h] === void 0) && (u[h] = i[h]); i = u, d ? vde(d, o)(...u) : a(null, ...u) } } function n(i) { if (typeof i != "function") throw new TypeError("Expected `middelware` to be a function, not " + i); return r.push(i), e } } function vde(r, e) { let t; return n; function n(...a) { const o = r.length > a.length; let l; o && a.push(i); try { l = r.apply(this, a) } catch (u) { const d = u; if (o && t) throw d; return i(d) } o || (l && l.then && typeof l.then == "function" ? l.then(s, i) : l instanceof Error ? i(l) : s(l)) } function i(a, ...o) { t || (t = !0, e(a, ...o)) } function s(a) { i(null, a) } } const xde = function (r) { const n = this.constructor.prototype, i = n[r], s = function () { return i.apply(s, arguments) }; return Object.setPrototypeOf(s, n), s }, wde = {}.hasOwnProperty; class Fb extends xde { constructor() { super("copy"), this.Compiler = void 0, this.Parser = void 0, this.attachers = [], this.compiler = void 0, this.freezeIndex = -1, this.frozen = void 0, this.namespace = {}, this.parser = void 0, this.transformers = bde() } copy() { const e = new Fb; let t = -1; for (; ++t < this.attachers.length;) { const n = this.attachers[t]; e.use(...n) } return e.data(rf(!0, {}, this.namespace)), e } data(e, t) { return typeof e == "string" ? arguments.length === 2 ? (of("data", this.frozen), this.namespace[e] = t, this) : wde.call(this.namespace, e) && this.namespace[e] || void 0 : e ? (of("data", this.frozen), this.namespace = e, this) : this.namespace } freeze() { if (this.frozen) return this; const e = this; for (; ++this.freezeIndex < this.attachers.length;) { const [t, ...n] = this.attachers[this.freezeIndex]; if (n[0] === !1) continue; n[0] === !0 && (n[0] = void 0); const i = t.call(e, ...n); typeof i == "function" && this.transformers.use(i) } return this.frozen = !0, this.freezeIndex = Number.POSITIVE_INFINITY, this } parse(e) { this.freeze(); const t = xu(e), n = this.parser || this.Parser; return sf("parse", n), n(String(t), t) } process(e, t) { const n = this; return this.freeze(), sf("process", this.parser || this.Parser), af("process", this.compiler || this.Compiler), t ? i(void 0, t) : new Promise(i); function i(s, a) { const o = xu(e), l = n.parse(o); n.run(l, o, function (d, h, g) { if (d || !h || !g) return u(d); const m = h, b = n.stringify(m, g); Ede(b) ? g.value = b : g.result = b, u(d, g) }); function u(d, h) { d || !h ? a(d) : s ? s(h) : t(void 0, h) } } } processSync(e) { let t = !1, n; return this.freeze(), sf("processSync", this.parser || this.Parser), af("processSync", this.compiler || this.Compiler), this.process(e, i), HC("processSync", "process", t), n; function i(s, a) { t = !0, FC(s), n = a } } run(e, t, n) { zC(e), this.freeze(); const i = this.transformers; return !n && typeof t == "function" && (n = t, t = void 0), n ? s(void 0, n) : new Promise(s); function s(a, o) { const l = xu(t); i.run(e, l, u); function u(d, h, g) { const m = h || e; d ? o(d) : a ? a(m) : n(void 0, m, g) } } } runSync(e, t) { let n = !1, i; return this.run(e, t, s), HC("runSync", "run", n), i; function s(a, o) { FC(a), i = o, n = !0 } } stringify(e, t) { this.freeze(); const n = xu(t), i = this.compiler || this.Compiler; return af("stringify", i), zC(e), i(e, n) } use(e, ...t) { const n = this.attachers, i = this.namespace; if (of("use", this.frozen), e != null) if (typeof e == "function") l(e, t); else if (typeof e == "object") Array.isArray(e) ? o(e) : a(e); else throw new TypeError("Expected usable value, not `" + e + "`"); return this; function s(u) { if (typeof u == "function") l(u, []); else if (typeof u == "object") if (Array.isArray(u)) { const [d, ...h] = u; l(d, h) } else a(u); else throw new TypeError("Expected usable value, not `" + u + "`") } function a(u) { if (!("plugins" in u) && !("settings" in u)) throw new Error("Expected usable value but received an empty preset, which is probably a mistake: presets typically come with `plugins` and sometimes with `settings`, but this has neither"); o(u.plugins), u.settings && (i.settings = rf(!0, i.settings, u.settings)) } function o(u) { let d = -1; if (u != null) if (Array.isArray(u)) for (; ++d < u.length;) { const h = u[d]; s(h) } else throw new TypeError("Expected a list of plugins, not `" + u + "`") } function l(u, d) { let h = -1, g = -1; for (; ++h < n.length;)if (n[h][0] === u) { g = h; break } if (g === -1) n.push([u, ...d]); else if (d.length > 0) { let [m, ...b] = d; const y = n[g][1]; am(y) && am(m) && (m = rf(!0, y, m)), n[g] = [u, m, ...b] } } } } const Cde = new Fb().freeze(); function sf(r, e) { if (typeof e != "function") throw new TypeError("Cannot `" + r + "` without `parser`") } function af(r, e) { if (typeof e != "function") throw new TypeError("Cannot `" + r + "` without `compiler`") } function of(r, e) { if (e) throw new Error("Cannot call `" + r + "` on a frozen processor.\nCreate a new processor first, by calling it: use `processor()` instead of `processor`.") } function zC(r) { if (!am(r) || typeof r.type != "string") throw new TypeError("Expected node, got `" + r + "`") } function HC(r, e, t) { if (!t) throw new Error("`" + r + "` finished async. Use `" + e + "` instead") } function xu(r) { return Sde(r) ? r : new oT(r) } function Sde(r) { return !!(r && typeof r == "object" && "message" in r && "messages" in r) } function Ede(r) { return typeof r == "string" || _de(r) } function _de(r) { return !!(r && typeof r == "object" && "byteLength" in r && "byteOffset" in r) } function Os(r, e) { const t = ["start", "end", "loc", "range"]; let n = -1; for (; ++n < t.length;) { const i = t[n]; i in r && (e[i] = r[i]) } } function $b(r, e) { let t = -1; const n = [], i = []; let s; for (; ++t < r.length;) { const a = r[t]; a.type === "ImportNamespaceSpecifier" ? s = a : i.push(a) } if (s) { const a = { type: "VariableDeclarator", id: s.local, init: e }; Os(s, a), n.push(a) } return n.push({ type: "VariableDeclarator", id: { type: "ObjectPattern", properties: i.map(function (a) { let o = a.type === "ImportSpecifier" ? a.imported : a.type === "ExportSpecifier" ? a.exported : { type: "Identifier", name: "default" }, l = a.local; a.type === "ExportSpecifier" && (l = o, o = a.local), l.type; const u = { type: "Property", kind: "init", shorthand: o.type === "Identifier" && l.type === "Identifier" && o.name === l.name, method: !1, computed: !1, key: o, value: l }; return Os(a, u), u }) }, init: s ? { type: "Identifier", name: s.local.name } : e }), n } function Ls(r) { let e = -1, t; for (; ++e < r.length;) { const n = r[e], i = typeof n == "string" && Bi(n) ? { type: "Identifier", name: n } : { type: "Literal", value: n }; t = t ? { type: "MemberExpression", object: t, property: i, computed: i.type === "Literal", optional: !1 } : i } return t.type, t } function KC(r) { let e = -1, t; for (; ++e < r.length;) { const n = r[e]; typeof n == "string" && Bi(n, { jsx: !0 }); const i = { type: "JSXIdentifier", name: n }; t = t ? { type: "JSXMemberExpression", object: t, property: i } : i } return t } function Ode(r) { const { outputFormat: e } = r || {}; return function (t) { if (t.comments && (t.comments = t.comments.filter(function (n) { var i; return !((i = n.data) != null && i._mdxIsPragmaComment) })), e === "function-body") { let n = 0; for (; n < t.body.length;) { const s = t.body[n]; if ("directive" in s && s.directive) n++; else break } const i = t.body[n]; i && i.type === "ImportDeclaration" && typeof i.source.value == "string" && /\/jsx-(dev-)?runtime$/.test(i.source.value) && (t.body[n] = { type: "VariableDeclaration", kind: "const", declarations: $b(i.specifiers, Ls(["arguments", 0])) }) } } } function sI() { const r = [{ block: !1, defined: [] }]; return { enter: e, exit: t, scopes: r }; function e(s) { if (s.type === "ArrowFunctionExpression") { r.push({ block: !1, defined: [] }); for (const a of s.params) i(a, !1) } else if (s.type === "BlockStatement" || s.type === "DoWhileStatement" || s.type === "ForInStatement" || s.type === "ForOfStatement" || s.type === "ForStatement" || s.type === "WhileStatement") r.push({ block: !0, defined: [] }); else if (s.type === "CatchClause") r.push({ block: !0, defined: [] }), s.param && i(s.param, !0); else if (s.type === "ClassDeclaration") n(s.id.name, !1); else if (s.type === "FunctionDeclaration") { n(s.id.name, !1), r.push({ block: !1, defined: [] }); for (const a of s.params) i(a, !1) } else if (s.type === "FunctionExpression") { s.id && n(s.id.name, !1), r.push({ block: !1, defined: [] }); for (const a of s.params) i(a, !1) } else if (s.type === "ImportDeclaration") for (const a of s.specifiers) n(a.local.name, !1); else if (s.type === "VariableDeclaration") for (const a of s.declarations) i(a.id, s.kind !== "var") } function t(s) { if (s.type === "ArrowFunctionExpression" || s.type === "FunctionDeclaration" || s.type === "FunctionExpression") { const a = r.pop(); a.block } else if (s.type === "BlockStatement" || s.type === "CatchClause" || s.type === "DoWhileStatement" || s.type === "ForInStatement" || s.type === "ForOfStatement" || s.type === "ForStatement" || s.type === "WhileStatement") { const a = r.pop(); a.block } } function n(s, a) { let o = r.length, l; for (; o-- && (l = r[o], !(a || !l.block));); l.defined.push(s) } function i(s, a) { if (s.type === "ArrayPattern") for (const o of s.elements) o && i(o, a); else if (s.type === "AssignmentPattern") i(s.left, a); else if (s.type === "Identifier") n(s.name, a); else if (s.type === "ObjectPattern") for (const o of s.properties) o.type === "Property" ? i(o.value, a) : (o.type, i(o, a)); else s.type, i(s.argument, a) } } function Tde(r) { return r.type === "FunctionDeclaration" ? { ...r, type: "FunctionExpression" } : (r.type, { ...r, type: "ClassExpression" }) } function Ide(r) { return r.type === "FunctionDeclaration" || r.type === "ClassDeclaration" || r.type === "VariableDeclaration" } function Pde(r) { const e = r.baseUrl || void 0, t = typeof e == "object" ? e.href : e, n = r.outputFormat || "program", i = r.pragma === void 0 ? "React.createElement" : r.pragma, s = r.pragmaFrag === void 0 ? "React.Fragment" : r.pragmaFrag, a = r.pragmaImportSource || "react", o = r.jsxImportSource || "react", l = r.jsxRuntime || "automatic"; return function (d, h) { const g = [], m = []; let b = 0, y, w, x; if (l === "classic" && s && wu(d, "@jsxFrag", s), l === "classic" && i && wu(d, "@jsx", i), l === "automatic" && o && wu(d, "@jsxImportSource", o), wu(d, "@jsxRuntime", l), l === "classic" && a) { if (!i) throw new Error("Missing `pragma` in classic runtime with `pragmaImportSource`"); E({ type: "ImportDeclaration", specifiers: [{ type: "ImportDefaultSpecifier", local: { type: "Identifier", name: i.split(".")[0] } }], source: { type: "Literal", value: a } }) } for (x of d.body) if (x.type === "ExportDefaultDeclaration") y && h.fail("Unexpected duplicate layout, expected a single layout (previous: " + Wr(ns(y)) + ")", { ancestors: [d, x], place: ns(x), ruleId: "duplicate-layout", source: "recma-document" }), y = x, m.push({ type: "VariableDeclaration", kind: "const", declarations: [{ type: "VariableDeclarator", id: { type: "Identifier", name: "MDXLayout" }, init: Ide(x.declaration) ? Tde(x.declaration) : x.declaration }] }); else if (x.type === "ExportNamedDeclaration" && x.source) { const v = x.source; x.specifiers = x.specifiers.filter(function (T) { if (T.exported.type === "Identifier" && T.exported.name === "default") { y && h.fail("Unexpected duplicate layout, expected a single layout (previous: " + Wr(ns(y)) + ")", { ancestors: [d, x, T], place: ns(x), ruleId: "duplicate-layout", source: "recma-document" }), y = T; const I = []; if (T.local.type === "Identifier" && T.local.name === "default") I.push({ type: "ImportDefaultSpecifier", local: { type: "Identifier", name: "MDXLayout" } }); else { const N = { type: "ImportSpecifier", imported: T.local, local: { type: "Identifier", name: "MDXLayout" } }; Os(T.local, N), I.push(N) } const k = { type: "Literal", value: v.value }; Os(v, k); const P = { type: "ImportDeclaration", specifiers: I, source: k }; return Os(T, P), E(P), !1 } return !0 }), x.specifiers.length > 0 && O(x) } else x.type === "ExportNamedDeclaration" || x.type === "ExportAllDeclaration" ? O(x) : x.type === "ImportDeclaration" ? E(x) : x.type === "ExpressionStatement" && (x.expression.type === "JSXElement" || x.expression.type === "JSXFragment") ? (w = !0, m.push(...u(x.expression, n, !!y))) : m.push(x); w || m.push(...u(void 0, n, !!y)), g.push(["MDXContent", "default"]), n === "function-body" && m.push({ type: "ReturnStatement", argument: { type: "ObjectExpression", properties: [...Array.from({ length: b }).map(function (v, T) { return { type: "SpreadElement", argument: { type: "Identifier", name: "_exportAll" + (T + 1) } } }), ...g.map(function (v) { return { type: "Property", kind: "init", method: !1, computed: !1, shorthand: typeof v == "string", key: { type: "Identifier", name: typeof v == "string" ? v : v[1] }, value: { type: "Identifier", name: typeof v == "string" ? v : v[0] } } })] } }), d.body = m; let S = !1, C = !1; (t || n === "function-body") && bo(d, { enter(v) { if ((v.type === "ExportAllDeclaration" || v.type === "ExportNamedDeclaration" || v.type === "ImportDeclaration") && v.source) { let T = v.source.value; try { new URL(T) } catch { (T.startsWith("/") || T.startsWith("./") || T.startsWith("../")) && (T = new URL(T, t).href) } const I = { type: "Literal", value: T }; Os(v.source, I), v.source = I; return } if (v.type === "ImportExpression") { C = !0; const T = { type: "CallExpression", callee: { type: "Identifier", name: "_resolveDynamicMdxSpecifier" }, arguments: [v.source], optional: !1 }; v.source = T; return } if (v.type === "MemberExpression" && "object" in v && v.object.type === "MetaProperty" && v.property.type === "Identifier" && v.object.meta.name === "import" && v.object.property.name === "meta" && v.property.name === "url") { S = !0; const T = { type: "Identifier", name: "_importMetaUrl" }; Os(v, T), this.replace(T) } } }), C && (t || (S = !0), d.body.push(kde(t ? { type: "Literal", value: t } : { type: "Identifier", name: "_importMetaUrl" }))), S && d.body.unshift(...Rde()); function O(v) { if (v.type === "ExportNamedDeclaration") { if (v.declaration) { const T = sI(); bo(v, { enter(I) { T.enter(I), (I.type === "ArrowFunctionExpression" || I.type === "FunctionDeclaration" || I.type === "FunctionExpression") && (this.skip(), T.exit(I)) }, leave: T.exit }), g.push(...T.scopes[0].defined) } for (x of v.specifiers) x.exported.type === "Identifier" ? g.push(x.exported.name) : (x.exported.value, g.push(x.exported.value)) } E(v) } function E(v) { let T, I; if (n === "function-body") if (v.type === "ImportDeclaration" || v.type === "ExportAllDeclaration" || v.type === "ExportNamedDeclaration" && v.source) { v.source; const k = { type: "ImportExpression", source: v.source }; Os(v, k), I = { type: "AwaitExpression", argument: k }, (v.type === "ImportDeclaration" || v.type === "ExportNamedDeclaration") && v.specifiers.length === 0 ? T = { type: "ExpressionStatement", expression: I } : T = { type: "VariableDeclaration", kind: "const", declarations: v.type === "ExportAllDeclaration" ? [{ type: "VariableDeclarator", id: { type: "Identifier", name: "_exportAll" + ++b }, init: I }] : $b(v.specifiers, I) } } else if (v.declaration) T = v.declaration; else { const k = []; for (const P of v.specifiers) P.exported.type === "Identifier" && P.local.type === "Identifier" && P.local.name !== P.exported.name && k.push({ type: "VariableDeclarator", id: P.exported, init: P.local }); k.length > 0 && (T = { type: "VariableDeclaration", kind: "const", declarations: k }) } else T = v; T && m.push(T) } }; function u(d, h, g) { let b = { type: "JSXElement", openingElement: { type: "JSXOpeningElement", name: { type: "JSXIdentifier", name: "MDXLayout" }, attributes: [{ type: "JSXSpreadAttribute", argument: { type: "Identifier", name: "props" } }], selfClosing: !1 }, closingElement: { type: "JSXClosingElement", name: { type: "JSXIdentifier", name: "MDXLayout" } }, children: [{ type: "JSXElement", openingElement: { type: "JSXOpeningElement", name: { type: "JSXIdentifier", name: "_createMdxContent" }, attributes: [{ type: "JSXSpreadAttribute", argument: { type: "Identifier", name: "props" } }], selfClosing: !0 }, closingElement: null, children: [] }] }; g || (b = { type: "ConditionalExpression", test: { type: "Identifier", name: "MDXLayout" }, consequent: b, alternate: { type: "CallExpression", callee: { type: "Identifier", name: "_createMdxContent" }, arguments: [{ type: "Identifier", name: "props" }], optional: !1 } }); let y = d || { type: "Identifier", name: "undefined" }; y.type === "JSXFragment" && y.children.length === 1 && y.children[0].type === "JSXElement" && (y = y.children[0]); let w = !1; bo(y, { enter(S) { if (S.type === "ArrowFunctionExpression" || S.type === "FunctionDeclaration" || S.type === "FunctionExpression") return this.skip(); (S.type === "AwaitExpression" || S.type === "ForOfStatement" && S.await) && (w = !0) } }); const x = { type: "FunctionDeclaration", id: { type: "Identifier", name: "MDXContent" }, params: [{ type: "AssignmentPattern", left: { type: "Identifier", name: "props" }, right: { type: "ObjectExpression", properties: [] } }], body: { type: "BlockStatement", body: [{ type: "ReturnStatement", argument: b }] } }; return [{ type: "FunctionDeclaration", async: w, id: { type: "Identifier", name: "_createMdxContent" }, params: [{ type: "Identifier", name: "props" }], body: { type: "BlockStatement", body: [{ type: "ReturnStatement", argument: y }] } }, h === "program" ? { type: "ExportDefaultDeclaration", declaration: x } : x] } } function wu(r, e, t) { var n; (n = r.comments) == null || n.unshift({ type: "Block", value: e + " " + t, data: { _mdxIsPragmaComment: !0 } }) } function kde(r) { return { type: "FunctionDeclaration", id: { type: "Identifier", name: "_resolveDynamicMdxSpecifier" }, generator: !1, async: !1, params: [{ type: "Identifier", name: "d" }], body: { type: "BlockStatement", body: [{ type: "IfStatement", test: { type: "BinaryExpression", left: { type: "UnaryExpression", operator: "typeof", prefix: !0, argument: { type: "Identifier", name: "d" } }, operator: "!==", right: { type: "Literal", value: "string" } }, consequent: { type: "ReturnStatement", argument: { type: "Identifier", name: "d" } }, alternate: null }, { type: "TryStatement", block: { type: "BlockStatement", body: [{ type: "ExpressionStatement", expression: { type: "NewExpression", callee: { type: "Identifier", name: "URL" }, arguments: [{ type: "Identifier", name: "d" }] } }, { type: "ReturnStatement", argument: { type: "Identifier", name: "d" } }] }, handler: { type: "CatchClause", param: null, body: { type: "BlockStatement", body: [] } }, finalizer: null }, { type: "IfStatement", test: { type: "LogicalExpression", left: { type: "LogicalExpression", left: { type: "CallExpression", callee: Ls(["d", "startsWith"]), arguments: [{ type: "Literal", value: "/" }], optional: !1 }, operator: "||", right: { type: "CallExpression", callee: Ls(["d", "startsWith"]), arguments: [{ type: "Literal", value: "./" }], optional: !1 } }, operator: "||", right: { type: "CallExpression", callee: Ls(["d", "startsWith"]), arguments: [{ type: "Literal", value: "../" }], optional: !1 } }, consequent: { type: "ReturnStatement", argument: { type: "MemberExpression", object: { type: "NewExpression", callee: { type: "Identifier", name: "URL" }, arguments: [{ type: "Identifier", name: "d" }, r] }, property: { type: "Identifier", name: "href" }, computed: !1, optional: !1 } }, alternate: null }, { type: "ReturnStatement", argument: { type: "Identifier", name: "d" } }] } } } function Rde() { return [{ type: "VariableDeclaration", declarations: [{ type: "VariableDeclarator", id: { type: "Identifier", name: "_importMetaUrl" }, init: Ls(["arguments", 0, "baseUrl"]) }], kind: "const" }, { type: "IfStatement", test: { type: "UnaryExpression", operator: "!", prefix: !0, argument: { type: "Identifier", name: "_importMetaUrl" } }, consequent: { type: "ThrowStatement", argument: { type: "NewExpression", callee: { type: "Identifier", name: "Error" }, arguments: [{ type: "Literal", value: "Unexpected missing `options.baseUrl` needed to support `export … from`, `import`, or `import.meta.url` when generating `function-body`" }] } }, alternate: null }] } function UC(r) { let e = -1, t; for (; ++e < r.length;) { const n = r[e]; t = t ? { type: "BinaryExpression", left: t, operator: "+", right: n } : n } return t } function Dde(r) { const { development: e, outputFormat: t, providerImportSource: n } = r; return function (i, s) { const a = sI(), o = []; let l = !1, u = !1; if (bo(i, { enter(d) { a.enter(d), (d.type === "FunctionDeclaration" || d.type === "FunctionExpression" || d.type === "ArrowFunctionExpression") && (o.push({ components: [], idToInvalidComponentName: new Map, node: d, objects: [], references: {}, tags: [] }), Qa(d, "MDXContent") && !lf(a.scopes, "MDXLayout") && o[0].components.push("MDXLayout")); const h = o[0]; if (!(!h || !Qa(h.node, "_createMdxContent") && !n) && d.type === "JSXElement") { let g = d.openingElement.name; if (g.type === "JSXMemberExpression") { const m = []; for (; g.type === "JSXMemberExpression";)m.unshift(g.property.name), g = g.object; m.unshift(g.name); const b = m.join("."), y = g.name, w = lf(a.scopes, y); !Object.hasOwn(h.references, b) && (!w || o.length === 1 && o[0].node.type === "FunctionDeclaration" && Qa(o[0].node, "_createMdxContent")) && (h.references[b] = { component: !0, node: d }), !h.objects.includes(y) && !w && h.objects.push(y) } else if (g.type !== "JSXNamespacedName") { if (Bi(g.name) && !/^[a-z]/.test(g.name)) { const m = g.name; lf(a.scopes, m) || (m !== "MDXLayout" && !Object.hasOwn(h.references, m) && (h.references[m] = { component: !0, node: d }), h.components.includes(m) || h.components.push(m)) } else if (!(d.data && d.data._mdxExplicitJsx)) { const m = g.name; h.tags.includes(m) || h.tags.push(m); let b = ["_components", m]; if (Bi(m) === !1) { let y = h.idToInvalidComponentName.get(m); y === void 0 && (y = `_component${h.idToInvalidComponentName.size}`, h.idToInvalidComponentName.set(m, y)), b = [y] } d.openingElement.name = KC(b), d.closingElement && (d.closingElement.name = KC(b)) } } } }, leave(d) { a.exit(d); const h = [], g = [], m = [], b = []; if (d.type === "FunctionDeclaration" || d.type === "FunctionExpression" || d.type === "ArrowFunctionExpression") { const y = o[o.length - 1]; let w; for (w of y.tags.sort()) h.push({ type: "Property", kind: "init", key: Bi(w) ? { type: "Identifier", name: w } : { type: "Literal", value: w }, value: { type: "Literal", value: w }, method: !1, shorthand: !1, computed: !1 }); g.push(...y.components); for (w of y.objects) g.includes(w) || g.push(w); g.sort(); const x = []; if (h.length > 0 || g.length > 0 || y.idToInvalidComponentName.size > 0) { if (n && (l = !0, m.push({ type: "CallExpression", callee: { type: "Identifier", name: "_provideComponents" }, arguments: [], optional: !1 })), (Qa(y.node, "MDXContent") || Qa(y.node, "_createMdxContent")) && m.push(Ls(["props", "components"])), h.length > 0 || m.length > 1) for (const T of m) h.push({ type: "SpreadElement", argument: T }); let E = h.length > 0 ? { type: "ObjectExpression", properties: h } : { type: "LogicalExpression", operator: "||", left: m[0], right: { type: "ObjectExpression", properties: [] } }, v; if (g.length > 0 && (v = { type: "ObjectPattern", properties: g.map(function (T) { return { type: "Property", kind: "init", key: { type: "Identifier", name: T === "MDXLayout" ? "wrapper" : T }, value: { type: "Identifier", name: T }, method: !1, shorthand: T !== "MDXLayout", computed: !1 } }) }), y.tags.length > 0 && (b.push({ type: "VariableDeclarator", id: { type: "Identifier", name: "_components" }, init: E }), E = { type: "Identifier", name: "_components" }), Qa(y.node, "_createMdxContent")) for (const [T, I] of [...y.idToInvalidComponentName].sort(function ([k], [P]) { return k.localeCompare(P) })) b.push({ type: "VariableDeclarator", id: { type: "Identifier", name: I }, init: { type: "MemberExpression", object: { type: "Identifier", name: "_components" }, property: { type: "Literal", value: T }, computed: !0, optional: !1 } }); v && b.push({ type: "VariableDeclarator", id: v, init: E }), b.length > 0 && x.push({ type: "VariableDeclaration", kind: "const", declarations: b }) } let S; for (S in y.references) if (Object.hasOwn(y.references, S)) { const E = S.split("."); let v = 0; for (; ++v < E.length;) { const T = E.slice(0, v).join("."); Object.hasOwn(y.references, T) || (y.references[T] = { component: !1, node: y.references[S].node }) } } const C = Object.keys(y.references).sort(); let O = -1; for (; ++O < C.length;) { const E = C[O], v = y.references[E], T = Wr(ns(v.node)), I = [{ type: "Literal", value: E }, { type: "Literal", value: v.component }]; u = !0, e && T && I.push({ type: "Literal", value: T }), x.push({ type: "IfStatement", test: { type: "UnaryExpression", operator: "!", prefix: !0, argument: Ls(E.split(".")) }, consequent: { type: "ExpressionStatement", expression: { type: "CallExpression", callee: { type: "Identifier", name: "_missingMdxReference" }, arguments: I, optional: !1 } }, alternate: void 0 }) } x.length > 0 && (d.body.type !== "BlockStatement" && (d.body = { type: "BlockStatement", body: [{ type: "ReturnStatement", argument: d.body }] }), d.body.body.unshift(...x)), o.pop() } } }), l && n && i.body.unshift(Ade(n, t)), u) { const d = [{ type: "Literal", value: "Expected " }, { type: "ConditionalExpression", test: { type: "Identifier", name: "component" }, consequent: { type: "Literal", value: "component" }, alternate: { type: "Literal", value: "object" } }, { type: "Literal", value: " `" }, { type: "Identifier", name: "id" }, { type: "Literal", value: "` to be defined: you likely forgot to import, pass, or provide it." }], h = [{ type: "Identifier", name: "id" }, { type: "Identifier", name: "component" }]; e && (d.push({ type: "ConditionalExpression", test: { type: "Identifier", name: "place" }, consequent: UC([{ type: "Literal", value: "\nIt’s referenced in your code at `" }, { type: "Identifier", name: "place" }, { type: "Literal", value: (s.path ? "` in `" + s.path : "") + "`" }]), alternate: { type: "Literal", value: "" } }), h.push({ type: "Identifier", name: "place" })), i.body.push({ type: "FunctionDeclaration", id: { type: "Identifier", name: "_missingMdxReference" }, generator: !1, async: !1, params: h, body: { type: "BlockStatement", body: [{ type: "ThrowStatement", argument: { type: "NewExpression", callee: { type: "Identifier", name: "Error" }, arguments: [UC(d)] } }] } }) } t === "function-body" && i.body.unshift({ type: "ExpressionStatement", expression: { type: "Literal", value: "use strict" }, directive: "use strict" }) } } function Ade(r, e) { const t = [{ type: "ImportSpecifier", imported: { type: "Identifier", name: "useMDXComponents" }, local: { type: "Identifier", name: "_provideComponents" } }]; return e === "function-body" ? { type: "VariableDeclaration", kind: "const", declarations: $b(t, Ls(["arguments", 0])) } : { type: "ImportDeclaration", specifiers: t, source: { type: "Literal", value: r } } } function Qa(r, e) { return !!(r && "id" in r && r.id && r.id.name === e) } function lf(r, e) { let t = r.length; for (; t--;)if (r[t].defined.includes(e)) return !0; return !1 } function Nde() { return function (r) { zh(r, "raw", function (e, t, n) { if (n && typeof t == "number") return n.children.splice(t, 1), t }) } } const Fde = /\s+/g, $de = /[\t\n\v\f\r ]+/g; function Lde(r, e) { e ? typeof e == "string" && (e = { style: e }) : e = {}; const t = e.preserveLineEndings ? Mde : jde; return String(r).replace(e.style === "html" ? $de : Fde, e.trim ? Vde(t) : t) } function Mde(r) { const e = /\r?\n|\r/.exec(r); return e ? e[0] : " " } function jde() { return " " } function Vde(r) { return e; function e(t, n, i) { return n === 0 || n + t.length === i.length ? "" : r(t) } } function Bde() { return function (r) { zh(r, function (e, t, n) { let i = -1, s = !0, a = !1; if (n && typeof t == "number" && e.type === "paragraph") { const o = e.children; for (; ++i < o.length;) { const l = o[i]; if (l.type === "mdxJsxTextElement" || l.type === "mdxTextExpression") a = !0; else if (!(l.type === "text" && Lde(l.value, { style: "html", trim: !0 }) === "")) { s = !1; break } } if (s && a) { i = -1; const l = []; for (; ++i < o.length;) { const u = o[i]; u.type === "mdxJsxTextElement" && (u.type = "mdxJsxFlowElement"), u.type === "mdxTextExpression" && (u.type = "mdxFlowExpression"), u.type === "text" && /^[\t\r\n ]+$/.test(String(u.value)) || l.push(u) } return n.children.splice(t, 1, ...l), t } } if (e.type === "mdxJsxFlowElement" || e.type === "mdxJsxTextElement") { const o = e.data || (e.data = {}); o._mdxExplicitJsx = !0 } (e.type === "mdxFlowExpression" || e.type === "mdxTextExpression" || e.type === "mdxjsEsm") && e.data && e.data.estree && bo(e.data.estree, { enter(o) { if (o.type === "JSXElement") { const l = o.data || (o.data = {}); l._mdxExplicitJsx = !0 } } }) }) } } const zde = ["mdxFlowExpression", "mdxJsxFlowElement", "mdxJsxTextElement", "mdxTextExpression", "mdxjsEsm"]; let WC = !1; function aI(r) { const e = r || {}; e.format, (e.jsxRuntime === "classic" || e.pragma || e.pragmaFrag || e.pragmaImportSource) && !WC && (WC = !0, console.warn("Unexpected deprecated option `jsxRuntime: 'classic'`, `pragma`, `pragmaFrag`, or `pragmaImportSource`; see <https://mdxjs.com/migrating/v3/> on how to migrate")); const t = Cde().use(Cue); e.format !== "md" && t.use(Vce); const n = e.remarkRehypeOptions || {}; return t.use(Bde).use(e.remarkPlugins || []).use(mde, { ...n, allowDangerousHtml: !0, passThrough: [...n.passThrough || [], ...zde] }).use(e.rehypePlugins || []), e.format === "md" && t.use(Nde), t.use(goe, e).use(Pde, e).use(Dde, e), e.jsx || t.use(Lse, e).use(Ode, e), t.use(uae).use(dae, e).use(e.recmaPlugins || []), t } function oI(r, e) { const { file: t, options: n } = lT(r, e); return aI(n).process(t) } function Hde(r, e) { const { file: t, options: n } = lT(r, e); return aI(n).processSync(t) } function lI(r) { const { Fragment: e, baseUrl: t, development: n, jsx: i, jsxDEV: s, jsxs: a, useMDXComponents: o, ...l } = r || {}; if (!e) throw new Error("Expected `Fragment` given to `evaluate`"); if (n) { if (!s) throw new Error("Expected `jsxDEV` given to `evaluate`") } else { if (!i) throw new Error("Expected `jsx` given to `evaluate`"); if (!a) throw new Error("Expected `jsxs` given to `evaluate`") } return { compiletime: { ...l, development: n, outputFormat: "function-body", providerImportSource: o ? "#" : void 0 }, runtime: { Fragment: e, baseUrl: t, jsx: i, jsxDEV: s, jsxs: a, useMDXComponents: o } } } const Kde = Object.getPrototypeOf(cI).constructor; async function cI(r, e) { return new Kde(String(r))(e) } function Ude(r, e) { return new Function(String(r))(e) } async function Wde(r, e) { const { compiletime: t, runtime: n } = lI(e); return cI(await oI(r, t), n) } function Gde(r, e) { const { compiletime: t, runtime: n } = lI(e); return Ude(Hde(r, t), n) } function Yde(r) { if (typeof r != "string") throw new TypeError("Expected a string"); return r.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d") } function Xde(r, e, t) { const i = Vh(t.ignore || []), s = qde(e); let a = -1; for (; ++a < s.length;)rI(r, "text", o); function o(u, d) { let h = -1, g; for (; ++h < d.length;) { const m = d[h], b = g ? g.children : void 0; if (i(m, b ? b.indexOf(m) : void 0, g)) return; g = m } if (g) return l(u, d) } function l(u, d) { const h = d[d.length - 1], g = s[a][0], m = s[a][1]; let b = 0; const w = h.children.indexOf(u); let x = !1, S = []; g.lastIndex = 0; let C = g.exec(u.value); for (; C;) { const O = C.index, E = { index: C.index, input: C.input, stack: [...d, u] }; let v = m(...C, E); if (typeof v == "string" && (v = v.length > 0 ? { type: "text", value: v } : void 0), v === !1 ? g.lastIndex = O + 1 : (b !== O && S.push({ type: "text", value: u.value.slice(b, O) }), Array.isArray(v) ? S.push(...v) : v && S.push(v), b = O + C[0].length, x = !0), !g.global) break; C = g.exec(u.value) } return x ? (b < u.value.length && S.push({ type: "text", value: u.value.slice(b) }), h.children.splice(w, 1, ...S)) : S = [u], w + S.length } } function qde(r) { const e = []; if (!Array.isArray(r)) throw new TypeError("Expected find and replace tuple or list of tuples"); const t = !r[0] || Array.isArray(r[0]) ? r : [r]; let n = -1; for (; ++n < t.length;) { const i = t[n]; e.push([Zde(i[0]), Jde(i[1])]) } return e } function Zde(r) { return typeof r == "string" ? new RegExp(Yde(r), "g") : r } function Jde(r) { return typeof r == "function" ? r : function () { return r } } const cf = "phrasing", uf = ["autolink", "link", "image", "label"]; function Qde() { return { transforms: [ahe], enter: { literalAutolink: the, literalAutolinkEmail: df, literalAutolinkHttp: df, literalAutolinkWww: df }, exit: { literalAutolink: she, literalAutolinkEmail: ihe, literalAutolinkHttp: nhe, literalAutolinkWww: rhe } } } function ehe() { return { unsafe: [{ character: "@", before: "[+\\-.\\w]", after: "[\\-.\\w]", inConstruct: cf, notInConstruct: uf }, { character: ".", before: "[Ww]", after: "[\\-.\\w]", inConstruct: cf, notInConstruct: uf }, { character: ":", before: "[ps]", after: "\\/", inConstruct: cf, notInConstruct: uf }] } } function the(r) { this.enter({ type: "link", title: null, url: "", children: [] }, r) } function df(r) { this.config.enter.autolinkProtocol.call(this, r) } function nhe(r) { this.config.exit.autolinkProtocol.call(this, r) } function rhe(r) { this.config.exit.data.call(this, r); const e = this.stack[this.stack.length - 1]; e.type, e.url = "http://" + this.sliceSerialize(r) } function ihe(r) { this.config.exit.autolinkEmail.call(this, r) } function she(r) { this.exit(r) } function ahe(r) { Xde(r, [[/(https?:\/\/|www(?=\.))([-.\w]+)([^ \t\r\n]*)/gi, ohe], [new RegExp("(?<=^|\\s|\\p{P}|\\p{S})([-.\\w+]+)@([-\\w]+(?:\\.[-\\w]+)+)", "gu"), lhe]], { ignore: ["link", "linkReference"] }) } function ohe(r, e, t, n, i) { let s = ""; if (!uI(i) || (/^w/i.test(e) && (t = e + t, e = "", s = "http://"), !che(t))) return !1; const a = uhe(t + n); if (!a[0]) return !1; const o = { type: "link", title: null, url: s + e + a[0], children: [{ type: "text", value: e + a[0] }] }; return a[1] ? [o, { type: "text", value: a[1] }] : o } function lhe(r, e, t, n) { return !uI(n, !0) || /[-\d_]$/.test(t) ? !1 : { type: "link", title: null, url: "mailto:" + e + "@" + t, children: [{ type: "text", value: e + "@" + t }] } } function che(r) { const e = r.split("."); return !(e.length < 2 || e[e.length - 1] && (/_/.test(e[e.length - 1]) || !/[a-zA-Z\d]/.test(e[e.length - 1])) || e[e.length - 2] && (/_/.test(e[e.length - 2]) || !/[a-zA-Z\d]/.test(e[e.length - 2]))) } function uhe(r) { const e = /[!"&'),.:;<>?\]}]+$/.exec(r); if (!e) return [r, void 0]; r = r.slice(0, e.index); let t = e[0], n = t.indexOf(")"); const i = wd(r, "("); let s = wd(r, ")"); for (; n !== -1 && i > s;)r += t.slice(0, n + 1), t = t.slice(n + 1), n = t.indexOf(")"), s++; return [r, t] } function uI(r, e) { const t = r.input.charCodeAt(r.index - 1); return (r.index === 0 || sr(t) || Lh(t)) && (!e || t !== 47) } dI.peek = whe; function dhe() { return { enter: { gfmFootnoteDefinition: phe, gfmFootnoteDefinitionLabelString: fhe, gfmFootnoteCall: yhe, gfmFootnoteCallString: bhe }, exit: { gfmFootnoteDefinition: mhe, gfmFootnoteDefinitionLabelString: ghe, gfmFootnoteCall: xhe, gfmFootnoteCallString: vhe } } } function hhe() { return { unsafe: [{ character: "[", inConstruct: ["phrasing", "label", "reference"] }], handlers: { footnoteDefinition: Che, footnoteReference: dI } } } function phe(r) { this.enter({ type: "footnoteDefinition", identifier: "", label: "", children: [] }, r) } function fhe() { this.buffer() } function ghe(r) { const e = this.resume(), t = this.stack[this.stack.length - 1]; t.type, t.label = e, t.identifier = mi(this.sliceSerialize(r)).toLowerCase() } function mhe(r) { this.exit(r) } function yhe(r) { this.enter({ type: "footnoteReference", identifier: "", label: "" }, r) } function bhe() { this.buffer() } function vhe(r) { const e = this.resume(), t = this.stack[this.stack.length - 1]; t.type, t.label = e, t.identifier = mi(this.sliceSerialize(r)).toLowerCase() } function xhe(r) { this.exit(r) } function dI(r, e, t, n) { const i = t.createTracker(n); let s = i.move("[^"); const a = t.enter("footnoteReference"), o = t.enter("reference"); return s += i.move(t.safe(t.associationId(r), { ...i.current(), before: s, after: "]" })), o(), a(), s += i.move("]"), s } function whe() { return "[" } function Che(r, e, t, n) { const i = t.createTracker(n); let s = i.move("[^"); const a = t.enter("footnoteDefinition"), o = t.enter("label"); return s += i.move(t.safe(t.associationId(r), { ...i.current(), before: s, after: "]" })), o(), s += i.move("]:" + (r.children && r.children.length > 0 ? " " : "")), i.shift(4), s += i.move(t.indentLines(t.containerFlow(r, i.current()), She)), a(), s } function She(r, e, t) { return e === 0 ? r : (t ? "" : "    ") + r } const Ehe = ["autolink", "destinationLiteral", "destinationRaw", "reference", "titleQuote", "titleApostrophe"]; hI.peek = Phe; function _he() { return { canContainEols: ["delete"], enter: { strikethrough: The }, exit: { strikethrough: Ihe } } } function Ohe() { return { unsafe: [{ character: "~", inConstruct: "phrasing", notInConstruct: Ehe }], handlers: { delete: hI } } } function The(r) { this.enter({ type: "delete", children: [] }, r) } function Ihe(r) { this.exit(r) } function hI(r, e, t, n) { const i = t.createTracker(n), s = t.enter("strikethrough"); let a = i.move("~~"); return a += t.containerPhrasing(r, { ...i.current(), before: a, after: "~" }), a += i.move("~~"), s(), a } function Phe() { return "~" } function khe(r) { return r.length } function Rhe(r, e) {
  const t = e, n = (t.align || []).concat(), i = t.stringLength || khe, s = [], a = [], o = [], l = []; let u = 0, d = -1; for (; ++d < r.length;) { const y = [], w = []; let x = -1; for (r[d].length > u && (u = r[d].length); ++x < r[d].length;) { const S = Dhe(r[d][x]); if (t.alignDelimiters !== !1) { const C = i(S); w[x] = C, (l[x] === void 0 || C > l[x]) && (l[x] = C) } y.push(S) } a[d] = y, o[d] = w } let h = -1; if (typeof n == "object" && "length" in n) for (; ++h < u;)s[h] = GC(n[h]); else { const y = GC(n); for (; ++h < u;)s[h] = y } h = -1; const g = [], m = []; for (; ++h < u;) { const y = s[h]; let w = "", x = ""; y === 99 ? (w = ":", x = ":") : y === 108 ? w = ":" : y === 114 && (x = ":"); let S = t.alignDelimiters === !1 ? 1 : Math.max(1, l[h] - w.length - x.length); const C = w + "-".repeat(S) + x; t.alignDelimiters !== !1 && (S = w.length + S + x.length, S > l[h] && (l[h] = S), m[h] = S), g[h] = C } a.splice(1, 0, g), o.splice(1, 0, m), d = -1; const b = []; for (; ++d < a.length;) { const y = a[d], w = o[d]; h = -1; const x = []; for (; ++h < u;) { const S = y[h] || ""; let C = "", O = ""; if (t.alignDelimiters !== !1) { const E = l[h] - (w[h] || 0), v = s[h]; v === 114 ? C = " ".repeat(E) : v === 99 ? E % 2 ? (C = " ".repeat(E / 2 + .5), O = " ".repeat(E / 2 - .5)) : (C = " ".repeat(E / 2), O = C) : O = " ".repeat(E) } t.delimiterStart !== !1 && !h && x.push("|"), t.padding !== !1 && !(t.alignDelimiters === !1 && S === "") && (t.delimiterStart !== !1 || h) && x.push(" "), t.alignDelimiters !== !1 && x.push(C), x.push(S), t.alignDelimiters !== !1 && x.push(O), t.padding !== !1 && x.push(" "), (t.delimiterEnd !== !1 || h !== u - 1) && x.push("|") } b.push(t.delimiterEnd === !1 ? x.join("").replace(/ +$/, "") : x.join("")) } return b.join(`
`)
} function Dhe(r) { return r == null ? "" : String(r) } function GC(r) { const e = typeof r == "string" ? r.codePointAt(0) : 0; return e === 67 || e === 99 ? 99 : e === 76 || e === 108 ? 108 : e === 82 || e === 114 ? 114 : 0 } function Ahe(r, e, t, n) { const i = t.enter("blockquote"), s = t.createTracker(n); s.move("> "), s.shift(2); const a = t.indentLines(t.containerFlow(r, s.current()), Nhe); return i(), a } function Nhe(r, e, t) { return ">" + (t ? "" : " ") + r } function Fhe(r, e) { return YC(r, e.inConstruct, !0) && !YC(r, e.notInConstruct, !1) } function YC(r, e, t) { if (typeof e == "string" && (e = [e]), !e || e.length === 0) return t; let n = -1; for (; ++n < e.length;)if (r.includes(e[n])) return !0; return !1 } function XC(r, e, t, n) {
  let i = -1; for (; ++i < t.unsafe.length;)if (t.unsafe[i].character === `
`&& Fhe(t.stack, t.unsafe[i])) return /[ \t]/.test(n.before) ? "" : " "; return `\\
`} function $he(r, e) { const t = String(r); let n = t.indexOf(e), i = n, s = 0, a = 0; if (typeof e != "string") throw new TypeError("Expected substring"); for (; n !== -1;)n === i ? ++s > a && (a = s) : s = 1, i = n + e.length, n = t.indexOf(e, i); return a } function Lhe(r, e) { return !!(e.options.fences === !1 && r.value && !r.lang && /[^ \r\n]/.test(r.value) && !/^[\t ]*(?:[\r\n]|$)|(?:^|[\r\n])[\t ]*$/.test(r.value)) } function Mhe(r) { const e = r.options.fence || "`"; if (e !== "`" && e !== "~") throw new Error("Cannot serialize code with `" + e + "` for `options.fence`, expected `` ` `` or `~`"); return e } function jhe(r, e, t, n) {
  const i = Mhe(t), s = r.value || "", a = i === "`" ? "GraveAccent" : "Tilde"; if (Lhe(r, t)) { const h = t.enter("codeIndented"), g = t.indentLines(s, Vhe); return h(), g } const o = t.createTracker(n), l = i.repeat(Math.max($he(s, i) + 1, 3)), u = t.enter("codeFenced"); let d = o.move(l); if (r.lang) { const h = t.enter(`codeFencedLang${a}`); d += o.move(t.safe(r.lang, { before: d, after: " ", encode: ["`"], ...o.current() })), h() } if (r.lang && r.meta) {
    const h = t.enter(`codeFencedMeta${a}`); d += o.move(" "), d += o.move(t.safe(r.meta, {
      before: d, after: `
`, encode: ["`"], ...o.current()
    })), h()
  } return d += o.move(`
`), s && (d += o.move(s + `
`)), d += o.move(l), u(), d
} function Vhe(r, e, t) { return (t ? "" : "    ") + r } function Lb(r) { const e = r.options.quote || '"'; if (e !== '"' && e !== "'") throw new Error("Cannot serialize title with `" + e + "` for `options.quote`, expected `\"`, or `'`"); return e } function Bhe(r, e, t, n) {
  const i = Lb(t), s = i === '"' ? "Quote" : "Apostrophe", a = t.enter("definition"); let o = t.enter("label"); const l = t.createTracker(n); let u = l.move("["); return u += l.move(t.safe(t.associationId(r), { before: u, after: "]", ...l.current() })), u += l.move("]: "), o(), !r.url || /[\0- \u007F]/.test(r.url) ? (o = t.enter("destinationLiteral"), u += l.move("<"), u += l.move(t.safe(r.url, { before: u, after: ">", ...l.current() })), u += l.move(">")) : (o = t.enter("destinationRaw"), u += l.move(t.safe(r.url, {
    before: u, after: r.title ? " " : `
`, ...l.current()
  }))), o(), r.title && (o = t.enter(`title${s}`), u += l.move(" " + i), u += l.move(t.safe(r.title, { before: u, after: i, ...l.current() })), u += l.move(i), o()), a(), u
} function zhe(r) { const e = r.options.emphasis || "*"; if (e !== "*" && e !== "_") throw new Error("Cannot serialize emphasis with `" + e + "` for `options.emphasis`, expected `*`, or `_`"); return e } function ic(r) { return "&#x" + r.toString(16).toUpperCase() + ";" } function Od(r, e, t) { const n = Ao(r), i = Ao(e); return n === void 0 ? i === void 0 ? t === "_" ? { inside: !0, outside: !0 } : { inside: !1, outside: !1 } : i === 1 ? { inside: !0, outside: !0 } : { inside: !1, outside: !0 } : n === 1 ? i === void 0 ? { inside: !1, outside: !1 } : i === 1 ? { inside: !0, outside: !0 } : { inside: !1, outside: !1 } : i === void 0 ? { inside: !1, outside: !1 } : i === 1 ? { inside: !0, outside: !1 } : { inside: !1, outside: !1 } } pI.peek = Hhe; function pI(r, e, t, n) { const i = zhe(t), s = t.enter("emphasis"), a = t.createTracker(n), o = a.move(i); let l = a.move(t.containerPhrasing(r, { after: i, before: o, ...a.current() })); const u = l.charCodeAt(0), d = Od(n.before.charCodeAt(n.before.length - 1), u, i); d.inside && (l = ic(u) + l.slice(1)); const h = l.charCodeAt(l.length - 1), g = Od(n.after.charCodeAt(0), h, i); g.inside && (l = l.slice(0, -1) + ic(h)); const m = a.move(i); return s(), t.attentionEncodeSurroundingInfo = { after: g.outside, before: d.outside }, o + l + m } function Hhe(r, e, t) { return t.options.emphasis || "*" } function Khe(r, e) { let t = !1; return zh(r, function (n) { if ("value" in n && /\r?\n|\r/.test(n.value) || n.type === "break") return t = !0, im }), !!((!r.depth || r.depth < 3) && kb(r) && (e.options.setext || t)) } function Uhe(r, e, t, n) {
  const i = Math.max(Math.min(6, r.depth || 1), 1), s = t.createTracker(n); if (Khe(r, t)) {
    const d = t.enter("headingSetext"), h = t.enter("phrasing"), g = t.containerPhrasing(r, {
      ...s.current(), before: `
`, after: `
`}); return h(), d(), g + `
`+ (i === 1 ? "=" : "-").repeat(g.length - (Math.max(g.lastIndexOf("\r"), g.lastIndexOf(`
`)) + 1))
  } const a = "#".repeat(i), o = t.enter("headingAtx"), l = t.enter("phrasing"); s.move(a + " "); let u = t.containerPhrasing(r, {
    before: "# ", after: `
`, ...s.current()
  }); return /^[\t ]/.test(u) && (u = ic(u.charCodeAt(0)) + u.slice(1)), u = u ? a + " " + u : a, t.options.closeAtx && (u += " " + a), l(), o(), u
} fI.peek = Whe; function fI(r) { return r.value || "" } function Whe() { return "<" } gI.peek = Ghe; function gI(r, e, t, n) { const i = Lb(t), s = i === '"' ? "Quote" : "Apostrophe", a = t.enter("image"); let o = t.enter("label"); const l = t.createTracker(n); let u = l.move("!["); return u += l.move(t.safe(r.alt, { before: u, after: "]", ...l.current() })), u += l.move("]("), o(), !r.url && r.title || /[\0- \u007F]/.test(r.url) ? (o = t.enter("destinationLiteral"), u += l.move("<"), u += l.move(t.safe(r.url, { before: u, after: ">", ...l.current() })), u += l.move(">")) : (o = t.enter("destinationRaw"), u += l.move(t.safe(r.url, { before: u, after: r.title ? " " : ")", ...l.current() }))), o(), r.title && (o = t.enter(`title${s}`), u += l.move(" " + i), u += l.move(t.safe(r.title, { before: u, after: i, ...l.current() })), u += l.move(i), o()), u += l.move(")"), a(), u } function Ghe() { return "!" } mI.peek = Yhe; function mI(r, e, t, n) { const i = r.referenceType, s = t.enter("imageReference"); let a = t.enter("label"); const o = t.createTracker(n); let l = o.move("!["); const u = t.safe(r.alt, { before: l, after: "]", ...o.current() }); l += o.move(u + "]["), a(); const d = t.stack; t.stack = [], a = t.enter("reference"); const h = t.safe(t.associationId(r), { before: l, after: "]", ...o.current() }); return a(), t.stack = d, s(), i === "full" || !u || u !== h ? l += o.move(h + "]") : i === "shortcut" ? l = l.slice(0, -1) : l += o.move("]"), l } function Yhe() { return "!" } yI.peek = Xhe; function yI(r, e, t) { let n = r.value || "", i = "`", s = -1; for (; new RegExp("(^|[^`])" + i + "([^`]|$)").test(n);)i += "`"; for (/[^ \r\n]/.test(n) && (/^[ \r\n]/.test(n) && /[ \r\n]$/.test(n) || /^`|`$/.test(n)) && (n = " " + n + " "); ++s < t.unsafe.length;) { const a = t.unsafe[s], o = t.compilePattern(a); let l; if (a.atBreak) for (; l = o.exec(n);) { let u = l.index; n.charCodeAt(u) === 10 && n.charCodeAt(u - 1) === 13 && u--, n = n.slice(0, u) + " " + n.slice(l.index + 1) } } return i + n + i } function Xhe() { return "`" } function bI(r, e) { const t = kb(r); return !!(!e.options.resourceLink && r.url && !r.title && r.children && r.children.length === 1 && r.children[0].type === "text" && (t === r.url || "mailto:" + t === r.url) && /^[a-z][a-z+.-]+:/i.test(r.url) && !/[\0- <>\u007F]/.test(r.url)) } vI.peek = qhe; function vI(r, e, t, n) { const i = Lb(t), s = i === '"' ? "Quote" : "Apostrophe", a = t.createTracker(n); let o, l; if (bI(r, t)) { const d = t.stack; t.stack = [], o = t.enter("autolink"); let h = a.move("<"); return h += a.move(t.containerPhrasing(r, { before: h, after: ">", ...a.current() })), h += a.move(">"), o(), t.stack = d, h } o = t.enter("link"), l = t.enter("label"); let u = a.move("["); return u += a.move(t.containerPhrasing(r, { before: u, after: "](", ...a.current() })), u += a.move("]("), l(), !r.url && r.title || /[\0- \u007F]/.test(r.url) ? (l = t.enter("destinationLiteral"), u += a.move("<"), u += a.move(t.safe(r.url, { before: u, after: ">", ...a.current() })), u += a.move(">")) : (l = t.enter("destinationRaw"), u += a.move(t.safe(r.url, { before: u, after: r.title ? " " : ")", ...a.current() }))), l(), r.title && (l = t.enter(`title${s}`), u += a.move(" " + i), u += a.move(t.safe(r.title, { before: u, after: i, ...a.current() })), u += a.move(i), l()), u += a.move(")"), o(), u } function qhe(r, e, t) { return bI(r, t) ? "<" : "[" } xI.peek = Zhe; function xI(r, e, t, n) { const i = r.referenceType, s = t.enter("linkReference"); let a = t.enter("label"); const o = t.createTracker(n); let l = o.move("["); const u = t.containerPhrasing(r, { before: l, after: "]", ...o.current() }); l += o.move(u + "]["), a(); const d = t.stack; t.stack = [], a = t.enter("reference"); const h = t.safe(t.associationId(r), { before: l, after: "]", ...o.current() }); return a(), t.stack = d, s(), i === "full" || !u || u !== h ? l += o.move(h + "]") : i === "shortcut" ? l = l.slice(0, -1) : l += o.move("]"), l } function Zhe() { return "[" } function Mb(r) { const e = r.options.bullet || "*"; if (e !== "*" && e !== "+" && e !== "-") throw new Error("Cannot serialize items with `" + e + "` for `options.bullet`, expected `*`, `+`, or `-`"); return e } function Jhe(r) { const e = Mb(r), t = r.options.bulletOther; if (!t) return e === "*" ? "-" : "*"; if (t !== "*" && t !== "+" && t !== "-") throw new Error("Cannot serialize items with `" + t + "` for `options.bulletOther`, expected `*`, `+`, or `-`"); if (t === e) throw new Error("Expected `bullet` (`" + e + "`) and `bulletOther` (`" + t + "`) to be different"); return t } function Qhe(r) { const e = r.options.bulletOrdered || "."; if (e !== "." && e !== ")") throw new Error("Cannot serialize items with `" + e + "` for `options.bulletOrdered`, expected `.` or `)`"); return e } function wI(r) { const e = r.options.rule || "*"; if (e !== "*" && e !== "-" && e !== "_") throw new Error("Cannot serialize rules with `" + e + "` for `options.rule`, expected `*`, `-`, or `_`"); return e } function epe(r, e, t, n) { const i = t.enter("list"), s = t.bulletCurrent; let a = r.ordered ? Qhe(t) : Mb(t); const o = r.ordered ? a === "." ? ")" : "." : Jhe(t); let l = e && t.bulletLastUsed ? a === t.bulletLastUsed : !1; if (!r.ordered) { const d = r.children ? r.children[0] : void 0; if ((a === "*" || a === "-") && d && (!d.children || !d.children[0]) && t.stack[t.stack.length - 1] === "list" && t.stack[t.stack.length - 2] === "listItem" && t.stack[t.stack.length - 3] === "list" && t.stack[t.stack.length - 4] === "listItem" && t.indexStack[t.indexStack.length - 1] === 0 && t.indexStack[t.indexStack.length - 2] === 0 && t.indexStack[t.indexStack.length - 3] === 0 && (l = !0), wI(t) === a && d) { let h = -1; for (; ++h < r.children.length;) { const g = r.children[h]; if (g && g.type === "listItem" && g.children && g.children[0] && g.children[0].type === "thematicBreak") { l = !0; break } } } } l && (a = o), t.bulletCurrent = a; const u = t.containerFlow(r, n); return t.bulletLastUsed = a, t.bulletCurrent = s, i(), u } function tpe(r) { const e = r.options.listItemIndent || "one"; if (e !== "tab" && e !== "one" && e !== "mixed") throw new Error("Cannot serialize items with `" + e + "` for `options.listItemIndent`, expected `tab`, `one`, or `mixed`"); return e } function npe(r, e, t, n) { const i = tpe(t); let s = t.bulletCurrent || Mb(t); e && e.type === "list" && e.ordered && (s = (typeof e.start == "number" && e.start > -1 ? e.start : 1) + (t.options.incrementListMarker === !1 ? 0 : e.children.indexOf(r)) + s); let a = s.length + 1; (i === "tab" || i === "mixed" && (e && e.type === "list" && e.spread || r.spread)) && (a = Math.ceil(a / 4) * 4); const o = t.createTracker(n); o.move(s + " ".repeat(a - s.length)), o.shift(a); const l = t.enter("listItem"), u = t.indentLines(t.containerFlow(r, o.current()), d); return l(), u; function d(h, g, m) { return g ? (m ? "" : " ".repeat(a)) + h : (m ? s : s + " ".repeat(a - s.length)) + h } } function rpe(r, e, t, n) { const i = t.enter("paragraph"), s = t.enter("phrasing"), a = t.containerPhrasing(r, n); return s(), i(), a } const ipe = Vh(["break", "delete", "emphasis", "footnote", "footnoteReference", "image", "imageReference", "inlineCode", "inlineMath", "link", "linkReference", "mdxJsxTextElement", "mdxTextExpression", "strong", "text", "textDirective"]); function spe(r, e, t, n) { return (r.children.some(function (a) { return ipe(a) }) ? t.containerPhrasing : t.containerFlow).call(t, r, n) } function ape(r) { const e = r.options.strong || "*"; if (e !== "*" && e !== "_") throw new Error("Cannot serialize strong with `" + e + "` for `options.strong`, expected `*`, or `_`"); return e } CI.peek = ope; function CI(r, e, t, n) { const i = ape(t), s = t.enter("strong"), a = t.createTracker(n), o = a.move(i + i); let l = a.move(t.containerPhrasing(r, { after: i, before: o, ...a.current() })); const u = l.charCodeAt(0), d = Od(n.before.charCodeAt(n.before.length - 1), u, i); d.inside && (l = ic(u) + l.slice(1)); const h = l.charCodeAt(l.length - 1), g = Od(n.after.charCodeAt(0), h, i); g.inside && (l = l.slice(0, -1) + ic(h)); const m = a.move(i + i); return s(), t.attentionEncodeSurroundingInfo = { after: g.outside, before: d.outside }, o + l + m } function ope(r, e, t) { return t.options.strong || "*" } function lpe(r, e, t, n) { return t.safe(r.value, n) } function cpe(r) { const e = r.options.ruleRepetition || 3; if (e < 3) throw new Error("Cannot serialize rules with repetition `" + e + "` for `options.ruleRepetition`, expected `3` or more"); return e } function upe(r, e, t) { const n = (wI(t) + (t.options.ruleSpaces ? " " : "")).repeat(cpe(t)); return t.options.ruleSpaces ? n.slice(0, -1) : n } const SI = { blockquote: Ahe, break: XC, code: jhe, definition: Bhe, emphasis: pI, hardBreak: XC, heading: Uhe, html: fI, image: gI, imageReference: mI, inlineCode: yI, link: vI, linkReference: xI, list: epe, listItem: npe, paragraph: rpe, root: spe, strong: CI, text: lpe, thematicBreak: upe }; function dpe() { return { enter: { table: hpe, tableData: qC, tableHeader: qC, tableRow: fpe }, exit: { codeText: gpe, table: ppe, tableData: hf, tableHeader: hf, tableRow: hf } } } function hpe(r) { const e = r._align; this.enter({ type: "table", align: e.map(function (t) { return t === "none" ? null : t }), children: [] }, r), this.data.inTable = !0 } function ppe(r) { this.exit(r), this.data.inTable = void 0 } function fpe(r) { this.enter({ type: "tableRow", children: [] }, r) } function hf(r) { this.exit(r) } function qC(r) { this.enter({ type: "tableCell", children: [] }, r) } function gpe(r) { let e = this.resume(); this.data.inTable && (e = e.replace(/\\([\\|])/g, mpe)); const t = this.stack[this.stack.length - 1]; t.type, t.value = e, this.exit(r) } function mpe(r, e) { return e === "|" ? e : r } function ype(r) {
  const e = r, t = e.tableCellPadding, n = e.tablePipeAlign, i = e.stringLength, s = t ? " " : "|"; return {
    unsafe: [{ character: "\r", inConstruct: "tableCell" }, {
      character: `
`, inConstruct: "tableCell"
    }, { atBreak: !0, character: "|", after: "[	 :-]" }, { character: "|", inConstruct: "tableCell" }, { atBreak: !0, character: ":", after: "-" }, { atBreak: !0, character: "-", after: "[:|-]" }], handlers: { inlineCode: g, table: a, tableCell: l, tableRow: o }
  }; function a(m, b, y, w) { return u(d(m, y, w), m.align) } function o(m, b, y, w) {
    const x = h(m, y, w), S = u([x]); return S.slice(0, S.indexOf(`
`))
  } function l(m, b, y, w) { const x = y.enter("tableCell"), S = y.enter("phrasing"), C = y.containerPhrasing(m, { ...w, before: s, after: s }); return S(), x(), C } function u(m, b) { return Rhe(m, { align: b, alignDelimiters: n, padding: t, stringLength: i }) } function d(m, b, y) { const w = m.children; let x = -1; const S = [], C = b.enter("table"); for (; ++x < w.length;)S[x] = h(w[x], b, y); return C(), S } function h(m, b, y) { const w = m.children; let x = -1; const S = [], C = b.enter("tableRow"); for (; ++x < w.length;)S[x] = l(w[x], m, b, y); return C(), S } function g(m, b, y) { let w = SI.inlineCode(m, b, y); return y.stack.includes("tableCell") && (w = w.replace(/\|/g, "\\$&")), w }
} function bpe() { return { exit: { taskListCheckValueChecked: ZC, taskListCheckValueUnchecked: ZC, paragraph: xpe } } } function vpe() { return { unsafe: [{ atBreak: !0, character: "-", after: "[:|-]" }], handlers: { listItem: wpe } } } function ZC(r) { const e = this.stack[this.stack.length - 2]; e.type, e.checked = r.type === "taskListCheckValueChecked" } function xpe(r) { const e = this.stack[this.stack.length - 2]; if (e && e.type === "listItem" && typeof e.checked == "boolean") { const t = this.stack[this.stack.length - 1]; t.type; const n = t.children[0]; if (n && n.type === "text") { const i = e.children; let s = -1, a; for (; ++s < i.length;) { const o = i[s]; if (o.type === "paragraph") { a = o; break } } a === t && (n.value = n.value.slice(1), n.value.length === 0 ? t.children.shift() : t.position && n.position && typeof n.position.start.offset == "number" && (n.position.start.column++, n.position.start.offset++, t.position.start = Object.assign({}, n.position.start))) } } this.exit(r) } function wpe(r, e, t, n) { const i = r.children[0], s = typeof r.checked == "boolean" && i && i.type === "paragraph", a = "[" + (r.checked ? "x" : " ") + "] ", o = t.createTracker(n); s && o.move(a); let l = SI.listItem(r, e, t, { ...n, ...o.current() }); return s && (l = l.replace(/^(?:[*+-]|\d+\.)([\r\n]| {1,3})/, u)), l; function u(d) { return d + a } } function Cpe() { return [Qde(), dhe(), _he(), dpe(), bpe()] } function Spe(r) { return { extensions: [ehe(), hhe(), Ohe(), ype(r), vpe()] } } const Epe = { tokenize: kpe, partial: !0 }, EI = { tokenize: Rpe, partial: !0 }, _I = { tokenize: Dpe, partial: !0 }, OI = { tokenize: Ape, partial: !0 }, _pe = { tokenize: Npe, partial: !0 }, TI = { name: "wwwAutolink", tokenize: Ipe, previous: PI }, II = { name: "protocolAutolink", tokenize: Ppe, previous: kI }, hs = { name: "emailAutolink", tokenize: Tpe, previous: RI }, Xi = {}; function Ope() { return { text: Xi } } let Zs = 48; for (; Zs < 123;)Xi[Zs] = hs, Zs++, Zs === 58 ? Zs = 65 : Zs === 91 && (Zs = 97); Xi[43] = hs; Xi[45] = hs; Xi[46] = hs; Xi[95] = hs; Xi[72] = [hs, II]; Xi[104] = [hs, II]; Xi[87] = [hs, TI]; Xi[119] = [hs, TI]; function Tpe(r, e, t) { const n = this; let i, s; return a; function a(h) { return !om(h) || !RI.call(n, n.previous) || jb(n.events) ? t(h) : (r.enter("literalAutolink"), r.enter("literalAutolinkEmail"), o(h)) } function o(h) { return om(h) ? (r.consume(h), o) : h === 64 ? (r.consume(h), l) : t(h) } function l(h) { return h === 46 ? r.check(_pe, d, u)(h) : h === 45 || h === 95 || Zn(h) ? (s = !0, r.consume(h), l) : d(h) } function u(h) { return r.consume(h), i = !0, l } function d(h) { return s && i && Xn(n.previous) ? (r.exit("literalAutolinkEmail"), r.exit("literalAutolink"), e(h)) : t(h) } } function Ipe(r, e, t) { const n = this; return i; function i(a) { return a !== 87 && a !== 119 || !PI.call(n, n.previous) || jb(n.events) ? t(a) : (r.enter("literalAutolink"), r.enter("literalAutolinkWww"), r.check(Epe, r.attempt(EI, r.attempt(_I, s), t), t)(a)) } function s(a) { return r.exit("literalAutolinkWww"), r.exit("literalAutolink"), e(a) } } function Ppe(r, e, t) { const n = this; let i = "", s = !1; return a; function a(h) { return (h === 72 || h === 104) && kI.call(n, n.previous) && !jb(n.events) ? (r.enter("literalAutolink"), r.enter("literalAutolinkHttp"), i += String.fromCodePoint(h), r.consume(h), o) : t(h) } function o(h) { if (Xn(h) && i.length < 5) return i += String.fromCodePoint(h), r.consume(h), o; if (h === 58) { const g = i.toLowerCase(); if (g === "http" || g === "https") return r.consume(h), l } return t(h) } function l(h) { return h === 47 ? (r.consume(h), s ? u : (s = !0, l)) : t(h) } function u(h) { return h === null || Cd(h) || it(h) || sr(h) || Lh(h) ? t(h) : r.attempt(EI, r.attempt(_I, d), t)(h) } function d(h) { return r.exit("literalAutolinkHttp"), r.exit("literalAutolink"), e(h) } } function kpe(r, e, t) { let n = 0; return i; function i(a) { return (a === 87 || a === 119) && n < 3 ? (n++, r.consume(a), i) : a === 46 && n === 3 ? (r.consume(a), s) : t(a) } function s(a) { return a === null ? t(a) : e(a) } } function Rpe(r, e, t) { let n, i, s; return a; function a(u) { return u === 46 || u === 95 ? r.check(OI, l, o)(u) : u === null || it(u) || sr(u) || u !== 45 && Lh(u) ? l(u) : (s = !0, r.consume(u), a) } function o(u) { return u === 95 ? n = !0 : (i = n, n = void 0), r.consume(u), a } function l(u) { return i || n || !s ? t(u) : e(u) } } function Dpe(r, e) { let t = 0, n = 0; return i; function i(a) { return a === 40 ? (t++, r.consume(a), i) : a === 41 && n < t ? s(a) : a === 33 || a === 34 || a === 38 || a === 39 || a === 41 || a === 42 || a === 44 || a === 46 || a === 58 || a === 59 || a === 60 || a === 63 || a === 93 || a === 95 || a === 126 ? r.check(OI, e, s)(a) : a === null || it(a) || sr(a) ? e(a) : (r.consume(a), i) } function s(a) { return a === 41 && n++, r.consume(a), i } } function Ape(r, e, t) { return n; function n(o) { return o === 33 || o === 34 || o === 39 || o === 41 || o === 42 || o === 44 || o === 46 || o === 58 || o === 59 || o === 63 || o === 95 || o === 126 ? (r.consume(o), n) : o === 38 ? (r.consume(o), s) : o === 93 ? (r.consume(o), i) : o === 60 || o === null || it(o) || sr(o) ? e(o) : t(o) } function i(o) { return o === null || o === 40 || o === 91 || it(o) || sr(o) ? e(o) : n(o) } function s(o) { return Xn(o) ? a(o) : t(o) } function a(o) { return o === 59 ? (r.consume(o), n) : Xn(o) ? (r.consume(o), a) : t(o) } } function Npe(r, e, t) { return n; function n(s) { return r.consume(s), i } function i(s) { return Zn(s) ? t(s) : e(s) } } function PI(r) { return r === null || r === 40 || r === 42 || r === 95 || r === 91 || r === 93 || r === 126 || it(r) } function kI(r) { return !Xn(r) } function RI(r) { return !(r === 47 || om(r)) } function om(r) { return r === 43 || r === 45 || r === 46 || r === 95 || Zn(r) } function jb(r) { let e = r.length, t = !1; for (; e--;) { const n = r[e][1]; if ((n.type === "labelLink" || n.type === "labelImage") && !n._balanced) { t = !0; break } if (n._gfmAutolinkLiteralWalkedInto) { t = !1; break } } return r.length > 0 && !t && (r[r.length - 1][1]._gfmAutolinkLiteralWalkedInto = !0), t } const Fpe = { tokenize: Hpe, partial: !0 }; function $pe() { return { document: { 91: { name: "gfmFootnoteDefinition", tokenize: Vpe, continuation: { tokenize: Bpe }, exit: zpe } }, text: { 91: { name: "gfmFootnoteCall", tokenize: jpe }, 93: { name: "gfmPotentialFootnoteCall", add: "after", tokenize: Lpe, resolveTo: Mpe } } } } function Lpe(r, e, t) { const n = this; let i = n.events.length; const s = n.parser.gfmFootnotes || (n.parser.gfmFootnotes = []); let a; for (; i--;) { const l = n.events[i][1]; if (l.type === "labelImage") { a = l; break } if (l.type === "gfmFootnoteCall" || l.type === "labelLink" || l.type === "label" || l.type === "image" || l.type === "link") break } return o; function o(l) { if (!a || !a._balanced) return t(l); const u = mi(n.sliceSerialize({ start: a.end, end: n.now() })); return u.codePointAt(0) !== 94 || !s.includes(u.slice(1)) ? t(l) : (r.enter("gfmFootnoteCallLabelMarker"), r.consume(l), r.exit("gfmFootnoteCallLabelMarker"), e(l)) } } function Mpe(r, e) { let t = r.length; for (; t--;)if (r[t][1].type === "labelImage" && r[t][0] === "enter") { r[t][1]; break } r[t + 1][1].type = "data", r[t + 3][1].type = "gfmFootnoteCallLabelMarker"; const n = { type: "gfmFootnoteCall", start: Object.assign({}, r[t + 3][1].start), end: Object.assign({}, r[r.length - 1][1].end) }, i = { type: "gfmFootnoteCallMarker", start: Object.assign({}, r[t + 3][1].end), end: Object.assign({}, r[t + 3][1].end) }; i.end.column++, i.end.offset++, i.end._bufferIndex++; const s = { type: "gfmFootnoteCallString", start: Object.assign({}, i.end), end: Object.assign({}, r[r.length - 1][1].start) }, a = { type: "chunkString", contentType: "string", start: Object.assign({}, s.start), end: Object.assign({}, s.end) }, o = [r[t + 1], r[t + 2], ["enter", n, e], r[t + 3], r[t + 4], ["enter", i, e], ["exit", i, e], ["enter", s, e], ["enter", a, e], ["exit", a, e], ["exit", s, e], r[r.length - 2], r[r.length - 1], ["exit", n, e]]; return r.splice(t, r.length - t + 1, ...o), r } function jpe(r, e, t) { const n = this, i = n.parser.gfmFootnotes || (n.parser.gfmFootnotes = []); let s = 0, a; return o; function o(h) { return r.enter("gfmFootnoteCall"), r.enter("gfmFootnoteCallLabelMarker"), r.consume(h), r.exit("gfmFootnoteCallLabelMarker"), l } function l(h) { return h !== 94 ? t(h) : (r.enter("gfmFootnoteCallMarker"), r.consume(h), r.exit("gfmFootnoteCallMarker"), r.enter("gfmFootnoteCallString"), r.enter("chunkString").contentType = "string", u) } function u(h) { if (s > 999 || h === 93 && !a || h === null || h === 91 || it(h)) return t(h); if (h === 93) { r.exit("chunkString"); const g = r.exit("gfmFootnoteCallString"); return i.includes(mi(n.sliceSerialize(g))) ? (r.enter("gfmFootnoteCallLabelMarker"), r.consume(h), r.exit("gfmFootnoteCallLabelMarker"), r.exit("gfmFootnoteCall"), e) : t(h) } return it(h) || (a = !0), s++, r.consume(h), h === 92 ? d : u } function d(h) { return h === 91 || h === 92 || h === 93 ? (r.consume(h), s++, u) : u(h) } } function Vpe(r, e, t) { const n = this, i = n.parser.gfmFootnotes || (n.parser.gfmFootnotes = []); let s, a = 0, o; return l; function l(b) { return r.enter("gfmFootnoteDefinition")._container = !0, r.enter("gfmFootnoteDefinitionLabel"), r.enter("gfmFootnoteDefinitionLabelMarker"), r.consume(b), r.exit("gfmFootnoteDefinitionLabelMarker"), u } function u(b) { return b === 94 ? (r.enter("gfmFootnoteDefinitionMarker"), r.consume(b), r.exit("gfmFootnoteDefinitionMarker"), r.enter("gfmFootnoteDefinitionLabelString"), r.enter("chunkString").contentType = "string", d) : t(b) } function d(b) { if (a > 999 || b === 93 && !o || b === null || b === 91 || it(b)) return t(b); if (b === 93) { r.exit("chunkString"); const y = r.exit("gfmFootnoteDefinitionLabelString"); return s = mi(n.sliceSerialize(y)), r.enter("gfmFootnoteDefinitionLabelMarker"), r.consume(b), r.exit("gfmFootnoteDefinitionLabelMarker"), r.exit("gfmFootnoteDefinitionLabel"), g } return it(b) || (o = !0), a++, r.consume(b), b === 92 ? h : d } function h(b) { return b === 91 || b === 92 || b === 93 ? (r.consume(b), a++, d) : d(b) } function g(b) { return b === 58 ? (r.enter("definitionMarker"), r.consume(b), r.exit("definitionMarker"), i.includes(s) || i.push(s), Ge(r, m, "gfmFootnoteDefinitionWhitespace")) : t(b) } function m(b) { return e(b) } } function Bpe(r, e, t) { return r.check(ol, e, r.attempt(Fpe, e, t)) } function zpe(r) { r.exit("gfmFootnoteDefinition") } function Hpe(r, e, t) { const n = this; return Ge(r, i, "gfmFootnoteDefinitionIndent", 5); function i(s) { const a = n.events[n.events.length - 1]; return a && a[1].type === "gfmFootnoteDefinitionIndent" && a[2].sliceSerialize(a[1], !0).length === 4 ? e(s) : t(s) } } function Kpe(r) { let t = r.singleTilde; const n = { name: "strikethrough", tokenize: s, resolveAll: i }; return t == null && (t = !0), { text: { 126: n }, insideSpan: { null: [n] }, attentionMarkers: { null: [126] } }; function i(a, o) { let l = -1; for (; ++l < a.length;)if (a[l][0] === "enter" && a[l][1].type === "strikethroughSequenceTemporary" && a[l][1]._close) { let u = l; for (; u--;)if (a[u][0] === "exit" && a[u][1].type === "strikethroughSequenceTemporary" && a[u][1]._open && a[l][1].end.offset - a[l][1].start.offset === a[u][1].end.offset - a[u][1].start.offset) { a[l][1].type = "strikethroughSequence", a[u][1].type = "strikethroughSequence"; const d = { type: "strikethrough", start: Object.assign({}, a[u][1].start), end: Object.assign({}, a[l][1].end) }, h = { type: "strikethroughText", start: Object.assign({}, a[u][1].end), end: Object.assign({}, a[l][1].start) }, g = [["enter", d, o], ["enter", a[u][1], o], ["exit", a[u][1], o], ["enter", h, o]], m = o.parser.constructs.insideSpan.null; m && Dr(g, g.length, 0, Mh(m, a.slice(u + 1, l), o)), Dr(g, g.length, 0, [["exit", h, o], ["enter", a[l][1], o], ["exit", a[l][1], o], ["exit", d, o]]), Dr(a, u - 1, l - u + 3, g), l = u + g.length - 2; break } } for (l = -1; ++l < a.length;)a[l][1].type === "strikethroughSequenceTemporary" && (a[l][1].type = "data"); return a } function s(a, o, l) { const u = this.previous, d = this.events; let h = 0; return g; function g(b) { return u === 126 && d[d.length - 1][1].type !== "characterEscape" ? l(b) : (a.enter("strikethroughSequenceTemporary"), m(b)) } function m(b) { const y = Ao(u); if (b === 126) return h > 1 ? l(b) : (a.consume(b), h++, m); if (h < 2 && !t) return l(b); const w = a.exit("strikethroughSequenceTemporary"), x = Ao(b); return w._open = !x || x === 2 && !!y, w._close = !y || y === 2 && !!x, o(b) } } } class Upe { constructor() { this.map = [] } add(e, t, n) { Wpe(this, e, t, n) } consume(e) { if (this.map.sort(function (s, a) { return s[0] - a[0] }), this.map.length === 0) return; let t = this.map.length; const n = []; for (; t > 0;)t -= 1, n.push(e.slice(this.map[t][0] + this.map[t][1]), this.map[t][2]), e.length = this.map[t][0]; n.push(e.slice()), e.length = 0; let i = n.pop(); for (; i;) { for (const s of i) e.push(s); i = n.pop() } this.map.length = 0 } } function Wpe(r, e, t, n) { let i = 0; if (!(t === 0 && n.length === 0)) { for (; i < r.map.length;) { if (r.map[i][0] === e) { r.map[i][1] += t, r.map[i][2].push(...n); return } i += 1 } r.map.push([e, t, n]) } } function Gpe(r, e) { let t = !1; const n = []; for (; e < r.length;) { const i = r[e]; if (t) { if (i[0] === "enter") i[1].type === "tableContent" && n.push(r[e + 1][1].type === "tableDelimiterMarker" ? "left" : "none"); else if (i[1].type === "tableContent") { if (r[e - 1][1].type === "tableDelimiterMarker") { const s = n.length - 1; n[s] = n[s] === "left" ? "center" : "right" } } else if (i[1].type === "tableDelimiterRow") break } else i[0] === "enter" && i[1].type === "tableDelimiterRow" && (t = !0); e += 1 } return n } function Ype() { return { flow: { null: { name: "table", tokenize: Xpe, resolveAll: qpe } } } } function Xpe(r, e, t) { const n = this; let i = 0, s = 0, a; return o; function o(P) { let N = n.events.length - 1; for (; N > -1;) { const K = n.events[N][1].type; if (K === "lineEnding" || K === "linePrefix") N--; else break } const M = N > -1 ? n.events[N][1].type : null, B = M === "tableHead" || M === "tableRow" ? v : l; return B === v && n.parser.lazy[n.now().line] ? t(P) : B(P) } function l(P) { return r.enter("tableHead"), r.enter("tableRow"), u(P) } function u(P) { return P === 124 || (a = !0, s += 1), d(P) } function d(P) { return P === null ? t(P) : Ee(P) ? s > 1 ? (s = 0, n.interrupt = !0, r.exit("tableRow"), r.enter("lineEnding"), r.consume(P), r.exit("lineEnding"), m) : t(P) : Ve(P) ? Ge(r, d, "whitespace")(P) : (s += 1, a && (a = !1, i += 1), P === 124 ? (r.enter("tableCellDivider"), r.consume(P), r.exit("tableCellDivider"), a = !0, d) : (r.enter("data"), h(P))) } function h(P) { return P === null || P === 124 || it(P) ? (r.exit("data"), d(P)) : (r.consume(P), P === 92 ? g : h) } function g(P) { return P === 92 || P === 124 ? (r.consume(P), h) : h(P) } function m(P) { return n.interrupt = !1, n.parser.lazy[n.now().line] ? t(P) : (r.enter("tableDelimiterRow"), a = !1, Ve(P) ? Ge(r, b, "linePrefix", n.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(P) : b(P)) } function b(P) { return P === 45 || P === 58 ? w(P) : P === 124 ? (a = !0, r.enter("tableCellDivider"), r.consume(P), r.exit("tableCellDivider"), y) : E(P) } function y(P) { return Ve(P) ? Ge(r, w, "whitespace")(P) : w(P) } function w(P) { return P === 58 ? (s += 1, a = !0, r.enter("tableDelimiterMarker"), r.consume(P), r.exit("tableDelimiterMarker"), x) : P === 45 ? (s += 1, x(P)) : P === null || Ee(P) ? O(P) : E(P) } function x(P) { return P === 45 ? (r.enter("tableDelimiterFiller"), S(P)) : E(P) } function S(P) { return P === 45 ? (r.consume(P), S) : P === 58 ? (a = !0, r.exit("tableDelimiterFiller"), r.enter("tableDelimiterMarker"), r.consume(P), r.exit("tableDelimiterMarker"), C) : (r.exit("tableDelimiterFiller"), C(P)) } function C(P) { return Ve(P) ? Ge(r, O, "whitespace")(P) : O(P) } function O(P) { return P === 124 ? b(P) : P === null || Ee(P) ? !a || i !== s ? E(P) : (r.exit("tableDelimiterRow"), r.exit("tableHead"), e(P)) : E(P) } function E(P) { return t(P) } function v(P) { return r.enter("tableRow"), T(P) } function T(P) { return P === 124 ? (r.enter("tableCellDivider"), r.consume(P), r.exit("tableCellDivider"), T) : P === null || Ee(P) ? (r.exit("tableRow"), e(P)) : Ve(P) ? Ge(r, T, "whitespace")(P) : (r.enter("data"), I(P)) } function I(P) { return P === null || P === 124 || it(P) ? (r.exit("data"), T(P)) : (r.consume(P), P === 92 ? k : I) } function k(P) { return P === 92 || P === 124 ? (r.consume(P), I) : I(P) } } function qpe(r, e) { let t = -1, n = !0, i = 0, s = [0, 0, 0, 0], a = [0, 0, 0, 0], o = !1, l = 0, u, d, h; const g = new Upe; for (; ++t < r.length;) { const m = r[t], b = m[1]; m[0] === "enter" ? b.type === "tableHead" ? (o = !1, l !== 0 && (JC(g, e, l, u, d), d = void 0, l = 0), u = { type: "table", start: Object.assign({}, b.start), end: Object.assign({}, b.end) }, g.add(t, 0, [["enter", u, e]])) : b.type === "tableRow" || b.type === "tableDelimiterRow" ? (n = !0, h = void 0, s = [0, 0, 0, 0], a = [0, t + 1, 0, 0], o && (o = !1, d = { type: "tableBody", start: Object.assign({}, b.start), end: Object.assign({}, b.end) }, g.add(t, 0, [["enter", d, e]])), i = b.type === "tableDelimiterRow" ? 2 : d ? 3 : 1) : i && (b.type === "data" || b.type === "tableDelimiterMarker" || b.type === "tableDelimiterFiller") ? (n = !1, a[2] === 0 && (s[1] !== 0 && (a[0] = a[1], h = Cu(g, e, s, i, void 0, h), s = [0, 0, 0, 0]), a[2] = t)) : b.type === "tableCellDivider" && (n ? n = !1 : (s[1] !== 0 && (a[0] = a[1], h = Cu(g, e, s, i, void 0, h)), s = a, a = [s[1], t, 0, 0])) : b.type === "tableHead" ? (o = !0, l = t) : b.type === "tableRow" || b.type === "tableDelimiterRow" ? (l = t, s[1] !== 0 ? (a[0] = a[1], h = Cu(g, e, s, i, t, h)) : a[1] !== 0 && (h = Cu(g, e, a, i, t, h)), i = 0) : i && (b.type === "data" || b.type === "tableDelimiterMarker" || b.type === "tableDelimiterFiller") && (a[3] = t) } for (l !== 0 && JC(g, e, l, u, d), g.consume(e.events), t = -1; ++t < e.events.length;) { const m = e.events[t]; m[0] === "enter" && m[1].type === "table" && (m[1]._align = Gpe(e.events, t)) } return r } function Cu(r, e, t, n, i, s) { const a = n === 1 ? "tableHeader" : n === 2 ? "tableDelimiter" : "tableData", o = "tableContent"; t[0] !== 0 && (s.end = Object.assign({}, no(e.events, t[0])), r.add(t[0], 0, [["exit", s, e]])); const l = no(e.events, t[1]); if (s = { type: a, start: Object.assign({}, l), end: Object.assign({}, l) }, r.add(t[1], 0, [["enter", s, e]]), t[2] !== 0) { const u = no(e.events, t[2]), d = no(e.events, t[3]), h = { type: o, start: Object.assign({}, u), end: Object.assign({}, d) }; if (r.add(t[2], 0, [["enter", h, e]]), n !== 2) { const g = e.events[t[2]], m = e.events[t[3]]; if (g[1].end = Object.assign({}, m[1].end), g[1].type = "chunkText", g[1].contentType = "text", t[3] > t[2] + 1) { const b = t[2] + 1, y = t[3] - t[2] - 1; r.add(b, y, []) } } r.add(t[3] + 1, 0, [["exit", h, e]]) } return i !== void 0 && (s.end = Object.assign({}, no(e.events, i)), r.add(i, 0, [["exit", s, e]]), s = void 0), s } function JC(r, e, t, n, i) { const s = [], a = no(e.events, t); i && (i.end = Object.assign({}, a), s.push(["exit", i, e])), n.end = Object.assign({}, a), s.push(["exit", n, e]), r.add(t + 1, 0, s) } function no(r, e) { const t = r[e], n = t[0] === "enter" ? "start" : "end"; return t[1][n] } const Zpe = { name: "tasklistCheck", tokenize: Qpe }; function Jpe() { return { text: { 91: Zpe } } } function Qpe(r, e, t) { const n = this; return i; function i(l) { return n.previous !== null || !n._gfmTasklistFirstContentOfListItem ? t(l) : (r.enter("taskListCheck"), r.enter("taskListCheckMarker"), r.consume(l), r.exit("taskListCheckMarker"), s) } function s(l) { return it(l) ? (r.enter("taskListCheckValueUnchecked"), r.consume(l), r.exit("taskListCheckValueUnchecked"), a) : l === 88 || l === 120 ? (r.enter("taskListCheckValueChecked"), r.consume(l), r.exit("taskListCheckValueChecked"), a) : t(l) } function a(l) { return l === 93 ? (r.enter("taskListCheckMarker"), r.consume(l), r.exit("taskListCheckMarker"), r.exit("taskListCheck"), o) : t(l) } function o(l) { return Ee(l) ? e(l) : Ve(l) ? r.check({ tokenize: efe }, e, t)(l) : t(l) } } function efe(r, e, t) { return Ge(r, n, "whitespace"); function n(i) { return i === null ? t(i) : e(i) } } function tfe(r) { return Pb([Ope(), $pe(), Kpe(r), Ype(), Jpe()]) } const nfe = {}; function rfe(r) { const e = this, t = r || nfe, n = e.data(), i = n.micromarkExtensions || (n.micromarkExtensions = []), s = n.fromMarkdownExtensions || (n.fromMarkdownExtensions = []), a = n.toMarkdownExtensions || (n.toMarkdownExtensions = []); i.push(tfe(t)), s.push(Cpe()), a.push(Spe(t)) } var QC = function (r, e, t, n) { function i(s) { return s instanceof t ? s : new t(function (a) { a(s) }) } return new (t || (t = Promise))(function (s, a) { function o(d) { try { u(n.next(d)) } catch (h) { a(h) } } function l(d) { try { u(n.throw(d)) } catch (h) { a(h) } } function u(d) { d.done ? s(d.value) : i(d.value).then(o, l) } u((n = n.apply(r, e || [])).next()) }) }; class ife extends ve { constructor() { super(...arguments), this.getOptions = () => { var e, t, n; const i = this._adapter.getProp("remarkGfm"), s = [...(e = this.getProp("remarkPlugins")) !== null && e !== void 0 ? e : []]; return i && s.unshift(rfe), { evaluateOptions: { remarkPlugins: s, rehypePlugins: (t = this.getProp("rehypePlugins")) !== null && t !== void 0 ? t : [], format: this.getProp("format") }, compileOptions: { format: this.getProp("format"), remarkPlugins: s, rehypePlugins: (n = this.getProp("rehypePlugins")) !== null && n !== void 0 ? n : [] }, runOptions: {} } }, this.compile = e => QC(this, void 0, void 0, function* () { return yield oI(e, this.getOptions().compileOptions) }), this.evaluate = e => QC(this, void 0, void 0, function* () { return (yield Wde(e, Object.assign(Object.assign(Object.assign({}, this.getOptions().runOptions), this.getOptions().evaluateOptions), this._adapter.getRuntime()))).default }), this.evaluateSync = e => Gde(e, Object.assign(Object.assign(Object.assign({}, this.getOptions().runOptions), this.getOptions().evaluateOptions), this._adapter.getRuntime())).default } } const wi = { PREFIX: `${G}-markdownRender` }, sfe = r => R.createElement(zn.Title, Object.assign({ heading: 1, className: `${wi.PREFIX}-component-header` }, r)), afe = r => R.createElement(zn.Title, Object.assign({ heading: 2, className: `${wi.PREFIX}-component-header` }, r)), ofe = r => R.createElement(zn.Title, Object.assign({ heading: 3, className: `${wi.PREFIX}-component-header` }, r)), lfe = r => R.createElement(zn.Title, Object.assign({ heading: 4, className: `${wi.PREFIX}-component-header` }, r)), cfe = r => R.createElement(zn.Title, Object.assign({ heading: 5, className: `${wi.PREFIX}-component-header` }, r)), ufe = r => R.createElement(zn.Title, Object.assign({ heading: 6, className: `${wi.PREFIX}-component-header` }, r)), dfe = r => R.createElement(zn.Text, Object.assign({ link: Object.assign({}, r) }, r)), hfe = r => R.createElement("div", { className: `${wi.PREFIX}-component-image` }, R.createElement(sl, Object.assign({ fallback: R.createElement(XS, null), width: "100%" }, Ht(r, "children"))), R.createElement("div", { className: `${wi.PREFIX}-component-image-alt` }, r.alt)), pfe = r => { var e, t, n; const { children: i } = r, s = d => Array.isArray(d) ? d : [d], a = s(H(i[0], "props.children.props.children")), o = s(H(i[1], "props.children")), l = a.map(d => { var h; return ((h = d == null ? void 0 : d.props) === null || h === void 0 ? void 0 : h.children) || "" }), u = []; for (let d = 0; d < o.length; d++) { let h = { key: String(d) }; (n = (t = (e = o[d]) === null || e === void 0 ? void 0 : e.props.children) === null || t === void 0 ? void 0 : t.forEach) === null || n === void 0 || n.call(t, (g, m) => { var b, y; h[l[m]] = (y = (b = g == null ? void 0 : g.props) === null || b === void 0 ? void 0 : b.children) !== null && y !== void 0 ? y : "" }), u.push(h) } return R.createElement(Na, Object.assign({ dataSource: u, columns: l.map(d => ({ title: d, dataIndex: d })) }, Ht(r, "children"))) }, ffe = r => R.createElement(zn.Paragraph, Object.assign({ className: `${wi.PREFIX}-component-p` }, r)); var gfe = hc; function mfe(r, e) { var t = r.length; if (t) return e += e < 0 ? t : 0, gfe(e, t) ? r[e] : void 0 } var yfe = mfe, bfe = yfe, vfe = Go; function xfe(r, e) { return r && r.length ? bfe(r, vfe(e)) : void 0 } var wfe = xfe; const DI = _e(wfe); var AI = { exports: {} }; (function (r) {
  var e = typeof window < "u" ? window : typeof WorkerGlobalScope < "u" && self instanceof WorkerGlobalScope ? self : {};/**
 * Prism: Lightweight, robust, elegant syntax highlighting
 *
 * @license MIT <https://opensource.org/licenses/MIT>
 * @author Lea Verou <https://lea.verou.me>
 * @namespace
 * @public
 */var t = function (n) { var i = /(?:^|\s)lang(?:uage)?-([\w-]+)(?=\s|$)/i, s = 0, a = {}, o = { manual: n.Prism && n.Prism.manual, disableWorkerMessageHandler: n.Prism && n.Prism.disableWorkerMessageHandler, util: { encode: function S(C) { return C instanceof l ? new l(C.type, S(C.content), C.alias) : Array.isArray(C) ? C.map(S) : C.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/\u00a0/g, " ") }, type: function (S) { return Object.prototype.toString.call(S).slice(8, -1) }, objId: function (S) { return S.__id || Object.defineProperty(S, "__id", { value: ++s }), S.__id }, clone: function S(C, O) { O = O || {}; var E, v; switch (o.util.type(C)) { case "Object": if (v = o.util.objId(C), O[v]) return O[v]; E = {}, O[v] = E; for (var T in C) C.hasOwnProperty(T) && (E[T] = S(C[T], O)); return E; case "Array": return v = o.util.objId(C), O[v] ? O[v] : (E = [], O[v] = E, C.forEach(function (I, k) { E[k] = S(I, O) }), E); default: return C } }, getLanguage: function (S) { for (; S;) { var C = i.exec(S.className); if (C) return C[1].toLowerCase(); S = S.parentElement } return "none" }, setLanguage: function (S, C) { S.className = S.className.replace(RegExp(i, "gi"), ""), S.classList.add("language-" + C) }, currentScript: function () { if (typeof document > "u") return null; if ("currentScript" in document) return document.currentScript; try { throw new Error } catch (E) { var S = (/at [^(\r\n]*\((.*):[^:]+:[^:]+\)$/i.exec(E.stack) || [])[1]; if (S) { var C = document.getElementsByTagName("script"); for (var O in C) if (C[O].src == S) return C[O] } return null } }, isActive: function (S, C, O) { for (var E = "no-" + C; S;) { var v = S.classList; if (v.contains(C)) return !0; if (v.contains(E)) return !1; S = S.parentElement } return !!O } }, languages: { plain: a, plaintext: a, text: a, txt: a, extend: function (S, C) { var O = o.util.clone(o.languages[S]); for (var E in C) O[E] = C[E]; return O }, insertBefore: function (S, C, O, E) { E = E || o.languages; var v = E[S], T = {}; for (var I in v) if (v.hasOwnProperty(I)) { if (I == C) for (var k in O) O.hasOwnProperty(k) && (T[k] = O[k]); O.hasOwnProperty(I) || (T[I] = v[I]) } var P = E[S]; return E[S] = T, o.languages.DFS(o.languages, function (N, M) { M === P && N != S && (this[N] = T) }), T }, DFS: function S(C, O, E, v) { v = v || {}; var T = o.util.objId; for (var I in C) if (C.hasOwnProperty(I)) { O.call(C, I, C[I], E || I); var k = C[I], P = o.util.type(k); P === "Object" && !v[T(k)] ? (v[T(k)] = !0, S(k, O, null, v)) : P === "Array" && !v[T(k)] && (v[T(k)] = !0, S(k, O, I, v)) } } }, plugins: {}, highlightAll: function (S, C) { o.highlightAllUnder(document, S, C) }, highlightAllUnder: function (S, C, O) { var E = { callback: O, container: S, selector: 'code[class*="language-"], [class*="language-"] code, code[class*="lang-"], [class*="lang-"] code' }; o.hooks.run("before-highlightall", E), E.elements = Array.prototype.slice.apply(E.container.querySelectorAll(E.selector)), o.hooks.run("before-all-elements-highlight", E); for (var v = 0, T; T = E.elements[v++];)o.highlightElement(T, C === !0, E.callback) }, highlightElement: function (S, C, O) { var E = o.util.getLanguage(S), v = o.languages[E]; o.util.setLanguage(S, E); var T = S.parentElement; T && T.nodeName.toLowerCase() === "pre" && o.util.setLanguage(T, E); var I = S.textContent, k = { element: S, language: E, grammar: v, code: I }; function P(M) { k.highlightedCode = M, o.hooks.run("before-insert", k), k.element.innerHTML = k.highlightedCode, o.hooks.run("after-highlight", k), o.hooks.run("complete", k), O && O.call(k.element) } if (o.hooks.run("before-sanity-check", k), T = k.element.parentElement, T && T.nodeName.toLowerCase() === "pre" && !T.hasAttribute("tabindex") && T.setAttribute("tabindex", "0"), !k.code) { o.hooks.run("complete", k), O && O.call(k.element); return } if (o.hooks.run("before-highlight", k), !k.grammar) { P(o.util.encode(k.code)); return } if (C && n.Worker) { var N = new Worker(o.filename); N.onmessage = function (M) { P(M.data) }, N.postMessage(JSON.stringify({ language: k.language, code: k.code, immediateClose: !0 })) } else P(o.highlight(k.code, k.grammar, k.language)) }, highlight: function (S, C, O) { var E = { code: S, grammar: C, language: O }; if (o.hooks.run("before-tokenize", E), !E.grammar) throw new Error('The language "' + E.language + '" has no grammar.'); return E.tokens = o.tokenize(E.code, E.grammar), o.hooks.run("after-tokenize", E), l.stringify(o.util.encode(E.tokens), E.language) }, tokenize: function (S, C) { var O = C.rest; if (O) { for (var E in O) C[E] = O[E]; delete C.rest } var v = new h; return g(v, v.head, S), d(S, v, C, v.head, 0), b(v) }, hooks: { all: {}, add: function (S, C) { var O = o.hooks.all; O[S] = O[S] || [], O[S].push(C) }, run: function (S, C) { var O = o.hooks.all[S]; if (!(!O || !O.length)) for (var E = 0, v; v = O[E++];)v(C) } }, Token: l }; n.Prism = o; function l(S, C, O, E) { this.type = S, this.content = C, this.alias = O, this.length = (E || "").length | 0 } l.stringify = function S(C, O) { if (typeof C == "string") return C; if (Array.isArray(C)) { var E = ""; return C.forEach(function (P) { E += S(P, O) }), E } var v = { type: C.type, content: S(C.content, O), tag: "span", classes: ["token", C.type], attributes: {}, language: O }, T = C.alias; T && (Array.isArray(T) ? Array.prototype.push.apply(v.classes, T) : v.classes.push(T)), o.hooks.run("wrap", v); var I = ""; for (var k in v.attributes) I += " " + k + '="' + (v.attributes[k] || "").replace(/"/g, "&quot;") + '"'; return "<" + v.tag + ' className="' + v.classes.join(" ") + '"' + I + ">" + v.content + "</" + v.tag + ">" }; function u(S, C, O, E) { S.lastIndex = C; var v = S.exec(O); if (v && E && v[1]) { var T = v[1].length; v.index += T, v[0] = v[0].slice(T) } return v } function d(S, C, O, E, v, T) { for (var I in O) if (!(!O.hasOwnProperty(I) || !O[I])) { var k = O[I]; k = Array.isArray(k) ? k : [k]; for (var P = 0; P < k.length; ++P) { if (T && T.cause == I + "," + P) return; var N = k[P], M = N.inside, B = !!N.lookbehind, K = !!N.greedy, U = N.alias; if (K && !N.pattern.global) { var W = N.pattern.toString().match(/[imsuy]*$/)[0]; N.pattern = RegExp(N.pattern.source, W + "g") } for (var Z = N.pattern || N, J = E.next, ee = v; J !== C.tail && !(T && ee >= T.reach); ee += J.value.length, J = J.next) { var $ = J.value; if (C.length > S.length) return; if (!($ instanceof l)) { var pe = 1, re; if (K) { if (re = u(Z, ee, S, B), !re || re.index >= S.length) break; var fe = re.index, j = re.index + re[0].length, ae = ee; for (ae += J.value.length; fe >= ae;)J = J.next, ae += J.value.length; if (ae -= J.value.length, ee = ae, J.value instanceof l) continue; for (var be = J; be !== C.tail && (ae < j || typeof be.value == "string"); be = be.next)pe++, ae += be.value.length; pe--, $ = S.slice(ee, ae), re.index -= ee } else if (re = u(Z, 0, $, B), !re) continue; var fe = re.index, Ce = re[0], ue = $.slice(0, fe), te = $.slice(fe + Ce.length), le = ee + $.length; T && le > T.reach && (T.reach = le); var Re = J.prev; ue && (Re = g(C, Re, ue), ee += ue.length), m(C, Re, pe); var at = new l(I, M ? o.tokenize(Ce, M) : Ce, U, Ce); if (J = g(C, Re, at), te && g(C, J, te), pe > 1) { var yt = { cause: I + "," + P, reach: le }; d(S, C, O, J.prev, ee, yt), T && yt.reach > T.reach && (T.reach = yt.reach) } } } } } } function h() { var S = { value: null, prev: null, next: null }, C = { value: null, prev: S, next: null }; S.next = C, this.head = S, this.tail = C, this.length = 0 } function g(S, C, O) { var E = C.next, v = { value: O, prev: C, next: E }; return C.next = v, E.prev = v, S.length++, v } function m(S, C, O) { for (var E = C.next, v = 0; v < O && E !== S.tail; v++)E = E.next; C.next = E, E.prev = C, S.length -= v } function b(S) { for (var C = [], O = S.head.next; O !== S.tail;)C.push(O.value), O = O.next; return C } if (!n.document) return n.addEventListener && (o.disableWorkerMessageHandler || n.addEventListener("message", function (S) { var C = JSON.parse(S.data), O = C.language, E = C.code, v = C.immediateClose; n.postMessage(o.highlight(E, o.languages[O], O)), v && n.close() }, !1)), o; var y = o.util.currentScript(); y && (o.filename = y.src, y.hasAttribute("data-manual") && (o.manual = !0)); function w() { o.manual || o.highlightAll() } if (!o.manual) { var x = document.readyState; x === "loading" || x === "interactive" && y && y.defer ? document.addEventListener("DOMContentLoaded", w) : window.requestAnimationFrame ? window.requestAnimationFrame(w) : window.setTimeout(w, 16) } return o }(e); r.exports && (r.exports = t), typeof Qi < "u" && (Qi.Prism = t), t.languages.markup = { comment: { pattern: /<!--(?:(?!<!--)[\s\S])*?-->/, greedy: !0 }, prolog: { pattern: /<\?[\s\S]+?\?>/, greedy: !0 }, doctype: { pattern: /<!DOCTYPE(?:[^>"'[\]]|"[^"]*"|'[^']*')+(?:\[(?:[^<"'\]]|"[^"]*"|'[^']*'|<(?!!--)|<!--(?:[^-]|-(?!->))*-->)*\]\s*)?>/i, greedy: !0, inside: { "internal-subset": { pattern: /(^[^\[]*\[)[\s\S]+(?=\]>$)/, lookbehind: !0, greedy: !0, inside: null }, string: { pattern: /"[^"]*"|'[^']*'/, greedy: !0 }, punctuation: /^<!|>$|[[\]]/, "doctype-tag": /^DOCTYPE/i, name: /[^\s<>'"]+/ } }, cdata: { pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i, greedy: !0 }, tag: { pattern: /<\/?(?!\d)[^\s>\/=$<%]+(?:\s(?:\s*[^\s>\/=]+(?:\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))|(?=[\s/>])))+)?\s*\/?>/, greedy: !0, inside: { tag: { pattern: /^<\/?[^\s>\/]+/, inside: { punctuation: /^<\/?/, namespace: /^[^\s>\/:]+:/ } }, "special-attr": [], "attr-value": { pattern: /=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+)/, inside: { punctuation: [{ pattern: /^=/, alias: "attr-equals" }, { pattern: /^(\s*)["']|["']$/, lookbehind: !0 }] } }, punctuation: /\/?>/, "attr-name": { pattern: /[^\s>\/]+/, inside: { namespace: /^[^\s>\/:]+:/ } } } }, entity: [{ pattern: /&[\da-z]{1,8};/i, alias: "named-entity" }, /&#x?[\da-f]{1,8};/i] }, t.languages.markup.tag.inside["attr-value"].inside.entity = t.languages.markup.entity, t.languages.markup.doctype.inside["internal-subset"].inside = t.languages.markup, t.hooks.add("wrap", function (n) { n.type === "entity" && (n.attributes.title = n.content.replace(/&amp;/, "&")) }), Object.defineProperty(t.languages.markup.tag, "addInlined", { value: function (i, s) { var a = {}; a["language-" + s] = { pattern: /(^<!\[CDATA\[)[\s\S]+?(?=\]\]>$)/i, lookbehind: !0, inside: t.languages[s] }, a.cdata = /^<!\[CDATA\[|\]\]>$/i; var o = { "included-cdata": { pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i, inside: a } }; o["language-" + s] = { pattern: /[\s\S]+/, inside: t.languages[s] }; var l = {}; l[i] = { pattern: RegExp(/(<__[^>]*>)(?:<!\[CDATA\[(?:[^\]]|\](?!\]>))*\]\]>|(?!<!\[CDATA\[)[\s\S])*?(?=<\/__>)/.source.replace(/__/g, function () { return i }), "i"), lookbehind: !0, greedy: !0, inside: o }, t.languages.insertBefore("markup", "cdata", l) } }), Object.defineProperty(t.languages.markup.tag, "addAttribute", { value: function (n, i) { t.languages.markup.tag.inside["special-attr"].push({ pattern: RegExp(/(^|["'\s])/.source + "(?:" + n + ")" + /\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))/.source, "i"), lookbehind: !0, inside: { "attr-name": /^[^\s=]+/, "attr-value": { pattern: /=[\s\S]+/, inside: { value: { pattern: /(^=\s*(["']|(?!["'])))\S[\s\S]*(?=\2$)/, lookbehind: !0, alias: [i, "language-" + i], inside: t.languages[i] }, punctuation: [{ pattern: /^=/, alias: "attr-equals" }, /"|'/] } } } }) } }), t.languages.html = t.languages.markup, t.languages.mathml = t.languages.markup, t.languages.svg = t.languages.markup, t.languages.xml = t.languages.extend("markup", {}), t.languages.ssml = t.languages.xml, t.languages.atom = t.languages.xml, t.languages.rss = t.languages.xml, function (n) { var i = /(?:"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"|'(?:\\(?:\r\n|[\s\S])|[^'\\\r\n])*')/; n.languages.css = { comment: /\/\*[\s\S]*?\*\//, atrule: { pattern: RegExp("@[\\w-](?:" + /[^;{\s"']|\s+(?!\s)/.source + "|" + i.source + ")*?" + /(?:;|(?=\s*\{))/.source), inside: { rule: /^@[\w-]+/, "selector-function-argument": { pattern: /(\bselector\s*\(\s*(?![\s)]))(?:[^()\s]|\s+(?![\s)])|\((?:[^()]|\([^()]*\))*\))+(?=\s*\))/, lookbehind: !0, alias: "selector" }, keyword: { pattern: /(^|[^\w-])(?:and|not|only|or)(?![\w-])/, lookbehind: !0 } } }, url: { pattern: RegExp("\\burl\\((?:" + i.source + "|" + /(?:[^\\\r\n()"']|\\[\s\S])*/.source + ")\\)", "i"), greedy: !0, inside: { function: /^url/i, punctuation: /^\(|\)$/, string: { pattern: RegExp("^" + i.source + "$"), alias: "url" } } }, selector: { pattern: RegExp(`(^|[{}\\s])[^{}\\s](?:[^{};"'\\s]|\\s+(?![\\s{])|` + i.source + ")*(?=\\s*\\{)"), lookbehind: !0 }, string: { pattern: i, greedy: !0 }, property: { pattern: /(^|[^-\w\xA0-\uFFFF])(?!\s)[-_a-z\xA0-\uFFFF](?:(?!\s)[-\w\xA0-\uFFFF])*(?=\s*:)/i, lookbehind: !0 }, important: /!important\b/i, function: { pattern: /(^|[^-a-z0-9])[-a-z0-9]+(?=\()/i, lookbehind: !0 }, punctuation: /[(){};:,]/ }, n.languages.css.atrule.inside.rest = n.languages.css; var s = n.languages.markup; s && (s.tag.addInlined("style", "css"), s.tag.addAttribute("style", "css")) }(t), t.languages.clike = { comment: [{ pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/, lookbehind: !0, greedy: !0 }, { pattern: /(^|[^\\:])\/\/.*/, lookbehind: !0, greedy: !0 }], string: { pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/, greedy: !0 }, "class-name": { pattern: /(\b(?:class|extends|implements|instanceof|interface|new|trait)\s+|\bcatch\s+\()[\w.\\]+/i, lookbehind: !0, inside: { punctuation: /[.\\]/ } }, keyword: /\b(?:break|catch|continue|do|else|finally|for|function|if|in|instanceof|new|null|return|throw|try|while)\b/, boolean: /\b(?:false|true)\b/, function: /\b\w+(?=\()/, number: /\b0x[\da-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?/i, operator: /[<>]=?|[!=]=?=?|--?|\+\+?|&&?|\|\|?|[?*/~^%]/, punctuation: /[{}[\];(),.:]/ }, t.languages.javascript = t.languages.extend("clike", { "class-name": [t.languages.clike["class-name"], { pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$A-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\.(?:constructor|prototype))/, lookbehind: !0 }], keyword: [{ pattern: /((?:^|\})\s*)catch\b/, lookbehind: !0 }, { pattern: /(^|[^.]|\.\.\.\s*)\b(?:as|assert(?=\s*\{)|async(?=\s*(?:function\b|\(|[$\w\xA0-\uFFFF]|$))|await|break|case|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally(?=\s*(?:\{|$))|for|from(?=\s*(?:['"]|$))|function|(?:get|set)(?=\s*(?:[#\[$\w\xA0-\uFFFF]|$))|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)\b/, lookbehind: !0 }], function: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*(?:\.\s*(?:apply|bind|call)\s*)?\()/, number: { pattern: RegExp(/(^|[^\w$])/.source + "(?:" + (/NaN|Infinity/.source + "|" + /0[bB][01]+(?:_[01]+)*n?/.source + "|" + /0[oO][0-7]+(?:_[0-7]+)*n?/.source + "|" + /0[xX][\dA-Fa-f]+(?:_[\dA-Fa-f]+)*n?/.source + "|" + /\d+(?:_\d+)*n/.source + "|" + /(?:\d+(?:_\d+)*(?:\.(?:\d+(?:_\d+)*)?)?|\.\d+(?:_\d+)*)(?:[Ee][+-]?\d+(?:_\d+)*)?/.source) + ")" + /(?![\w$])/.source), lookbehind: !0 }, operator: /--|\+\+|\*\*=?|=>|&&=?|\|\|=?|[!=]==|<<=?|>>>?=?|[-+*/%&|^!=<>]=?|\.{3}|\?\?=?|\?\.?|[~:]/ }), t.languages.javascript["class-name"][0].pattern = /(\b(?:class|extends|implements|instanceof|interface|new)\s+)[\w.\\]+/, t.languages.insertBefore("javascript", "keyword", { regex: { pattern: RegExp(/((?:^|[^$\w\xA0-\uFFFF."'\])\s]|\b(?:return|yield))\s*)/.source + /\//.source + "(?:" + /(?:\[(?:[^\]\\\r\n]|\\.)*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}/.source + "|" + /(?:\[(?:[^[\]\\\r\n]|\\.|\[(?:[^[\]\\\r\n]|\\.|\[(?:[^[\]\\\r\n]|\\.)*\])*\])*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}v[dgimyus]{0,7}/.source + ")" + /(?=(?:\s|\/\*(?:[^*]|\*(?!\/))*\*\/)*(?:$|[\r\n,.;:})\]]|\/\/))/.source), lookbehind: !0, greedy: !0, inside: { "regex-source": { pattern: /^(\/)[\s\S]+(?=\/[a-z]*$)/, lookbehind: !0, alias: "language-regex", inside: t.languages.regex }, "regex-delimiter": /^\/|\/$/, "regex-flags": /^[a-z]+$/ } }, "function-variable": { pattern: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*[=:]\s*(?:async\s*)?(?:\bfunction\b|(?:\((?:[^()]|\([^()]*\))*\)|(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)\s*=>))/, alias: "function" }, parameter: [{ pattern: /(function(?:\s+(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)?\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\))/, lookbehind: !0, inside: t.languages.javascript }, { pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$a-z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*=>)/i, lookbehind: !0, inside: t.languages.javascript }, { pattern: /(\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*=>)/, lookbehind: !0, inside: t.languages.javascript }, { pattern: /((?:\b|\s|^)(?!(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)(?![$\w\xA0-\uFFFF]))(?:(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*\s*)\(\s*|\]\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*\{)/, lookbehind: !0, inside: t.languages.javascript }], constant: /\b[A-Z](?:[A-Z_]|\dx?)*\b/ }), t.languages.insertBefore("javascript", "string", { hashbang: { pattern: /^#!.*/, greedy: !0, alias: "comment" }, "template-string": { pattern: /`(?:\\[\s\S]|\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}|(?!\$\{)[^\\`])*`/, greedy: !0, inside: { "template-punctuation": { pattern: /^`|`$/, alias: "string" }, interpolation: { pattern: /((?:^|[^\\])(?:\\{2})*)\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}/, lookbehind: !0, inside: { "interpolation-punctuation": { pattern: /^\$\{|\}$/, alias: "punctuation" }, rest: t.languages.javascript } }, string: /[\s\S]+/ } }, "string-property": { pattern: /((?:^|[,{])[ \t]*)(["'])(?:\\(?:\r\n|[\s\S])|(?!\2)[^\\\r\n])*\2(?=\s*:)/m, lookbehind: !0, greedy: !0, alias: "property" } }), t.languages.insertBefore("javascript", "operator", { "literal-property": { pattern: /((?:^|[,{])[ \t]*)(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*:)/m, lookbehind: !0, alias: "property" } }), t.languages.markup && (t.languages.markup.tag.addInlined("script", "javascript"), t.languages.markup.tag.addAttribute(/on(?:abort|blur|change|click|composition(?:end|start|update)|dblclick|error|focus(?:in|out)?|key(?:down|up)|load|mouse(?:down|enter|leave|move|out|over|up)|reset|resize|scroll|select|slotchange|submit|unload|wheel)/.source, "javascript")), t.languages.js = t.languages.javascript, function () {
    if (typeof t > "u" || typeof document > "u") return; Element.prototype.matches || (Element.prototype.matches = Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector); var n = "Loading…", i = function (y, w) { return "✖ Error " + y + " while fetching file: " + w }, s = "✖ Error: File does not exist or is empty", a = { js: "javascript", py: "python", rb: "ruby", ps1: "powershell", psm1: "powershell", sh: "bash", bat: "batch", h: "c", tex: "latex" }, o = "data-src-status", l = "loading", u = "loaded", d = "failed", h = "pre[data-src]:not([" + o + '="' + u + '"]):not([' + o + '="' + l + '"])'; function g(y, w, x) { var S = new XMLHttpRequest; S.open("GET", y, !0), S.onreadystatechange = function () { S.readyState == 4 && (S.status < 400 && S.responseText ? w(S.responseText) : S.status >= 400 ? x(i(S.status, S.statusText)) : x(s)) }, S.send(null) } function m(y) { var w = /^\s*(\d+)\s*(?:(,)\s*(?:(\d+)\s*)?)?$/.exec(y || ""); if (w) { var x = Number(w[1]), S = w[2], C = w[3]; return S ? C ? [x, Number(C)] : [x, void 0] : [x, x] } } t.hooks.add("before-highlightall", function (y) { y.selector += ", " + h }), t.hooks.add("before-sanity-check", function (y) {
      var w = y.element; if (w.matches(h)) {
        y.code = "", w.setAttribute(o, l); var x = w.appendChild(document.createElement("CODE")); x.textContent = n; var S = w.getAttribute("data-src"), C = y.language; if (C === "none") { var O = (/\.(\w+)$/.exec(S) || [, "none"])[1]; C = a[O] || O } t.util.setLanguage(x, C), t.util.setLanguage(w, C); var E = t.plugins.autoloader; E && E.loadLanguages(C), g(S, function (v) {
          w.setAttribute(o, u); var T = m(w.getAttribute("data-range")); if (T) {
            var I = v.split(/\r\n?|\n/g), k = T[0], P = T[1] == null ? I.length : T[1]; k < 0 && (k += I.length), k = Math.max(0, Math.min(k - 1, I.length)), P < 0 && (P += I.length), P = Math.max(0, Math.min(P, I.length)), v = I.slice(k, P).join(`
`), w.hasAttribute("data-start") || w.setAttribute("data-start", String(k + 1))
          } x.textContent = v, t.highlightElement(x)
        }, function (v) { w.setAttribute(o, d), x.textContent = v })
      }
    }), t.plugins.fileHighlight = { highlight: function (w) { for (var x = (w || document).querySelectorAll(h), S = 0, C; C = x[S++];)t.highlightElement(C) } }; var b = !1; t.fileHighlight = function () { b || (console.warn("Prism.fileHighlight is deprecated. Use `Prism.plugins.fileHighlight.highlight` instead."), b = !0), t.plugins.fileHighlight.highlight.apply(this, arguments) }
  }()
})(AI); var Cfe = AI.exports; const NI = _e(Cfe); (function () { if (typeof Prism < "u" && typeof document < "u") { var r = "line-numbers", e = /\n(?!$)/g, t = Prism.plugins.lineNumbers = { getLine: function (s, a) { if (s.tagName === "PRE" && s.classList.contains(r)) { var o = s.querySelector(".line-numbers-rows"); if (o) { var l = parseInt(s.getAttribute("data-start"), 10) || 1, u = l + (o.children.length - 1); a < l && (a = l), a > u && (a = u); var d = a - l; return o.children[d] } } }, resize: function (s) { i([s]) }, assumeViewportIndependence: !0 }, n = void 0; window.addEventListener("resize", function () { t.assumeViewportIndependence && n === window.innerWidth || (n = window.innerWidth, i(Array.prototype.slice.call(document.querySelectorAll("pre.line-numbers")))) }), Prism.hooks.add("complete", function (s) { if (s.code) { var a = s.element, o = a.parentNode; if (o && /pre/i.test(o.nodeName) && !a.querySelector(".line-numbers-rows") && Prism.util.isActive(a, r)) { a.classList.remove(r), o.classList.add(r); var l, u = s.code.match(e), d = u ? u.length + 1 : 1, h = new Array(d + 1).join("<span></span>"); (l = document.createElement("span")).setAttribute("aria-hidden", "true"), l.className = "line-numbers-rows", l.innerHTML = h, o.hasAttribute("data-start") && (o.style.counterReset = "linenumber " + (parseInt(o.getAttribute("data-start"), 10) - 1)), s.element.appendChild(l), i([o]), Prism.hooks.run("line-numbers", s) } } }), Prism.hooks.add("line-numbers", function (s) { s.plugins = s.plugins || {}, s.plugins.lineNumbers = !0 }) } function i(s) { if ((s = s.filter(function (o) { var l, u = (l = o, l ? window.getComputedStyle ? getComputedStyle(l) : l.currentStyle || null : null)["white-space"]; return u === "pre-wrap" || u === "pre-line" })).length != 0) { var a = s.map(function (o) { var l = o.querySelector("code"), u = o.querySelector(".line-numbers-rows"); if (l && u) { var d = o.querySelector(".line-numbers-sizer"), h = l.textContent.split(e); d || ((d = document.createElement("span")).className = "line-numbers-sizer", l.appendChild(d)), d.innerHTML = "0", d.style.display = "block"; var g = d.getBoundingClientRect().height; return d.innerHTML = "", { element: o, lines: h, lineHeights: [], oneLinerHeight: g, sizer: d } } }).filter(Boolean); a.forEach(function (o) { var l = o.sizer, u = o.lines, d = o.lineHeights, h = o.oneLinerHeight; d[u.length - 1] = void 0, u.forEach(function (g, m) { if (g && g.length > 1) { var b = l.appendChild(document.createElement("span")); b.style.display = "block", b.textContent = g } else d[m] = h }) }), a.forEach(function (o) { for (var l = o.sizer, u = o.lineHeights, d = 0, h = 0; h < u.length; h++)u[h] === void 0 && (u[h] = l.children[d++].getBoundingClientRect().height) }), a.forEach(function (o) { var l = o.sizer, u = o.element.querySelector(".line-numbers-rows"); l.style.display = "none", l.innerHTML = "", o.lineHeights.forEach(function (d, h) { u.children[h].style.height = d + "px" }) }) } } })(); NI.manual = !0; class Sfe extends ve { constructor(e) { super(Object.assign({}, e)), this.highlightCode = (t, n) => { let i = t.className; const s = `language-${n}`; i.includes(s) || (i = F(i, s)), this.getProp("lineNumber") && (i = F(i, "line-numbers")), t.className = i, NI.highlightElement(t, !1) } } } const e1 = { PREFIX: `${G}-codeHighlight` }; class sc extends de { constructor(e) { super(e), this.codeRef = R.createRef(), this.foundation = new Sfe(this.adapter), this.state = {} } get adapter() { return Object.assign({}, super.adapter) } componentDidMount() { super.componentDidMount(), this.codeRef.current && this.foundation.highlightCode(this.codeRef.current, this.props.language) } componentDidUpdate(e, t, n) { (this.codeRef.current && e.code !== this.props.code || this.props.language !== this.props.language) && this.foundation.highlightCode(this.codeRef.current, this.props.language) } render() { return R.createElement("div", Object.assign({ style: this.props.style, className: F(this.props.className, e1.PREFIX, "semi-light-scrollbar", { [`${e1.PREFIX}-defaultTheme`]: this.props.defaultTheme }) }, this.getDataAttr(this.props)), R.createElement("pre", null, R.createElement("code", { ref: this.codeRef }, this.props.code))) } } sc.__SemiComponentName__ = "CodeHighlight"; sc.propTypes = { className: c.string, style: c.any, code: c.string, language: c.string, lineNumber: c.bool, defaultTheme: c.bool }; sc.defaultProps = xn(sc.__SemiComponentName__, { lineNumber: !0, defaultTheme: !0 }); const lm = r => { var e; const t = DI((e = r.className) === null || e === void 0 ? void 0 : e.split("-"), -1); return t ? R.createElement(sc, { code: r.children, language: t, lineNumber: !0 }) : R.createElement("span", { className: `${wi.PREFIX}-simple-code` }, r.children) }, FI = Object.freeze(Object.defineProperty({ __proto__: null, a: dfe, code: lm, h1: sfe, h2: afe, h3: ofe, h4: lfe, h5: cfe, h6: ufe, img: hfe, p: ffe, table: pfe }, Symbol.toStringTag, { value: "Module" })); class xa extends de { constructor(e) { super(e), this.foundation = new ife(this.adapter), this.state = { MDXContentComponent: this.foundation.evaluateSync(this.props.raw) } } componentDidUpdate(e, t, n) { e.raw !== this.props.raw && this.setState({ MDXContentComponent: this.foundation.evaluateSync(this.props.raw) }) } get adapter() { return Object.assign(Object.assign({}, super.adapter), { getRuntime: () => uP }) } render() { const e = this.state.MDXContentComponent; return R.createElement("div", Object.assign({ className: F(wi.PREFIX, this.props.className), style: this.props.style }, this.getDataAttr()), R.createElement(e, { components: Object.assign(Object.assign({}, FI), this.props.components) })) } } xa.propTypes = { className: c.string, style: c.object, format: c.string, components: c.any, raw: c.string, remarkPlugins: c.arrayOf(c.object), rehypePlugins: c.arrayOf(c.object), remarkGfm: c.bool }; xa.__SemiComponentName__ = "MarkdownRender"; xa.defaultProps = xn(xa.__SemiComponentName__, { format: "mdx", remarkGfm: !0 }); xa.defaultComponents = FI; const _i = { PREFIX: `${G}-chat`, PREFIX_DIVIDER: `${G}-chat-divider`, PREFIX_CHAT_BOX: `${G}-chat-chatBox`, PREFIX_CHAT_BOX_ACTION: `${G}-chat-chatBox-action`, PREFIX_INPUT_BOX: `${G}-chat-inputBox`, PREFIX_ATTACHMENT: `${G}-chat-attachment`, PREFIX_HINT: `${G}-chat-hint` }, Efe = { USER: "user", ASSISTANT: "assistant", SYSTEM: "system", DIVIDER: "divider" }, _fe = { LEFT_RIGHT: "leftRight", LEFT_ALIGN: "leftAlign" }, Ofe = { LOADING: "loading", INCOMPLETE: "incomplete", COMPLETE: "complete", ERROR: "error" }, Tfe = ["png", "jpg", "jpeg", "gif", "bmp", "webp"], Ife = "image/", Pfe = 300, kfe = 100, Rfe = { BUBBLE: "bubble", NO_BUBBLE: "noBubble", USER_BUBBLE: "userBubble" }, Dfe = { ENTER: "enter", SHIFT_PLUS_ENTER: "shift+enter" }, ps = { ROLE: Efe, CHAT_ALIGN: _fe, MESSAGE_STATUS: Ofe, PIC_SUFFIX_ARRAY: Tfe, PIC_PREFIX: Ife, SCROLL_ANIMATION_TIME: Pfe, SHOW_SCROLL_GAP: kfe, MODE: Rfe, SEND_HOT_KEY: Dfe }, { SEND_HOT_KEY: t1 } = ps; class Afe extends ve { constructor(e) { super(Object.assign({}, e)), this.onInputAreaChange = t => { const n = this.getState("attachment"); this._adapter.setInputValue(t), this._adapter.notifyInputChange({ inputValue: t, attachment: n }) }, this.onAttachmentAdd = t => { const { fileList: n } = t, { uploadProps: i } = this.getProps(), { onChange: s } = i; s && s(t); const { content: a } = this.getStates(); let o = [...n]; this._adapter.setAttachment(o), this._adapter.notifyInputChange({ inputValue: a, attachment: o }) }, this.onAttachmentDelete = t => { const { content: n, attachment: i } = this.getStates(), s = i.filter(a => a.uid !== t.uid); this._adapter.setAttachment(s), this._adapter.notifyInputChange({ inputValue: n, attachment: s }) }, this.onSend = t => { if (this.getDisableSend()) return; const { content: n, attachment: i } = this.getStates(); this._adapter.setInputValue(""), this._adapter.setAttachment([]), this._adapter.notifySend(n, i) }, this.getDisableSend = () => { const { content: t, attachment: n } = this.getStates(), { disableSend: i } = this.getProps(); return i || t.length === 0 && n.length === 0 }, this.onEnterPress = t => { const { sendHotKey: n } = this.getProps(); n === t1.SHIFT_PLUS_ENTER && t.shiftKey === !1 || n === t1.ENTER && t.shiftKey === !0 || (yn(t), this.onSend(t)) }, this.onPaste = t => { var n; const i = (n = t.clipboardData) === null || n === void 0 ? void 0 : n.items, { manualUpload: s } = this.getProps(); let a = []; if (i) { for (const o of i) o.getAsFile() && a.push(o.getAsFile()); a.length && (s(a), t.preventDefault(), t.stopPropagation()) } } } } const { PREFIX_ATTACHMENT: ui } = _i, { PIC_SUFFIX_ARRAY: Nfe, PIC_PREFIX: Ffe } = ps, cm = f.memo(r => { const { url: e, name: t, size: n, type: i } = r; return f.createElement("a", { href: e, target: "_blank", className: `${ui}-file`, rel: "noreferrer" }, f.createElement(Ez, { size: "extra-large", className: `${ui}-file-icon` }), f.createElement("div", { className: `${ui}-file-info` }, f.createElement("span", { className: `${ui}-file-title` }, t), f.createElement("span", { className: `${ui}-file-metadata` }, f.createElement("span", { className: `${ui}-file-type` }, i), i ? " · " : "", n))) }), um = f.memo(r => { const { src: e } = r; return f.createElement(sl, { className: `${ui}-img`, width: 60, height: 60, src: e }) }), $fe = f.memo(r => { const { attachment: e, onClear: t, showClear: n = !0, className: i } = r; return f.createElement("div", { className: F(ui, { [i]: i }) }, e.map(s => { var a, o, l, u; const { percent: d, status: h } = s, g = s == null ? void 0 : s.name.split(".").pop(), m = ((o = (a = s == null ? void 0 : s.fileInstance) === null || a === void 0 ? void 0 : a.type) === null || o === void 0 ? void 0 : o.startsWith(Ffe)) || Nfe.includes(g), b = g ?? ((u = (l = s == null ? void 0 : s.fileInstance) === null || l === void 0 ? void 0 : l.type) === null || u === void 0 ? void 0 : u.split("/").pop()), y = !(d === 100 || typeof d > "u") && h === "uploading"; return f.createElement("div", { className: `${ui}-item`, key: s.uid }, m ? f.createElement(um, { src: s.url }) : f.createElement(cm, { url: s.url, name: s.name, size: s.size, type: b }), n && f.createElement(us, { size: "large", className: `${ui}-clear`, onClick: () => { t && t(s) } }), y && f.createElement(Zl, { percent: d, type: "circle", size: "small", width: 30, className: `${ui}-process`, "aria-label": "upload progress" })) })) }); var Lfe = function (r, e) { var t = {}; for (var n in r) Object.prototype.hasOwnProperty.call(r, n) && e.indexOf(n) < 0 && (t[n] = r[n]); if (r != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, n = Object.getOwnPropertySymbols(r); i < n.length; i++)e.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(r, n[i]) && (t[n[i]] = r[n[i]]); return t }; const { PREFIX_INPUT_BOX: Pi } = _i, { SEND_HOT_KEY: Mfe } = ps, jfe = { minRows: 1, maxRows: 5 }; class Vb extends de { constructor(e) { super(e), this.onClick = () => { var t; (t = this.inputAreaRef.current) === null || t === void 0 || t.focus() }, this.renderUploadButton = () => { const { uploadProps: t, uploadRef: n, uploadTipProps: i } = this.props, { attachment: s } = this.state, { className: a, onChange: o, renderFileItem: l, children: u } = t, d = Lfe(t, ["className", "onChange", "renderFileItem", "children"]), h = Object.assign(Object.assign({}, d), { className: F(`${Pi}-upload`, { [a]: a }), onChange: this.foundation.onAttachmentAdd }), g = f.createElement(Bc, Object.assign({ ref: n, fileList: s }, h), u || f.createElement(St, { className: `${Pi}-uploadButton`, icon: f.createElement(Az, { size: "extra-large" }), theme: "borderless" })); return i ? f.createElement(ln, Object.assign({}, i), f.createElement("span", null, g)) : g }, this.renderInputArea = () => { const { content: t, attachment: n } = this.state, { placeholder: i, sendHotKey: s } = this.props; return f.createElement("div", { className: `${Pi}-inputArea` }, f.createElement(tO, { placeholder: i, onEnterPress: this.foundation.onEnterPress, value: t, onChange: this.foundation.onInputAreaChange, ref: this.inputAreaRef, className: `${Pi}-textarea`, autosize: jfe, disabledEnterStartNewLine: s === Mfe.ENTER, onPaste: this.foundation.onPaste }), f.createElement($fe, { attachment: n, onClear: this.foundation.onAttachmentDelete })) }, this.renderClearButton = () => { const { onClearContext: t } = this.props; return f.createElement(St, { className: `${Pi}-clearButton`, theme: "borderless", icon: f.createElement(US, null), onClick: t }) }, this.renderSendButton = () => { const t = this.foundation.getDisableSend(); return f.createElement(St, { disabled: t, theme: "solid", type: "primary", className: `${Pi}-sendButton`, icon: f.createElement(Cz, { size: "large", className: `${Pi}-sendButton-icon` }), onClick: this.foundation.onSend }) }, this.inputAreaRef = f.createRef(), this.foundation = new Afe(this.adapter), this.state = { content: "", attachment: [] } } get adapter() { return Object.assign(Object.assign({}, super.adapter), { notifyInputChange: e => { const { onInputChange: t } = this.props; t && t(e) }, setInputValue: e => { this.setState({ content: e }) }, setAttachment: e => { this.setState({ attachment: e }) }, notifySend: (e, t) => { const { onSend: n } = this.props; n && n(e, t) } }) } render() { const { onClearContext: e, renderInputArea: t, onSend: n, style: i, className: s, showClearContext: a } = this.props, o = this.renderClearButton(), l = this.renderUploadButton(), u = this.renderInputArea(), d = this.renderSendButton(), h = f.createElement("div", { className: F(Pi, { [s]: s }), style: i }, f.createElement("div", { className: `${Pi}-inner`, onClick: this.onClick }, a && o, f.createElement("div", { className: `${Pi}-container` }, l, u, d))); return t ? t({ defaultNode: h, onClear: e, onSend: n, detailProps: { clearContextNode: o, uploadNode: l, inputNode: u, sendNode: d, onClick: this.onClick } }) : h } } Vb.propTypes = { uploadProps: c.object }; Vb.defaultProps = { uploadProps: {} }; const { PREFIX_HINT: Su } = _i, Vfe = f.memo(r => { const { value: e, onHintClick: t, renderHintBox: n, className: i, style: s } = r; return f.createElement("section", { className: F(`${Su}s`, { [i]: !!i }), style: s }, e.map((a, o) => n ? n({ content: a, index: o, onHintClick: () => { t == null || t(a) } }) : f.createElement("div", { className: `${Su}-item`, key: o, onClick: () => { t == null || t(a) } }, f.createElement("div", { className: `${Su}-content` }, a), f.createElement(BS, { className: `${Su}-icon` })))) }), { PREFIX_CHAT_BOX: n1 } = _i, Bfe = f.memo(r => { const { role: e, customRenderFunc: t, continueSend: n, message: i } = r, s = R.useMemo(() => { const { avatar: a, color: o } = e; return f.createElement(ma, { className: F(`${n1}-avatar`, { [`${n1}-avatar-hidden`]: n }), src: a, size: "extra-small" }) }, [e]); return t && typeof t == "function" ? t({ role: e, defaultAvatar: s, message: i }) : s }), { PREFIX_CHAT_BOX: zfe } = _i, Hfe = f.memo(r => { const { role: e, message: t, customRenderFunc: n } = r, i = R.useMemo(() => f.createElement("span", { className: `${zfe}-title` }, e == null ? void 0 : e.name), [e]); return n && typeof n == "function" ? n({ role: e, message: t, defaultTitle: i }) : i }); (function (r) { var e = r.util.clone(r.languages.javascript), t = /(?:\s|\/\/.*(?!.)|\/\*(?:[^*]|\*(?!\/))\*\/)/.source, n = /(?:\{(?:\{(?:\{[^{}]*\}|[^{}])*\}|[^{}])*\})/.source, i = /(?:\{<S>*\.{3}(?:[^{}]|<BRACES>)*\})/.source; function s(l, u) { return l = l.replace(/<S>/g, function () { return t }).replace(/<BRACES>/g, function () { return n }).replace(/<SPREAD>/g, function () { return i }), RegExp(l, u) } i = s(i).source, r.languages.jsx = r.languages.extend("markup", e), r.languages.jsx.tag.pattern = s(/<\/?(?:[\w.:-]+(?:<S>+(?:[\w.:$-]+(?:=(?:"(?:\\[\s\S]|[^\\"])*"|'(?:\\[\s\S]|[^\\'])*'|[^\s{'"/>=]+|<BRACES>))?|<SPREAD>))*<S>*\/?)?>/.source), r.languages.jsx.tag.inside.tag.pattern = /^<\/?[^\s>\/]*/, r.languages.jsx.tag.inside["attr-value"].pattern = /=(?!\{)(?:"(?:\\[\s\S]|[^\\"])*"|'(?:\\[\s\S]|[^\\'])*'|[^\s'">]+)/, r.languages.jsx.tag.inside.tag.inside["class-name"] = /^[A-Z]\w*(?:\.[A-Z]\w*)*$/, r.languages.jsx.tag.inside.comment = e.comment, r.languages.insertBefore("inside", "attr-name", { spread: { pattern: s(/<SPREAD>/.source), inside: r.languages.jsx } }, r.languages.jsx.tag), r.languages.insertBefore("inside", "special-attr", { script: { pattern: s(/=<BRACES>/.source), alias: "language-javascript", inside: { "script-punctuation": { pattern: /^=(?=\{)/, alias: "punctuation" }, rest: r.languages.jsx } } }, r.languages.jsx.tag); var a = function (l) { return l ? typeof l == "string" ? l : typeof l.content == "string" ? l.content : l.content.map(a).join("") : "" }, o = function (l) { for (var u = [], d = 0; d < l.length; d++) { var h = l[d], g = !1; if (typeof h != "string" && (h.type === "tag" && h.content[0] && h.content[0].type === "tag" ? h.content[0].content[0].content === "</" ? u.length > 0 && u[u.length - 1].tagName === a(h.content[0].content[1]) && u.pop() : h.content[h.content.length - 1].content === "/>" || u.push({ tagName: a(h.content[0].content[1]), openedBraces: 0 }) : u.length > 0 && h.type === "punctuation" && h.content === "{" ? u[u.length - 1].openedBraces++ : u.length > 0 && u[u.length - 1].openedBraces > 0 && h.type === "punctuation" && h.content === "}" ? u[u.length - 1].openedBraces-- : g = !0), (g || typeof h == "string") && u.length > 0 && u[u.length - 1].openedBraces === 0) { var m = a(h); d < l.length - 1 && (typeof l[d + 1] == "string" || l[d + 1].type === "plain-text") && (m += a(l[d + 1]), l.splice(d + 1, 1)), d > 0 && (typeof l[d - 1] == "string" || l[d - 1].type === "plain-text") && (m = a(l[d - 1]) + m, l.splice(d - 1, 1), d--), l[d] = new r.Token("plain-text", m, null, m) } h.content && typeof h.content != "string" && o(h.content) } }; r.hooks.add("after-tokenize", function (l) { l.language !== "jsx" && l.language !== "tsx" || o(l.tokens) }) })(Prism); (function (r) { var e = r.util.clone(r.languages.typescript); r.languages.tsx = r.languages.extend("jsx", e), delete r.languages.tsx.parameter, delete r.languages.tsx["literal-property"]; var t = r.languages.tsx.tag; t.pattern = RegExp(/(^|[^\w$]|(?=<\/))/.source + "(?:" + t.pattern.source + ")", t.pattern.flags), t.lookbehind = !0 })(Prism); const { PREFIX_CHAT_BOX: Js } = _i, Kfe = r => { const [e, t] = R.useState(!1), n = R.useMemo(() => { var s; return DI((s = r.className) === null || s === void 0 ? void 0 : s.split("-"), -1) }, [r.className]), i = R.useCallback(() => { qu(r.children), t(!0), setTimeout(() => { t(!1) }, 2e3) }, [r.children]); return n ? f.createElement("div", { className: `${Js}-content-code semi-always-dark` }, f.createElement("div", { className: `${Js}-content-code-topSlot` }, f.createElement("span", { className: `${Js}-content-code-topSlot-type` }, n), f.createElement("span", { className: `${Js}-content-code-topSlot-copy` }, e ? f.createElement("span", { className: `${Js}-content-code-topSlot-copy-wrapper` }, f.createElement(ga, null), f.createElement(Ke, { componentName: "Chat" }, s => s.copied)) : f.createElement("button", { className: `${Js}-content-code-topSlot-copy-wrapper ${Js}-content-code-topSlot-toCopy`, onClick: i }, f.createElement(KS, null), f.createElement(Ke, { componentName: "Chat" }, s => s.copy)))), lm(r)) : lm(r) }, { PREFIX_CHAT_BOX: eo } = _i, { MESSAGE_STATUS: r1, MODE: i1, ROLE: Ufe } = ps, Wfe = r => { const { message: e = {}, customRenderFunc: t, role: n, customMarkDownComponents: i, mode: s } = r, { content: a, role: o, status: l } = e, u = R.useMemo(() => Object.assign({ code: Kfe, SemiFile: cm, img: um }, i), [i]), d = R.useMemo(() => { const g = o === Ufe.USER, m = s === i1.BUBBLE, b = s === i1.USER_BUBBLE && g; return F(`${eo}-content`, { [`${eo}-content-${s}`]: m || b, [`${eo}-content-user`]: m && g || b, [`${eo}-content-error`]: l === r1.ERROR && (m || b) }) }, [o, l, s]), h = R.useMemo(() => { if (l === r1.LOADING) return f.createElement("span", { className: `${eo}-content-loading` }, f.createElement("span", { className: `${eo}-content-loading-item` })); { let g; return typeof a == "string" ? g = f.createElement(xa, { format: "md", raw: a, components: u }) : Array.isArray(a) && (g = a.map((m, b) => { var y; if (m.type === "text") return f.createElement(xa, { key: "index", format: "md", raw: m.text, components: u }); if (m.type === "image_url") return f.createElement(um, { key: "index", src: m.image_url.url }); if (m.type === "file_url") { const { name: w, size: x, url: S, type: C } = m.file_url, O = (y = w.split(".").pop()) !== null && y !== void 0 ? y : C == null ? void 0 : C.split("/").pop(); return f.createElement(cm, { key: "index", url: S, name: w, size: x, type: O }) } return null })), f.createElement(f.Fragment, null, g) } }, [l, a]); return t ? t({ message: e, role: n, defaultContent: h, className: d }) : f.createElement("div", { className: d }, h) }; class Gfe extends ve { constructor(e) { super(Object.assign({}, e)), this.showDeletePopup = () => { this._adapter.setVisible(!0), this._adapter.setShowAction(!0), this._adapter.registerClickOutsideHandler(this.hideDeletePopup) }, this.hideDeletePopup = () => { this._adapter.setVisible(!1), setTimeout(() => { this._adapter.setShowAction(!1) }, 150), this._adapter.unregisterClickOutsideHandler() }, this.destroy = () => { this._adapter.unregisterClickOutsideHandler() }, this.deleteMessage = () => { this._adapter.notifyDeleteMessage() }, this.copyMessage = () => { this._adapter.notifyMessageCopy(), this._adapter.copyToClipboardAndToast() }, this.likeMessage = () => { this._adapter.notifyLikeMessage() }, this.dislikeMessage = () => { this._adapter.notifyDislikeMessage() }, this.resetMessage = () => { this._adapter.notifyResetMessage() } } } const { PREFIX_CHAT_BOX_ACTION: oi } = _i, { ROLE: s1, MESSAGE_STATUS: Eu } = ps; class $I extends de { constructor(e) { super(e), this.copyNode = () => f.createElement(St, { key: "copy", theme: "borderless", icon: f.createElement(KS, null), type: "tertiary", onClick: this.foundation.copyMessage, className: `${oi}-btn` }), this.likeNode = () => { const { message: t = {} } = this.props, { like: n } = t; return f.createElement(St, { key: "like", theme: "borderless", icon: n ? f.createElement(yx, null) : f.createElement(bx, null), type: "tertiary", className: `${oi}-btn`, onClick: this.foundation.likeMessage }) }, this.dislikeNode = () => { const { message: t = {} } = this.props, { dislike: n } = t; return f.createElement(St, { theme: "borderless", key: "dislike", icon: n ? f.createElement(yx, { className: `${oi}-icon-flip` }) : f.createElement(bx, { className: "semi-chat-chatBox-action-icon-flip" }), type: "tertiary", className: `${oi}-btn`, onClick: this.foundation.dislikeMessage }) }, this.resetNode = () => f.createElement(St, { key: "reset", theme: "borderless", icon: f.createElement(KH, { className: `${oi}-icon-redo` }), type: "tertiary", onClick: this.foundation.resetMessage, className: `${oi}-btn` }), this.deleteNode = () => { const t = f.createElement(Ke, { componentName: "Chat" }, n => n.deleteConfirm); return f.createElement(Po, { trigger: "custom", visible: this.state.visible, key: "delete", title: t, onConfirm: this.foundation.deleteMessage, onCancel: this.foundation.hideDeletePopup, position: "top" }, f.createElement("span", { ref: this.popconfirmTriggerRef, className: `${oi}-delete-wrap` }, f.createElement(St, { theme: "borderless", icon: f.createElement(US, null), type: "tertiary", className: `${oi}-btn`, onClick: this.foundation.showDeletePopup }))) }, this.foundation = new Gfe(this.adapter), this.copySuccessNode = null, this.state = { visible: !1, showAction: !1 }, this.clickOutsideHandler = null, this.containerRef = f.createRef(), this.popconfirmTriggerRef = f.createRef() } componentDidMount() { this.copySuccessNode = f.createElement(Ke, { componentName: "Chat" }, e => e.copySuccess) } componentWillUnmount() { this.foundation.destroy() } get adapter() { return Object.assign(Object.assign({}, super.adapter), { notifyDeleteMessage: () => { const { message: e, onMessageDelete: t } = this.props; t == null || t(e) }, notifyMessageCopy: () => { const { message: e, onMessageCopy: t } = this.props; t == null || t(e) }, copyToClipboardAndToast: () => { var e; const { message: t = {}, toast: n } = this.props; if (typeof t.content == "string") qu(t.content); else if (Array.isArray(t.content)) { const i = (e = t.content) === null || e === void 0 ? void 0 : e.map(s => s.text).join(""); qu(i) } n.success({ content: this.copySuccessNode }) }, notifyLikeMessage: () => { const { message: e, onMessageGoodFeedback: t } = this.props; t == null || t(e) }, notifyDislikeMessage: () => { const { message: e, onMessageBadFeedback: t } = this.props; t == null || t(e) }, notifyResetMessage: () => { const { message: e, onMessageReset: t } = this.props; t == null || t(e) }, setVisible: e => { this.setState({ visible: e }) }, setShowAction: e => { this.setState({ showAction: e }) }, registerClickOutsideHandler: e => { this.clickOutsideHandler && this.adapter.unregisterClickOutsideHandler(), this.clickOutsideHandler = t => { let n = this.popconfirmTriggerRef && this.popconfirmTriggerRef.current; const i = t.target, s = t.composedPath && t.composedPath() || [i]; n && !n.contains(i) && !s.includes(n) && e() }, window.addEventListener("mousedown", this.clickOutsideHandler) }, unregisterClickOutsideHandler: () => { this.clickOutsideHandler && (window.removeEventListener("mousedown", this.clickOutsideHandler), this.clickOutsideHandler = null) } }) } render() { const { message: e = {}, lastChat: t } = this.props, { showAction: n } = this.state, { role: i, status: s = Eu.COMPLETE } = e, a = s === Eu.COMPLETE, o = i !== s1.USER && a, l = t && i === s1.ASSISTANT, u = s !== Eu.LOADING && s !== Eu.INCOMPLETE, d = F(oi, { [`${oi}-show`]: l && u || n, [`${oi}-hidden`]: !u }), { customRenderFunc: h } = this.props; if (h) { const g = [], m = {}; if (a) { const y = this.copyNode(); g.push(y), m.copyNode = y } if (o) { const y = this.likeNode(); g.push(y), m.likeNode = y; const w = this.dislikeNode(); g.push(w), m.dislikeNode = w } if (l) { const y = this.resetNode(); g.push(y), m.resetNode = y } const b = this.deleteNode(); return g.push(b), m.deleteNode = b, h({ message: e, defaultActions: g, className: d, defaultActionsObj: m }) } return f.createElement("div", { className: d, ref: this.containerRef }, a && this.copyNode(), o && this.likeNode(), o && this.dislikeNode(), l && this.resetNode(), this.deleteNode()) } } $I.propTypes = { role: c.object, message: c.object, showReset: c.bool, onMessageBadFeedback: c.func, onMessageGoodFeedback: c.func, onMessageCopy: c.func, onChatsChange: c.func, onMessageDelete: c.func, onMessageReset: c.func, customRenderFunc: c.func }; const { PREFIX_CHAT_BOX: pf } = _i, { ROLE: Yfe, CHAT_ALIGN: Xfe } = ps, qfe = f.memo(r => { const { message: e, lastChat: t, align: n, toast: i, mode: s, roleConfig: a, onMessageBadFeedback: o, onMessageGoodFeedback: l, onMessageCopy: u, onChatsChange: d, onMessageDelete: h, onMessageReset: g, chatBoxRenderConfig: m = {}, customMarkDownComponents: b, previousMessage: y } = r, { renderChatBoxAvatar: w, renderChatBoxAction: x, renderChatBoxContent: S, renderChatBoxTitle: C, renderFullChatBox: O } = m, E = R.useMemo(() => (e == null ? void 0 : e.role) === (y == null ? void 0 : y.role), [e.role, y]), v = R.useMemo(() => { var M; let B = {}; return a && (B = (M = a[e.role]) !== null && M !== void 0 ? M : {}), B }, [e.role, a]), T = R.useMemo(() => f.createElement(Bfe, { continueSend: E, role: v, message: e, customRenderFunc: w }), [v, e, w]), I = R.useMemo(() => f.createElement(Hfe, { role: v, message: e, customRenderFunc: C }), [v, e, C]), k = R.useMemo(() => f.createElement(Wfe, { mode: s, role: v, message: e, customMarkDownComponents: b, customRenderFunc: S }), [e, v, S, s]), P = R.useMemo(() => f.createElement($I, { toast: i, role: v, message: e, lastChat: t, onMessageBadFeedback: o, onMessageCopy: u, onChatsChange: d, onMessageDelete: h, onMessageGoodFeedback: l, onMessageReset: g, customRenderFunc: x }), [e, v, t, o, l, u, d, h, g, x]), N = R.useMemo(() => F(pf, { [`${pf}-right`]: e.role === Yfe.USER && n === Xfe.LEFT_RIGHT }), [e.role, n]); return typeof O != "function" ? f.createElement("div", { className: N }, T, f.createElement("div", { className: `${pf}-wrap` }, !E && I, k, P)) : O({ message: e, role: v, defaultNodes: { avatar: T, title: I, content: k, action: P }, className: N }) }), { PREFIX_DIVIDER: Zfe, PREFIX: Jfe } = _i, { ROLE: Qfe } = ps, ege = f.memo(r => { const { chats: e, onMessageBadFeedback: t, onMessageCopy: n, mode: i, onChatsChange: s, onMessageDelete: a, onMessageGoodFeedback: o, onMessageReset: l, roleConfig: u, chatBoxRenderConfig: d, align: h, customMarkDownComponents: g, renderDivider: m } = r, [b, y] = bre.useToast(); return f.createElement(f.Fragment, null, e.map((w, x) => { const S = x === e.length - 1; return w.role === Qfe.DIVIDER ? m ? m(w) : f.createElement(Pg, { key: w.id, className: Zfe }, f.createElement(Ke, { componentName: "Chat" }, C => C.clearContext)) : f.createElement(qfe, { previousMessage: x ? e[x - 1] : void 0, toast: b, align: h, mode: i, key: w.id, message: w, roleConfig: u, onMessageBadFeedback: t, onMessageCopy: n, onChatsChange: s, onMessageDelete: a, onMessageGoodFeedback: o, onMessageReset: l, lastChat: S, customMarkDownComponents: g, chatBoxRenderConfig: d }) }), f.createElement("div", { className: `${Jfe}-toast` }, y)) }), { PIC_PREFIX: tge, PIC_SUFFIX_ARRAY: nge, ROLE: _u, SCROLL_ANIMATION_TIME: rge, SHOW_SCROLL_GAP: ige } = ps; class sge extends ve { constructor(e) { super(Object.assign({}, e)), this.init = () => { this.scrollToBottomImmediately(), this._adapter.registerWheelEvent() }, this.destroy = () => { this.animation && this.animation.destroy(), this._adapter.unRegisterWheelEvent() }, this.stopGenerate = t => { this._adapter.notifyStopGenerate(t) }, this.scrollToBottomImmediately = () => { const t = this._adapter.getContainerRef(); t && (t.scrollTop = t.scrollHeight) }, this.scrollToBottomWithAnimation = () => { const t = rge, n = this._adapter.getContainerRef(); if (!n) return; const i = n.scrollTop, s = n.scrollHeight; this.animation = new Jm({ from: { scrollTop: i }, to: { scrollTop: s } }, { duration: t, easing: "easeInOutCubic" }), this.animation.on("frame", a => { let { scrollTop: o } = a; n.scrollTop = o }), this.animation.start() }, this.containerScroll = t => { this._persistEvent(t), requestAnimationFrame(() => { this.getScroll(t.target) }) }, this.getScroll = $d(t => { const n = t.scrollHeight, i = t.clientHeight, s = t.scrollTop, { backBottomVisible: a } = this.getStates(); return n - s - i <= ige ? a && this._adapter.setBackBottomVisible(!1) : a || this._adapter.setBackBottomVisible(!0), scroll }, 100), this.clearContext = t => { const { chats: n } = this.getStates(); if (n[n.length - 1].role === _u.DIVIDER) return; const i = { role: _u.DIVIDER, id: es(), createAt: Date.now() }, s = [...n, i]; this._adapter.notifyChatsChange(s), this._adapter.notifyClearContext() }, this.onMessageSend = (t, n) => { let i; if (n && n.length === 0 ? i = t : (i = [], t && i.push({ type: "text", text: t }), (n ?? []).map(s => { var a; const { fileInstance: o, name: l = "", url: u, size: d } = s, h = l.split(".").pop(); ((a = o == null ? void 0 : o.type) === null || a === void 0 ? void 0 : a.startsWith(tge)) || nge.includes(h) ? i.push({ type: "image_url", image_url: { url: u } }) : i.push({ type: "file_url", file_url: { url: u, name: l, size: d, type: o == null ? void 0 : o.type } }) })), i) { const s = { role: _u.USER, id: es(), createAt: Date.now(), content: i }; this._adapter.notifyChatsChange([...this.getStates().chats, s]) } this._adapter.setWheelScroll(!1), this._adapter.registerWheelEvent(), this._adapter.notifyMessageSend(t, n) }, this.onHintClick = t => { const { chats: n } = this.getStates(), i = { role: _u.USER, id: es(), createAt: Date.now(), content: t }, s = [...n, i]; this._adapter.notifyChatsChange(s), this._adapter.notifyHintClick(t) }, this.onInputChange = t => { this._adapter.notifyInputChange(t) }, this.deleteMessage = t => { const { onMessageDelete: n, onChatsChange: i } = this.getProps(), { chats: s } = this.getStates(); n == null || n(t); const a = s.filter(o => o.id !== t.id); i == null || i(a) }, this.likeMessage = t => { const { chats: n } = this.getStates(); this._adapter.notifyLikeMessage(t); const i = n.findIndex(o => o.id === t.id), s = Object.assign(Object.assign({}, n[i]), { like: !n[i].like, dislike: !1 }), a = [...n]; a.splice(i, 1, s), this._adapter.notifyChatsChange(a) }, this.dislikeMessage = t => { const { chats: n } = this.getStates(); this._adapter.notifyDislikeMessage(t); const i = n.findIndex(o => o.id === t.id), s = Object.assign(Object.assign({}, n[i]), { like: !1, dislike: !n[i].dislike }), a = [...n]; a.splice(i, 1, s), this._adapter.notifyChatsChange(a) }, this.resetMessage = t => { const { chats: n } = this.getStates(), i = n[n.length - 1], s = Object.assign(Object.assign({}, i), { status: "loading", content: "", id: es(), createAt: Date.now() }), a = n.slice(0, -1).concat(s); this._adapter.notifyChatsChange(a); const { onMessageReset: o } = this.getProps(); o == null || o(t) }, this.handleDragOver = t => { this._adapter.getDragStatus() || this._adapter.setUploadAreaVisible(!0) }, this.handleDragStart = t => { this._adapter.setDragStatus(!0) }, this.handleDragEnd = t => { this._adapter.setDragStatus(!1) }, this.handleContainerDragOver = t => { yn(t) }, this.handleContainerDrop = t => { var n; this._adapter.setUploadAreaVisible(!1), this._adapter.manualUpload((n = t == null ? void 0 : t.dataTransfer) === null || n === void 0 ? void 0 : n.files), yn(t) }, this.handleContainerDragLeave = t => { yn(t); const n = this._adapter.getDropAreaElement(), i = t.relatedTarget; n.contains(i) || setTimeout(() => { this._adapter.setUploadAreaVisible(!1) }) } } } const Mr = _i.PREFIX, { CHAT_ALIGN: age, MODE: oge, SEND_HOT_KEY: lge, MESSAGE_STATUS: a1 } = ps; class Td extends de { constructor(e) { super(e), this.dragStatus = !1, this.resetMessage = () => { this.foundation.resetMessage(null) }, this.clearContext = () => { this.foundation.clearContext(null) }, this.scrollToBottom = t => { t ? this.foundation.scrollToBottomWithAnimation() : this.foundation.scrollToBottomImmediately() }, this.sendMessage = (t, n) => { this.foundation.onMessageSend(t, n) }, this.containerScroll = t => { this.scrollTargetRef.current = t.target, t.target === t.currentTarget && this.foundation.containerScroll(t) }, this.containerRef = R.createRef(), this.uploadRef = R.createRef(), this.dropAreaRef = R.createRef(), this.wheelEventHandler = null, this.foundation = new sge(this.adapter), this.scrollTargetRef = R.createRef(), this.state = { backBottomVisible: !1, chats: [], cacheHints: [], wheelScroll: !1, uploadAreaVisible: !1 } } get adapter() { return Object.assign(Object.assign({}, super.adapter), { getContainerRef: () => { var e; return (e = this.containerRef) === null || e === void 0 ? void 0 : e.current }, setWheelScroll: e => { this.setState({ wheelScroll: e }) }, notifyChatsChange: e => { const { onChatsChange: t } = this.props; t && t(e) }, notifyLikeMessage: e => { const { onMessageGoodFeedback: t } = this.props; t && t(e) }, notifyDislikeMessage: e => { const { onMessageBadFeedback: t } = this.props; t && t(e) }, notifyCopyMessage: e => { const { onMessageCopy: t } = this.props; t && t(e) }, notifyClearContext: () => { const { onClear: e } = this.props; e && e() }, notifyMessageSend: (e, t) => { const { onMessageSend: n } = this.props; n && n(e, t) }, notifyInputChange: e => { const { onInputChange: t } = this.props; t && t(e) }, setBackBottomVisible: e => { this.setState(t => t.backBottomVisible !== e ? { backBottomVisible: e } : null) }, registerWheelEvent: () => { this.adapter.unRegisterWheelEvent(); const e = this.containerRef.current; e && (this.wheelEventHandler = t => { var n; ((n = this.scrollTargetRef) === null || n === void 0 ? void 0 : n.current) === t.currentTarget && (this.adapter.setWheelScroll(!0), this.adapter.unRegisterWheelEvent()) }, e.addEventListener("wheel", this.wheelEventHandler)) }, unRegisterWheelEvent: () => { if (this.wheelEventHandler) { const e = this.containerRef.current; if (e) e.removeEventListener("wheel", this.wheelEventHandler); else return; this.wheelEventHandler = null } }, notifyStopGenerate: e => { const { onStopGenerator: t } = this.props; t && t(e) }, notifyHintClick: e => { const { onHintClick: t } = this.props; t && t(e) }, setUploadAreaVisible: e => { this.setState({ uploadAreaVisible: e }) }, manualUpload: e => { const t = this.uploadRef.current; t && t.insert(e) }, getDropAreaElement: () => { var e; return (e = this.dropAreaRef) === null || e === void 0 ? void 0 : e.current }, getDragStatus: () => this.dragStatus, setDragStatus: e => { this.dragStatus = e } }) } static getDerivedStateFromProps(e, t) { const { chats: n, hints: i } = e, s = {}; return n !== t.chats && (s.chats = n ?? []), i !== t.cacheHints && (s.cacheHints = i), Object.keys(s).length ? s : null } componentDidMount() { this.foundation.init() } componentDidUpdate(e, t, n) { const { chats: i, hints: s } = this.props, { chats: a, cacheHints: o } = t, { wheelScroll: l } = this.state; let u = !1; if (i !== a && Array.isArray(i) && Array.isArray(a)) { const d = i[i.length - 1], h = a[a.length - 1]; i.length > a.length ? (a.length === 0 || d.id !== h.id) && (u = !0) : i.length === a.length && i.length && (d.status !== "complete" || d.status !== h.status) && (u = !0) } s !== o && s.length > o.length && (u = !0), !l && u && this.foundation.scrollToBottomImmediately() } componentWillUnmount() { this.foundation.destroy() } render() { const { topSlot: e, bottomSlot: t, roleConfig: n, hints: i, onChatsChange: s, onMessageCopy: a, renderInputArea: o, chatBoxRenderConfig: l, align: u, renderHintBox: d, style: h, className: g, showStopGenerate: m, customMarkDownComponents: b, mode: y, showClearContext: w, placeholder: x, inputBoxCls: S, inputBoxStyle: C, hintStyle: O, hintCls: E, uploadProps: v, uploadTipProps: T, sendHotKey: I, renderDivider: k } = this.props, { backBottomVisible: P, chats: N, wheelScroll: M, uploadAreaVisible: B } = this.state; let K = !1; const U = N.length > 0 && N[N.length - 1]; let W = !1; if (U && m) { const Z = (U == null ? void 0 : U.status) && [a1.LOADING, a1.INCOMPLETE].includes(U == null ? void 0 : U.status); W = Z, m && (K = Z) } return R.createElement("div", { className: F(`${Mr}`, g), style: h, onDragOver: this.foundation.handleDragOver, onDragStart: this.foundation.handleDragStart, onDragEnd: this.foundation.handleDragEnd }, B && R.createElement("div", { ref: this.dropAreaRef, className: `${Mr}-dropArea`, onDragOver: this.foundation.handleContainerDragOver, onDrop: this.foundation.handleContainerDrop, onDragLeave: this.foundation.handleContainerDragLeave }, R.createElement("span", { className: `${Mr}-dropArea-text` }, R.createElement(Ke, { componentName: "Chat" }, Z => Z.dropAreaText))), R.createElement("div", { className: `${Mr}-inner` }, e, R.createElement("div", { className: `${Mr}-content` }, R.createElement("div", { className: F(`${Mr}-container`, { "semi-chat-container-scroll-hidden": !M }), onScroll: this.containerScroll, ref: this.containerRef }, R.createElement(ege, { align: u, mode: y, chats: N, roleConfig: n, customMarkDownComponents: b, onMessageDelete: this.foundation.deleteMessage, onChatsChange: s, onMessageBadFeedback: this.foundation.dislikeMessage, onMessageGoodFeedback: this.foundation.likeMessage, onMessageReset: this.foundation.resetMessage, onMessageCopy: a, chatBoxRenderConfig: l, renderDivider: k }), !!(i != null && i.length) && R.createElement(Vfe, { className: E, style: O, value: i, onHintClick: this.foundation.onHintClick, renderHintBox: d }))), P && !K && R.createElement("span", { className: `${Mr}-action` }, R.createElement(St, { className: `${Mr}-action-content ${Mr}-action-backBottom`, icon: R.createElement(os, { size: "extra-large" }), type: "tertiary", onClick: this.foundation.scrollToBottomWithAnimation })), K && R.createElement("span", { className: `${Mr}-action` }, R.createElement(St, { className: `${Mr}-action-content ${Mr}-action-stop`, icon: R.createElement(nH, { size: "extra-large" }), type: "tertiary", onClick: this.foundation.stopGenerate }, R.createElement(Ke, { componentName: "Chat" }, Z => Z.stop))), R.createElement(Vb, { showClearContext: w, uploadRef: this.uploadRef, manualUpload: this.adapter.manualUpload, style: C, className: S, placeholder: x, disableSend: W, onClearContext: this.foundation.clearContext, onSend: this.foundation.onMessageSend, onInputChange: this.foundation.onInputChange, renderInputArea: o, uploadProps: v, uploadTipProps: T, sendHotKey: I }), t)) } } Td.__SemiComponentName__ = "Chat"; Td.propTypes = { className: c.string, style: c.object, roleConfig: c.object, chats: c.array, hints: c.array, renderHintBox: c.func, onChatsChange: c.func, align: c.string, chatBoxRenderConfig: c.object, customMarkDownComponents: c.object, onClear: c.func, onMessageDelete: c.func, onMessageReset: c.func, onMessageCopy: c.func, onMessageGoodFeedback: c.func, onMessageBadFeedback: c.func, inputContentConvert: c.func, onMessageSend: c.func, InputBoxStyle: c.object, inputBoxCls: c.string, renderFullInputBox: c.func, placeholder: c.string, topSlot: c.node || c.array, bottomSlot: c.node || c.array, showStopGenerate: c.bool, showClearContext: c.bool, hintStyle: c.object, hintCls: c.string, uploadProps: c.object, uploadTipProps: c.object, mode: c.string }; Td.defaultProps = xn(Td.__SemiComponentName__, { align: age.LEFT_RIGHT, showStopGenerate: !1, mode: oge.BUBBLE, showClearContext: !1, sendHotKey: lge.ENTER }); export { kn as $, ma as A, St as B, ry as C, Pg as D, MH as E, xr as F, Ige as G, GS as H, VS as I, Do as J, Ah as K, Qo as L, qr as M, tO as N, Of as O, Po as P, aJ as Q, gh as R, yi as S, bre as T, Jt as U, YS as V, Uy as W, Oge as X, xq as Y, So as Z, p9 as _, jge as a, Yd as a0, Zl as a1, aT as a2, Rge as a3, EH as a4, wh as a5, Td as a6, Pge as a7, Vs as a8, Tge as a9, Cge as aa, Ege as ab, kge as ac, Sge as ad, gge as ae, _ge as af, fge as ag, Tz as ah, bge as ai, mge as aj, xge as ak, wge as al, pge as am, ye as b, Tf as c, uw as d, rt as e, nt as f, zn as g, wr as h, Jl as i, c1 as j, Gm as k, Zd as l, Zr as m, ln as n, Kt as o, Na as p, c as q, Gd as r, vge as s, vr as t, cE as u, nO as v, ls as w, hh as x, sl as y, yge as z };
